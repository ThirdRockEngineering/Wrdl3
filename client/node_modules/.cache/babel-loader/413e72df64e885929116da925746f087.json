{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar tlru = require('./utils/tlru.js');\n\nvar PQueue = require('p-queue');\n\nvar HTTP = require('ipfs-utils/src/http.js');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar PQueue__default = /*#__PURE__*/_interopDefaultLegacy(PQueue);\n\nvar HTTP__default = /*#__PURE__*/_interopDefaultLegacy(HTTP);\n\nconst cache = new tlru.TLRU(1000);\nconst ttl = 60 * 1000;\nconst Queue = PQueue__default[\"default\"].default ? PQueue__default[\"default\"].default : PQueue__default[\"default\"];\nconst httpQueue = new Queue({\n  concurrency: 4\n});\n\nconst ipfsPath = response => {\n  if (response.Path) return response.Path;\n  throw new Error(response.Message);\n};\n\nasync function resolveDnslink(fqdn, opts) {\n  const resolve = async function (fqdn) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const searchParams = new URLSearchParams(opts);\n    searchParams.set('arg', fqdn);\n    const query = searchParams.toString();\n\n    if (!opts.nocache && cache.has(query)) {\n      const response = cache.get(query);\n      return ipfsPath(response);\n    }\n\n    const response = await httpQueue.add(async () => {\n      const res = await HTTP__default[\"default\"].get('https://ipfs.io/api/v0/dns', {\n        searchParams\n      });\n      const query = new URL(res.url).search.slice(1);\n      const json = await res.json();\n      cache.set(query, json, ttl);\n      return json;\n    });\n    return ipfsPath(response);\n  };\n\n  return resolve(fqdn, opts);\n}\n\nexports.resolveDnslink = resolveDnslink;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-core-config/cjs/src/dns.browser.js"],"names":["Object","defineProperty","exports","value","tlru","require","PQueue","HTTP","_interopDefaultLegacy","e","PQueue__default","HTTP__default","cache","TLRU","ttl","Queue","default","httpQueue","concurrency","ipfsPath","response","Path","Error","Message","resolveDnslink","fqdn","opts","resolve","searchParams","URLSearchParams","set","query","toString","nocache","has","get","add","res","URL","url","search","slice","json"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AAEA,IAAIC,IAAI,GAAGC,OAAO,CAAC,iBAAD,CAAlB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,SAAD,CAApB;;AACA,IAAIE,IAAI,GAAGF,OAAO,CAAC,wBAAD,CAAlB;;AAEA,SAASG,qBAAT,CAAgCC,CAAhC,EAAmC;AAAE,SAAOA,CAAC,IAAI,OAAOA,CAAP,KAAa,QAAlB,IAA8B,aAAaA,CAA3C,GAA+CA,CAA/C,GAAmD;AAAE,eAAWA;AAAb,GAA1D;AAA6E;;AAElH,IAAIC,eAAe,GAAG,aAAaF,qBAAqB,CAACF,MAAD,CAAxD;;AACA,IAAIK,aAAa,GAAG,aAAaH,qBAAqB,CAACD,IAAD,CAAtD;;AAEA,MAAMK,KAAK,GAAG,IAAIR,IAAI,CAACS,IAAT,CAAc,IAAd,CAAd;AACA,MAAMC,GAAG,GAAG,KAAK,IAAjB;AACA,MAAMC,KAAK,GAAGL,eAAe,CAAC,SAAD,CAAf,CAA2BM,OAA3B,GAAqCN,eAAe,CAAC,SAAD,CAAf,CAA2BM,OAAhE,GAA0EN,eAAe,CAAC,SAAD,CAAvG;AACA,MAAMO,SAAS,GAAG,IAAIF,KAAJ,CAAU;AAAEG,EAAAA,WAAW,EAAE;AAAf,CAAV,CAAlB;;AACA,MAAMC,QAAQ,GAAGC,QAAQ,IAAI;AAC3B,MAAIA,QAAQ,CAACC,IAAb,EACE,OAAOD,QAAQ,CAACC,IAAhB;AACF,QAAM,IAAIC,KAAJ,CAAUF,QAAQ,CAACG,OAAnB,CAAN;AACD,CAJD;;AAKA,eAAeC,cAAf,CAA8BC,IAA9B,EAAoCC,IAApC,EAA0C;AACxC,QAAMC,OAAO,GAAG,gBAAOF,IAAP,EAA2B;AAAA,QAAdC,IAAc,uEAAP,EAAO;AACzC,UAAME,YAAY,GAAG,IAAIC,eAAJ,CAAoBH,IAApB,CAArB;AACAE,IAAAA,YAAY,CAACE,GAAb,CAAiB,KAAjB,EAAwBL,IAAxB;AACA,UAAMM,KAAK,GAAGH,YAAY,CAACI,QAAb,EAAd;;AACA,QAAI,CAACN,IAAI,CAACO,OAAN,IAAiBrB,KAAK,CAACsB,GAAN,CAAUH,KAAV,CAArB,EAAuC;AACrC,YAAMX,QAAQ,GAAGR,KAAK,CAACuB,GAAN,CAAUJ,KAAV,CAAjB;AACA,aAAOZ,QAAQ,CAACC,QAAD,CAAf;AACD;;AACD,UAAMA,QAAQ,GAAG,MAAMH,SAAS,CAACmB,GAAV,CAAc,YAAY;AAC/C,YAAMC,GAAG,GAAG,MAAM1B,aAAa,CAAC,SAAD,CAAb,CAAyBwB,GAAzB,CAA6B,4BAA7B,EAA2D;AAAEP,QAAAA;AAAF,OAA3D,CAAlB;AACA,YAAMG,KAAK,GAAG,IAAIO,GAAJ,CAAQD,GAAG,CAACE,GAAZ,EAAiBC,MAAjB,CAAwBC,KAAxB,CAA8B,CAA9B,CAAd;AACA,YAAMC,IAAI,GAAG,MAAML,GAAG,CAACK,IAAJ,EAAnB;AACA9B,MAAAA,KAAK,CAACkB,GAAN,CAAUC,KAAV,EAAiBW,IAAjB,EAAuB5B,GAAvB;AACA,aAAO4B,IAAP;AACD,KANsB,CAAvB;AAOA,WAAOvB,QAAQ,CAACC,QAAD,CAAf;AACD,GAhBD;;AAiBA,SAAOO,OAAO,CAACF,IAAD,EAAOC,IAAP,CAAd;AACD;;AAEDxB,OAAO,CAACsB,cAAR,GAAyBA,cAAzB","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar tlru = require('./utils/tlru.js');\nvar PQueue = require('p-queue');\nvar HTTP = require('ipfs-utils/src/http.js');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar PQueue__default = /*#__PURE__*/_interopDefaultLegacy(PQueue);\nvar HTTP__default = /*#__PURE__*/_interopDefaultLegacy(HTTP);\n\nconst cache = new tlru.TLRU(1000);\nconst ttl = 60 * 1000;\nconst Queue = PQueue__default[\"default\"].default ? PQueue__default[\"default\"].default : PQueue__default[\"default\"];\nconst httpQueue = new Queue({ concurrency: 4 });\nconst ipfsPath = response => {\n  if (response.Path)\n    return response.Path;\n  throw new Error(response.Message);\n};\nasync function resolveDnslink(fqdn, opts) {\n  const resolve = async (fqdn, opts = {}) => {\n    const searchParams = new URLSearchParams(opts);\n    searchParams.set('arg', fqdn);\n    const query = searchParams.toString();\n    if (!opts.nocache && cache.has(query)) {\n      const response = cache.get(query);\n      return ipfsPath(response);\n    }\n    const response = await httpQueue.add(async () => {\n      const res = await HTTP__default[\"default\"].get('https://ipfs.io/api/v0/dns', { searchParams });\n      const query = new URL(res.url).search.slice(1);\n      const json = await res.json();\n      cache.set(query, json, ttl);\n      return json;\n    });\n    return ipfsPath(response);\n  };\n  return resolve(fqdn, opts);\n}\n\nexports.resolveDnslink = resolveDnslink;\n"]},"metadata":{},"sourceType":"script"}