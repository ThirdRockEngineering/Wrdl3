{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar filter = require('it-filter');\n\nvar pushable = require('it-pushable');\n\nvar drain = require('it-drain');\n\nvar cid = require('multiformats/cid');\n\nvar errCode = require('err-code');\n\nvar identity = require('multiformats/hashes/identity');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar filter__default = /*#__PURE__*/_interopDefaultLegacy(filter);\n\nvar pushable__default = /*#__PURE__*/_interopDefaultLegacy(pushable);\n\nvar drain__default = /*#__PURE__*/_interopDefaultLegacy(drain);\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\n\nfunction createIdStore(store) {\n  return {\n    open() {\n      return store.open();\n    },\n\n    close() {\n      return store.close();\n    },\n\n    query(query, options) {\n      return store.query(query, options);\n    },\n\n    queryKeys(query, options) {\n      return store.queryKeys(query, options);\n    },\n\n    async get(cid, options) {\n      const extracted = extractContents(cid);\n\n      if (extracted.isIdentity) {\n        return Promise.resolve(extracted.digest);\n      }\n\n      return store.get(cid, options);\n    },\n\n    async *getMany(cids, options) {\n      for await (const cid of cids) {\n        yield this.get(cid, options);\n      }\n    },\n\n    async put(cid, buf, options) {\n      const {\n        isIdentity\n      } = extractContents(cid);\n\n      if (isIdentity) {\n        return;\n      }\n\n      await store.put(cid, buf, options);\n    },\n\n    async *putMany(pairs, options) {\n      const output = pushable__default[\"default\"]();\n      const runner = globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : globalThis.setImmediate || globalThis.setTimeout;\n      runner(async () => {\n        try {\n          await drain__default[\"default\"](store.putMany(async function* () {\n            for await (const {\n              key,\n              value\n            } of pairs) {\n              if (!extractContents(key).isIdentity) {\n                yield {\n                  key,\n                  value\n                };\n              }\n\n              output.push({\n                key,\n                value\n              });\n            }\n          }()));\n          output.end();\n        } catch (err) {\n          output.end(err);\n        }\n      });\n      yield* output;\n    },\n\n    has(cid, options) {\n      const {\n        isIdentity\n      } = extractContents(cid);\n\n      if (isIdentity) {\n        return Promise.resolve(true);\n      }\n\n      return store.has(cid, options);\n    },\n\n    delete(cid, options) {\n      const {\n        isIdentity\n      } = extractContents(cid);\n\n      if (isIdentity) {\n        return Promise.resolve();\n      }\n\n      return store.delete(cid, options);\n    },\n\n    deleteMany(cids, options) {\n      return store.deleteMany(filter__default[\"default\"](cids, cid => !extractContents(cid).isIdentity), options);\n    },\n\n    batch() {\n      const batch = store.batch();\n      return {\n        put(cid, buf) {\n          const {\n            isIdentity\n          } = extractContents(cid);\n\n          if (isIdentity) {\n            return;\n          }\n\n          batch.put(cid, buf);\n        },\n\n        delete(cid) {\n          const {\n            isIdentity\n          } = extractContents(cid);\n\n          if (isIdentity) {\n            return;\n          }\n\n          batch.delete(cid);\n        },\n\n        commit: options => {\n          return batch.commit(options);\n        }\n      };\n    }\n\n  };\n}\n\nfunction extractContents(k) {\n  const cid$1 = cid.CID.asCID(k);\n\n  if (cid$1 == null) {\n    throw errCode__default[\"default\"](new Error('Not a valid cid'), 'ERR_INVALID_CID');\n  }\n\n  if (cid$1.multihash.code !== identity.identity.code) {\n    return {\n      isIdentity: false\n    };\n  }\n\n  return {\n    isIdentity: true,\n    digest: cid$1.multihash.digest\n  };\n}\n\nexports.createIdStore = createIdStore;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-repo/cjs/src/idstore.js"],"names":["Object","defineProperty","exports","value","filter","require","pushable","drain","cid","errCode","identity","_interopDefaultLegacy","e","filter__default","pushable__default","drain__default","errCode__default","createIdStore","store","open","close","query","options","queryKeys","get","extracted","extractContents","isIdentity","Promise","resolve","digest","getMany","cids","put","buf","putMany","pairs","output","runner","globalThis","process","nextTick","setImmediate","setTimeout","key","push","end","err","has","delete","deleteMany","batch","commit","k","cid$1","CID","asCID","Error","multihash","code"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar filter = require('it-filter');\nvar pushable = require('it-pushable');\nvar drain = require('it-drain');\nvar cid = require('multiformats/cid');\nvar errCode = require('err-code');\nvar identity = require('multiformats/hashes/identity');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar filter__default = /*#__PURE__*/_interopDefaultLegacy(filter);\nvar pushable__default = /*#__PURE__*/_interopDefaultLegacy(pushable);\nvar drain__default = /*#__PURE__*/_interopDefaultLegacy(drain);\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\n\nfunction createIdStore(store) {\n  return {\n    open() {\n      return store.open();\n    },\n    close() {\n      return store.close();\n    },\n    query(query, options) {\n      return store.query(query, options);\n    },\n    queryKeys(query, options) {\n      return store.queryKeys(query, options);\n    },\n    async get(cid, options) {\n      const extracted = extractContents(cid);\n      if (extracted.isIdentity) {\n        return Promise.resolve(extracted.digest);\n      }\n      return store.get(cid, options);\n    },\n    async *getMany(cids, options) {\n      for await (const cid of cids) {\n        yield this.get(cid, options);\n      }\n    },\n    async put(cid, buf, options) {\n      const {isIdentity} = extractContents(cid);\n      if (isIdentity) {\n        return;\n      }\n      await store.put(cid, buf, options);\n    },\n    async *putMany(pairs, options) {\n      const output = pushable__default[\"default\"]();\n      const runner = globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : globalThis.setImmediate || globalThis.setTimeout;\n      runner(async () => {\n        try {\n          await drain__default[\"default\"](store.putMany(async function* () {\n            for await (const {key, value} of pairs) {\n              if (!extractContents(key).isIdentity) {\n                yield {\n                  key,\n                  value\n                };\n              }\n              output.push({\n                key,\n                value\n              });\n            }\n          }()));\n          output.end();\n        } catch (err) {\n          output.end(err);\n        }\n      });\n      yield* output;\n    },\n    has(cid, options) {\n      const {isIdentity} = extractContents(cid);\n      if (isIdentity) {\n        return Promise.resolve(true);\n      }\n      return store.has(cid, options);\n    },\n    delete(cid, options) {\n      const {isIdentity} = extractContents(cid);\n      if (isIdentity) {\n        return Promise.resolve();\n      }\n      return store.delete(cid, options);\n    },\n    deleteMany(cids, options) {\n      return store.deleteMany(filter__default[\"default\"](cids, cid => !extractContents(cid).isIdentity), options);\n    },\n    batch() {\n      const batch = store.batch();\n      return {\n        put(cid, buf) {\n          const {isIdentity} = extractContents(cid);\n          if (isIdentity) {\n            return;\n          }\n          batch.put(cid, buf);\n        },\n        delete(cid) {\n          const {isIdentity} = extractContents(cid);\n          if (isIdentity) {\n            return;\n          }\n          batch.delete(cid);\n        },\n        commit: options => {\n          return batch.commit(options);\n        }\n      };\n    }\n  };\n}\nfunction extractContents(k) {\n  const cid$1 = cid.CID.asCID(k);\n  if (cid$1 == null) {\n    throw errCode__default[\"default\"](new Error('Not a valid cid'), 'ERR_INVALID_CID');\n  }\n  if (cid$1.multihash.code !== identity.identity.code) {\n    return { isIdentity: false };\n  }\n  return {\n    isIdentity: true,\n    digest: cid$1.multihash.digest\n  };\n}\n\nexports.createIdStore = createIdStore;\n"]},"metadata":{},"sourceType":"script"}