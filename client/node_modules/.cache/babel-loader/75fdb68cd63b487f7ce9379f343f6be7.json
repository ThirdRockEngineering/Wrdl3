{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.XXFallbackHandshake = void 0;\n\nconst handshake_xx_1 = require(\"./handshake-xx\");\n\nconst utils_1 = require(\"./utils\");\n\nconst logger_1 = require(\"./logger\");\n\nconst encoder_1 = require(\"./encoder\");\n\nclass XXFallbackHandshake extends handshake_xx_1.XXHandshake {\n  constructor(isInitiator, payload, prologue, staticKeypair, connection, initialMsg, remotePeer, ephemeralKeys, handshake) {\n    super(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake);\n\n    if (ephemeralKeys) {\n      this.ephemeralKeys = ephemeralKeys;\n    }\n\n    this.initialMsg = initialMsg;\n  } // stage 0\n  // eslint-disable-next-line require-await\n\n\n  async propose() {\n    if (this.isInitiator) {\n      this.xx.sendMessage(this.session, new Uint8Array(0), this.ephemeralKeys);\n      (0, logger_1.logger)('XX Fallback Stage 0 - Initialized state as the first message was sent by initiator.');\n      (0, logger_1.logLocalEphemeralKeys)(this.session.hs.e);\n    } else {\n      (0, logger_1.logger)('XX Fallback Stage 0 - Responder decoding initial msg from IK.');\n      const receivedMessageBuffer = (0, encoder_1.decode0)(this.initialMsg);\n      const {\n        valid\n      } = this.xx.recvMessage(this.session, {\n        ne: receivedMessageBuffer.ne,\n        ns: new Uint8Array(0),\n        ciphertext: new Uint8Array(0)\n      });\n\n      if (!valid) {\n        throw new Error('xx fallback stage 0 decryption validation fail');\n      }\n\n      (0, logger_1.logger)('XX Fallback Stage 0 - Responder used received message from IK.');\n      (0, logger_1.logRemoteEphemeralKey)(this.session.hs.re);\n    }\n  } // stage 1\n\n\n  async exchange() {\n    if (this.isInitiator) {\n      const receivedMessageBuffer = (0, encoder_1.decode1)(this.initialMsg);\n      const {\n        plaintext,\n        valid\n      } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n\n      if (!valid) {\n        throw new Error('xx fallback stage 1 decryption validation fail');\n      }\n\n      (0, logger_1.logger)('XX Fallback Stage 1 - Initiator used received message from IK.');\n      (0, logger_1.logRemoteEphemeralKey)(this.session.hs.re);\n      (0, logger_1.logRemoteStaticKey)(this.session.hs.rs);\n      (0, logger_1.logger)(\"Initiator going to check remote's signature...\");\n\n      try {\n        const decodedPayload = await (0, utils_1.decodePayload)(plaintext);\n        this.remotePeer = this.remotePeer || (await (0, utils_1.getPeerIdFromPayload)(decodedPayload));\n        await (0, utils_1.verifySignedPayload)(this.session.hs.rs, decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data);\n      } catch (e) {\n        const err = e;\n        throw new Error(`Error occurred while verifying signed payload from responder: ${err.message}`);\n      }\n\n      (0, logger_1.logger)('All good with the signature!');\n    } else {\n      (0, logger_1.logger)('XX Fallback Stage 1 - Responder start');\n      await super.exchange();\n      (0, logger_1.logger)('XX Fallback Stage 1 - Responder end');\n    }\n  }\n\n}\n\nexports.XXFallbackHandshake = XXFallbackHandshake;","map":{"version":3,"mappings":";;;;;;;AAAA;;AAIA;;AACA;;AAEA;;AAGA,MAAaA,mBAAb,SAAyCC,0BAAzC,CAAoD;AAIlDC,cACEC,WADF,EAEEC,OAFF,EAGEC,QAHF,EAIEC,aAJF,EAKEC,UALF,EAMEC,UANF,EAOEC,UAPF,EAQEC,aARF,EASEC,SATF,EASgB;AAEd,UAAMR,WAAN,EAAmBC,OAAnB,EAA4BC,QAA5B,EAAsCC,aAAtC,EAAqDC,UAArD,EAAiEE,UAAjE,EAA6EE,SAA7E;;AACA,QAAID,aAAJ,EAAmB;AACjB,WAAKA,aAAL,GAAqBA,aAArB;AACD;;AACD,SAAKF,UAAL,GAAkBA,UAAlB;AACD,GApBiD,CAsBlD;AACA;;;AACoB,QAAPI,OAAO;AAClB,QAAI,KAAKT,WAAT,EAAsB;AACpB,WAAKU,EAAL,CAAQC,WAAR,CAAoB,KAAKC,OAAzB,EAAkC,IAAIC,UAAJ,CAAe,CAAf,CAAlC,EAAqD,KAAKN,aAA1D;AACA,2BAAO,qFAAP;AACA,0CAAsB,KAAKK,OAAL,CAAaE,EAAb,CAAgBC,CAAtC;AACD,KAJD,MAIO;AACL,2BAAO,+DAAP;AACA,YAAMC,qBAAqB,GAAG,uBAAQ,KAAKX,UAAb,CAA9B;AACA,YAAM;AAAEY;AAAF,UAAY,KAAKP,EAAL,CAAQQ,WAAR,CAAoB,KAAKN,OAAzB,EAAkC;AAClDO,UAAE,EAAEH,qBAAqB,CAACG,EADwB;AAElDC,UAAE,EAAE,IAAIP,UAAJ,CAAe,CAAf,CAF8C;AAGlDQ,kBAAU,EAAE,IAAIR,UAAJ,CAAe,CAAf;AAHsC,OAAlC,CAAlB;;AAKA,UAAI,CAACI,KAAL,EAAY;AACV,cAAM,IAAIK,KAAJ,CAAU,gDAAV,CAAN;AACD;;AACD,2BAAO,gEAAP;AACA,0CAAsB,KAAKV,OAAL,CAAaE,EAAb,CAAgBS,EAAtC;AACD;AACF,GA3CiD,CA6ClD;;;AACqB,QAARC,QAAQ;AACnB,QAAI,KAAKxB,WAAT,EAAsB;AACpB,YAAMgB,qBAAqB,GAAG,uBAAQ,KAAKX,UAAb,CAA9B;AACA,YAAM;AAAEoB,iBAAF;AAAaR;AAAb,UAAuB,KAAKP,EAAL,CAAQQ,WAAR,CAAoB,KAAKN,OAAzB,EAAkCI,qBAAlC,CAA7B;;AACA,UAAI,CAACC,KAAL,EAAY;AACV,cAAM,IAAIK,KAAJ,CAAU,gDAAV,CAAN;AACD;;AACD,2BAAO,gEAAP;AACA,0CAAsB,KAAKV,OAAL,CAAaE,EAAb,CAAgBS,EAAtC;AACA,uCAAmB,KAAKX,OAAL,CAAaE,EAAb,CAAgBY,EAAnC;AAEA,2BAAO,gDAAP;;AACA,UAAI;AACF,cAAMC,cAAc,GAAG,MAAM,2BAAcF,SAAd,CAA7B;AACA,aAAKnB,UAAL,GAAkB,KAAKA,UAAL,KAAmB,MAAM,kCAAqBqB,cAArB,CAAzB,CAAlB;AACA,cAAM,iCAAoB,KAAKf,OAAL,CAAaE,EAAb,CAAgBY,EAApC,EAAwCC,cAAxC,EAAwD,KAAKrB,UAA7D,CAAN;AACA,aAAKsB,kBAAL,CAAwBD,cAAc,CAACE,IAAvC;AACD,OALD,CAKE,OAAOd,CAAP,EAAe;AACf,cAAMe,GAAG,GAAGf,CAAZ;AACA,cAAM,IAAIO,KAAJ,CAAU,iEAAiEQ,GAAG,CAACC,OAAO,EAAtF,CAAN;AACD;;AACD,2BAAO,8BAAP;AACD,KArBD,MAqBO;AACL,2BAAO,uCAAP;AACA,YAAM,MAAMP,QAAN,EAAN;AACA,2BAAO,qCAAP;AACD;AACF;;AAzEiD;;AAApDQ","names":["XXFallbackHandshake","handshake_xx_1","constructor","isInitiator","payload","prologue","staticKeypair","connection","initialMsg","remotePeer","ephemeralKeys","handshake","propose","xx","sendMessage","session","Uint8Array","hs","e","receivedMessageBuffer","valid","recvMessage","ne","ns","ciphertext","Error","re","exchange","plaintext","rs","decodedPayload","setRemoteEarlyData","data","err","message","exports"],"sourceRoot":"","sources":["../../src/handshake-xx-fallback.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}