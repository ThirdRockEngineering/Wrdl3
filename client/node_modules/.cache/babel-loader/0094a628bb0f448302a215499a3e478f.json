{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar errCode = require('err-code');\n\nvar updateTree = require('./utils/update-tree.js');\n\nvar updateMfsRoot = require('./utils/update-mfs-root.js');\n\nvar removeLink = require('./utils/remove-link.js');\n\nvar toMfsPath = require('./utils/to-mfs-path.js');\n\nvar toTrail = require('./utils/to-trail.js');\n\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\n\nvar mergeOpts = require('merge-options');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\n\nvar mergeOpts__default = /*#__PURE__*/_interopDefaultLegacy(mergeOpts);\n\nconst mergeOptions = mergeOpts__default[\"default\"].bind({\n  ignoreUndefined: true\n});\nconst defaultOptions = {\n  recursive: false,\n  cidVersion: 0,\n  hashAlg: 'sha2-256',\n  flush: true,\n  shardSplitThreshold: 1000\n};\n\nfunction createRm(context) {\n  async function mfsRm(paths) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const options = mergeOptions(defaultOptions, opts);\n\n    if (!Array.isArray(paths)) {\n      paths = [paths];\n    }\n\n    const sources = await Promise.all(paths.map(path => toMfsPath.toMfsPath(context, path, options)));\n\n    if (!sources.length) {\n      throw errCode__default[\"default\"](new Error('Please supply at least one path to remove'), 'ERR_INVALID_PARAMS');\n    }\n\n    sources.forEach(source => {\n      if (source.path === '/') {\n        throw errCode__default[\"default\"](new Error('Cannot delete root'), 'ERR_INVALID_PARAMS');\n      }\n    });\n\n    for (const source of sources) {\n      await removePath(context, source.path, options);\n    }\n  }\n\n  return withTimeoutOption.withTimeoutOption(mfsRm);\n}\n\nconst removePath = async (context, path, options) => {\n  const mfsPath = await toMfsPath.toMfsPath(context, path, options);\n  const trail = await toTrail.toTrail(context, mfsPath.mfsPath);\n  const child = trail[trail.length - 1];\n  trail.pop();\n  const parent = trail[trail.length - 1];\n\n  if (!parent) {\n    throw errCode__default[\"default\"](new Error(`${path} does not exist`), 'ERR_NOT_FOUND');\n  }\n\n  if (child.type === 'directory' && !options.recursive) {\n    throw errCode__default[\"default\"](new Error(`${path} is a directory, use -r to remove directories`), 'ERR_WAS_DIR');\n  }\n\n  const {\n    cid\n  } = await removeLink.removeLink(context, {\n    parentCid: parent.cid,\n    name: child.name,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush,\n    shardSplitThreshold: options.shardSplitThreshold\n  });\n  parent.cid = cid;\n  const newRootCid = await updateTree.updateTree(context, trail, options);\n  await updateMfsRoot.updateMfsRoot(context, newRootCid, options);\n};\n\nexports.createRm = createRm;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-core/cjs/src/components/files/rm.js"],"names":["Object","defineProperty","exports","value","errCode","require","updateTree","updateMfsRoot","removeLink","toMfsPath","toTrail","withTimeoutOption","mergeOpts","_interopDefaultLegacy","e","errCode__default","mergeOpts__default","mergeOptions","bind","ignoreUndefined","defaultOptions","recursive","cidVersion","hashAlg","flush","shardSplitThreshold","createRm","context","mfsRm","paths","opts","options","Array","isArray","sources","Promise","all","map","path","length","Error","forEach","source","removePath","mfsPath","trail","child","pop","parent","type","cid","parentCid","name","newRootCid"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar errCode = require('err-code');\nvar updateTree = require('./utils/update-tree.js');\nvar updateMfsRoot = require('./utils/update-mfs-root.js');\nvar removeLink = require('./utils/remove-link.js');\nvar toMfsPath = require('./utils/to-mfs-path.js');\nvar toTrail = require('./utils/to-trail.js');\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\nvar mergeOpts = require('merge-options');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\nvar mergeOpts__default = /*#__PURE__*/_interopDefaultLegacy(mergeOpts);\n\nconst mergeOptions = mergeOpts__default[\"default\"].bind({ ignoreUndefined: true });\nconst defaultOptions = {\n  recursive: false,\n  cidVersion: 0,\n  hashAlg: 'sha2-256',\n  flush: true,\n  shardSplitThreshold: 1000\n};\nfunction createRm(context) {\n  async function mfsRm(paths, opts = {}) {\n    const options = mergeOptions(defaultOptions, opts);\n    if (!Array.isArray(paths)) {\n      paths = [paths];\n    }\n    const sources = await Promise.all(paths.map(path => toMfsPath.toMfsPath(context, path, options)));\n    if (!sources.length) {\n      throw errCode__default[\"default\"](new Error('Please supply at least one path to remove'), 'ERR_INVALID_PARAMS');\n    }\n    sources.forEach(source => {\n      if (source.path === '/') {\n        throw errCode__default[\"default\"](new Error('Cannot delete root'), 'ERR_INVALID_PARAMS');\n      }\n    });\n    for (const source of sources) {\n      await removePath(context, source.path, options);\n    }\n  }\n  return withTimeoutOption.withTimeoutOption(mfsRm);\n}\nconst removePath = async (context, path, options) => {\n  const mfsPath = await toMfsPath.toMfsPath(context, path, options);\n  const trail = await toTrail.toTrail(context, mfsPath.mfsPath);\n  const child = trail[trail.length - 1];\n  trail.pop();\n  const parent = trail[trail.length - 1];\n  if (!parent) {\n    throw errCode__default[\"default\"](new Error(`${ path } does not exist`), 'ERR_NOT_FOUND');\n  }\n  if (child.type === 'directory' && !options.recursive) {\n    throw errCode__default[\"default\"](new Error(`${ path } is a directory, use -r to remove directories`), 'ERR_WAS_DIR');\n  }\n  const {cid} = await removeLink.removeLink(context, {\n    parentCid: parent.cid,\n    name: child.name,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush,\n    shardSplitThreshold: options.shardSplitThreshold\n  });\n  parent.cid = cid;\n  const newRootCid = await updateTree.updateTree(context, trail, options);\n  await updateMfsRoot.updateMfsRoot(context, newRootCid, options);\n};\n\nexports.createRm = createRm;\n"]},"metadata":{},"sourceType":"script"}