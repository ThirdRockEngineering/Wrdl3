{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar NanoDate = require('timestamp-nano');\n\nvar key = require('interface-datastore/key');\n\nvar crypto = require('libp2p-crypto');\n\nvar PeerId = require('peer-id');\n\nvar Digest = require('multiformats/hashes/digest');\n\nvar identity = require('multiformats/hashes/identity');\n\nvar errCode = require('err-code');\n\nvar base32 = require('multiformats/bases/base32');\n\nvar fromString = require('uint8arrays/from-string');\n\nvar toString = require('uint8arrays/to-string');\n\nvar concat = require('uint8arrays/concat');\n\nvar equals = require('uint8arrays/equals');\n\nvar cborg = require('cborg');\n\nvar Long = require('long');\n\nvar debug = require('debug');\n\nvar ipns = require('./pb/ipns.js');\n\nvar utils = require('./utils.js');\n\nvar errors = require('./errors.js');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar NanoDate__default = /*#__PURE__*/_interopDefaultLegacy(NanoDate);\n\nvar crypto__default = /*#__PURE__*/_interopDefaultLegacy(crypto);\n\nvar PeerId__default = /*#__PURE__*/_interopDefaultLegacy(PeerId);\n\nvar Digest__namespace = /*#__PURE__*/_interopNamespace(Digest);\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\n\nvar cborg__namespace = /*#__PURE__*/_interopNamespace(cborg);\n\nvar Long__default = /*#__PURE__*/_interopDefaultLegacy(Long);\n\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\n\nconst log = Object.assign(debug__default[\"default\"]('jsipns'), {\n  error: debug__default[\"default\"]('jsipns:error')\n});\nconst ID_MULTIHASH_CODE = identity.identity.code;\nconst IPNS_PREFIX = fromString.fromString('/ipns/');\nconst namespace = '/ipns/';\nconst namespaceLength = namespace.length;\n\nconst create = (privateKey, value, seq, lifetime) => {\n  const expirationDate = new NanoDate__default[\"default\"](Date.now() + Number(lifetime));\n  const validityType = ipns.IpnsEntry.ValidityType.EOL;\n  const [ms, ns] = lifetime.toString().split('.');\n  const lifetimeNs = BigInt(ms) * BigInt(100000) + BigInt(ns || 0);\n  return _create(privateKey, value, seq, validityType, expirationDate, lifetimeNs);\n};\n\nconst createWithExpiration = (privateKey, value, seq, expiration) => {\n  const expirationDate = NanoDate__default[\"default\"].fromString(expiration);\n  const validityType = ipns.IpnsEntry.ValidityType.EOL;\n  const ttlMs = expirationDate.toDate().getTime() - Date.now();\n  const ttlNs = BigInt(ttlMs) * BigInt(100000) + BigInt(expirationDate.getNano());\n  return _create(privateKey, value, seq, validityType, expirationDate, ttlNs);\n};\n\nconst _create = async (privateKey, value, seq, validityType, expirationDate, ttl) => {\n  seq = BigInt(seq);\n  const isoValidity = fromString.fromString(expirationDate.toString());\n  const signatureV1 = await sign(privateKey, value, validityType, isoValidity);\n  const data = createCborData(value, isoValidity, validityType, seq, ttl);\n  const sigData = ipnsEntryDataForV2Sig(data);\n  const signatureV2 = await privateKey.sign(sigData);\n  const entry = {\n    value,\n    signature: signatureV1,\n    validityType: validityType,\n    validity: isoValidity,\n    sequence: seq,\n    ttl,\n    signatureV2,\n    data\n  };\n  log(`ipns entry for ${value} created`);\n  return entry;\n};\n\nconst createCborData = (value, validity, validityType, sequence, ttl) => {\n  const data = {\n    Value: value,\n    Validity: validity,\n    ValidityType: validityType,\n    Sequence: sequence,\n    TTL: ttl\n  };\n  return cborg__namespace.encode(data);\n};\n\nconst validate = async (publicKey, entry) => {\n  const {\n    value,\n    validityType,\n    validity\n  } = entry;\n  let dataForSignature;\n  let signature;\n\n  if (entry.signatureV2 && entry.data) {\n    signature = entry.signatureV2;\n    dataForSignature = ipnsEntryDataForV2Sig(entry.data);\n    validateCborDataMatchesPbData(entry);\n  } else {\n    signature = entry.signature;\n    dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity);\n  }\n\n  let isValid;\n\n  try {\n    isValid = await publicKey.verify(dataForSignature, signature);\n  } catch (err) {\n    isValid = false;\n  }\n\n  if (!isValid) {\n    log.error('record signature verification failed');\n    throw errCode__default[\"default\"](new Error('record signature verification failed'), errors.ERR_SIGNATURE_VERIFICATION);\n  }\n\n  if (validityType === ipns.IpnsEntry.ValidityType.EOL) {\n    let validityDate;\n\n    try {\n      validityDate = utils.parseRFC3339(toString.toString(validity));\n    } catch (e) {\n      log.error('unrecognized validity format (not an rfc3339 format)');\n      throw errCode__default[\"default\"](new Error('unrecognized validity format (not an rfc3339 format)'), errors.ERR_UNRECOGNIZED_FORMAT);\n    }\n\n    if (validityDate.getTime() < Date.now()) {\n      log.error('record has expired');\n      throw errCode__default[\"default\"](new Error('record has expired'), errors.ERR_IPNS_EXPIRED_RECORD);\n    }\n  } else if (validityType) {\n    log.error('unrecognized validity type');\n    throw errCode__default[\"default\"](new Error('unrecognized validity type'), errors.ERR_UNRECOGNIZED_VALIDITY);\n  }\n\n  log(`ipns entry for ${value} is valid`);\n};\n\nconst validateCborDataMatchesPbData = entry => {\n  if (!entry.data) {\n    throw errCode__default[\"default\"](new Error('Record data is missing'), errors.ERR_INVALID_RECORD_DATA);\n  }\n\n  const data = cborg__namespace.decode(entry.data);\n\n  if (Number.isInteger(data.Sequence)) {\n    data.Sequence = BigInt(data.Sequence);\n  }\n\n  if (Number.isInteger(data.TTL)) {\n    data.TTL = BigInt(data.TTL);\n  }\n\n  if (!equals.equals(data.Value, entry.value)) {\n    throw errCode__default[\"default\"](new Error('Field \"value\" did not match between protobuf and CBOR'), errors.ERR_SIGNATURE_VERIFICATION);\n  }\n\n  if (!equals.equals(data.Validity, entry.validity)) {\n    throw errCode__default[\"default\"](new Error('Field \"validity\" did not match between protobuf and CBOR'), errors.ERR_SIGNATURE_VERIFICATION);\n  }\n\n  if (data.ValidityType !== entry.validityType) {\n    throw errCode__default[\"default\"](new Error('Field \"validityType\" did not match between protobuf and CBOR'), errors.ERR_SIGNATURE_VERIFICATION);\n  }\n\n  if (data.Sequence !== entry.sequence) {\n    throw errCode__default[\"default\"](new Error('Field \"sequence\" did not match between protobuf and CBOR'), errors.ERR_SIGNATURE_VERIFICATION);\n  }\n\n  if (data.TTL !== entry.ttl) {\n    throw errCode__default[\"default\"](new Error('Field \"ttl\" did not match between protobuf and CBOR'), errors.ERR_SIGNATURE_VERIFICATION);\n  }\n};\n\nconst embedPublicKey = async (publicKey, entry) => {\n  if (!publicKey || !publicKey.bytes || !entry) {\n    const error = new Error('one or more of the provided parameters are not defined');\n    log.error(error);\n    throw errCode__default[\"default\"](error, errors.ERR_UNDEFINED_PARAMETER);\n  }\n\n  let peerId;\n\n  try {\n    peerId = await PeerId__default[\"default\"].createFromPubKey(publicKey.bytes);\n  } catch (err) {\n    throw errCode__default[\"default\"](err, errors.ERR_PEER_ID_FROM_PUBLIC_KEY);\n  }\n\n  let extractedPublicKey;\n\n  try {\n    extractedPublicKey = extractPublicKeyFromId(peerId);\n  } catch (err) {\n    log.error(err);\n    throw errCode__default[\"default\"](err, errors.ERR_PUBLIC_KEY_FROM_ID);\n  }\n\n  if (extractedPublicKey) {\n    return null;\n  }\n\n  try {\n    entry.pubKey = crypto__default[\"default\"].keys.marshalPublicKey(publicKey);\n  } catch (err) {\n    log.error(err);\n    throw err;\n  }\n\n  return entry;\n};\n\nconst extractPublicKey = async (peerId, entry) => {\n  if (!entry || !peerId) {\n    const error = new Error('one or more of the provided parameters are not defined');\n    log.error(error);\n    throw errCode__default[\"default\"](error, errors.ERR_UNDEFINED_PARAMETER);\n  }\n\n  let pubKey;\n\n  if (entry.pubKey) {\n    try {\n      pubKey = crypto__default[\"default\"].keys.unmarshalPublicKey(entry.pubKey);\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n\n    const otherId = await PeerId__default[\"default\"].createFromPubKey(entry.pubKey);\n\n    if (!otherId.equals(peerId)) {\n      throw errCode__default[\"default\"](new Error('Embedded public key did not match PeerID'), errors.ERR_INVALID_EMBEDDED_KEY);\n    }\n  } else if (peerId.pubKey) {\n    pubKey = peerId.pubKey;\n  }\n\n  if (pubKey) {\n    return pubKey;\n  }\n\n  throw errCode__default[\"default\"](new Error('no public key is available'), errors.ERR_UNDEFINED_PARAMETER);\n};\n\nconst rawStdEncoding = key => base32.base32upper.encode(key).slice(1);\n\nconst getLocalKey = key$1 => new key.Key(`/ipns/${rawStdEncoding(key$1)}`);\n\nconst getIdKeys = pid => {\n  const pkBuffer = fromString.fromString('/pk/');\n  const ipnsBuffer = fromString.fromString('/ipns/');\n  return {\n    routingPubKey: new key.Key(concat.concat([pkBuffer, pid]), false),\n    pkKey: new key.Key(rawStdEncoding(concat.concat([pkBuffer, pid]))),\n    routingKey: new key.Key(concat.concat([ipnsBuffer, pid]), false),\n    ipnsKey: new key.Key(rawStdEncoding(concat.concat([ipnsBuffer, pid])))\n  };\n};\n\nconst sign = (privateKey, value, validityType, validity) => {\n  try {\n    const dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity);\n    return privateKey.sign(dataForSignature);\n  } catch (error) {\n    log.error('record signature creation failed');\n    throw errCode__default[\"default\"](new Error('record signature creation failed: ' + error.message), errors.ERR_SIGNATURE_CREATION);\n  }\n};\n\nconst getValidityType = validityType => {\n  if (validityType.toString() === '0') {\n    return 'EOL';\n  }\n\n  const error = new Error(`unrecognized validity type ${validityType.toString()}`);\n  log.error(error);\n  throw errCode__default[\"default\"](error, errors.ERR_UNRECOGNIZED_VALIDITY);\n};\n\nconst ipnsEntryDataForV1Sig = (value, validityType, validity) => {\n  const validityTypeBuffer = fromString.fromString(getValidityType(validityType));\n  return concat.concat([value, validity, validityTypeBuffer]);\n};\n\nconst ipnsEntryDataForV2Sig = data => {\n  const entryData = fromString.fromString('ipns-signature:');\n  return concat.concat([entryData, data]);\n};\n\nconst extractPublicKeyFromId = peerId => {\n  const digest = Digest__namespace.decode(peerId.id);\n\n  if (digest.code !== ID_MULTIHASH_CODE) {\n    return null;\n  }\n\n  return crypto__default[\"default\"].keys.unmarshalPublicKey(digest.digest);\n};\n\nconst marshal = obj => {\n  return ipns.IpnsEntry.encode({ ...obj,\n    sequence: Long__default[\"default\"].fromString(obj.sequence.toString()),\n    ttl: obj.ttl == null ? undefined : Long__default[\"default\"].fromString(obj.ttl.toString())\n  }).finish();\n};\n\nconst unmarshal = buf => {\n  const message = ipns.IpnsEntry.decode(buf);\n  const object = ipns.IpnsEntry.toObject(message, {\n    defaults: false,\n    arrays: true,\n    objects: false\n  });\n  return {\n    value: object.value,\n    signature: object.signature,\n    validityType: object.validityType,\n    validity: object.validity,\n    sequence: Object.hasOwnProperty.call(object, 'sequence') ? BigInt(`${object.sequence}`) : 0,\n    pubKey: object.pubKey,\n    ttl: Object.hasOwnProperty.call(object, 'ttl') ? BigInt(`${object.ttl}`) : undefined,\n    signatureV2: object.signatureV2,\n    data: object.data\n  };\n};\n\nconst validator = {\n  validate: async (marshalledData, key) => {\n    const receivedEntry = unmarshal(marshalledData);\n    const bufferId = key.slice(IPNS_PREFIX.length);\n    const peerId = PeerId__default[\"default\"].createFromBytes(bufferId);\n    const pubKey = await extractPublicKey(peerId, receivedEntry);\n    await validate(pubKey, receivedEntry);\n  },\n  select: (dataA, dataB) => {\n    const entryA = unmarshal(dataA);\n    const entryB = unmarshal(dataB);\n\n    if (entryA.signatureV2 && !entryB.signatureV2) {\n      return 0;\n    } else if (entryB.signatureV2 && !entryA.signatureV2) {\n      return 1;\n    }\n\n    if (entryA.sequence > entryB.sequence) {\n      return 0;\n    } else if (entryA.sequence < entryB.sequence) {\n      return 1;\n    }\n\n    const entryAValidityDate = utils.parseRFC3339(toString.toString(entryA.validity));\n    const entryBValidityDate = utils.parseRFC3339(toString.toString(entryB.validity));\n    return entryBValidityDate.getTime() > entryAValidityDate.getTime() ? 1 : 0;\n  }\n};\nexports.create = create;\nexports.createWithExpiration = createWithExpiration;\nexports.embedPublicKey = embedPublicKey;\nexports.extractPublicKey = extractPublicKey;\nexports.getIdKeys = getIdKeys;\nexports.getLocalKey = getLocalKey;\nexports.marshal = marshal;\nexports.namespace = namespace;\nexports.namespaceLength = namespaceLength;\nexports.unmarshal = unmarshal;\nexports.validate = validate;\nexports.validator = validator;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipns/cjs/src/index.js"],"names":["Object","defineProperty","exports","value","NanoDate","require","key","crypto","PeerId","Digest","identity","errCode","base32","fromString","toString","concat","equals","cborg","Long","debug","ipns","utils","errors","_interopDefaultLegacy","e","_interopNamespace","__esModule","n","create","keys","forEach","k","d","getOwnPropertyDescriptor","get","enumerable","freeze","NanoDate__default","crypto__default","PeerId__default","Digest__namespace","errCode__default","cborg__namespace","Long__default","debug__default","log","assign","error","ID_MULTIHASH_CODE","code","IPNS_PREFIX","namespace","namespaceLength","length","privateKey","seq","lifetime","expirationDate","Date","now","Number","validityType","IpnsEntry","ValidityType","EOL","ms","ns","split","lifetimeNs","BigInt","_create","createWithExpiration","expiration","ttlMs","toDate","getTime","ttlNs","getNano","ttl","isoValidity","signatureV1","sign","data","createCborData","sigData","ipnsEntryDataForV2Sig","signatureV2","entry","signature","validity","sequence","Value","Validity","Sequence","TTL","encode","validate","publicKey","dataForSignature","validateCborDataMatchesPbData","ipnsEntryDataForV1Sig","isValid","verify","err","Error","ERR_SIGNATURE_VERIFICATION","validityDate","parseRFC3339","ERR_UNRECOGNIZED_FORMAT","ERR_IPNS_EXPIRED_RECORD","ERR_UNRECOGNIZED_VALIDITY","ERR_INVALID_RECORD_DATA","decode","isInteger","embedPublicKey","bytes","ERR_UNDEFINED_PARAMETER","peerId","createFromPubKey","ERR_PEER_ID_FROM_PUBLIC_KEY","extractedPublicKey","extractPublicKeyFromId","ERR_PUBLIC_KEY_FROM_ID","pubKey","marshalPublicKey","extractPublicKey","unmarshalPublicKey","otherId","ERR_INVALID_EMBEDDED_KEY","rawStdEncoding","base32upper","slice","getLocalKey","key$1","Key","getIdKeys","pid","pkBuffer","ipnsBuffer","routingPubKey","pkKey","routingKey","ipnsKey","message","ERR_SIGNATURE_CREATION","getValidityType","validityTypeBuffer","entryData","digest","id","marshal","obj","undefined","finish","unmarshal","buf","object","toObject","defaults","arrays","objects","hasOwnProperty","call","validator","marshalledData","receivedEntry","bufferId","createFromBytes","select","dataA","dataB","entryA","entryB","entryAValidityDate","entryBValidityDate"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar NanoDate = require('timestamp-nano');\nvar key = require('interface-datastore/key');\nvar crypto = require('libp2p-crypto');\nvar PeerId = require('peer-id');\nvar Digest = require('multiformats/hashes/digest');\nvar identity = require('multiformats/hashes/identity');\nvar errCode = require('err-code');\nvar base32 = require('multiformats/bases/base32');\nvar fromString = require('uint8arrays/from-string');\nvar toString = require('uint8arrays/to-string');\nvar concat = require('uint8arrays/concat');\nvar equals = require('uint8arrays/equals');\nvar cborg = require('cborg');\nvar Long = require('long');\nvar debug = require('debug');\nvar ipns = require('./pb/ipns.js');\nvar utils = require('./utils.js');\nvar errors = require('./errors.js');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar NanoDate__default = /*#__PURE__*/_interopDefaultLegacy(NanoDate);\nvar crypto__default = /*#__PURE__*/_interopDefaultLegacy(crypto);\nvar PeerId__default = /*#__PURE__*/_interopDefaultLegacy(PeerId);\nvar Digest__namespace = /*#__PURE__*/_interopNamespace(Digest);\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\nvar cborg__namespace = /*#__PURE__*/_interopNamespace(cborg);\nvar Long__default = /*#__PURE__*/_interopDefaultLegacy(Long);\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\n\nconst log = Object.assign(debug__default[\"default\"]('jsipns'), { error: debug__default[\"default\"]('jsipns:error') });\nconst ID_MULTIHASH_CODE = identity.identity.code;\nconst IPNS_PREFIX = fromString.fromString('/ipns/');\nconst namespace = '/ipns/';\nconst namespaceLength = namespace.length;\nconst create = (privateKey, value, seq, lifetime) => {\n  const expirationDate = new NanoDate__default[\"default\"](Date.now() + Number(lifetime));\n  const validityType = ipns.IpnsEntry.ValidityType.EOL;\n  const [ms, ns] = lifetime.toString().split('.');\n  const lifetimeNs = BigInt(ms) * BigInt(100000) + BigInt(ns || 0);\n  return _create(privateKey, value, seq, validityType, expirationDate, lifetimeNs);\n};\nconst createWithExpiration = (privateKey, value, seq, expiration) => {\n  const expirationDate = NanoDate__default[\"default\"].fromString(expiration);\n  const validityType = ipns.IpnsEntry.ValidityType.EOL;\n  const ttlMs = expirationDate.toDate().getTime() - Date.now();\n  const ttlNs = BigInt(ttlMs) * BigInt(100000) + BigInt(expirationDate.getNano());\n  return _create(privateKey, value, seq, validityType, expirationDate, ttlNs);\n};\nconst _create = async (privateKey, value, seq, validityType, expirationDate, ttl) => {\n  seq = BigInt(seq);\n  const isoValidity = fromString.fromString(expirationDate.toString());\n  const signatureV1 = await sign(privateKey, value, validityType, isoValidity);\n  const data = createCborData(value, isoValidity, validityType, seq, ttl);\n  const sigData = ipnsEntryDataForV2Sig(data);\n  const signatureV2 = await privateKey.sign(sigData);\n  const entry = {\n    value,\n    signature: signatureV1,\n    validityType: validityType,\n    validity: isoValidity,\n    sequence: seq,\n    ttl,\n    signatureV2,\n    data\n  };\n  log(`ipns entry for ${ value } created`);\n  return entry;\n};\nconst createCborData = (value, validity, validityType, sequence, ttl) => {\n  const data = {\n    Value: value,\n    Validity: validity,\n    ValidityType: validityType,\n    Sequence: sequence,\n    TTL: ttl\n  };\n  return cborg__namespace.encode(data);\n};\nconst validate = async (publicKey, entry) => {\n  const {value, validityType, validity} = entry;\n  let dataForSignature;\n  let signature;\n  if (entry.signatureV2 && entry.data) {\n    signature = entry.signatureV2;\n    dataForSignature = ipnsEntryDataForV2Sig(entry.data);\n    validateCborDataMatchesPbData(entry);\n  } else {\n    signature = entry.signature;\n    dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity);\n  }\n  let isValid;\n  try {\n    isValid = await publicKey.verify(dataForSignature, signature);\n  } catch (err) {\n    isValid = false;\n  }\n  if (!isValid) {\n    log.error('record signature verification failed');\n    throw errCode__default[\"default\"](new Error('record signature verification failed'), errors.ERR_SIGNATURE_VERIFICATION);\n  }\n  if (validityType === ipns.IpnsEntry.ValidityType.EOL) {\n    let validityDate;\n    try {\n      validityDate = utils.parseRFC3339(toString.toString(validity));\n    } catch (e) {\n      log.error('unrecognized validity format (not an rfc3339 format)');\n      throw errCode__default[\"default\"](new Error('unrecognized validity format (not an rfc3339 format)'), errors.ERR_UNRECOGNIZED_FORMAT);\n    }\n    if (validityDate.getTime() < Date.now()) {\n      log.error('record has expired');\n      throw errCode__default[\"default\"](new Error('record has expired'), errors.ERR_IPNS_EXPIRED_RECORD);\n    }\n  } else if (validityType) {\n    log.error('unrecognized validity type');\n    throw errCode__default[\"default\"](new Error('unrecognized validity type'), errors.ERR_UNRECOGNIZED_VALIDITY);\n  }\n  log(`ipns entry for ${ value } is valid`);\n};\nconst validateCborDataMatchesPbData = entry => {\n  if (!entry.data) {\n    throw errCode__default[\"default\"](new Error('Record data is missing'), errors.ERR_INVALID_RECORD_DATA);\n  }\n  const data = cborg__namespace.decode(entry.data);\n  if (Number.isInteger(data.Sequence)) {\n    data.Sequence = BigInt(data.Sequence);\n  }\n  if (Number.isInteger(data.TTL)) {\n    data.TTL = BigInt(data.TTL);\n  }\n  if (!equals.equals(data.Value, entry.value)) {\n    throw errCode__default[\"default\"](new Error('Field \"value\" did not match between protobuf and CBOR'), errors.ERR_SIGNATURE_VERIFICATION);\n  }\n  if (!equals.equals(data.Validity, entry.validity)) {\n    throw errCode__default[\"default\"](new Error('Field \"validity\" did not match between protobuf and CBOR'), errors.ERR_SIGNATURE_VERIFICATION);\n  }\n  if (data.ValidityType !== entry.validityType) {\n    throw errCode__default[\"default\"](new Error('Field \"validityType\" did not match between protobuf and CBOR'), errors.ERR_SIGNATURE_VERIFICATION);\n  }\n  if (data.Sequence !== entry.sequence) {\n    throw errCode__default[\"default\"](new Error('Field \"sequence\" did not match between protobuf and CBOR'), errors.ERR_SIGNATURE_VERIFICATION);\n  }\n  if (data.TTL !== entry.ttl) {\n    throw errCode__default[\"default\"](new Error('Field \"ttl\" did not match between protobuf and CBOR'), errors.ERR_SIGNATURE_VERIFICATION);\n  }\n};\nconst embedPublicKey = async (publicKey, entry) => {\n  if (!publicKey || !publicKey.bytes || !entry) {\n    const error = new Error('one or more of the provided parameters are not defined');\n    log.error(error);\n    throw errCode__default[\"default\"](error, errors.ERR_UNDEFINED_PARAMETER);\n  }\n  let peerId;\n  try {\n    peerId = await PeerId__default[\"default\"].createFromPubKey(publicKey.bytes);\n  } catch (err) {\n    throw errCode__default[\"default\"](err, errors.ERR_PEER_ID_FROM_PUBLIC_KEY);\n  }\n  let extractedPublicKey;\n  try {\n    extractedPublicKey = extractPublicKeyFromId(peerId);\n  } catch (err) {\n    log.error(err);\n    throw errCode__default[\"default\"](err, errors.ERR_PUBLIC_KEY_FROM_ID);\n  }\n  if (extractedPublicKey) {\n    return null;\n  }\n  try {\n    entry.pubKey = crypto__default[\"default\"].keys.marshalPublicKey(publicKey);\n  } catch (err) {\n    log.error(err);\n    throw err;\n  }\n  return entry;\n};\nconst extractPublicKey = async (peerId, entry) => {\n  if (!entry || !peerId) {\n    const error = new Error('one or more of the provided parameters are not defined');\n    log.error(error);\n    throw errCode__default[\"default\"](error, errors.ERR_UNDEFINED_PARAMETER);\n  }\n  let pubKey;\n  if (entry.pubKey) {\n    try {\n      pubKey = crypto__default[\"default\"].keys.unmarshalPublicKey(entry.pubKey);\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n    const otherId = await PeerId__default[\"default\"].createFromPubKey(entry.pubKey);\n    if (!otherId.equals(peerId)) {\n      throw errCode__default[\"default\"](new Error('Embedded public key did not match PeerID'), errors.ERR_INVALID_EMBEDDED_KEY);\n    }\n  } else if (peerId.pubKey) {\n    pubKey = peerId.pubKey;\n  }\n  if (pubKey) {\n    return pubKey;\n  }\n  throw errCode__default[\"default\"](new Error('no public key is available'), errors.ERR_UNDEFINED_PARAMETER);\n};\nconst rawStdEncoding = key => base32.base32upper.encode(key).slice(1);\nconst getLocalKey = key$1 => new key.Key(`/ipns/${ rawStdEncoding(key$1) }`);\nconst getIdKeys = pid => {\n  const pkBuffer = fromString.fromString('/pk/');\n  const ipnsBuffer = fromString.fromString('/ipns/');\n  return {\n    routingPubKey: new key.Key(concat.concat([\n      pkBuffer,\n      pid\n    ]), false),\n    pkKey: new key.Key(rawStdEncoding(concat.concat([\n      pkBuffer,\n      pid\n    ]))),\n    routingKey: new key.Key(concat.concat([\n      ipnsBuffer,\n      pid\n    ]), false),\n    ipnsKey: new key.Key(rawStdEncoding(concat.concat([\n      ipnsBuffer,\n      pid\n    ])))\n  };\n};\nconst sign = (privateKey, value, validityType, validity) => {\n  try {\n    const dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity);\n    return privateKey.sign(dataForSignature);\n  } catch (error) {\n    log.error('record signature creation failed');\n    throw errCode__default[\"default\"](new Error('record signature creation failed: ' + error.message), errors.ERR_SIGNATURE_CREATION);\n  }\n};\nconst getValidityType = validityType => {\n  if (validityType.toString() === '0') {\n    return 'EOL';\n  }\n  const error = new Error(`unrecognized validity type ${ validityType.toString() }`);\n  log.error(error);\n  throw errCode__default[\"default\"](error, errors.ERR_UNRECOGNIZED_VALIDITY);\n};\nconst ipnsEntryDataForV1Sig = (value, validityType, validity) => {\n  const validityTypeBuffer = fromString.fromString(getValidityType(validityType));\n  return concat.concat([\n    value,\n    validity,\n    validityTypeBuffer\n  ]);\n};\nconst ipnsEntryDataForV2Sig = data => {\n  const entryData = fromString.fromString('ipns-signature:');\n  return concat.concat([\n    entryData,\n    data\n  ]);\n};\nconst extractPublicKeyFromId = peerId => {\n  const digest = Digest__namespace.decode(peerId.id);\n  if (digest.code !== ID_MULTIHASH_CODE) {\n    return null;\n  }\n  return crypto__default[\"default\"].keys.unmarshalPublicKey(digest.digest);\n};\nconst marshal = obj => {\n  return ipns.IpnsEntry.encode({\n    ...obj,\n    sequence: Long__default[\"default\"].fromString(obj.sequence.toString()),\n    ttl: obj.ttl == null ? undefined : Long__default[\"default\"].fromString(obj.ttl.toString())\n  }).finish();\n};\nconst unmarshal = buf => {\n  const message = ipns.IpnsEntry.decode(buf);\n  const object = ipns.IpnsEntry.toObject(message, {\n    defaults: false,\n    arrays: true,\n    objects: false\n  });\n  return {\n    value: object.value,\n    signature: object.signature,\n    validityType: object.validityType,\n    validity: object.validity,\n    sequence: Object.hasOwnProperty.call(object, 'sequence') ? BigInt(`${ object.sequence }`) : 0,\n    pubKey: object.pubKey,\n    ttl: Object.hasOwnProperty.call(object, 'ttl') ? BigInt(`${ object.ttl }`) : undefined,\n    signatureV2: object.signatureV2,\n    data: object.data\n  };\n};\nconst validator = {\n  validate: async (marshalledData, key) => {\n    const receivedEntry = unmarshal(marshalledData);\n    const bufferId = key.slice(IPNS_PREFIX.length);\n    const peerId = PeerId__default[\"default\"].createFromBytes(bufferId);\n    const pubKey = await extractPublicKey(peerId, receivedEntry);\n    await validate(pubKey, receivedEntry);\n  },\n  select: (dataA, dataB) => {\n    const entryA = unmarshal(dataA);\n    const entryB = unmarshal(dataB);\n    if (entryA.signatureV2 && !entryB.signatureV2) {\n      return 0;\n    } else if (entryB.signatureV2 && !entryA.signatureV2) {\n      return 1;\n    }\n    if (entryA.sequence > entryB.sequence) {\n      return 0;\n    } else if (entryA.sequence < entryB.sequence) {\n      return 1;\n    }\n    const entryAValidityDate = utils.parseRFC3339(toString.toString(entryA.validity));\n    const entryBValidityDate = utils.parseRFC3339(toString.toString(entryB.validity));\n    return entryBValidityDate.getTime() > entryAValidityDate.getTime() ? 1 : 0;\n  }\n};\n\nexports.create = create;\nexports.createWithExpiration = createWithExpiration;\nexports.embedPublicKey = embedPublicKey;\nexports.extractPublicKey = extractPublicKey;\nexports.getIdKeys = getIdKeys;\nexports.getLocalKey = getLocalKey;\nexports.marshal = marshal;\nexports.namespace = namespace;\nexports.namespaceLength = namespaceLength;\nexports.unmarshal = unmarshal;\nexports.validate = validate;\nexports.validator = validator;\n"]},"metadata":{},"sourceType":"script"}