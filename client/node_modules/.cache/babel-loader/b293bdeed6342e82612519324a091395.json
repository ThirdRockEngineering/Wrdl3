{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar errCode = require('err-code');\n\nvar debug = require('debug');\n\nvar ipfsUnixfsExporter = require('ipfs-unixfs-exporter');\n\nvar createNode = require('./utils/create-node.js');\n\nvar toPathComponents = require('./utils/to-path-components.js');\n\nvar updateMfsRoot = require('./utils/update-mfs-root.js');\n\nvar updateTree = require('./utils/update-tree.js');\n\nvar addLink = require('./utils/add-link.js');\n\nvar withMfsRoot = require('./utils/with-mfs-root.js');\n\nvar mergeOpts = require('merge-options');\n\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\n\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\n\nvar mergeOpts__default = /*#__PURE__*/_interopDefaultLegacy(mergeOpts);\n\nconst mergeOptions = mergeOpts__default[\"default\"].bind({\n  ignoreUndefined: true\n});\nconst log = debug__default[\"default\"]('ipfs:mfs:mkdir');\nconst defaultOptions = {\n  parents: false,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000,\n  flush: true\n};\n\nfunction createMkdir(context) {\n  async function mfsMkdir(path) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const opts = mergeOptions(defaultOptions, options);\n\n    if (!path) {\n      throw new Error('no path given to Mkdir');\n    }\n\n    path = path.trim();\n\n    if (path === '/') {\n      if (opts.parents) {\n        return;\n      }\n\n      throw errCode__default[\"default\"](new Error('cannot create directory \\'/\\': Already exists'), 'ERR_INVALID_PATH');\n    }\n\n    if (path.substring(0, 1) !== '/') {\n      throw errCode__default[\"default\"](new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH');\n    }\n\n    log(`Creating ${path}`);\n    const pathComponents = toPathComponents.toPathComponents(path);\n\n    if (pathComponents[0] === 'ipfs') {\n      throw errCode__default[\"default\"](new Error('path cannot have the prefix \\'ipfs\\''), 'ERR_INVALID_PATH');\n    }\n\n    const root = await withMfsRoot.loadMfsRoot(context, opts);\n    let parent;\n    const trail = [];\n    const emptyDir = await createNode.createNode(context, 'directory', opts);\n\n    for (let i = 0; i <= pathComponents.length; i++) {\n      const subPathComponents = pathComponents.slice(0, i);\n      const subPath = `/ipfs/${root}/${subPathComponents.join('/')}`;\n\n      try {\n        parent = await ipfsUnixfsExporter.exporter(subPath, context.repo.blocks);\n\n        if (parent.type !== 'file' && parent.type !== 'directory') {\n          throw errCode__default[\"default\"](new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS');\n        }\n\n        if (i === pathComponents.length) {\n          if (opts.parents) {\n            return;\n          }\n\n          throw errCode__default[\"default\"](new Error('file already exists'), 'ERR_ALREADY_EXISTS');\n        }\n\n        trail.push({\n          name: parent.name,\n          cid: parent.cid\n        });\n      } catch (err) {\n        if (err.code === 'ERR_NOT_FOUND') {\n          if (i < pathComponents.length && !opts.parents) {\n            throw errCode__default[\"default\"](new Error(`Intermediate directory path ${subPath} does not exist, use the -p flag to create it`), 'ERR_NOT_FOUND');\n          }\n\n          await addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, opts);\n        } else {\n          throw err;\n        }\n      }\n    }\n\n    const newRootCid = await updateTree.updateTree(context, trail, opts);\n    await updateMfsRoot.updateMfsRoot(context, newRootCid, opts);\n  }\n\n  return withTimeoutOption.withTimeoutOption(mfsMkdir);\n}\n\nconst addEmptyDir = async (context, childName, emptyDir, parent, trail, options) => {\n  log(`Adding empty dir called ${childName} to ${parent.cid}`);\n  const result = await addLink.addLink(context, {\n    parent: parent.node,\n    parentCid: parent.cid,\n    size: 0,\n    cid: emptyDir.cid,\n    name: childName,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush,\n    shardSplitThreshold: options.shardSplitThreshold\n  });\n  trail[trail.length - 1].cid = result.cid;\n  trail.push({\n    name: childName,\n    cid: emptyDir.cid\n  });\n};\n\nexports.createMkdir = createMkdir;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-core/cjs/src/components/files/mkdir.js"],"names":["Object","defineProperty","exports","value","errCode","require","debug","ipfsUnixfsExporter","createNode","toPathComponents","updateMfsRoot","updateTree","addLink","withMfsRoot","mergeOpts","withTimeoutOption","_interopDefaultLegacy","e","errCode__default","debug__default","mergeOpts__default","mergeOptions","bind","ignoreUndefined","log","defaultOptions","parents","hashAlg","cidVersion","shardSplitThreshold","flush","createMkdir","context","mfsMkdir","path","options","opts","Error","trim","substring","pathComponents","root","loadMfsRoot","parent","trail","emptyDir","i","length","subPathComponents","slice","subPath","join","exporter","repo","blocks","type","push","name","cid","err","code","addEmptyDir","newRootCid","childName","result","node","parentCid","size"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar errCode = require('err-code');\nvar debug = require('debug');\nvar ipfsUnixfsExporter = require('ipfs-unixfs-exporter');\nvar createNode = require('./utils/create-node.js');\nvar toPathComponents = require('./utils/to-path-components.js');\nvar updateMfsRoot = require('./utils/update-mfs-root.js');\nvar updateTree = require('./utils/update-tree.js');\nvar addLink = require('./utils/add-link.js');\nvar withMfsRoot = require('./utils/with-mfs-root.js');\nvar mergeOpts = require('merge-options');\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\nvar mergeOpts__default = /*#__PURE__*/_interopDefaultLegacy(mergeOpts);\n\nconst mergeOptions = mergeOpts__default[\"default\"].bind({ ignoreUndefined: true });\nconst log = debug__default[\"default\"]('ipfs:mfs:mkdir');\nconst defaultOptions = {\n  parents: false,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000,\n  flush: true\n};\nfunction createMkdir(context) {\n  async function mfsMkdir(path, options = {}) {\n    const opts = mergeOptions(defaultOptions, options);\n    if (!path) {\n      throw new Error('no path given to Mkdir');\n    }\n    path = path.trim();\n    if (path === '/') {\n      if (opts.parents) {\n        return;\n      }\n      throw errCode__default[\"default\"](new Error('cannot create directory \\'/\\': Already exists'), 'ERR_INVALID_PATH');\n    }\n    if (path.substring(0, 1) !== '/') {\n      throw errCode__default[\"default\"](new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH');\n    }\n    log(`Creating ${ path }`);\n    const pathComponents = toPathComponents.toPathComponents(path);\n    if (pathComponents[0] === 'ipfs') {\n      throw errCode__default[\"default\"](new Error('path cannot have the prefix \\'ipfs\\''), 'ERR_INVALID_PATH');\n    }\n    const root = await withMfsRoot.loadMfsRoot(context, opts);\n    let parent;\n    const trail = [];\n    const emptyDir = await createNode.createNode(context, 'directory', opts);\n    for (let i = 0; i <= pathComponents.length; i++) {\n      const subPathComponents = pathComponents.slice(0, i);\n      const subPath = `/ipfs/${ root }/${ subPathComponents.join('/') }`;\n      try {\n        parent = await ipfsUnixfsExporter.exporter(subPath, context.repo.blocks);\n        if (parent.type !== 'file' && parent.type !== 'directory') {\n          throw errCode__default[\"default\"](new Error(`${ path } was not a UnixFS node`), 'ERR_NOT_UNIXFS');\n        }\n        if (i === pathComponents.length) {\n          if (opts.parents) {\n            return;\n          }\n          throw errCode__default[\"default\"](new Error('file already exists'), 'ERR_ALREADY_EXISTS');\n        }\n        trail.push({\n          name: parent.name,\n          cid: parent.cid\n        });\n      } catch (err) {\n        if (err.code === 'ERR_NOT_FOUND') {\n          if (i < pathComponents.length && !opts.parents) {\n            throw errCode__default[\"default\"](new Error(`Intermediate directory path ${ subPath } does not exist, use the -p flag to create it`), 'ERR_NOT_FOUND');\n          }\n          await addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, opts);\n        } else {\n          throw err;\n        }\n      }\n    }\n    const newRootCid = await updateTree.updateTree(context, trail, opts);\n    await updateMfsRoot.updateMfsRoot(context, newRootCid, opts);\n  }\n  return withTimeoutOption.withTimeoutOption(mfsMkdir);\n}\nconst addEmptyDir = async (context, childName, emptyDir, parent, trail, options) => {\n  log(`Adding empty dir called ${ childName } to ${ parent.cid }`);\n  const result = await addLink.addLink(context, {\n    parent: parent.node,\n    parentCid: parent.cid,\n    size: 0,\n    cid: emptyDir.cid,\n    name: childName,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush,\n    shardSplitThreshold: options.shardSplitThreshold\n  });\n  trail[trail.length - 1].cid = result.cid;\n  trail.push({\n    name: childName,\n    cid: emptyDir.cid\n  });\n};\n\nexports.createMkdir = createMkdir;\n"]},"metadata":{},"sourceType":"script"}