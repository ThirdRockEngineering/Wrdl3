{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar iterator = require('@ipld/car/iterator');\n\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\n\nvar itPeekable = require('it-peekable');\n\nvar drain = require('it-drain');\n\nvar map = require('it-map');\n\nvar debug = require('debug');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar itPeekable__default = /*#__PURE__*/_interopDefaultLegacy(itPeekable);\n\nvar drain__default = /*#__PURE__*/_interopDefaultLegacy(drain);\n\nvar map__default = /*#__PURE__*/_interopDefaultLegacy(map);\n\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\n\nconst log = debug__default[\"default\"]('ipfs:components:dag:import');\n\nfunction createImport(_ref) {\n  let {\n    repo\n  } = _ref;\n\n  async function* dagImport(sources) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const release = await repo.gcLock.readLock();\n\n    try {\n      const abortOptions = {\n        signal: options.signal,\n        timeout: options.timeout\n      };\n      const peekable = itPeekable__default[\"default\"](sources);\n      const {\n        value,\n        done\n      } = await peekable.peek();\n\n      if (done) {\n        return;\n      }\n\n      if (value) {\n        peekable.push(value);\n      }\n\n      let cars;\n\n      if (value instanceof Uint8Array) {\n        cars = [peekable];\n      } else {\n        cars = peekable;\n      }\n\n      for await (const car of cars) {\n        const roots = await importCar(repo, abortOptions, car);\n\n        if (options.pinRoots !== false) {\n          for (const cid of roots) {\n            let pinErrorMsg = '';\n\n            try {\n              if (await repo.blocks.has(cid)) {\n                log(`Pinning root ${cid}`);\n                await repo.pins.pinRecursively(cid);\n              } else {\n                pinErrorMsg = 'blockstore: block not found';\n              }\n            } catch (err) {\n              pinErrorMsg = err.message;\n            }\n\n            yield {\n              root: {\n                cid,\n                pinErrorMsg\n              }\n            };\n          }\n        }\n      }\n    } finally {\n      release();\n    }\n  }\n\n  return withTimeoutOption.withTimeoutOption(dagImport);\n}\n\nasync function importCar(repo, options, source) {\n  const reader = await iterator.CarBlockIterator.fromIterable(source);\n  const roots = await reader.getRoots();\n  await drain__default[\"default\"](repo.blocks.putMany(map__default[\"default\"](reader, _ref2 => {\n    let {\n      cid: key,\n      bytes: value\n    } = _ref2;\n    log(`Import block ${key}`);\n    return {\n      key,\n      value\n    };\n  }), {\n    signal: options.signal\n  }));\n  return roots;\n}\n\nexports.createImport = createImport;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-core/cjs/src/components/dag/import.js"],"names":["Object","defineProperty","exports","value","iterator","require","withTimeoutOption","itPeekable","drain","map","debug","_interopDefaultLegacy","e","itPeekable__default","drain__default","map__default","debug__default","log","createImport","repo","dagImport","sources","options","release","gcLock","readLock","abortOptions","signal","timeout","peekable","done","peek","push","cars","Uint8Array","car","roots","importCar","pinRoots","cid","pinErrorMsg","blocks","has","pins","pinRecursively","err","message","root","source","reader","CarBlockIterator","fromIterable","getRoots","putMany","key","bytes"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar iterator = require('@ipld/car/iterator');\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\nvar itPeekable = require('it-peekable');\nvar drain = require('it-drain');\nvar map = require('it-map');\nvar debug = require('debug');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar itPeekable__default = /*#__PURE__*/_interopDefaultLegacy(itPeekable);\nvar drain__default = /*#__PURE__*/_interopDefaultLegacy(drain);\nvar map__default = /*#__PURE__*/_interopDefaultLegacy(map);\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\n\nconst log = debug__default[\"default\"]('ipfs:components:dag:import');\nfunction createImport({repo}) {\n  async function* dagImport(sources, options = {}) {\n    const release = await repo.gcLock.readLock();\n    try {\n      const abortOptions = {\n        signal: options.signal,\n        timeout: options.timeout\n      };\n      const peekable = itPeekable__default[\"default\"](sources);\n      const {value, done} = await peekable.peek();\n      if (done) {\n        return;\n      }\n      if (value) {\n        peekable.push(value);\n      }\n      let cars;\n      if (value instanceof Uint8Array) {\n        cars = [peekable];\n      } else {\n        cars = peekable;\n      }\n      for await (const car of cars) {\n        const roots = await importCar(repo, abortOptions, car);\n        if (options.pinRoots !== false) {\n          for (const cid of roots) {\n            let pinErrorMsg = '';\n            try {\n              if (await repo.blocks.has(cid)) {\n                log(`Pinning root ${ cid }`);\n                await repo.pins.pinRecursively(cid);\n              } else {\n                pinErrorMsg = 'blockstore: block not found';\n              }\n            } catch (err) {\n              pinErrorMsg = err.message;\n            }\n            yield {\n              root: {\n                cid,\n                pinErrorMsg\n              }\n            };\n          }\n        }\n      }\n    } finally {\n      release();\n    }\n  }\n  return withTimeoutOption.withTimeoutOption(dagImport);\n}\nasync function importCar(repo, options, source) {\n  const reader = await iterator.CarBlockIterator.fromIterable(source);\n  const roots = await reader.getRoots();\n  await drain__default[\"default\"](repo.blocks.putMany(map__default[\"default\"](reader, ({\n    cid: key,\n    bytes: value\n  }) => {\n    log(`Import block ${ key }`);\n    return {\n      key,\n      value\n    };\n  }), { signal: options.signal }));\n  return roots;\n}\n\nexports.createImport = createImport;\n"]},"metadata":{},"sourceType":"script"}