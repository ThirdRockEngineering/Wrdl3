{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar interfaceDatastore = require('interface-datastore');\n\nvar shard = require('./shard.js');\n\nvar base = require('./base.js');\n\nvar keytransform = require('./keytransform.js');\n\nvar errors = require('./errors.js');\n\nvar shardReadme = require('./shard-readme.js');\n\nconst shardKey = new interfaceDatastore.Key(shard.SHARDING_FN);\nconst shardReadmeKey = new interfaceDatastore.Key(shard.README_FN);\n\nclass ShardingDatastore extends base.BaseDatastore {\n  constructor(store, shard) {\n    super();\n    this.child = new keytransform.KeyTransformDatastore(store, {\n      convert: this._convertKey.bind(this),\n      invert: this._invertKey.bind(this)\n    });\n    this.shard = shard;\n  }\n\n  async open() {\n    await this.child.open();\n    this.shard = await ShardingDatastore.create(this.child, this.shard);\n  }\n\n  _convertKey(key) {\n    const s = key.toString();\n\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key;\n    }\n\n    const parent = new interfaceDatastore.Key(this.shard.fun(s));\n    return parent.child(key);\n  }\n\n  _invertKey(key) {\n    const s = key.toString();\n\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key;\n    }\n\n    return interfaceDatastore.Key.withNamespaces(key.list().slice(1));\n  }\n\n  static async createOrOpen(store, shard) {\n    try {\n      await ShardingDatastore.create(store, shard);\n    } catch (err) {\n      if (err && err.message !== 'datastore exists') throw err;\n    }\n\n    return ShardingDatastore.open(store);\n  }\n\n  static async open(store) {\n    const shard$1 = await shard.readShardFun('/', store);\n    return new ShardingDatastore(store, shard$1);\n  }\n\n  static async create(store, shard$1) {\n    const hasShard = await store.has(shardKey);\n\n    if (!hasShard && !shard$1) {\n      throw errors.dbOpenFailedError(Error('Shard is required when datastore doesn\\'t have a shard key already.'));\n    }\n\n    if (!hasShard) {\n      const put = typeof store.putRaw === 'function' ? store.putRaw.bind(store) : store.put.bind(store);\n      await Promise.all([put(shardKey, new TextEncoder().encode(shard$1.toString() + '\\n')), put(shardReadmeKey, new TextEncoder().encode(shardReadme))]);\n      return shard$1;\n    }\n\n    const diskShard = await shard.readShardFun('/', store);\n    const a = (diskShard || '').toString();\n    const b = shard$1.toString();\n\n    if (a !== b) {\n      throw new Error(`specified fun ${b} does not match repo shard fun ${a}`);\n    }\n\n    return diskShard;\n  }\n\n  put(key, val, options) {\n    return this.child.put(key, val, options);\n  }\n\n  get(key, options) {\n    return this.child.get(key, options);\n  }\n\n  has(key, options) {\n    return this.child.has(key, options);\n  }\n\n  delete(key, options) {\n    return this.child.delete(key, options);\n  }\n\n  async *putMany(source) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    yield* this.child.putMany(source, options);\n  }\n\n  async *getMany(source) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    yield* this.child.getMany(source, options);\n  }\n\n  async *deleteMany(source) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    yield* this.child.deleteMany(source, options);\n  }\n\n  batch() {\n    return this.child.batch();\n  }\n\n  query(q, options) {\n    const tq = { ...q,\n      filters: [_ref => {\n        let {\n          key\n        } = _ref;\n        return key.toString() !== shardKey.toString();\n      }, _ref2 => {\n        let {\n          key\n        } = _ref2;\n        return key.toString() !== shardReadmeKey.toString();\n      }].concat(q.filters || [])\n    };\n    return this.child.query(tq, options);\n  }\n\n  queryKeys(q, options) {\n    const tq = { ...q,\n      filters: [key => key.toString() !== shardKey.toString(), key => key.toString() !== shardReadmeKey.toString()].concat(q.filters || [])\n    };\n    return this.child.queryKeys(tq, options);\n  }\n\n  close() {\n    return this.child.close();\n  }\n\n}\n\nexports.ShardingDatastore = ShardingDatastore;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/datastore-core/cjs/src/sharding.js"],"names":["Object","defineProperty","exports","value","interfaceDatastore","require","shard","base","keytransform","errors","shardReadme","shardKey","Key","SHARDING_FN","shardReadmeKey","README_FN","ShardingDatastore","BaseDatastore","constructor","store","child","KeyTransformDatastore","convert","_convertKey","bind","invert","_invertKey","open","create","key","s","toString","parent","fun","withNamespaces","list","slice","createOrOpen","err","message","shard$1","readShardFun","hasShard","has","dbOpenFailedError","Error","put","putRaw","Promise","all","TextEncoder","encode","diskShard","a","b","val","options","get","delete","putMany","source","getMany","deleteMany","batch","query","q","tq","filters","concat","queryKeys","close"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar interfaceDatastore = require('interface-datastore');\nvar shard = require('./shard.js');\nvar base = require('./base.js');\nvar keytransform = require('./keytransform.js');\nvar errors = require('./errors.js');\nvar shardReadme = require('./shard-readme.js');\n\nconst shardKey = new interfaceDatastore.Key(shard.SHARDING_FN);\nconst shardReadmeKey = new interfaceDatastore.Key(shard.README_FN);\nclass ShardingDatastore extends base.BaseDatastore {\n  constructor(store, shard) {\n    super();\n    this.child = new keytransform.KeyTransformDatastore(store, {\n      convert: this._convertKey.bind(this),\n      invert: this._invertKey.bind(this)\n    });\n    this.shard = shard;\n  }\n  async open() {\n    await this.child.open();\n    this.shard = await ShardingDatastore.create(this.child, this.shard);\n  }\n  _convertKey(key) {\n    const s = key.toString();\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key;\n    }\n    const parent = new interfaceDatastore.Key(this.shard.fun(s));\n    return parent.child(key);\n  }\n  _invertKey(key) {\n    const s = key.toString();\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key;\n    }\n    return interfaceDatastore.Key.withNamespaces(key.list().slice(1));\n  }\n  static async createOrOpen(store, shard) {\n    try {\n      await ShardingDatastore.create(store, shard);\n    } catch (err) {\n      if (err && err.message !== 'datastore exists')\n        throw err;\n    }\n    return ShardingDatastore.open(store);\n  }\n  static async open(store) {\n    const shard$1 = await shard.readShardFun('/', store);\n    return new ShardingDatastore(store, shard$1);\n  }\n  static async create(store, shard$1) {\n    const hasShard = await store.has(shardKey);\n    if (!hasShard && !shard$1) {\n      throw errors.dbOpenFailedError(Error('Shard is required when datastore doesn\\'t have a shard key already.'));\n    }\n    if (!hasShard) {\n      const put = typeof store.putRaw === 'function' ? store.putRaw.bind(store) : store.put.bind(store);\n      await Promise.all([\n        put(shardKey, new TextEncoder().encode(shard$1.toString() + '\\n')),\n        put(shardReadmeKey, new TextEncoder().encode(shardReadme))\n      ]);\n      return shard$1;\n    }\n    const diskShard = await shard.readShardFun('/', store);\n    const a = (diskShard || '').toString();\n    const b = shard$1.toString();\n    if (a !== b) {\n      throw new Error(`specified fun ${ b } does not match repo shard fun ${ a }`);\n    }\n    return diskShard;\n  }\n  put(key, val, options) {\n    return this.child.put(key, val, options);\n  }\n  get(key, options) {\n    return this.child.get(key, options);\n  }\n  has(key, options) {\n    return this.child.has(key, options);\n  }\n  delete(key, options) {\n    return this.child.delete(key, options);\n  }\n  async *putMany(source, options = {}) {\n    yield* this.child.putMany(source, options);\n  }\n  async *getMany(source, options = {}) {\n    yield* this.child.getMany(source, options);\n  }\n  async *deleteMany(source, options = {}) {\n    yield* this.child.deleteMany(source, options);\n  }\n  batch() {\n    return this.child.batch();\n  }\n  query(q, options) {\n    const tq = {\n      ...q,\n      filters: [\n        ({key}) => key.toString() !== shardKey.toString(),\n        ({key}) => key.toString() !== shardReadmeKey.toString()\n      ].concat(q.filters || [])\n    };\n    return this.child.query(tq, options);\n  }\n  queryKeys(q, options) {\n    const tq = {\n      ...q,\n      filters: [\n        key => key.toString() !== shardKey.toString(),\n        key => key.toString() !== shardReadmeKey.toString()\n      ].concat(q.filters || [])\n    };\n    return this.child.queryKeys(tq, options);\n  }\n  close() {\n    return this.child.close();\n  }\n}\n\nexports.ShardingDatastore = ShardingDatastore;\n"]},"metadata":{},"sourceType":"script"}