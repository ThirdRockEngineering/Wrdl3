{"ast":null,"code":"'use strict';\n\nconst Topology = require('./index');\n\nconst multicodecTopologySymbol = Symbol.for('@libp2p/js-interfaces/topology/multicodec-topology');\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:topology:multicodec-topology'), {\n  error: debug('libp2p:topology:multicodec-topology:error')\n});\n\nclass MulticodecTopology extends Topology {\n  /**\n   * @param {TopologyOptions & MulticodecOptions} props\n   */\n  constructor(_ref) {\n    let {\n      min,\n      max,\n      multicodecs,\n      handlers\n    } = _ref;\n    super({\n      min,\n      max,\n      handlers\n    });\n\n    if (!multicodecs) {\n      throw new Error('one or more multicodec should be provided');\n    }\n\n    if (!handlers) {\n      throw new Error('the handlers should be provided');\n    }\n\n    if (typeof handlers.onConnect !== 'function') {\n      throw new Error('the \\'onConnect\\' handler must be provided');\n    }\n\n    if (typeof handlers.onDisconnect !== 'function') {\n      throw new Error('the \\'onDisconnect\\' handler must be provided');\n    }\n\n    this.multicodecs = Array.isArray(multicodecs) ? multicodecs : [multicodecs];\n    this._registrar = undefined;\n    this._onProtocolChange = this._onProtocolChange.bind(this);\n    this._onPeerConnect = this._onPeerConnect.bind(this);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Topology';\n  }\n\n  get [multicodecTopologySymbol]() {\n    return true;\n  }\n  /**\n   * Checks if the given value is a `MulticodecTopology` instance.\n   *\n   * @param {any} other\n   * @returns {other is MulticodecTopology}\n   */\n\n\n  static isMulticodecTopology(other) {\n    return Boolean(other && other[multicodecTopologySymbol]);\n  }\n  /**\n   * @param {any} registrar\n   */\n\n\n  async setRegistrar(registrar) {\n    // eslint-disable-line\n    this._registrar = registrar;\n\n    this._registrar.peerStore.on('change:protocols', this._onProtocolChange);\n\n    this._registrar.connectionManager.on('peer:connect', this._onPeerConnect); // Update topology peers\n\n\n    await this._updatePeers(this._registrar.peerStore.getPeers());\n  }\n  /**\n   * Update topology.\n   *\n   * @param {AsyncIterable<any> | Iterable<any>} peerDataIterable\n   */\n\n\n  async _updatePeers(peerDataIterable) {\n    for await (const {\n      id,\n      protocols\n    } of peerDataIterable) {\n      if (this.multicodecs.filter(multicodec => protocols.includes(multicodec)).length) {\n        // Add the peer regardless of whether or not there is currently a connection\n        this.peers.add(id.toB58String()); // If there is a connection, call _onConnect\n\n        const connection = this._registrar.getConnection(id);\n\n        connection && this._onConnect(id, connection);\n      } else {\n        // Remove any peers we might be tracking that are no longer of value to us\n        this.peers.delete(id.toB58String());\n      }\n    }\n  }\n  /**\n   * Check if a new peer support the multicodecs for this topology.\n   *\n   * @param {Object} props\n   * @param {PeerId} props.peerId\n   * @param {Array<string>} props.protocols\n   */\n\n\n  async _onProtocolChange(_ref2) {\n    let {\n      peerId,\n      protocols\n    } = _ref2;\n\n    try {\n      const hadPeer = this.peers.has(peerId.toB58String());\n      const hasProtocol = protocols.filter(protocol => this.multicodecs.includes(protocol)); // Not supporting the protocol anymore?\n\n      if (hadPeer && hasProtocol.length === 0) {\n        this._onDisconnect(peerId);\n      } // New to protocol support\n\n\n      for (const protocol of protocols) {\n        if (this.multicodecs.includes(protocol)) {\n          const peerData = await this._registrar.peerStore.get(peerId);\n          await this._updatePeers([peerData]);\n          return;\n        }\n      }\n    } catch (err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Verify if a new connected peer has a topology multicodec and call _onConnect.\n   *\n   * @param {Connection} connection\n   */\n\n\n  async _onPeerConnect(connection) {\n    try {\n      // @ts-ignore - remotePeer does not existist on Connection\n      const peerId = connection.remotePeer;\n      const protocols = await this._registrar.peerStore.protoBook.get(peerId);\n\n      if (!protocols) {\n        return;\n      }\n\n      if (this.multicodecs.find(multicodec => protocols.includes(multicodec))) {\n        this.peers.add(peerId.toB58String());\n\n        this._onConnect(peerId, connection);\n      }\n    } catch (err) {\n      log.error(err);\n    }\n  }\n\n}\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr')} Multiaddr\n * @typedef {import('../connection/connection')} Connection\n * @typedef {import('.').Options} TopologyOptions\n * @typedef {Object} MulticodecOptions\n * @property {string[]} multicodecs - protocol multicodecs\n * @property {Required<Handlers>} handlers\n * @typedef {import('.').Handlers} Handlers\n */\n\n\nmodule.exports = MulticodecTopology;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p-interfaces/src/topology/multicodec-topology.js"],"names":["Topology","require","multicodecTopologySymbol","Symbol","for","debug","log","Object","assign","error","MulticodecTopology","constructor","min","max","multicodecs","handlers","Error","onConnect","onDisconnect","Array","isArray","_registrar","undefined","_onProtocolChange","bind","_onPeerConnect","toStringTag","isMulticodecTopology","other","Boolean","setRegistrar","registrar","peerStore","on","connectionManager","_updatePeers","getPeers","peerDataIterable","id","protocols","filter","multicodec","includes","length","peers","add","toB58String","connection","getConnection","_onConnect","delete","peerId","hadPeer","has","hasProtocol","protocol","_onDisconnect","peerData","get","err","remotePeer","protoBook","find","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Topology = require('./index')\nconst multicodecTopologySymbol = Symbol.for('@libp2p/js-interfaces/topology/multicodec-topology')\nconst debug = require('debug')\n\nconst log = Object.assign(debug('libp2p:topology:multicodec-topology'), {\n  error: debug('libp2p:topology:multicodec-topology:error')\n})\n\nclass MulticodecTopology extends Topology {\n  /**\n   * @param {TopologyOptions & MulticodecOptions} props\n   */\n  constructor ({\n    min,\n    max,\n    multicodecs,\n    handlers\n  }) {\n    super({ min, max, handlers })\n\n    if (!multicodecs) {\n      throw new Error('one or more multicodec should be provided')\n    }\n\n    if (!handlers) {\n      throw new Error('the handlers should be provided')\n    }\n\n    if (typeof handlers.onConnect !== 'function') {\n      throw new Error('the \\'onConnect\\' handler must be provided')\n    }\n\n    if (typeof handlers.onDisconnect !== 'function') {\n      throw new Error('the \\'onDisconnect\\' handler must be provided')\n    }\n\n    this.multicodecs = Array.isArray(multicodecs) ? multicodecs : [multicodecs]\n    this._registrar = undefined\n\n    this._onProtocolChange = this._onProtocolChange.bind(this)\n    this._onPeerConnect = this._onPeerConnect.bind(this)\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Topology'\n  }\n\n  get [multicodecTopologySymbol] () {\n    return true\n  }\n\n  /**\n   * Checks if the given value is a `MulticodecTopology` instance.\n   *\n   * @param {any} other\n   * @returns {other is MulticodecTopology}\n   */\n  static isMulticodecTopology (other) {\n    return Boolean(other && other[multicodecTopologySymbol])\n  }\n\n  /**\n   * @param {any} registrar\n   */\n  async setRegistrar (registrar) { // eslint-disable-line\n    this._registrar = registrar\n    this._registrar.peerStore.on('change:protocols', this._onProtocolChange)\n    this._registrar.connectionManager.on('peer:connect', this._onPeerConnect)\n\n    // Update topology peers\n    await this._updatePeers(this._registrar.peerStore.getPeers())\n  }\n\n  /**\n   * Update topology.\n   *\n   * @param {AsyncIterable<any> | Iterable<any>} peerDataIterable\n   */\n  async _updatePeers (peerDataIterable) {\n    for await (const { id, protocols } of peerDataIterable) {\n      if (this.multicodecs.filter(multicodec => protocols.includes(multicodec)).length) {\n        // Add the peer regardless of whether or not there is currently a connection\n        this.peers.add(id.toB58String())\n        // If there is a connection, call _onConnect\n        const connection = this._registrar.getConnection(id)\n        connection && this._onConnect(id, connection)\n      } else {\n        // Remove any peers we might be tracking that are no longer of value to us\n        this.peers.delete(id.toB58String())\n      }\n    }\n  }\n\n  /**\n   * Check if a new peer support the multicodecs for this topology.\n   *\n   * @param {Object} props\n   * @param {PeerId} props.peerId\n   * @param {Array<string>} props.protocols\n   */\n  async _onProtocolChange ({ peerId, protocols }) {\n    try {\n      const hadPeer = this.peers.has(peerId.toB58String())\n      const hasProtocol = protocols.filter(protocol => this.multicodecs.includes(protocol))\n\n      // Not supporting the protocol anymore?\n      if (hadPeer && hasProtocol.length === 0) {\n        this._onDisconnect(peerId)\n      }\n\n      // New to protocol support\n      for (const protocol of protocols) {\n        if (this.multicodecs.includes(protocol)) {\n          const peerData = await this._registrar.peerStore.get(peerId)\n          await this._updatePeers([peerData])\n          return\n        }\n      }\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Verify if a new connected peer has a topology multicodec and call _onConnect.\n   *\n   * @param {Connection} connection\n   */\n  async _onPeerConnect (connection) {\n    try {\n      // @ts-ignore - remotePeer does not existist on Connection\n      const peerId = connection.remotePeer\n      const protocols = await this._registrar.peerStore.protoBook.get(peerId)\n\n      if (!protocols) {\n        return\n      }\n\n      if (this.multicodecs.find(multicodec => protocols.includes(multicodec))) {\n        this.peers.add(peerId.toB58String())\n        this._onConnect(peerId, connection)\n      }\n    } catch (err) {\n      log.error(err)\n    }\n  }\n}\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr')} Multiaddr\n * @typedef {import('../connection/connection')} Connection\n * @typedef {import('.').Options} TopologyOptions\n * @typedef {Object} MulticodecOptions\n * @property {string[]} multicodecs - protocol multicodecs\n * @property {Required<Handlers>} handlers\n * @typedef {import('.').Handlers} Handlers\n */\nmodule.exports = MulticodecTopology\n"]},"metadata":{},"sourceType":"script"}