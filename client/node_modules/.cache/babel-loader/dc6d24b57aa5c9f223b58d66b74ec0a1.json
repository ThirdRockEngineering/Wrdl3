{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar isIpfs = require('is-ipfs');\n\nvar cid = require('multiformats/cid');\n\nvar key = require('interface-datastore/key');\n\nvar errCode = require('err-code');\n\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\n\nvar toCidAndPath = require('ipfs-core-utils/to-cid-and-path');\n\nvar dagPB = require('@ipld/dag-pb');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar isIpfs__default = /*#__PURE__*/_interopDefaultLegacy(isIpfs);\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\n\nvar dagPB__namespace = /*#__PURE__*/_interopNamespace(dagPB);\n\nconst ERR_BAD_PATH = 'ERR_BAD_PATH';\nconst OFFLINE_ERROR = 'This command must be run in online mode. Try running \\'ipfs daemon\\' first.';\nconst MFS_ROOT_KEY = new key.Key('/local/filesroot');\nconst MFS_MAX_CHUNK_SIZE = 262144;\nconst MFS_MAX_LINKS = 174;\n\nconst normalizePath = pathStr => {\n  const cid$1 = cid.CID.asCID(pathStr);\n\n  if (cid$1) {\n    return `/ipfs/${pathStr}`;\n  }\n\n  const str = pathStr.toString();\n\n  try {\n    return `/ipfs/${cid.CID.parse(str)}`;\n  } catch {}\n\n  if (isIpfs__default[\"default\"].path(str)) {\n    return str;\n  } else {\n    throw errCode__default[\"default\"](new Error(`invalid path: ${pathStr}`), ERR_BAD_PATH);\n  }\n};\n\nconst normalizeCidPath = path => {\n  if (path instanceof Uint8Array) {\n    return cid.CID.decode(path).toString();\n  }\n\n  path = path.toString();\n\n  if (path.indexOf('/ipfs/') === 0) {\n    path = path.substring('/ipfs/'.length);\n  }\n\n  if (path.charAt(path.length - 1) === '/') {\n    path = path.substring(0, path.length - 1);\n  }\n\n  return path;\n};\n\nconst resolvePath = async function (repo, codecs, ipfsPath) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const {\n    cid: cid$1,\n    path\n  } = toCidAndPath.toCidAndPath(ipfsPath);\n\n  if (path) {\n    options.path = path;\n  }\n\n  let lastCid = cid$1;\n  let lastRemainderPath = options.path || '';\n\n  if (lastRemainderPath.startsWith('/')) {\n    lastRemainderPath = lastRemainderPath.substring(1);\n  }\n\n  if (options.path) {\n    try {\n      for await (const {\n        value,\n        remainderPath\n      } of resolve(cid$1, options.path, codecs, repo, {\n        signal: options.signal\n      })) {\n        if (!cid.CID.asCID(value)) {\n          break;\n        }\n\n        lastRemainderPath = remainderPath;\n        lastCid = value;\n      }\n    } catch (err) {\n      if (err.message.startsWith('Object has no property')) {\n        err.message = `no link named \"${lastRemainderPath.split('/')[0]}\" under ${lastCid}`;\n        err.code = 'ERR_NO_LINK';\n      }\n\n      throw err;\n    }\n  }\n\n  return {\n    cid: lastCid,\n    remainderPath: lastRemainderPath || ''\n  };\n};\n\nconst mapFile = file => {\n  if (file.type !== 'file' && file.type !== 'directory' && file.type !== 'raw') {\n    throw new Error(`Unknown node type '${file.type}'`);\n  }\n\n  const output = {\n    cid: file.cid,\n    path: file.path,\n    name: file.name,\n    size: file.size,\n    type: 'file'\n  };\n\n  if (file.type === 'directory') {\n    output.type = 'dir';\n  }\n\n  if (file.type === 'file') {\n    output.size = file.unixfs.fileSize();\n  }\n\n  if (file.type === 'file' || file.type === 'directory') {\n    output.mode = file.unixfs.mode;\n\n    if (file.unixfs.mtime !== undefined) {\n      output.mtime = file.unixfs.mtime;\n    }\n  }\n\n  return output;\n};\n\nconst withTimeout = withTimeoutOption.withTimeoutOption(async (promise, _options) => await promise);\n\nconst resolve = async function* (cid$1, path, codecs, repo, options) {\n  const load = async cid => {\n    const codec = await codecs.getCodec(cid.code);\n    const block = await repo.blocks.get(cid, options);\n    return codec.decode(block);\n  };\n\n  const parts = path.split('/').filter(Boolean);\n  let value = await load(cid$1);\n  let lastCid = cid$1;\n\n  while (parts.length) {\n    const key = parts.shift();\n\n    if (!key) {\n      throw errCode__default[\"default\"](new Error(`Could not resolve path \"${path}\"`), 'ERR_INVALID_PATH');\n    }\n\n    if (cid$1.code === dagPB__namespace.code && Array.isArray(value.Links)) {\n      const link = value.Links.find(l => l.Name === key);\n\n      if (link) {\n        yield {\n          value: link.Hash,\n          remainderPath: parts.join('/')\n        };\n        value = await load(link.Hash);\n        lastCid = link.Hash;\n        continue;\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      value = value[key];\n      yield {\n        value,\n        remainderPath: parts.join('/')\n      };\n    } else {\n      throw errCode__default[\"default\"](new Error(`no link named \"${key}\" under ${lastCid}`), 'ERR_NO_LINK');\n    }\n\n    if (cid.CID.asCID(value)) {\n      lastCid = value;\n      value = await load(value);\n    }\n  }\n\n  yield {\n    value,\n    remainderPath: ''\n  };\n};\n\nexports.MFS_MAX_CHUNK_SIZE = MFS_MAX_CHUNK_SIZE;\nexports.MFS_MAX_LINKS = MFS_MAX_LINKS;\nexports.MFS_ROOT_KEY = MFS_ROOT_KEY;\nexports.OFFLINE_ERROR = OFFLINE_ERROR;\nexports.mapFile = mapFile;\nexports.normalizeCidPath = normalizeCidPath;\nexports.normalizePath = normalizePath;\nexports.resolve = resolve;\nexports.resolvePath = resolvePath;\nexports.withTimeout = withTimeout;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-core/cjs/src/utils.js"],"names":["Object","defineProperty","exports","value","isIpfs","require","cid","key","errCode","withTimeoutOption","toCidAndPath","dagPB","_interopDefaultLegacy","e","_interopNamespace","__esModule","n","create","keys","forEach","k","d","getOwnPropertyDescriptor","get","enumerable","freeze","isIpfs__default","errCode__default","dagPB__namespace","ERR_BAD_PATH","OFFLINE_ERROR","MFS_ROOT_KEY","Key","MFS_MAX_CHUNK_SIZE","MFS_MAX_LINKS","normalizePath","pathStr","cid$1","CID","asCID","str","toString","parse","path","Error","normalizeCidPath","Uint8Array","decode","indexOf","substring","length","charAt","resolvePath","repo","codecs","ipfsPath","options","lastCid","lastRemainderPath","startsWith","remainderPath","resolve","signal","err","message","split","code","mapFile","file","type","output","name","size","unixfs","fileSize","mode","mtime","undefined","withTimeout","promise","_options","load","codec","getCodec","block","blocks","parts","filter","Boolean","shift","Array","isArray","Links","link","find","l","Name","Hash","join","prototype","hasOwnProperty","call"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar isIpfs = require('is-ipfs');\nvar cid = require('multiformats/cid');\nvar key = require('interface-datastore/key');\nvar errCode = require('err-code');\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\nvar toCidAndPath = require('ipfs-core-utils/to-cid-and-path');\nvar dagPB = require('@ipld/dag-pb');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar isIpfs__default = /*#__PURE__*/_interopDefaultLegacy(isIpfs);\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\nvar dagPB__namespace = /*#__PURE__*/_interopNamespace(dagPB);\n\nconst ERR_BAD_PATH = 'ERR_BAD_PATH';\nconst OFFLINE_ERROR = 'This command must be run in online mode. Try running \\'ipfs daemon\\' first.';\nconst MFS_ROOT_KEY = new key.Key('/local/filesroot');\nconst MFS_MAX_CHUNK_SIZE = 262144;\nconst MFS_MAX_LINKS = 174;\nconst normalizePath = pathStr => {\n  const cid$1 = cid.CID.asCID(pathStr);\n  if (cid$1) {\n    return `/ipfs/${ pathStr }`;\n  }\n  const str = pathStr.toString();\n  try {\n    return `/ipfs/${ cid.CID.parse(str) }`;\n  } catch {\n  }\n  if (isIpfs__default[\"default\"].path(str)) {\n    return str;\n  } else {\n    throw errCode__default[\"default\"](new Error(`invalid path: ${ pathStr }`), ERR_BAD_PATH);\n  }\n};\nconst normalizeCidPath = path => {\n  if (path instanceof Uint8Array) {\n    return cid.CID.decode(path).toString();\n  }\n  path = path.toString();\n  if (path.indexOf('/ipfs/') === 0) {\n    path = path.substring('/ipfs/'.length);\n  }\n  if (path.charAt(path.length - 1) === '/') {\n    path = path.substring(0, path.length - 1);\n  }\n  return path;\n};\nconst resolvePath = async function (repo, codecs, ipfsPath, options = {}) {\n  const {cid: cid$1, path} = toCidAndPath.toCidAndPath(ipfsPath);\n  if (path) {\n    options.path = path;\n  }\n  let lastCid = cid$1;\n  let lastRemainderPath = options.path || '';\n  if (lastRemainderPath.startsWith('/')) {\n    lastRemainderPath = lastRemainderPath.substring(1);\n  }\n  if (options.path) {\n    try {\n      for await (const {value, remainderPath} of resolve(cid$1, options.path, codecs, repo, { signal: options.signal })) {\n        if (!cid.CID.asCID(value)) {\n          break;\n        }\n        lastRemainderPath = remainderPath;\n        lastCid = value;\n      }\n    } catch (err) {\n      if (err.message.startsWith('Object has no property')) {\n        err.message = `no link named \"${ lastRemainderPath.split('/')[0] }\" under ${ lastCid }`;\n        err.code = 'ERR_NO_LINK';\n      }\n      throw err;\n    }\n  }\n  return {\n    cid: lastCid,\n    remainderPath: lastRemainderPath || ''\n  };\n};\nconst mapFile = file => {\n  if (file.type !== 'file' && file.type !== 'directory' && file.type !== 'raw') {\n    throw new Error(`Unknown node type '${ file.type }'`);\n  }\n  const output = {\n    cid: file.cid,\n    path: file.path,\n    name: file.name,\n    size: file.size,\n    type: 'file'\n  };\n  if (file.type === 'directory') {\n    output.type = 'dir';\n  }\n  if (file.type === 'file') {\n    output.size = file.unixfs.fileSize();\n  }\n  if (file.type === 'file' || file.type === 'directory') {\n    output.mode = file.unixfs.mode;\n    if (file.unixfs.mtime !== undefined) {\n      output.mtime = file.unixfs.mtime;\n    }\n  }\n  return output;\n};\nconst withTimeout = withTimeoutOption.withTimeoutOption(async (promise, _options) => await promise);\nconst resolve = async function* (cid$1, path, codecs, repo, options) {\n  const load = async cid => {\n    const codec = await codecs.getCodec(cid.code);\n    const block = await repo.blocks.get(cid, options);\n    return codec.decode(block);\n  };\n  const parts = path.split('/').filter(Boolean);\n  let value = await load(cid$1);\n  let lastCid = cid$1;\n  while (parts.length) {\n    const key = parts.shift();\n    if (!key) {\n      throw errCode__default[\"default\"](new Error(`Could not resolve path \"${ path }\"`), 'ERR_INVALID_PATH');\n    }\n    if (cid$1.code === dagPB__namespace.code && Array.isArray(value.Links)) {\n      const link = value.Links.find(l => l.Name === key);\n      if (link) {\n        yield {\n          value: link.Hash,\n          remainderPath: parts.join('/')\n        };\n        value = await load(link.Hash);\n        lastCid = link.Hash;\n        continue;\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      value = value[key];\n      yield {\n        value,\n        remainderPath: parts.join('/')\n      };\n    } else {\n      throw errCode__default[\"default\"](new Error(`no link named \"${ key }\" under ${ lastCid }`), 'ERR_NO_LINK');\n    }\n    if (cid.CID.asCID(value)) {\n      lastCid = value;\n      value = await load(value);\n    }\n  }\n  yield {\n    value,\n    remainderPath: ''\n  };\n};\n\nexports.MFS_MAX_CHUNK_SIZE = MFS_MAX_CHUNK_SIZE;\nexports.MFS_MAX_LINKS = MFS_MAX_LINKS;\nexports.MFS_ROOT_KEY = MFS_ROOT_KEY;\nexports.OFFLINE_ERROR = OFFLINE_ERROR;\nexports.mapFile = mapFile;\nexports.normalizeCidPath = normalizeCidPath;\nexports.normalizePath = normalizePath;\nexports.resolve = resolve;\nexports.resolvePath = resolvePath;\nexports.withTimeout = withTimeout;\n"]},"metadata":{},"sourceType":"script"}