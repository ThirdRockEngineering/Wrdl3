{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nconst pubsub_1 = __importStar(require(\"libp2p-interfaces/src/pubsub\"));\n\nconst message_cache_1 = require(\"./message-cache\");\n\nconst rpc_1 = require(\"./message/rpc\");\n\nconst constants = __importStar(require(\"./constants\"));\n\nconst heartbeat_1 = require(\"./heartbeat\");\n\nconst get_gossip_peers_1 = require(\"./get-gossip-peers\");\n\nconst utils_1 = require(\"./utils\");\n\nconst score_1 = require(\"./score\");\n\nconst tracer_1 = require(\"./tracer\");\n\nconst time_cache_1 = require(\"./utils/time-cache\");\n\nconst PeerId = require(\"peer-id\"); // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\n\n\nconst Envelope = require(\"libp2p/src/record/envelope\");\n\nconst constants_1 = require(\"./constants\");\n\nclass Gossipsub extends pubsub_1.default {\n  // TODO: add remaining props\n\n  /**\n   * @param {Libp2p} libp2p\n   * @param {Object} [options]\n   * @param {boolean} [options.emitSelf = false] if publish should emit to self, if subscribed\n   * @param {boolean} [options.canRelayMessage = false] - if can relay messages not subscribed\n   * @param {boolean} [options.gossipIncoming = true] if incoming messages on a subscribed topic should be automatically gossiped\n   * @param {boolean} [options.fallbackToFloodsub = true] if dial should fallback to floodsub\n   * @param {boolean} [options.floodPublish = true] if self-published messages should be sent to all peers\n   * @param {boolean} [options.doPX = false] whether PX is enabled; this should be enabled in bootstrappers and other well connected/trusted nodes.\n   * @param {Object} [options.messageCache] override the default MessageCache\n   * @param {FastMsgIdFn} [options.fastMsgIdFn] fast message id function\n   * @param {string} [options.globalSignaturePolicy = \"StrictSign\"] signing policy to apply across all messages\n   * @param {Object} [options.scoreParams] peer score parameters\n   * @param {Object} [options.scoreThresholds] peer score thresholds\n   * @param {AddrInfo[]} [options.directPeers] peers with which we will maintain direct connections\n   * @constructor\n   */\n  constructor(libp2p) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var _a;\n\n    const multicodecs = [constants.GossipsubIDv11, constants.GossipsubIDv10];\n    const opts = Object.assign(Object.assign({\n      gossipIncoming: true,\n      fallbackToFloodsub: true,\n      floodPublish: true,\n      doPX: false,\n      directPeers: [],\n      D: constants.GossipsubD,\n      Dlo: constants.GossipsubDlo,\n      Dhi: constants.GossipsubDhi,\n      Dscore: constants.GossipsubDscore,\n      Dout: constants.GossipsubDout,\n      Dlazy: constants.GossipsubDlazy,\n      heartbeatInterval: constants.GossipsubHeartbeatInterval,\n      fanoutTTL: constants.GossipsubFanoutTTL,\n      mcacheLength: constants.GossipsubHistoryLength,\n      mcacheGossip: constants.GossipsubHistoryGossip,\n      seenTTL: constants.GossipsubSeenTTL\n    }, options), {\n      scoreParams: score_1.createPeerScoreParams(options.scoreParams),\n      scoreThresholds: score_1.createPeerScoreThresholds(options.scoreThresholds)\n    }); // Also wants to get notified of peers connected using floodsub\n\n    if (opts.fallbackToFloodsub) {\n      multicodecs.push(constants.FloodsubID);\n    }\n\n    super(Object.assign({\n      debugName: 'libp2p:gossipsub',\n      multicodecs,\n      libp2p\n    }, opts));\n    this._options = opts;\n    /**\n     * Direct peers\n     * @type {Set<string>}\n     */\n\n    this.direct = new Set(opts.directPeers.map(p => p.id.toB58String()));\n    /**\n     * Map of peer id and AcceptRequestWhileListEntry\n     *\n     * @type {Map<string, AcceptFromWhitelistEntry}\n     */\n\n    this.acceptFromWhitelist = new Map(); // set direct peer addresses in the address book\n\n    opts.directPeers.forEach(p => {\n      libp2p.peerStore.addressBook.add(p.id, p.addrs);\n    });\n    /**\n     * Cache of seen messages\n     *\n     * @type {SimpleTimeCache}\n     */\n\n    this.seenCache = new time_cache_1.SimpleTimeCache({\n      validityMs: opts.seenTTL\n    });\n    /**\n     * Map of topic meshes\n     * topic => peer id set\n     *\n     * @type {Map<string, Set<string>>}\n     */\n\n    this.mesh = new Map();\n    /**\n     * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership\n     * topic => peer id set\n     *\n     * @type {Map<string, Set<string>>}\n     */\n\n    this.fanout = new Map();\n    /**\n     * Map of last publish time for fanout topics\n     * topic => last publish time\n     *\n     * @type {Map<string, number>}\n     */\n\n    this.lastpub = new Map();\n    /**\n     * Map of pending messages to gossip\n     * peer id => control messages\n     *\n     * @type {Map<string, Array<RPC.IControlIHave object>> }\n     */\n\n    this.gossip = new Map();\n    /**\n     * Map of control messages\n     * peer id => control message\n     *\n     * @type {Map<string, RPC.IControlMessage object>}\n     */\n\n    this.control = new Map();\n    /**\n     * Number of IHAVEs received from peer in the last heartbeat\n     * @type {Map<string, number>}\n     */\n\n    this.peerhave = new Map();\n    /**\n     * Number of messages we have asked from peer in the last heartbeat\n     * @type {Map<string, number>}\n     */\n\n    this.iasked = new Map();\n    /**\n     * Prune backoff map\n     */\n\n    this.backoff = new Map();\n    /**\n     * Connection direction cache, marks peers with outbound connections\n     * peer id => direction\n     *\n     * @type {Map<string, boolean>}\n     */\n\n    this.outbound = new Map();\n    /**\n     * A message cache that contains the messages for last few hearbeat ticks\n     */\n\n    this.messageCache = options.messageCache || new message_cache_1.MessageCache(opts.mcacheGossip, opts.mcacheLength);\n    /**\n     * A fast message id function used for internal message de-duplication\n     */\n\n    this.getFastMsgIdStr = (_a = options.fastMsgIdFn) !== null && _a !== void 0 ? _a : undefined;\n    /**\n     * Maps fast message-id to canonical message-id\n     */\n\n    this.fastMsgIdCache = options.fastMsgIdFn ? new time_cache_1.SimpleTimeCache({\n      validityMs: opts.seenTTL\n    }) : undefined;\n    /**\n     * A heartbeat timer that maintains the mesh\n     */\n\n    this.heartbeat = new heartbeat_1.Heartbeat(this);\n    /**\n     * Number of heartbeats since the beginning of time\n     * This allows us to amortize some resource cleanup -- eg: backoff cleanup\n     */\n\n    this.heartbeatTicks = 0;\n    /**\n     * Tracks IHAVE/IWANT promises broken by peers\n     */\n\n    this.gossipTracer = new tracer_1.IWantTracer();\n    /**\n     * libp2p\n     */\n\n    this._libp2p = libp2p;\n    /**\n     * Peer score tracking\n     */\n\n    this.score = new score_1.PeerScore(this._options.scoreParams, libp2p.connectionManager);\n  }\n  /**\n   * Decode a Uint8Array into an RPC object\n   * Overrided to use an extended protocol-specific protobuf decoder\n   * @override\n   * @param {Uint8Array} bytes\n   * @returns {RPC}\n   */\n\n\n  _decodeRpc(bytes) {\n    return rpc_1.RPC.decode(bytes);\n  }\n  /**\n   * Encode an RPC object into a Uint8Array\n   * Overrided to use an extended protocol-specific protobuf encoder\n   * @override\n   * @param {RPC} rpc\n   * @returns {Uint8Array}\n   */\n\n\n  _encodeRpc(rpc) {\n    return rpc_1.RPC.encode(rpc).finish();\n  }\n  /**\n   * Add a peer to the router\n   * @override\n   * @param {PeerId} peerId\n   * @param {string} protocol\n   * @returns {PeerStreams}\n   */\n\n\n  _addPeer(peerId, protocol) {\n    const p = super._addPeer(peerId, protocol); // Add to peer scoring\n\n\n    this.score.addPeer(peerId.toB58String()); // track the connection direction\n\n    let outbound = false;\n\n    for (const c of this._libp2p.connectionManager.getAll(peerId)) {\n      if (c.stat.direction === 'outbound') {\n        if (Array.from(c.registry.values()).some(rvalue => protocol === rvalue.protocol)) {\n          outbound = true;\n          break;\n        }\n      }\n    }\n\n    this.outbound.set(p.id.toB58String(), outbound);\n    return p;\n  }\n  /**\n   * Removes a peer from the router\n   * @override\n   * @param {PeerId} peer\n   * @returns {PeerStreams | undefined}\n   */\n\n\n  _removePeer(peerId) {\n    const peerStreams = super._removePeer(peerId);\n\n    const id = peerId.toB58String(); // Remove this peer from the mesh\n    // eslint-disable-next-line no-unused-vars\n\n    for (const peers of this.mesh.values()) {\n      peers.delete(id);\n    } // Remove this peer from the fanout\n    // eslint-disable-next-line no-unused-vars\n\n\n    for (const peers of this.fanout.values()) {\n      peers.delete(id);\n    } // Remove from gossip mapping\n\n\n    this.gossip.delete(id); // Remove from control mapping\n\n    this.control.delete(id); // Remove from backoff mapping\n\n    this.outbound.delete(id); // Remove from peer scoring\n\n    this.score.removePeer(id);\n    this.acceptFromWhitelist.delete(id);\n    return peerStreams;\n  }\n  /**\n   * Handles an rpc request from a peer\n   *\n   * @override\n   * @param {String} idB58Str\n   * @param {PeerStreams} peerStreams\n   * @param {RPC} rpc\n   * @returns {Promise<boolean>}\n   */\n\n\n  _processRpc(id, peerStreams, rpc) {\n    const _super = Object.create(null, {\n      _processRpc: {\n        get: () => super._processRpc\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (yield _super._processRpc.call(this, id, peerStreams, rpc)) {\n        if (rpc.control) {\n          yield this._processRpcControlMessage(id, rpc.control);\n        }\n\n        return true;\n      }\n\n      return false;\n    });\n  }\n  /**\n   * Handles an rpc control message from a peer\n   * @param {string} id peer id\n   * @param {RPC.IControlMessage} controlMsg\n   * @returns {void}\n   */\n\n\n  _processRpcControlMessage(id, controlMsg) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!controlMsg) {\n        return;\n      }\n\n      const iwant = controlMsg.ihave ? this._handleIHave(id, controlMsg.ihave) : [];\n      const ihave = controlMsg.iwant ? this._handleIWant(id, controlMsg.iwant) : [];\n      const prune = controlMsg.graft ? yield this._handleGraft(id, controlMsg.graft) : [];\n      controlMsg.prune && this._handlePrune(id, controlMsg.prune);\n\n      if (!iwant.length && !ihave.length && !prune.length) {\n        return;\n      }\n\n      const outRpc = utils_1.createGossipRpc(ihave, {\n        iwant,\n        prune\n      });\n\n      this._sendRpc(id, outRpc);\n    });\n  }\n  /**\n   * Process incoming message,\n   * emitting locally and forwarding on to relevant floodsub and gossipsub peers\n   * @override\n   * @param {InMessage} msg\n   * @returns {Promise<void>}\n   */\n\n\n  _processRpcMessage(msg) {\n    const _super = Object.create(null, {\n      _processRpcMessage: {\n        get: () => super._processRpcMessage\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      let canonicalMsgIdStr;\n\n      if (this.getFastMsgIdStr && this.fastMsgIdCache) {\n        // check duplicate\n        const fastMsgIdStr = yield this.getFastMsgIdStr(msg);\n        canonicalMsgIdStr = this.fastMsgIdCache.get(fastMsgIdStr);\n\n        if (canonicalMsgIdStr !== undefined) {\n          this.score.duplicateMessage(msg, canonicalMsgIdStr);\n          return;\n        }\n\n        canonicalMsgIdStr = utils_1.messageIdToString(yield this.getMsgId(msg));\n        this.fastMsgIdCache.put(fastMsgIdStr, canonicalMsgIdStr);\n      } else {\n        // check duplicate\n        canonicalMsgIdStr = utils_1.messageIdToString(yield this.getMsgId(msg));\n\n        if (this.seenCache.has(canonicalMsgIdStr)) {\n          this.score.duplicateMessage(msg, canonicalMsgIdStr);\n          return;\n        }\n      } // put in cache\n\n\n      this.seenCache.put(canonicalMsgIdStr);\n      yield this.score.validateMessage(canonicalMsgIdStr);\n      yield _super._processRpcMessage.call(this, msg);\n    });\n  }\n  /**\n   * Whether to accept a message from a peer\n   * @override\n   * @param {string} id\n   * @returns {boolean}\n   */\n\n\n  _acceptFrom(id) {\n    if (this.direct.has(id)) {\n      return true;\n    }\n\n    const now = Date.now();\n    const entry = this.acceptFromWhitelist.get(id);\n\n    if (entry && entry.messagesAccepted < constants_1.ACCEPT_FROM_WHITELIST_MAX_MESSAGES && entry.acceptUntil >= now) {\n      entry.messagesAccepted += 1;\n      return true;\n    }\n\n    const score = this.score.score(id);\n\n    if (score >= constants_1.ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE) {\n      // peer is unlikely to be able to drop its score to `graylistThreshold`\n      // after 128 messages or 1s\n      this.acceptFromWhitelist.set(id, {\n        messagesAccepted: 0,\n        acceptUntil: now + constants_1.ACCEPT_FROM_WHITELIST_DURATION_MS\n      });\n    } else {\n      this.acceptFromWhitelist.delete(id);\n    }\n\n    return score >= this._options.scoreThresholds.graylistThreshold;\n  }\n  /**\n   * Validate incoming message\n   * @override\n   * @param {InMessage} msg\n   * @returns {Promise<void>}\n   */\n\n\n  validate(msg) {\n    const _super = Object.create(null, {\n      validate: {\n        get: () => super.validate\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield _super.validate.call(this, msg);\n      } catch (e) {\n        const canonicalMsgIdStr = yield this.getCanonicalMsgIdStr(msg);\n        this.score.rejectMessage(msg, canonicalMsgIdStr, e.code);\n        this.gossipTracer.rejectMessage(canonicalMsgIdStr, e.code);\n        throw e;\n      }\n    });\n  }\n  /**\n   * Handles IHAVE messages\n   * @param {string} id peer id\n   * @param {Array<RPC.IControlIHave>} ihave\n   * @returns {RPC.IControlIWant}\n   */\n\n\n  _handleIHave(id, ihave) {\n    if (!ihave.length) {\n      return [];\n    } // we ignore IHAVE gossip from any peer whose score is below the gossips threshold\n\n\n    const score = this.score.score(id);\n\n    if (score < this._options.scoreThresholds.gossipThreshold) {\n      this.log('IHAVE: ignoring peer %s with score below threshold [ score = %d ]', id, score);\n      return [];\n    } // IHAVE flood protection\n\n\n    const peerhave = (this.peerhave.get(id) || 0) + 1;\n    this.peerhave.set(id, peerhave);\n\n    if (peerhave > constants.GossipsubMaxIHaveMessages) {\n      this.log('IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring', id, peerhave);\n      return [];\n    }\n\n    const iasked = this.iasked.get(id) || 0;\n\n    if (iasked >= constants.GossipsubMaxIHaveLength) {\n      this.log('IHAVE: peer %s has already advertised too many messages (%d); ignoring', id, iasked);\n      return [];\n    } // string msgId => msgId\n\n\n    const iwant = new Map();\n    ihave.forEach(_ref => {\n      let {\n        topicID,\n        messageIDs\n      } = _ref;\n\n      if (!topicID || !messageIDs || !this.mesh.has(topicID)) {\n        return;\n      }\n\n      messageIDs.forEach(msgId => {\n        const msgIdStr = utils_1.messageIdToString(msgId);\n\n        if (this.seenCache.has(msgIdStr)) {\n          return;\n        }\n\n        iwant.set(msgIdStr, msgId);\n      });\n    });\n\n    if (!iwant.size) {\n      return [];\n    }\n\n    let iask = iwant.size;\n\n    if (iask + iasked > constants.GossipsubMaxIHaveLength) {\n      iask = constants.GossipsubMaxIHaveLength - iasked;\n    }\n\n    this.log('IHAVE: Asking for %d out of %d messages from %s', iask, iwant.size, id);\n    let iwantList = Array.from(iwant.values()); // ask in random order\n\n    utils_1.shuffle(iwantList); // truncate to the messages we are actually asking for and update the iasked counter\n\n    iwantList = iwantList.slice(0, iask);\n    this.iasked.set(id, iasked + iask);\n    this.gossipTracer.addPromise(id, iwantList);\n    return [{\n      messageIDs: iwantList\n    }];\n  }\n  /**\n   * Handles IWANT messages\n   * Returns messages to send back to peer\n   * @param {string} id peer id\n   * @param {Array<RPC.IControlIWant>} iwant\n   * @returns {Array<RPC.IMessage>}\n   */\n\n\n  _handleIWant(id, iwant) {\n    if (!iwant.length) {\n      return [];\n    } // we don't respond to IWANT requests from any per whose score is below the gossip threshold\n\n\n    const score = this.score.score(id);\n\n    if (score < this._options.scoreThresholds.gossipThreshold) {\n      this.log('IWANT: ignoring peer %s with score below threshold [score = %d]', id, score);\n      return [];\n    } // @type {Map<string, Message>}\n\n\n    const ihave = new Map();\n    iwant.forEach(_ref2 => {\n      let {\n        messageIDs\n      } = _ref2;\n      messageIDs && messageIDs.forEach(msgId => {\n        const msgIdStr = utils_1.messageIdToString(msgId);\n        const [msg, count] = this.messageCache.getForPeer(msgIdStr, id);\n\n        if (!msg) {\n          return;\n        }\n\n        if (count > constants.GossipsubGossipRetransmission) {\n          this.log('IWANT: Peer %s has asked for message %s too many times: ignoring request', id, msgId);\n          return;\n        }\n\n        ihave.set(msgIdStr, msg);\n      });\n    });\n\n    if (!ihave.size) {\n      return [];\n    }\n\n    this.log('IWANT: Sending %d messages to %s', ihave.size, id);\n    return Array.from(ihave.values()).map(pubsub_1.utils.normalizeOutRpcMessage);\n  }\n  /**\n   * Handles Graft messages\n   * @param {string} id peer id\n   * @param {Array<RPC.IControlGraft>} graft\n   * @return {Promise<RPC.IControlPrune[]>}\n   */\n\n\n  _handleGraft(id, graft) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const prune = [];\n      const score = this.score.score(id);\n\n      const now = this._now();\n\n      let doPX = this._options.doPX;\n      graft.forEach(_ref3 => {\n        let {\n          topicID\n        } = _ref3;\n\n        var _a;\n\n        if (!topicID) {\n          return;\n        }\n\n        const peersInMesh = this.mesh.get(topicID);\n\n        if (!peersInMesh) {\n          // don't do PX when there is an unknown topic to avoid leaking our peers\n          doPX = false; // spam hardening: ignore GRAFTs for unknown topics\n\n          return;\n        } // check if peer is already in the mesh; if so do nothing\n\n\n        if (peersInMesh.has(id)) {\n          return;\n        } // we don't GRAFT to/from direct peers; complain loudly if this happens\n\n\n        if (this.direct.has(id)) {\n          this.log('GRAFT: ignoring request from direct peer %s', id); // this is possibly a bug from a non-reciprical configuration; send a PRUNE\n\n          prune.push(topicID); // but don't px\n\n          doPX = false;\n          return;\n        } // make sure we are not backing off that peer\n\n\n        const expire = (_a = this.backoff.get(topicID)) === null || _a === void 0 ? void 0 : _a.get(id);\n\n        if (typeof expire === 'number' && now < expire) {\n          this.log('GRAFT: ignoring backed off peer %s', id); // add behavioral penalty\n\n          this.score.addPenalty(id, 1); // no PX\n\n          doPX = false; // check the flood cutoff -- is the GRAFT coming too fast?\n\n          const floodCutoff = expire + constants.GossipsubGraftFloodThreshold - constants.GossipsubPruneBackoff;\n\n          if (now < floodCutoff) {\n            // extra penalty\n            this.score.addPenalty(id, 1);\n          } // refresh the backoff\n\n\n          this._addBackoff(id, topicID);\n\n          prune.push(topicID);\n          return;\n        } // check the score\n\n\n        if (score < 0) {\n          // we don't GRAFT peers with negative score\n          this.log('GRAFT: ignoring peer %s with negative score: score=%d, topic=%s', id, score, topicID); // we do send them PRUNE however, because it's a matter of protocol correctness\n\n          prune.push(topicID); // but we won't PX to them\n\n          doPX = false; // add/refresh backoff so that we don't reGRAFT too early even if the score decays\n\n          this._addBackoff(id, topicID);\n\n          return;\n        } // check the number of mesh peers; if it is at (or over) Dhi, we only accept grafts\n        // from peers with outbound connections; this is a defensive check to restrict potential\n        // mesh takeover attacks combined with love bombing\n\n\n        if (peersInMesh.size >= this._options.Dhi && !this.outbound.get(id)) {\n          prune.push(topicID);\n\n          this._addBackoff(id, topicID);\n\n          return;\n        }\n\n        this.log('GRAFT: Add mesh link from %s in %s', id, topicID);\n        this.score.graft(id, topicID);\n        peersInMesh.add(id);\n      });\n\n      if (!prune.length) {\n        return [];\n      }\n\n      return Promise.all(prune.map(topic => this._makePrune(id, topic, doPX)));\n    });\n  }\n  /**\n   * Handles Prune messages\n   * @param {string} id peer id\n   * @param {Array<RPC.IControlPrune>} prune\n   * @returns {void}\n   */\n\n\n  _handlePrune(id, prune) {\n    const score = this.score.score(id);\n    prune.forEach(_ref4 => {\n      let {\n        topicID,\n        backoff,\n        peers\n      } = _ref4;\n\n      if (!topicID) {\n        return;\n      }\n\n      const peersInMesh = this.mesh.get(topicID);\n\n      if (!peersInMesh) {\n        return;\n      }\n\n      this.log('PRUNE: Remove mesh link to %s in %s', id, topicID);\n      this.score.prune(id, topicID);\n      peersInMesh.delete(id); // is there a backoff specified by the peer? if so obey it\n\n      if (typeof backoff === 'number' && backoff > 0) {\n        this._doAddBackoff(id, topicID, backoff * 1000);\n      } else {\n        this._addBackoff(id, topicID);\n      } // PX\n\n\n      if (peers && peers.length) {\n        // we ignore PX from peers with insufficient scores\n        if (score < this._options.scoreThresholds.acceptPXThreshold) {\n          this.log('PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]', id, score, topicID);\n          return;\n        }\n\n        this._pxConnect(peers);\n      }\n    });\n  }\n  /**\n   * Add standard backoff log for a peer in a topic\n   * @param {string} id\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  _addBackoff(id, topic) {\n    this._doAddBackoff(id, topic, constants.GossipsubPruneBackoff);\n  }\n  /**\n   * Add backoff expiry interval for a peer in a topic\n   * @param {string} id\n   * @param {string} topic\n   * @param {number} interval backoff duration in milliseconds\n   * @returns {void}\n   */\n\n\n  _doAddBackoff(id, topic, interval) {\n    let backoff = this.backoff.get(topic);\n\n    if (!backoff) {\n      backoff = new Map();\n      this.backoff.set(topic, backoff);\n    }\n\n    const expire = this._now() + interval;\n    const existingExpire = backoff.get(id) || 0;\n\n    if (existingExpire < expire) {\n      backoff.set(id, expire);\n    }\n  }\n  /**\n   * Apply penalties from broken IHAVE/IWANT promises\n   * @returns {void}\n   */\n\n\n  _applyIwantPenalties() {\n    this.gossipTracer.getBrokenPromises().forEach((count, p) => {\n      this.log('peer %s didn\\'t follow up in %d IWANT requests; adding penalty', p, count);\n      this.score.addPenalty(p, count);\n    });\n  }\n  /**\n   * Clear expired backoff expiries\n   * @returns {void}\n   */\n\n\n  _clearBackoff() {\n    // we only clear once every GossipsubPruneBackoffTicks ticks to avoid iterating over the maps too much\n    if (this.heartbeatTicks % constants.GossipsubPruneBackoffTicks !== 0) {\n      return;\n    }\n\n    const now = this._now();\n\n    this.backoff.forEach((backoff, topic) => {\n      backoff.forEach((expire, id) => {\n        if (expire < now) {\n          backoff.delete(id);\n        }\n      });\n\n      if (backoff.size === 0) {\n        this.backoff.delete(topic);\n      }\n    });\n  }\n  /**\n   * Maybe reconnect to direct peers\n   * @returns {void}\n   */\n\n\n  _directConnect() {\n    // we only do this every few ticks to allow pending connections to complete and account for\n    // restarts/downtime\n    if (this.heartbeatTicks % constants.GossipsubDirectConnectTicks !== 0) {\n      return;\n    }\n\n    const toconnect = [];\n    this.direct.forEach(id => {\n      const peer = this.peers.get(id);\n\n      if (!peer || !peer.isWritable) {\n        toconnect.push(id);\n      }\n    });\n\n    if (toconnect.length) {\n      toconnect.forEach(id => {\n        this._connect(id);\n      });\n    }\n  }\n  /**\n   * Maybe attempt connection given signed peer records\n   * @param {RPC.IPeerInfo[]} peers\n   * @returns {Promise<void>}\n   */\n\n\n  _pxConnect(peers) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (peers.length > constants.GossipsubPrunePeers) {\n        utils_1.shuffle(peers);\n        peers = peers.slice(0, constants.GossipsubPrunePeers);\n      }\n\n      const toconnect = [];\n      yield Promise.all(peers.map(pi => __awaiter(this, void 0, void 0, function* () {\n        if (!pi.peerID) {\n          return;\n        }\n\n        const p = PeerId.createFromBytes(pi.peerID);\n        const id = p.toB58String();\n\n        if (this.peers.has(id)) {\n          return;\n        }\n\n        if (!pi.signedPeerRecord) {\n          toconnect.push(id);\n          return;\n        } // The peer sent us a signed record\n        // This is not a record from the peer who sent the record, but another peer who is connected with it\n        // Ensure that it is valid\n\n\n        try {\n          const envelope = yield Envelope.openAndCertify(pi.signedPeerRecord, 'libp2p-peer-record');\n          const eid = envelope.peerId.toB58String();\n\n          if (id !== eid) {\n            this.log('bogus peer record obtained through px: peer ID %s doesn\\'t match expected peer %s', eid, id);\n            return;\n          }\n\n          if (!this._libp2p.peerStore.addressBook.consumePeerRecord(envelope)) {\n            this.log('bogus peer record obtained through px: could not add peer record to address book');\n            return;\n          }\n\n          toconnect.push(id);\n        } catch (e) {\n          this.log('bogus peer record obtained through px: invalid signature or not a peer record');\n        }\n      })));\n\n      if (!toconnect.length) {\n        return;\n      }\n\n      toconnect.forEach(id => this._connect(id));\n    });\n  }\n  /**\n   * Mounts the gossipsub protocol onto the libp2p node and sends our\n   * our subscriptions to every peer connected\n   * @override\n   * @returns {Promise<void>}\n   */\n\n\n  start() {\n    const _super = Object.create(null, {\n      start: {\n        get: () => super.start\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      yield _super.start.call(this);\n      this.heartbeat.start();\n      this.score.start(); // connect to direct peers\n\n      this._directPeerInitial = setTimeout(() => {\n        this.direct.forEach(id => {\n          this._connect(id);\n        });\n      }, constants.GossipsubDirectConnectInitialDelay);\n    });\n  }\n  /**\n   * Unmounts the gossipsub protocol and shuts down every connection\n   * @override\n   * @returns {Promise<void>}\n   */\n\n\n  stop() {\n    const _super = Object.create(null, {\n      stop: {\n        get: () => super.stop\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      yield _super.stop.call(this);\n      this.heartbeat.stop();\n      this.score.stop();\n      this.mesh = new Map();\n      this.fanout = new Map();\n      this.lastpub = new Map();\n      this.gossip = new Map();\n      this.control = new Map();\n      this.peerhave = new Map();\n      this.iasked = new Map();\n      this.backoff = new Map();\n      this.outbound = new Map();\n      this.gossipTracer.clear();\n      this.seenCache.clear();\n      if (this.fastMsgIdCache) this.fastMsgIdCache.clear();\n      clearTimeout(this._directPeerInitial);\n    });\n  }\n  /**\n   * Connect to a peer using the gossipsub protocol\n   * @param {string} id\n   * @returns {void}\n   */\n\n\n  _connect(id) {\n    this.log('Initiating connection with %s', id);\n\n    this._libp2p.dialProtocol(PeerId.createFromB58String(id), this.multicodecs);\n  }\n  /**\n   * Subscribes to a topic\n   * @override\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  subscribe(topic) {\n    super.subscribe(topic);\n    this.join(topic);\n  }\n  /**\n   * Unsubscribe to a topic\n   * @override\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  unsubscribe(topic) {\n    super.unsubscribe(topic);\n    this.leave(topic);\n  }\n  /**\n   * Join topic\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  join(topic) {\n    if (!this.started) {\n      throw new Error('Gossipsub has not started');\n    }\n\n    this.log('JOIN %s', topic);\n    const fanoutPeers = this.fanout.get(topic);\n\n    if (fanoutPeers) {\n      // these peers have a score above the publish threshold, which may be negative\n      // so drop the ones with a negative score\n      fanoutPeers.forEach(id => {\n        if (this.score.score(id) < 0) {\n          fanoutPeers.delete(id);\n        }\n      });\n\n      if (fanoutPeers.size < this._options.D) {\n        // we need more peers; eager, as this would get fixed in the next heartbeat\n        get_gossip_peers_1.getGossipPeers(this, topic, this._options.D - fanoutPeers.size, id => {\n          // filter our current peers, direct peers, and peers with negative scores\n          return !fanoutPeers.has(id) && !this.direct.has(id) && this.score.score(id) >= 0;\n        }).forEach(id => fanoutPeers.add(id));\n      }\n\n      this.mesh.set(topic, fanoutPeers);\n      this.fanout.delete(topic);\n      this.lastpub.delete(topic);\n    } else {\n      const peers = get_gossip_peers_1.getGossipPeers(this, topic, this._options.D, id => {\n        // filter direct peers and peers with negative score\n        return !this.direct.has(id) && this.score.score(id) >= 0;\n      });\n      this.mesh.set(topic, peers);\n    }\n\n    this.mesh.get(topic).forEach(id => {\n      this.log('JOIN: Add mesh link to %s in %s', id, topic);\n\n      this._sendGraft(id, topic);\n    });\n  }\n  /**\n   * Leave topic\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  leave(topic) {\n    if (!this.started) {\n      throw new Error('Gossipsub has not started');\n    }\n\n    this.log('LEAVE %s', topic); // Send PRUNE to mesh peers\n\n    const meshPeers = this.mesh.get(topic);\n\n    if (meshPeers) {\n      meshPeers.forEach(id => {\n        this.log('LEAVE: Remove mesh link to %s in %s', id, topic);\n\n        this._sendPrune(id, topic);\n      });\n      this.mesh.delete(topic);\n    }\n  }\n  /**\n   * Return the canonical message-id of a message as a string\n   *\n   * If a fast message-id is set: Try 1. the application cache 2. the fast cache 3. `getMsgId()`\n   * If a fast message-id is NOT set: Just `getMsgId()`\n   * @param {InMessage} msg\n   * @returns {Promise<string>}\n   */\n\n\n  getCanonicalMsgIdStr(msg) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.fastMsgIdCache && this.getFastMsgIdStr ? (_b = (_a = this.getCachedMsgIdStr(msg)) !== null && _a !== void 0 ? _a : this.fastMsgIdCache.get(this.getFastMsgIdStr(msg))) !== null && _b !== void 0 ? _b : utils_1.messageIdToString(yield this.getMsgId(msg)) : utils_1.messageIdToString(yield this.getMsgId(msg));\n    });\n  }\n  /**\n   * An application should override this function to return its cached message id string without computing it.\n   * Return undefined if message id is not found.\n   * If a fast message id function is not defined, this function is ignored.\n   * @param {InMessage} msg\n   * @returns {string | undefined}\n   */\n\n\n  getCachedMsgIdStr(msg) {\n    return undefined;\n  }\n  /**\n   * Publish messages\n   *\n   * @override\n   * @param {InMessage} msg\n   * @returns {void}\n   */\n\n\n  _publish(msg) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const msgIdStr = yield this.getCanonicalMsgIdStr(msg);\n\n      if (msg.receivedFrom !== this.peerId.toB58String()) {\n        this.score.deliverMessage(msg, msgIdStr);\n        this.gossipTracer.deliverMessage(msgIdStr);\n      } // put in seen cache\n\n\n      this.seenCache.put(msgIdStr);\n      this.messageCache.put(msg, msgIdStr);\n      const tosend = new Set();\n      msg.topicIDs.forEach(topic => {\n        const peersInTopic = this.topics.get(topic);\n\n        if (!peersInTopic) {\n          return;\n        }\n\n        if (this._options.floodPublish && msg.from === this.peerId.toB58String()) {\n          // flood-publish behavior\n          // send to direct peers and _all_ peers meeting the publishThreshold\n          peersInTopic.forEach(id => {\n            if (this.direct.has(id) || this.score.score(id) >= this._options.scoreThresholds.publishThreshold) {\n              tosend.add(id);\n            }\n          });\n        } else {\n          // non-flood-publish behavior\n          // send to direct peers, subscribed floodsub peers\n          // and some mesh peers above publishThreshold\n          // direct peers\n          this.direct.forEach(id => {\n            tosend.add(id);\n          }); // floodsub peers\n\n          peersInTopic.forEach(id => {\n            const score = this.score.score(id);\n            const peerStreams = this.peers.get(id);\n\n            if (!peerStreams) {\n              return;\n            }\n\n            if (peerStreams.protocol === constants.FloodsubID && score >= this._options.scoreThresholds.publishThreshold) {\n              tosend.add(id);\n            }\n          }); // Gossipsub peers handling\n\n          let meshPeers = this.mesh.get(topic);\n\n          if (!meshPeers || !meshPeers.size) {\n            // We are not in the mesh for topic, use fanout peers\n            meshPeers = this.fanout.get(topic);\n\n            if (!meshPeers) {\n              // If we are not in the fanout, then pick peers in topic above the publishThreshold\n              const peers = get_gossip_peers_1.getGossipPeers(this, topic, this._options.D, id => {\n                return this.score.score(id) >= this._options.scoreThresholds.publishThreshold;\n              });\n\n              if (peers.size > 0) {\n                meshPeers = peers;\n                this.fanout.set(topic, peers);\n              } else {\n                meshPeers = new Set();\n              }\n            } // Store the latest publishing time\n\n\n            this.lastpub.set(topic, this._now());\n          }\n\n          meshPeers.forEach(peer => {\n            tosend.add(peer);\n          });\n        }\n      }); // Publish messages to peers\n\n      const rpc = utils_1.createGossipRpc([pubsub_1.utils.normalizeOutRpcMessage(msg)]);\n      tosend.forEach(id => {\n        if (id === msg.from) {\n          return;\n        }\n\n        this._sendRpc(id, rpc);\n      });\n    });\n  }\n  /**\n   * Sends a GRAFT message to a peer\n   * @param {string} id peer id\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  _sendGraft(id, topic) {\n    const graft = [{\n      topicID: topic\n    }];\n    const out = utils_1.createGossipRpc([], {\n      graft\n    });\n\n    this._sendRpc(id, out);\n  }\n  /**\n   * Sends a PRUNE message to a peer\n   * @param {string} id peer id\n   * @param {string} topic\n   * @returns {Promise<void>}\n   */\n\n\n  _sendPrune(id, topic) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const prune = [yield this._makePrune(id, topic, this._options.doPX)];\n      const out = utils_1.createGossipRpc([], {\n        prune\n      });\n\n      this._sendRpc(id, out);\n    });\n  }\n  /**\n   * @override\n   */\n\n\n  _sendRpc(id, outRpc) {\n    const peerStreams = this.peers.get(id);\n\n    if (!peerStreams || !peerStreams.isWritable) {\n      return;\n    } // piggyback control message retries\n\n\n    const ctrl = this.control.get(id);\n\n    if (ctrl) {\n      this._piggybackControl(id, outRpc, ctrl);\n\n      this.control.delete(id);\n    } // piggyback gossip\n\n\n    const ihave = this.gossip.get(id);\n\n    if (ihave) {\n      this._piggybackGossip(id, outRpc, ihave);\n\n      this.gossip.delete(id);\n    }\n\n    peerStreams.write(rpc_1.RPC.encode(outRpc).finish());\n  }\n\n  _piggybackControl(id, outRpc, ctrl) {\n    const tograft = (ctrl.graft || []).filter(_ref5 => {\n      let {\n        topicID\n      } = _ref5;\n      return (topicID && this.mesh.get(topicID) || new Set()).has(id);\n    });\n    const toprune = (ctrl.prune || []).filter(_ref6 => {\n      let {\n        topicID\n      } = _ref6;\n      return !(topicID && this.mesh.get(topicID) || new Set()).has(id);\n    });\n\n    if (!tograft.length && !toprune.length) {\n      return;\n    }\n\n    if (outRpc.control) {\n      outRpc.control.graft = outRpc.control.graft && outRpc.control.graft.concat(tograft);\n      outRpc.control.prune = outRpc.control.prune && outRpc.control.prune.concat(toprune);\n    } else {\n      outRpc.control = {\n        ihave: [],\n        iwant: [],\n        graft: tograft,\n        prune: toprune\n      };\n    }\n  }\n\n  _piggybackGossip(id, outRpc, ihave) {\n    if (!outRpc.control) {\n      outRpc.control = {\n        ihave: [],\n        iwant: [],\n        graft: [],\n        prune: []\n      };\n    }\n\n    outRpc.control.ihave = ihave;\n  }\n  /**\n   * Send graft and prune messages\n   * @param {Map<string, Array<string>>} tograft peer id => topic[]\n   * @param {Map<string, Array<string>>} toprune peer id => topic[]\n   */\n\n\n  _sendGraftPrune(tograft, toprune, noPX) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const doPX = this._options.doPX;\n\n      for (const [id, topics] of tograft) {\n        const graft = topics.map(topicID => ({\n          topicID\n        }));\n        let prune = []; // If a peer also has prunes, process them now\n\n        const pruning = toprune.get(id);\n\n        if (pruning) {\n          prune = yield Promise.all(pruning.map(topicID => this._makePrune(id, topicID, doPX && !noPX.get(id))));\n          toprune.delete(id);\n        }\n\n        const outRpc = utils_1.createGossipRpc([], {\n          graft,\n          prune\n        });\n\n        this._sendRpc(id, outRpc);\n      }\n\n      for (const [id, topics] of toprune) {\n        const prune = yield Promise.all(topics.map(topicID => this._makePrune(id, topicID, doPX && !noPX.get(id))));\n        const outRpc = utils_1.createGossipRpc([], {\n          prune\n        });\n\n        this._sendRpc(id, outRpc);\n      }\n    });\n  }\n  /**\n   * Emits gossip to peers in a particular topic\n   * @param {string} topic\n   * @param {Set<string>} exclude peers to exclude\n   * @returns {void}\n   */\n\n\n  _emitGossip(topic, exclude) {\n    const messageIDs = this.messageCache.getGossipIDs(topic);\n\n    if (!messageIDs.length) {\n      return;\n    } // shuffle to emit in random order\n\n\n    utils_1.shuffle(messageIDs); // if we are emitting more than GossipsubMaxIHaveLength ids, truncate the list\n\n    if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n      // we do the truncation (with shuffling) per peer below\n      this.log('too many messages for gossip; will truncate IHAVE list (%d messages)', messageIDs.length);\n    } // Send gossip to GossipFactor peers above threshold with a minimum of D_lazy\n    // First we collect the peers above gossipThreshold that are not in the exclude set\n    // and then randomly select from that set\n    // We also exclude direct peers, as there is no reason to emit gossip to them\n\n\n    const peersToGossip = [];\n    const topicPeers = this.topics.get(topic);\n\n    if (!topicPeers) {\n      // no topic peers, no gossip\n      return;\n    }\n\n    topicPeers.forEach(id => {\n      const peerStreams = this.peers.get(id);\n\n      if (!peerStreams) {\n        return;\n      }\n\n      if (!exclude.has(id) && !this.direct.has(id) && utils_1.hasGossipProtocol(peerStreams.protocol) && this.score.score(id) >= this._options.scoreThresholds.gossipThreshold) {\n        peersToGossip.push(id);\n      }\n    });\n    let target = this._options.Dlazy;\n    const factor = constants.GossipsubGossipFactor * peersToGossip.length;\n\n    if (factor > target) {\n      target = factor;\n    }\n\n    if (target > peersToGossip.length) {\n      target = peersToGossip.length;\n    } else {\n      utils_1.shuffle(peersToGossip);\n    } // Emit the IHAVE gossip to the selected peers up to the target\n\n\n    peersToGossip.slice(0, target).forEach(id => {\n      let peerMessageIDs = messageIDs;\n\n      if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n        // shuffle and slice message IDs per peer so that we emit a different set for each peer\n        // we have enough reduncancy in the system that this will significantly increase the message\n        // coverage when we do truncate\n        peerMessageIDs = utils_1.shuffle(peerMessageIDs.slice()).slice(0, constants.GossipsubMaxIHaveLength);\n      }\n\n      this._pushGossip(id, {\n        topicID: topic,\n        messageIDs: peerMessageIDs\n      });\n    });\n  }\n  /**\n   * Flush gossip and control messages\n   */\n\n\n  _flush() {\n    // send gossip first, which will also piggyback control\n    for (const [peer, ihave] of this.gossip.entries()) {\n      this.gossip.delete(peer);\n      const out = utils_1.createGossipRpc([], {\n        ihave\n      });\n\n      this._sendRpc(peer, out);\n    } // send the remaining control messages\n\n\n    for (const [peer, control] of this.control.entries()) {\n      this.control.delete(peer);\n      const out = utils_1.createGossipRpc([], {\n        graft: control.graft,\n        prune: control.prune\n      });\n\n      this._sendRpc(peer, out);\n    }\n  }\n  /**\n   * Adds new IHAVE messages to pending gossip\n   * @param {PeerStreams} peerStreams\n   * @param {Array<RPC.IControlIHave>} controlIHaveMsgs\n   * @returns {void}\n   */\n\n\n  _pushGossip(id, controlIHaveMsgs) {\n    this.log('Add gossip to %s', id);\n    const gossip = this.gossip.get(id) || [];\n    this.gossip.set(id, gossip.concat(controlIHaveMsgs));\n  }\n  /**\n   * Returns the current time in milliseconds\n   * @returns {number}\n   */\n\n\n  _now() {\n    return Date.now();\n  }\n  /**\n   * Make a PRUNE control message for a peer in a topic\n   * @param {string} id\n   * @param {string} topic\n   * @param {boolean} doPX\n   * @returns {Promise<RPC.IControlPrune>}\n   */\n\n\n  _makePrune(id, topic, doPX) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.peers.get(id).protocol === constants.GossipsubIDv10) {\n        // Gossipsub v1.0 -- no backoff, the peer won't be able to parse it anyway\n        return {\n          topicID: topic,\n          peers: []\n        };\n      } // backoff is measured in seconds\n      // GossipsubPruneBackoff is measured in milliseconds\n\n\n      const backoff = constants.GossipsubPruneBackoff / 1000;\n\n      if (!doPX) {\n        return {\n          topicID: topic,\n          peers: [],\n          backoff: backoff\n        };\n      } // select peers for Peer eXchange\n\n\n      const peers = get_gossip_peers_1.getGossipPeers(this, topic, constants.GossipsubPrunePeers, xid => {\n        return xid !== id && this.score.score(xid) >= 0;\n      });\n      const px = yield Promise.all(Array.from(peers).map(p => __awaiter(this, void 0, void 0, function* () {\n        // see if we have a signed record to send back; if we don't, just send\n        // the peer ID and let the pruned peer find them in the DHT -- we can't trust\n        // unsigned address records through PX anyways\n        // Finding signed records in the DHT is not supported at the time of writing in js-libp2p\n        const peerId = PeerId.createFromB58String(p);\n        return {\n          peerID: peerId.toBytes(),\n          signedPeerRecord: yield this._libp2p.peerStore.addressBook.getRawEnvelope(peerId)\n        };\n      })));\n      return {\n        topicID: topic,\n        peers: px,\n        backoff: backoff\n      };\n    });\n  }\n\n}\n\nGossipsub.multicodec = constants.GossipsubIDv11;\nmodule.exports = Gossipsub;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p-gossipsub/src/index.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","prototype","hasOwnProperty","call","__awaiter","thisArg","_arguments","P","generator","adopt","resolve","Promise","reject","fulfilled","step","next","e","rejected","done","then","apply","pubsub_1","require","message_cache_1","rpc_1","constants","heartbeat_1","get_gossip_peers_1","utils_1","score_1","tracer_1","time_cache_1","PeerId","Envelope","constants_1","Gossipsub","default","constructor","libp2p","options","_a","multicodecs","GossipsubIDv11","GossipsubIDv10","opts","assign","gossipIncoming","fallbackToFloodsub","floodPublish","doPX","directPeers","D","GossipsubD","Dlo","GossipsubDlo","Dhi","GossipsubDhi","Dscore","GossipsubDscore","Dout","GossipsubDout","Dlazy","GossipsubDlazy","heartbeatInterval","GossipsubHeartbeatInterval","fanoutTTL","GossipsubFanoutTTL","mcacheLength","GossipsubHistoryLength","mcacheGossip","GossipsubHistoryGossip","seenTTL","GossipsubSeenTTL","scoreParams","createPeerScoreParams","scoreThresholds","createPeerScoreThresholds","push","FloodsubID","debugName","_options","direct","Set","map","p","id","toB58String","acceptFromWhitelist","Map","forEach","peerStore","addressBook","add","addrs","seenCache","SimpleTimeCache","validityMs","mesh","fanout","lastpub","gossip","control","peerhave","iasked","backoff","outbound","messageCache","MessageCache","getFastMsgIdStr","fastMsgIdFn","fastMsgIdCache","heartbeat","Heartbeat","heartbeatTicks","gossipTracer","IWantTracer","_libp2p","score","PeerScore","connectionManager","_decodeRpc","bytes","RPC","decode","_encodeRpc","rpc","encode","finish","_addPeer","peerId","protocol","addPeer","c","getAll","stat","direction","Array","from","registry","values","some","rvalue","set","_removePeer","peerStreams","peers","delete","removePeer","_processRpc","_super","_processRpcControlMessage","controlMsg","iwant","ihave","_handleIHave","_handleIWant","prune","graft","_handleGraft","_handlePrune","length","outRpc","createGossipRpc","_sendRpc","_processRpcMessage","msg","canonicalMsgIdStr","fastMsgIdStr","duplicateMessage","messageIdToString","getMsgId","put","has","validateMessage","_acceptFrom","now","Date","entry","messagesAccepted","ACCEPT_FROM_WHITELIST_MAX_MESSAGES","acceptUntil","ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE","ACCEPT_FROM_WHITELIST_DURATION_MS","graylistThreshold","validate","getCanonicalMsgIdStr","rejectMessage","code","gossipThreshold","log","GossipsubMaxIHaveMessages","GossipsubMaxIHaveLength","topicID","messageIDs","msgId","msgIdStr","size","iask","iwantList","shuffle","slice","addPromise","count","getForPeer","GossipsubGossipRetransmission","utils","normalizeOutRpcMessage","_now","peersInMesh","expire","addPenalty","floodCutoff","GossipsubGraftFloodThreshold","GossipsubPruneBackoff","_addBackoff","all","topic","_makePrune","_doAddBackoff","acceptPXThreshold","_pxConnect","interval","existingExpire","_applyIwantPenalties","getBrokenPromises","_clearBackoff","GossipsubPruneBackoffTicks","_directConnect","GossipsubDirectConnectTicks","toconnect","peer","isWritable","_connect","GossipsubPrunePeers","pi","peerID","createFromBytes","signedPeerRecord","envelope","openAndCertify","eid","consumePeerRecord","start","_directPeerInitial","setTimeout","GossipsubDirectConnectInitialDelay","stop","clear","clearTimeout","dialProtocol","createFromB58String","subscribe","join","unsubscribe","leave","started","Error","fanoutPeers","getGossipPeers","_sendGraft","meshPeers","_sendPrune","_b","getCachedMsgIdStr","_publish","receivedFrom","deliverMessage","tosend","topicIDs","peersInTopic","topics","publishThreshold","out","ctrl","_piggybackControl","_piggybackGossip","write","tograft","filter","toprune","concat","_sendGraftPrune","noPX","pruning","_emitGossip","exclude","getGossipIDs","peersToGossip","topicPeers","hasGossipProtocol","target","factor","GossipsubGossipFactor","peerMessageIDs","_pushGossip","_flush","entries","controlIHaveMsgs","xid","px","toBytes","getRawEnvelope","multicodec","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst pubsub_1 = __importStar(require(\"libp2p-interfaces/src/pubsub\"));\nconst message_cache_1 = require(\"./message-cache\");\nconst rpc_1 = require(\"./message/rpc\");\nconst constants = __importStar(require(\"./constants\"));\nconst heartbeat_1 = require(\"./heartbeat\");\nconst get_gossip_peers_1 = require(\"./get-gossip-peers\");\nconst utils_1 = require(\"./utils\");\nconst score_1 = require(\"./score\");\nconst tracer_1 = require(\"./tracer\");\nconst time_cache_1 = require(\"./utils/time-cache\");\nconst PeerId = require(\"peer-id\");\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nconst Envelope = require(\"libp2p/src/record/envelope\");\nconst constants_1 = require(\"./constants\");\nclass Gossipsub extends pubsub_1.default {\n    // TODO: add remaining props\n    /**\n     * @param {Libp2p} libp2p\n     * @param {Object} [options]\n     * @param {boolean} [options.emitSelf = false] if publish should emit to self, if subscribed\n     * @param {boolean} [options.canRelayMessage = false] - if can relay messages not subscribed\n     * @param {boolean} [options.gossipIncoming = true] if incoming messages on a subscribed topic should be automatically gossiped\n     * @param {boolean} [options.fallbackToFloodsub = true] if dial should fallback to floodsub\n     * @param {boolean} [options.floodPublish = true] if self-published messages should be sent to all peers\n     * @param {boolean} [options.doPX = false] whether PX is enabled; this should be enabled in bootstrappers and other well connected/trusted nodes.\n     * @param {Object} [options.messageCache] override the default MessageCache\n     * @param {FastMsgIdFn} [options.fastMsgIdFn] fast message id function\n     * @param {string} [options.globalSignaturePolicy = \"StrictSign\"] signing policy to apply across all messages\n     * @param {Object} [options.scoreParams] peer score parameters\n     * @param {Object} [options.scoreThresholds] peer score thresholds\n     * @param {AddrInfo[]} [options.directPeers] peers with which we will maintain direct connections\n     * @constructor\n     */\n    constructor(libp2p, options = {}) {\n        var _a;\n        const multicodecs = [constants.GossipsubIDv11, constants.GossipsubIDv10];\n        const opts = Object.assign(Object.assign({ gossipIncoming: true, fallbackToFloodsub: true, floodPublish: true, doPX: false, directPeers: [], D: constants.GossipsubD, Dlo: constants.GossipsubDlo, Dhi: constants.GossipsubDhi, Dscore: constants.GossipsubDscore, Dout: constants.GossipsubDout, Dlazy: constants.GossipsubDlazy, heartbeatInterval: constants.GossipsubHeartbeatInterval, fanoutTTL: constants.GossipsubFanoutTTL, mcacheLength: constants.GossipsubHistoryLength, mcacheGossip: constants.GossipsubHistoryGossip, seenTTL: constants.GossipsubSeenTTL }, options), { scoreParams: score_1.createPeerScoreParams(options.scoreParams), scoreThresholds: score_1.createPeerScoreThresholds(options.scoreThresholds) });\n        // Also wants to get notified of peers connected using floodsub\n        if (opts.fallbackToFloodsub) {\n            multicodecs.push(constants.FloodsubID);\n        }\n        super(Object.assign({ debugName: 'libp2p:gossipsub', multicodecs,\n            libp2p }, opts));\n        this._options = opts;\n        /**\n         * Direct peers\n         * @type {Set<string>}\n         */\n        this.direct = new Set(opts.directPeers.map(p => p.id.toB58String()));\n        /**\n         * Map of peer id and AcceptRequestWhileListEntry\n         *\n         * @type {Map<string, AcceptFromWhitelistEntry}\n         */\n        this.acceptFromWhitelist = new Map();\n        // set direct peer addresses in the address book\n        opts.directPeers.forEach(p => {\n            libp2p.peerStore.addressBook.add(p.id, p.addrs);\n        });\n        /**\n         * Cache of seen messages\n         *\n         * @type {SimpleTimeCache}\n         */\n        this.seenCache = new time_cache_1.SimpleTimeCache({ validityMs: opts.seenTTL });\n        /**\n         * Map of topic meshes\n         * topic => peer id set\n         *\n         * @type {Map<string, Set<string>>}\n         */\n        this.mesh = new Map();\n        /**\n         * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership\n         * topic => peer id set\n         *\n         * @type {Map<string, Set<string>>}\n         */\n        this.fanout = new Map();\n        /**\n         * Map of last publish time for fanout topics\n         * topic => last publish time\n         *\n         * @type {Map<string, number>}\n         */\n        this.lastpub = new Map();\n        /**\n         * Map of pending messages to gossip\n         * peer id => control messages\n         *\n         * @type {Map<string, Array<RPC.IControlIHave object>> }\n         */\n        this.gossip = new Map();\n        /**\n         * Map of control messages\n         * peer id => control message\n         *\n         * @type {Map<string, RPC.IControlMessage object>}\n         */\n        this.control = new Map();\n        /**\n         * Number of IHAVEs received from peer in the last heartbeat\n         * @type {Map<string, number>}\n         */\n        this.peerhave = new Map();\n        /**\n         * Number of messages we have asked from peer in the last heartbeat\n         * @type {Map<string, number>}\n         */\n        this.iasked = new Map();\n        /**\n         * Prune backoff map\n         */\n        this.backoff = new Map();\n        /**\n         * Connection direction cache, marks peers with outbound connections\n         * peer id => direction\n         *\n         * @type {Map<string, boolean>}\n         */\n        this.outbound = new Map();\n        /**\n         * A message cache that contains the messages for last few hearbeat ticks\n         */\n        this.messageCache = options.messageCache || new message_cache_1.MessageCache(opts.mcacheGossip, opts.mcacheLength);\n        /**\n         * A fast message id function used for internal message de-duplication\n         */\n        this.getFastMsgIdStr = (_a = options.fastMsgIdFn) !== null && _a !== void 0 ? _a : undefined;\n        /**\n         * Maps fast message-id to canonical message-id\n         */\n        this.fastMsgIdCache = options.fastMsgIdFn ? new time_cache_1.SimpleTimeCache({ validityMs: opts.seenTTL }) : undefined;\n        /**\n         * A heartbeat timer that maintains the mesh\n         */\n        this.heartbeat = new heartbeat_1.Heartbeat(this);\n        /**\n         * Number of heartbeats since the beginning of time\n         * This allows us to amortize some resource cleanup -- eg: backoff cleanup\n         */\n        this.heartbeatTicks = 0;\n        /**\n         * Tracks IHAVE/IWANT promises broken by peers\n         */\n        this.gossipTracer = new tracer_1.IWantTracer();\n        /**\n         * libp2p\n         */\n        this._libp2p = libp2p;\n        /**\n         * Peer score tracking\n         */\n        this.score = new score_1.PeerScore(this._options.scoreParams, libp2p.connectionManager);\n    }\n    /**\n     * Decode a Uint8Array into an RPC object\n     * Overrided to use an extended protocol-specific protobuf decoder\n     * @override\n     * @param {Uint8Array} bytes\n     * @returns {RPC}\n     */\n    _decodeRpc(bytes) {\n        return rpc_1.RPC.decode(bytes);\n    }\n    /**\n     * Encode an RPC object into a Uint8Array\n     * Overrided to use an extended protocol-specific protobuf encoder\n     * @override\n     * @param {RPC} rpc\n     * @returns {Uint8Array}\n     */\n    _encodeRpc(rpc) {\n        return rpc_1.RPC.encode(rpc).finish();\n    }\n    /**\n     * Add a peer to the router\n     * @override\n     * @param {PeerId} peerId\n     * @param {string} protocol\n     * @returns {PeerStreams}\n     */\n    _addPeer(peerId, protocol) {\n        const p = super._addPeer(peerId, protocol);\n        // Add to peer scoring\n        this.score.addPeer(peerId.toB58String());\n        // track the connection direction\n        let outbound = false;\n        for (const c of this._libp2p.connectionManager.getAll(peerId)) {\n            if (c.stat.direction === 'outbound') {\n                if (Array.from(c.registry.values()).some(rvalue => protocol === rvalue.protocol)) {\n                    outbound = true;\n                    break;\n                }\n            }\n        }\n        this.outbound.set(p.id.toB58String(), outbound);\n        return p;\n    }\n    /**\n     * Removes a peer from the router\n     * @override\n     * @param {PeerId} peer\n     * @returns {PeerStreams | undefined}\n     */\n    _removePeer(peerId) {\n        const peerStreams = super._removePeer(peerId);\n        const id = peerId.toB58String();\n        // Remove this peer from the mesh\n        // eslint-disable-next-line no-unused-vars\n        for (const peers of this.mesh.values()) {\n            peers.delete(id);\n        }\n        // Remove this peer from the fanout\n        // eslint-disable-next-line no-unused-vars\n        for (const peers of this.fanout.values()) {\n            peers.delete(id);\n        }\n        // Remove from gossip mapping\n        this.gossip.delete(id);\n        // Remove from control mapping\n        this.control.delete(id);\n        // Remove from backoff mapping\n        this.outbound.delete(id);\n        // Remove from peer scoring\n        this.score.removePeer(id);\n        this.acceptFromWhitelist.delete(id);\n        return peerStreams;\n    }\n    /**\n     * Handles an rpc request from a peer\n     *\n     * @override\n     * @param {String} idB58Str\n     * @param {PeerStreams} peerStreams\n     * @param {RPC} rpc\n     * @returns {Promise<boolean>}\n     */\n    _processRpc(id, peerStreams, rpc) {\n        const _super = Object.create(null, {\n            _processRpc: { get: () => super._processRpc }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            if (yield _super._processRpc.call(this, id, peerStreams, rpc)) {\n                if (rpc.control) {\n                    yield this._processRpcControlMessage(id, rpc.control);\n                }\n                return true;\n            }\n            return false;\n        });\n    }\n    /**\n     * Handles an rpc control message from a peer\n     * @param {string} id peer id\n     * @param {RPC.IControlMessage} controlMsg\n     * @returns {void}\n     */\n    _processRpcControlMessage(id, controlMsg) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!controlMsg) {\n                return;\n            }\n            const iwant = controlMsg.ihave ? this._handleIHave(id, controlMsg.ihave) : [];\n            const ihave = controlMsg.iwant ? this._handleIWant(id, controlMsg.iwant) : [];\n            const prune = controlMsg.graft ? yield this._handleGraft(id, controlMsg.graft) : [];\n            controlMsg.prune && this._handlePrune(id, controlMsg.prune);\n            if (!iwant.length && !ihave.length && !prune.length) {\n                return;\n            }\n            const outRpc = utils_1.createGossipRpc(ihave, { iwant, prune });\n            this._sendRpc(id, outRpc);\n        });\n    }\n    /**\n     * Process incoming message,\n     * emitting locally and forwarding on to relevant floodsub and gossipsub peers\n     * @override\n     * @param {InMessage} msg\n     * @returns {Promise<void>}\n     */\n    _processRpcMessage(msg) {\n        const _super = Object.create(null, {\n            _processRpcMessage: { get: () => super._processRpcMessage }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            let canonicalMsgIdStr;\n            if (this.getFastMsgIdStr && this.fastMsgIdCache) {\n                // check duplicate\n                const fastMsgIdStr = yield this.getFastMsgIdStr(msg);\n                canonicalMsgIdStr = this.fastMsgIdCache.get(fastMsgIdStr);\n                if (canonicalMsgIdStr !== undefined) {\n                    this.score.duplicateMessage(msg, canonicalMsgIdStr);\n                    return;\n                }\n                canonicalMsgIdStr = utils_1.messageIdToString(yield this.getMsgId(msg));\n                this.fastMsgIdCache.put(fastMsgIdStr, canonicalMsgIdStr);\n            }\n            else {\n                // check duplicate\n                canonicalMsgIdStr = utils_1.messageIdToString(yield this.getMsgId(msg));\n                if (this.seenCache.has(canonicalMsgIdStr)) {\n                    this.score.duplicateMessage(msg, canonicalMsgIdStr);\n                    return;\n                }\n            }\n            // put in cache\n            this.seenCache.put(canonicalMsgIdStr);\n            yield this.score.validateMessage(canonicalMsgIdStr);\n            yield _super._processRpcMessage.call(this, msg);\n        });\n    }\n    /**\n     * Whether to accept a message from a peer\n     * @override\n     * @param {string} id\n     * @returns {boolean}\n     */\n    _acceptFrom(id) {\n        if (this.direct.has(id)) {\n            return true;\n        }\n        const now = Date.now();\n        const entry = this.acceptFromWhitelist.get(id);\n        if (entry &&\n            entry.messagesAccepted < constants_1.ACCEPT_FROM_WHITELIST_MAX_MESSAGES &&\n            entry.acceptUntil >= now) {\n            entry.messagesAccepted += 1;\n            return true;\n        }\n        const score = this.score.score(id);\n        if (score >= constants_1.ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE) {\n            // peer is unlikely to be able to drop its score to `graylistThreshold`\n            // after 128 messages or 1s\n            this.acceptFromWhitelist.set(id, {\n                messagesAccepted: 0,\n                acceptUntil: now + constants_1.ACCEPT_FROM_WHITELIST_DURATION_MS\n            });\n        }\n        else {\n            this.acceptFromWhitelist.delete(id);\n        }\n        return score >= this._options.scoreThresholds.graylistThreshold;\n    }\n    /**\n     * Validate incoming message\n     * @override\n     * @param {InMessage} msg\n     * @returns {Promise<void>}\n     */\n    validate(msg) {\n        const _super = Object.create(null, {\n            validate: { get: () => super.validate }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield _super.validate.call(this, msg);\n            }\n            catch (e) {\n                const canonicalMsgIdStr = yield this.getCanonicalMsgIdStr(msg);\n                this.score.rejectMessage(msg, canonicalMsgIdStr, e.code);\n                this.gossipTracer.rejectMessage(canonicalMsgIdStr, e.code);\n                throw e;\n            }\n        });\n    }\n    /**\n     * Handles IHAVE messages\n     * @param {string} id peer id\n     * @param {Array<RPC.IControlIHave>} ihave\n     * @returns {RPC.IControlIWant}\n     */\n    _handleIHave(id, ihave) {\n        if (!ihave.length) {\n            return [];\n        }\n        // we ignore IHAVE gossip from any peer whose score is below the gossips threshold\n        const score = this.score.score(id);\n        if (score < this._options.scoreThresholds.gossipThreshold) {\n            this.log('IHAVE: ignoring peer %s with score below threshold [ score = %d ]', id, score);\n            return [];\n        }\n        // IHAVE flood protection\n        const peerhave = (this.peerhave.get(id) || 0) + 1;\n        this.peerhave.set(id, peerhave);\n        if (peerhave > constants.GossipsubMaxIHaveMessages) {\n            this.log('IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring', id, peerhave);\n            return [];\n        }\n        const iasked = this.iasked.get(id) || 0;\n        if (iasked >= constants.GossipsubMaxIHaveLength) {\n            this.log('IHAVE: peer %s has already advertised too many messages (%d); ignoring', id, iasked);\n            return [];\n        }\n        // string msgId => msgId\n        const iwant = new Map();\n        ihave.forEach(({ topicID, messageIDs }) => {\n            if (!topicID || !messageIDs || !this.mesh.has(topicID)) {\n                return;\n            }\n            messageIDs.forEach((msgId) => {\n                const msgIdStr = utils_1.messageIdToString(msgId);\n                if (this.seenCache.has(msgIdStr)) {\n                    return;\n                }\n                iwant.set(msgIdStr, msgId);\n            });\n        });\n        if (!iwant.size) {\n            return [];\n        }\n        let iask = iwant.size;\n        if (iask + iasked > constants.GossipsubMaxIHaveLength) {\n            iask = constants.GossipsubMaxIHaveLength - iasked;\n        }\n        this.log('IHAVE: Asking for %d out of %d messages from %s', iask, iwant.size, id);\n        let iwantList = Array.from(iwant.values());\n        // ask in random order\n        utils_1.shuffle(iwantList);\n        // truncate to the messages we are actually asking for and update the iasked counter\n        iwantList = iwantList.slice(0, iask);\n        this.iasked.set(id, iasked + iask);\n        this.gossipTracer.addPromise(id, iwantList);\n        return [{\n                messageIDs: iwantList\n            }];\n    }\n    /**\n     * Handles IWANT messages\n     * Returns messages to send back to peer\n     * @param {string} id peer id\n     * @param {Array<RPC.IControlIWant>} iwant\n     * @returns {Array<RPC.IMessage>}\n     */\n    _handleIWant(id, iwant) {\n        if (!iwant.length) {\n            return [];\n        }\n        // we don't respond to IWANT requests from any per whose score is below the gossip threshold\n        const score = this.score.score(id);\n        if (score < this._options.scoreThresholds.gossipThreshold) {\n            this.log('IWANT: ignoring peer %s with score below threshold [score = %d]', id, score);\n            return [];\n        }\n        // @type {Map<string, Message>}\n        const ihave = new Map();\n        iwant.forEach(({ messageIDs }) => {\n            messageIDs && messageIDs.forEach((msgId) => {\n                const msgIdStr = utils_1.messageIdToString(msgId);\n                const [msg, count] = this.messageCache.getForPeer(msgIdStr, id);\n                if (!msg) {\n                    return;\n                }\n                if (count > constants.GossipsubGossipRetransmission) {\n                    this.log('IWANT: Peer %s has asked for message %s too many times: ignoring request', id, msgId);\n                    return;\n                }\n                ihave.set(msgIdStr, msg);\n            });\n        });\n        if (!ihave.size) {\n            return [];\n        }\n        this.log('IWANT: Sending %d messages to %s', ihave.size, id);\n        return Array.from(ihave.values()).map(pubsub_1.utils.normalizeOutRpcMessage);\n    }\n    /**\n     * Handles Graft messages\n     * @param {string} id peer id\n     * @param {Array<RPC.IControlGraft>} graft\n     * @return {Promise<RPC.IControlPrune[]>}\n     */\n    _handleGraft(id, graft) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const prune = [];\n            const score = this.score.score(id);\n            const now = this._now();\n            let doPX = this._options.doPX;\n            graft.forEach(({ topicID }) => {\n                var _a;\n                if (!topicID) {\n                    return;\n                }\n                const peersInMesh = this.mesh.get(topicID);\n                if (!peersInMesh) {\n                    // don't do PX when there is an unknown topic to avoid leaking our peers\n                    doPX = false;\n                    // spam hardening: ignore GRAFTs for unknown topics\n                    return;\n                }\n                // check if peer is already in the mesh; if so do nothing\n                if (peersInMesh.has(id)) {\n                    return;\n                }\n                // we don't GRAFT to/from direct peers; complain loudly if this happens\n                if (this.direct.has(id)) {\n                    this.log('GRAFT: ignoring request from direct peer %s', id);\n                    // this is possibly a bug from a non-reciprical configuration; send a PRUNE\n                    prune.push(topicID);\n                    // but don't px\n                    doPX = false;\n                    return;\n                }\n                // make sure we are not backing off that peer\n                const expire = (_a = this.backoff.get(topicID)) === null || _a === void 0 ? void 0 : _a.get(id);\n                if (typeof expire === 'number' && now < expire) {\n                    this.log('GRAFT: ignoring backed off peer %s', id);\n                    // add behavioral penalty\n                    this.score.addPenalty(id, 1);\n                    // no PX\n                    doPX = false;\n                    // check the flood cutoff -- is the GRAFT coming too fast?\n                    const floodCutoff = expire + constants.GossipsubGraftFloodThreshold - constants.GossipsubPruneBackoff;\n                    if (now < floodCutoff) {\n                        // extra penalty\n                        this.score.addPenalty(id, 1);\n                    }\n                    // refresh the backoff\n                    this._addBackoff(id, topicID);\n                    prune.push(topicID);\n                    return;\n                }\n                // check the score\n                if (score < 0) {\n                    // we don't GRAFT peers with negative score\n                    this.log('GRAFT: ignoring peer %s with negative score: score=%d, topic=%s', id, score, topicID);\n                    // we do send them PRUNE however, because it's a matter of protocol correctness\n                    prune.push(topicID);\n                    // but we won't PX to them\n                    doPX = false;\n                    // add/refresh backoff so that we don't reGRAFT too early even if the score decays\n                    this._addBackoff(id, topicID);\n                    return;\n                }\n                // check the number of mesh peers; if it is at (or over) Dhi, we only accept grafts\n                // from peers with outbound connections; this is a defensive check to restrict potential\n                // mesh takeover attacks combined with love bombing\n                if (peersInMesh.size >= this._options.Dhi && !this.outbound.get(id)) {\n                    prune.push(topicID);\n                    this._addBackoff(id, topicID);\n                    return;\n                }\n                this.log('GRAFT: Add mesh link from %s in %s', id, topicID);\n                this.score.graft(id, topicID);\n                peersInMesh.add(id);\n            });\n            if (!prune.length) {\n                return [];\n            }\n            return Promise.all(prune.map(topic => this._makePrune(id, topic, doPX)));\n        });\n    }\n    /**\n     * Handles Prune messages\n     * @param {string} id peer id\n     * @param {Array<RPC.IControlPrune>} prune\n     * @returns {void}\n     */\n    _handlePrune(id, prune) {\n        const score = this.score.score(id);\n        prune.forEach(({ topicID, backoff, peers }) => {\n            if (!topicID) {\n                return;\n            }\n            const peersInMesh = this.mesh.get(topicID);\n            if (!peersInMesh) {\n                return;\n            }\n            this.log('PRUNE: Remove mesh link to %s in %s', id, topicID);\n            this.score.prune(id, topicID);\n            peersInMesh.delete(id);\n            // is there a backoff specified by the peer? if so obey it\n            if (typeof backoff === 'number' && backoff > 0) {\n                this._doAddBackoff(id, topicID, backoff * 1000);\n            }\n            else {\n                this._addBackoff(id, topicID);\n            }\n            // PX\n            if (peers && peers.length) {\n                // we ignore PX from peers with insufficient scores\n                if (score < this._options.scoreThresholds.acceptPXThreshold) {\n                    this.log('PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]', id, score, topicID);\n                    return;\n                }\n                this._pxConnect(peers);\n            }\n        });\n    }\n    /**\n     * Add standard backoff log for a peer in a topic\n     * @param {string} id\n     * @param {string} topic\n     * @returns {void}\n     */\n    _addBackoff(id, topic) {\n        this._doAddBackoff(id, topic, constants.GossipsubPruneBackoff);\n    }\n    /**\n     * Add backoff expiry interval for a peer in a topic\n     * @param {string} id\n     * @param {string} topic\n     * @param {number} interval backoff duration in milliseconds\n     * @returns {void}\n     */\n    _doAddBackoff(id, topic, interval) {\n        let backoff = this.backoff.get(topic);\n        if (!backoff) {\n            backoff = new Map();\n            this.backoff.set(topic, backoff);\n        }\n        const expire = this._now() + interval;\n        const existingExpire = backoff.get(id) || 0;\n        if (existingExpire < expire) {\n            backoff.set(id, expire);\n        }\n    }\n    /**\n     * Apply penalties from broken IHAVE/IWANT promises\n     * @returns {void}\n     */\n    _applyIwantPenalties() {\n        this.gossipTracer.getBrokenPromises().forEach((count, p) => {\n            this.log('peer %s didn\\'t follow up in %d IWANT requests; adding penalty', p, count);\n            this.score.addPenalty(p, count);\n        });\n    }\n    /**\n     * Clear expired backoff expiries\n     * @returns {void}\n     */\n    _clearBackoff() {\n        // we only clear once every GossipsubPruneBackoffTicks ticks to avoid iterating over the maps too much\n        if (this.heartbeatTicks % constants.GossipsubPruneBackoffTicks !== 0) {\n            return;\n        }\n        const now = this._now();\n        this.backoff.forEach((backoff, topic) => {\n            backoff.forEach((expire, id) => {\n                if (expire < now) {\n                    backoff.delete(id);\n                }\n            });\n            if (backoff.size === 0) {\n                this.backoff.delete(topic);\n            }\n        });\n    }\n    /**\n     * Maybe reconnect to direct peers\n     * @returns {void}\n     */\n    _directConnect() {\n        // we only do this every few ticks to allow pending connections to complete and account for\n        // restarts/downtime\n        if (this.heartbeatTicks % constants.GossipsubDirectConnectTicks !== 0) {\n            return;\n        }\n        const toconnect = [];\n        this.direct.forEach(id => {\n            const peer = this.peers.get(id);\n            if (!peer || !peer.isWritable) {\n                toconnect.push(id);\n            }\n        });\n        if (toconnect.length) {\n            toconnect.forEach(id => {\n                this._connect(id);\n            });\n        }\n    }\n    /**\n     * Maybe attempt connection given signed peer records\n     * @param {RPC.IPeerInfo[]} peers\n     * @returns {Promise<void>}\n     */\n    _pxConnect(peers) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (peers.length > constants.GossipsubPrunePeers) {\n                utils_1.shuffle(peers);\n                peers = peers.slice(0, constants.GossipsubPrunePeers);\n            }\n            const toconnect = [];\n            yield Promise.all(peers.map((pi) => __awaiter(this, void 0, void 0, function* () {\n                if (!pi.peerID) {\n                    return;\n                }\n                const p = PeerId.createFromBytes(pi.peerID);\n                const id = p.toB58String();\n                if (this.peers.has(id)) {\n                    return;\n                }\n                if (!pi.signedPeerRecord) {\n                    toconnect.push(id);\n                    return;\n                }\n                // The peer sent us a signed record\n                // This is not a record from the peer who sent the record, but another peer who is connected with it\n                // Ensure that it is valid\n                try {\n                    const envelope = yield Envelope.openAndCertify(pi.signedPeerRecord, 'libp2p-peer-record');\n                    const eid = envelope.peerId.toB58String();\n                    if (id !== eid) {\n                        this.log('bogus peer record obtained through px: peer ID %s doesn\\'t match expected peer %s', eid, id);\n                        return;\n                    }\n                    if (!this._libp2p.peerStore.addressBook.consumePeerRecord(envelope)) {\n                        this.log('bogus peer record obtained through px: could not add peer record to address book');\n                        return;\n                    }\n                    toconnect.push(id);\n                }\n                catch (e) {\n                    this.log('bogus peer record obtained through px: invalid signature or not a peer record');\n                }\n            })));\n            if (!toconnect.length) {\n                return;\n            }\n            toconnect.forEach(id => this._connect(id));\n        });\n    }\n    /**\n     * Mounts the gossipsub protocol onto the libp2p node and sends our\n     * our subscriptions to every peer connected\n     * @override\n     * @returns {Promise<void>}\n     */\n    start() {\n        const _super = Object.create(null, {\n            start: { get: () => super.start }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.start.call(this);\n            this.heartbeat.start();\n            this.score.start();\n            // connect to direct peers\n            this._directPeerInitial = setTimeout(() => {\n                this.direct.forEach(id => {\n                    this._connect(id);\n                });\n            }, constants.GossipsubDirectConnectInitialDelay);\n        });\n    }\n    /**\n     * Unmounts the gossipsub protocol and shuts down every connection\n     * @override\n     * @returns {Promise<void>}\n     */\n    stop() {\n        const _super = Object.create(null, {\n            stop: { get: () => super.stop }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.stop.call(this);\n            this.heartbeat.stop();\n            this.score.stop();\n            this.mesh = new Map();\n            this.fanout = new Map();\n            this.lastpub = new Map();\n            this.gossip = new Map();\n            this.control = new Map();\n            this.peerhave = new Map();\n            this.iasked = new Map();\n            this.backoff = new Map();\n            this.outbound = new Map();\n            this.gossipTracer.clear();\n            this.seenCache.clear();\n            if (this.fastMsgIdCache)\n                this.fastMsgIdCache.clear();\n            clearTimeout(this._directPeerInitial);\n        });\n    }\n    /**\n     * Connect to a peer using the gossipsub protocol\n     * @param {string} id\n     * @returns {void}\n     */\n    _connect(id) {\n        this.log('Initiating connection with %s', id);\n        this._libp2p.dialProtocol(PeerId.createFromB58String(id), this.multicodecs);\n    }\n    /**\n     * Subscribes to a topic\n     * @override\n     * @param {string} topic\n     * @returns {void}\n     */\n    subscribe(topic) {\n        super.subscribe(topic);\n        this.join(topic);\n    }\n    /**\n     * Unsubscribe to a topic\n     * @override\n     * @param {string} topic\n     * @returns {void}\n     */\n    unsubscribe(topic) {\n        super.unsubscribe(topic);\n        this.leave(topic);\n    }\n    /**\n     * Join topic\n     * @param {string} topic\n     * @returns {void}\n     */\n    join(topic) {\n        if (!this.started) {\n            throw new Error('Gossipsub has not started');\n        }\n        this.log('JOIN %s', topic);\n        const fanoutPeers = this.fanout.get(topic);\n        if (fanoutPeers) {\n            // these peers have a score above the publish threshold, which may be negative\n            // so drop the ones with a negative score\n            fanoutPeers.forEach(id => {\n                if (this.score.score(id) < 0) {\n                    fanoutPeers.delete(id);\n                }\n            });\n            if (fanoutPeers.size < this._options.D) {\n                // we need more peers; eager, as this would get fixed in the next heartbeat\n                get_gossip_peers_1.getGossipPeers(this, topic, this._options.D - fanoutPeers.size, (id) => {\n                    // filter our current peers, direct peers, and peers with negative scores\n                    return !fanoutPeers.has(id) && !this.direct.has(id) && this.score.score(id) >= 0;\n                }).forEach(id => fanoutPeers.add(id));\n            }\n            this.mesh.set(topic, fanoutPeers);\n            this.fanout.delete(topic);\n            this.lastpub.delete(topic);\n        }\n        else {\n            const peers = get_gossip_peers_1.getGossipPeers(this, topic, this._options.D, (id) => {\n                // filter direct peers and peers with negative score\n                return !this.direct.has(id) && this.score.score(id) >= 0;\n            });\n            this.mesh.set(topic, peers);\n        }\n        this.mesh.get(topic).forEach((id) => {\n            this.log('JOIN: Add mesh link to %s in %s', id, topic);\n            this._sendGraft(id, topic);\n        });\n    }\n    /**\n     * Leave topic\n     * @param {string} topic\n     * @returns {void}\n     */\n    leave(topic) {\n        if (!this.started) {\n            throw new Error('Gossipsub has not started');\n        }\n        this.log('LEAVE %s', topic);\n        // Send PRUNE to mesh peers\n        const meshPeers = this.mesh.get(topic);\n        if (meshPeers) {\n            meshPeers.forEach((id) => {\n                this.log('LEAVE: Remove mesh link to %s in %s', id, topic);\n                this._sendPrune(id, topic);\n            });\n            this.mesh.delete(topic);\n        }\n    }\n    /**\n     * Return the canonical message-id of a message as a string\n     *\n     * If a fast message-id is set: Try 1. the application cache 2. the fast cache 3. `getMsgId()`\n     * If a fast message-id is NOT set: Just `getMsgId()`\n     * @param {InMessage} msg\n     * @returns {Promise<string>}\n     */\n    getCanonicalMsgIdStr(msg) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            return (this.fastMsgIdCache && this.getFastMsgIdStr)\n                ? (_b = (_a = this.getCachedMsgIdStr(msg)) !== null && _a !== void 0 ? _a : this.fastMsgIdCache.get(this.getFastMsgIdStr(msg))) !== null && _b !== void 0 ? _b : utils_1.messageIdToString(yield this.getMsgId(msg)) : utils_1.messageIdToString(yield this.getMsgId(msg));\n        });\n    }\n    /**\n     * An application should override this function to return its cached message id string without computing it.\n     * Return undefined if message id is not found.\n     * If a fast message id function is not defined, this function is ignored.\n     * @param {InMessage} msg\n     * @returns {string | undefined}\n     */\n    getCachedMsgIdStr(msg) {\n        return undefined;\n    }\n    /**\n     * Publish messages\n     *\n     * @override\n     * @param {InMessage} msg\n     * @returns {void}\n     */\n    _publish(msg) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const msgIdStr = yield this.getCanonicalMsgIdStr(msg);\n            if (msg.receivedFrom !== this.peerId.toB58String()) {\n                this.score.deliverMessage(msg, msgIdStr);\n                this.gossipTracer.deliverMessage(msgIdStr);\n            }\n            // put in seen cache\n            this.seenCache.put(msgIdStr);\n            this.messageCache.put(msg, msgIdStr);\n            const tosend = new Set();\n            msg.topicIDs.forEach((topic) => {\n                const peersInTopic = this.topics.get(topic);\n                if (!peersInTopic) {\n                    return;\n                }\n                if (this._options.floodPublish && msg.from === this.peerId.toB58String()) {\n                    // flood-publish behavior\n                    // send to direct peers and _all_ peers meeting the publishThreshold\n                    peersInTopic.forEach(id => {\n                        if (this.direct.has(id) || this.score.score(id) >= this._options.scoreThresholds.publishThreshold) {\n                            tosend.add(id);\n                        }\n                    });\n                }\n                else {\n                    // non-flood-publish behavior\n                    // send to direct peers, subscribed floodsub peers\n                    // and some mesh peers above publishThreshold\n                    // direct peers\n                    this.direct.forEach(id => {\n                        tosend.add(id);\n                    });\n                    // floodsub peers\n                    peersInTopic.forEach((id) => {\n                        const score = this.score.score(id);\n                        const peerStreams = this.peers.get(id);\n                        if (!peerStreams) {\n                            return;\n                        }\n                        if (peerStreams.protocol === constants.FloodsubID && score >= this._options.scoreThresholds.publishThreshold) {\n                            tosend.add(id);\n                        }\n                    });\n                    // Gossipsub peers handling\n                    let meshPeers = this.mesh.get(topic);\n                    if (!meshPeers || !meshPeers.size) {\n                        // We are not in the mesh for topic, use fanout peers\n                        meshPeers = this.fanout.get(topic);\n                        if (!meshPeers) {\n                            // If we are not in the fanout, then pick peers in topic above the publishThreshold\n                            const peers = get_gossip_peers_1.getGossipPeers(this, topic, this._options.D, id => {\n                                return this.score.score(id) >= this._options.scoreThresholds.publishThreshold;\n                            });\n                            if (peers.size > 0) {\n                                meshPeers = peers;\n                                this.fanout.set(topic, peers);\n                            }\n                            else {\n                                meshPeers = new Set();\n                            }\n                        }\n                        // Store the latest publishing time\n                        this.lastpub.set(topic, this._now());\n                    }\n                    meshPeers.forEach((peer) => {\n                        tosend.add(peer);\n                    });\n                }\n            });\n            // Publish messages to peers\n            const rpc = utils_1.createGossipRpc([\n                pubsub_1.utils.normalizeOutRpcMessage(msg)\n            ]);\n            tosend.forEach((id) => {\n                if (id === msg.from) {\n                    return;\n                }\n                this._sendRpc(id, rpc);\n            });\n        });\n    }\n    /**\n     * Sends a GRAFT message to a peer\n     * @param {string} id peer id\n     * @param {string} topic\n     * @returns {void}\n     */\n    _sendGraft(id, topic) {\n        const graft = [{\n                topicID: topic\n            }];\n        const out = utils_1.createGossipRpc([], { graft });\n        this._sendRpc(id, out);\n    }\n    /**\n     * Sends a PRUNE message to a peer\n     * @param {string} id peer id\n     * @param {string} topic\n     * @returns {Promise<void>}\n     */\n    _sendPrune(id, topic) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const prune = [\n                yield this._makePrune(id, topic, this._options.doPX)\n            ];\n            const out = utils_1.createGossipRpc([], { prune });\n            this._sendRpc(id, out);\n        });\n    }\n    /**\n     * @override\n     */\n    _sendRpc(id, outRpc) {\n        const peerStreams = this.peers.get(id);\n        if (!peerStreams || !peerStreams.isWritable) {\n            return;\n        }\n        // piggyback control message retries\n        const ctrl = this.control.get(id);\n        if (ctrl) {\n            this._piggybackControl(id, outRpc, ctrl);\n            this.control.delete(id);\n        }\n        // piggyback gossip\n        const ihave = this.gossip.get(id);\n        if (ihave) {\n            this._piggybackGossip(id, outRpc, ihave);\n            this.gossip.delete(id);\n        }\n        peerStreams.write(rpc_1.RPC.encode(outRpc).finish());\n    }\n    _piggybackControl(id, outRpc, ctrl) {\n        const tograft = (ctrl.graft || [])\n            .filter(({ topicID }) => (topicID && this.mesh.get(topicID) || new Set()).has(id));\n        const toprune = (ctrl.prune || [])\n            .filter(({ topicID }) => !(topicID && this.mesh.get(topicID) || new Set()).has(id));\n        if (!tograft.length && !toprune.length) {\n            return;\n        }\n        if (outRpc.control) {\n            outRpc.control.graft = outRpc.control.graft && outRpc.control.graft.concat(tograft);\n            outRpc.control.prune = outRpc.control.prune && outRpc.control.prune.concat(toprune);\n        }\n        else {\n            outRpc.control = { ihave: [], iwant: [], graft: tograft, prune: toprune };\n        }\n    }\n    _piggybackGossip(id, outRpc, ihave) {\n        if (!outRpc.control) {\n            outRpc.control = { ihave: [], iwant: [], graft: [], prune: [] };\n        }\n        outRpc.control.ihave = ihave;\n    }\n    /**\n     * Send graft and prune messages\n     * @param {Map<string, Array<string>>} tograft peer id => topic[]\n     * @param {Map<string, Array<string>>} toprune peer id => topic[]\n     */\n    _sendGraftPrune(tograft, toprune, noPX) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const doPX = this._options.doPX;\n            for (const [id, topics] of tograft) {\n                const graft = topics.map((topicID) => ({ topicID }));\n                let prune = [];\n                // If a peer also has prunes, process them now\n                const pruning = toprune.get(id);\n                if (pruning) {\n                    prune = yield Promise.all(pruning.map((topicID) => this._makePrune(id, topicID, doPX && !noPX.get(id))));\n                    toprune.delete(id);\n                }\n                const outRpc = utils_1.createGossipRpc([], { graft, prune });\n                this._sendRpc(id, outRpc);\n            }\n            for (const [id, topics] of toprune) {\n                const prune = yield Promise.all(topics.map((topicID) => this._makePrune(id, topicID, doPX && !noPX.get(id))));\n                const outRpc = utils_1.createGossipRpc([], { prune });\n                this._sendRpc(id, outRpc);\n            }\n        });\n    }\n    /**\n     * Emits gossip to peers in a particular topic\n     * @param {string} topic\n     * @param {Set<string>} exclude peers to exclude\n     * @returns {void}\n     */\n    _emitGossip(topic, exclude) {\n        const messageIDs = this.messageCache.getGossipIDs(topic);\n        if (!messageIDs.length) {\n            return;\n        }\n        // shuffle to emit in random order\n        utils_1.shuffle(messageIDs);\n        // if we are emitting more than GossipsubMaxIHaveLength ids, truncate the list\n        if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n            // we do the truncation (with shuffling) per peer below\n            this.log('too many messages for gossip; will truncate IHAVE list (%d messages)', messageIDs.length);\n        }\n        // Send gossip to GossipFactor peers above threshold with a minimum of D_lazy\n        // First we collect the peers above gossipThreshold that are not in the exclude set\n        // and then randomly select from that set\n        // We also exclude direct peers, as there is no reason to emit gossip to them\n        const peersToGossip = [];\n        const topicPeers = this.topics.get(topic);\n        if (!topicPeers) {\n            // no topic peers, no gossip\n            return;\n        }\n        topicPeers.forEach(id => {\n            const peerStreams = this.peers.get(id);\n            if (!peerStreams) {\n                return;\n            }\n            if (!exclude.has(id) &&\n                !this.direct.has(id) &&\n                utils_1.hasGossipProtocol(peerStreams.protocol) &&\n                this.score.score(id) >= this._options.scoreThresholds.gossipThreshold) {\n                peersToGossip.push(id);\n            }\n        });\n        let target = this._options.Dlazy;\n        const factor = constants.GossipsubGossipFactor * peersToGossip.length;\n        if (factor > target) {\n            target = factor;\n        }\n        if (target > peersToGossip.length) {\n            target = peersToGossip.length;\n        }\n        else {\n            utils_1.shuffle(peersToGossip);\n        }\n        // Emit the IHAVE gossip to the selected peers up to the target\n        peersToGossip.slice(0, target).forEach(id => {\n            let peerMessageIDs = messageIDs;\n            if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n                // shuffle and slice message IDs per peer so that we emit a different set for each peer\n                // we have enough reduncancy in the system that this will significantly increase the message\n                // coverage when we do truncate\n                peerMessageIDs = utils_1.shuffle(peerMessageIDs.slice()).slice(0, constants.GossipsubMaxIHaveLength);\n            }\n            this._pushGossip(id, {\n                topicID: topic,\n                messageIDs: peerMessageIDs\n            });\n        });\n    }\n    /**\n     * Flush gossip and control messages\n     */\n    _flush() {\n        // send gossip first, which will also piggyback control\n        for (const [peer, ihave] of this.gossip.entries()) {\n            this.gossip.delete(peer);\n            const out = utils_1.createGossipRpc([], { ihave });\n            this._sendRpc(peer, out);\n        }\n        // send the remaining control messages\n        for (const [peer, control] of this.control.entries()) {\n            this.control.delete(peer);\n            const out = utils_1.createGossipRpc([], { graft: control.graft, prune: control.prune });\n            this._sendRpc(peer, out);\n        }\n    }\n    /**\n     * Adds new IHAVE messages to pending gossip\n     * @param {PeerStreams} peerStreams\n     * @param {Array<RPC.IControlIHave>} controlIHaveMsgs\n     * @returns {void}\n     */\n    _pushGossip(id, controlIHaveMsgs) {\n        this.log('Add gossip to %s', id);\n        const gossip = this.gossip.get(id) || [];\n        this.gossip.set(id, gossip.concat(controlIHaveMsgs));\n    }\n    /**\n     * Returns the current time in milliseconds\n     * @returns {number}\n     */\n    _now() {\n        return Date.now();\n    }\n    /**\n     * Make a PRUNE control message for a peer in a topic\n     * @param {string} id\n     * @param {string} topic\n     * @param {boolean} doPX\n     * @returns {Promise<RPC.IControlPrune>}\n     */\n    _makePrune(id, topic, doPX) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.peers.get(id).protocol === constants.GossipsubIDv10) {\n                // Gossipsub v1.0 -- no backoff, the peer won't be able to parse it anyway\n                return {\n                    topicID: topic,\n                    peers: []\n                };\n            }\n            // backoff is measured in seconds\n            // GossipsubPruneBackoff is measured in milliseconds\n            const backoff = constants.GossipsubPruneBackoff / 1000;\n            if (!doPX) {\n                return {\n                    topicID: topic,\n                    peers: [],\n                    backoff: backoff\n                };\n            }\n            // select peers for Peer eXchange\n            const peers = get_gossip_peers_1.getGossipPeers(this, topic, constants.GossipsubPrunePeers, (xid) => {\n                return xid !== id && this.score.score(xid) >= 0;\n            });\n            const px = yield Promise.all(Array.from(peers).map((p) => __awaiter(this, void 0, void 0, function* () {\n                // see if we have a signed record to send back; if we don't, just send\n                // the peer ID and let the pruned peer find them in the DHT -- we can't trust\n                // unsigned address records through PX anyways\n                // Finding signed records in the DHT is not supported at the time of writing in js-libp2p\n                const peerId = PeerId.createFromB58String(p);\n                return {\n                    peerID: peerId.toBytes(),\n                    signedPeerRecord: yield this._libp2p.peerStore.addressBook.getRawEnvelope(peerId)\n                };\n            })));\n            return {\n                topicID: topic,\n                peers: px,\n                backoff: backoff\n            };\n        });\n    }\n}\nGossipsub.multicodec = constants.GossipsubIDv11;\nmodule.exports = Gossipsub;\n"]},"metadata":{},"sourceType":"script"}