{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar cid = require('multiformats/cid');\n\nvar base58 = require('multiformats/bases/base58');\n\nvar index = require('../message/index.js');\n\nvar index$2 = require('../wantlist/index.js');\n\nvar ledger = require('./ledger.js');\n\nvar reqQueue = require('./req-queue.js');\n\nvar taskMerger = require('./task-merger.js');\n\nvar index$1 = require('../utils/index.js');\n\nvar trackedMap = require('libp2p/src/metrics/tracked-map.js');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar trackedMap__default = /*#__PURE__*/_interopDefaultLegacy(trackedMap);\n\nconst WantType = index.BitswapMessage.WantType;\nconst TARGET_MESSAGE_SIZE = 16 * 1024;\nconst MAX_SIZE_REPLACE_HAS_WITH_BLOCK = 1024;\n\nclass DecisionEngine {\n  constructor(peerId, blockstore, network, stats, libp2p) {\n    let opts = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    this._log = index$1.logger(peerId, 'engine');\n    this.blockstore = blockstore;\n    this.network = network;\n    this._stats = stats;\n    this._opts = this._processOpts(opts);\n    this.ledgerMap = trackedMap__default[\"default\"]({\n      system: 'ipfs',\n      component: 'bitswap',\n      metric: 'ledger-map',\n      metrics: libp2p.metrics\n    });\n    this._running = false;\n    this._requestQueue = new reqQueue.RequestQueue(taskMerger.TaskMerger);\n  }\n\n  _processOpts(opts) {\n    return {\n      maxSizeReplaceHasWithBlock: MAX_SIZE_REPLACE_HAS_WITH_BLOCK,\n      targetMessageSize: TARGET_MESSAGE_SIZE,\n      ...opts\n    };\n  }\n\n  _scheduleProcessTasks() {\n    setTimeout(() => {\n      this._processTasks();\n    });\n  }\n\n  async _processTasks() {\n    if (!this._running) {\n      return;\n    }\n\n    const {\n      peerId,\n      tasks,\n      pendingSize\n    } = this._requestQueue.popTasks(this._opts.targetMessageSize);\n\n    if (tasks.length === 0) {\n      return;\n    }\n\n    const msg = new index.BitswapMessage(false);\n    msg.setPendingBytes(pendingSize);\n    const blockCids = [];\n    const blockTasks = new Map();\n\n    for (const task of tasks) {\n      const cid$1 = cid.CID.parse(task.topic);\n\n      if (task.data.haveBlock) {\n        if (task.data.isWantBlock) {\n          blockCids.push(cid$1);\n          blockTasks.set(task.topic, task.data);\n        } else {\n          msg.addHave(cid$1);\n        }\n      } else {\n        msg.addDontHave(cid$1);\n      }\n    }\n\n    const blocks = await this._getBlocks(blockCids);\n\n    for (const [topic, taskData] of blockTasks) {\n      const cid$1 = cid.CID.parse(topic);\n      const blk = blocks.get(topic);\n\n      if (blk) {\n        msg.addBlock(cid$1, blk);\n      } else {\n        if (taskData.sendDontHave) {\n          msg.addDontHave(cid$1);\n        }\n      }\n    }\n\n    if (msg.empty) {\n      peerId && this._requestQueue.tasksDone(peerId, tasks);\n\n      this._scheduleProcessTasks();\n\n      return;\n    }\n\n    try {\n      peerId && (await this.network.sendMessage(peerId, msg));\n\n      for (const [cidStr, block] of blocks.entries()) {\n        peerId && this.messageSent(peerId, cid.CID.parse(cidStr), block);\n      }\n    } catch (err) {\n      this._log.error(err);\n    }\n\n    peerId && this._requestQueue.tasksDone(peerId, tasks);\n\n    this._scheduleProcessTasks();\n  }\n\n  wantlistForPeer(peerId) {\n    const peerIdStr = peerId.toB58String();\n    const ledger = this.ledgerMap.get(peerIdStr);\n    return ledger ? ledger.wantlist.sortedEntries() : new Map();\n  }\n\n  ledgerForPeer(peerId) {\n    const peerIdStr = peerId.toB58String();\n    const ledger = this.ledgerMap.get(peerIdStr);\n\n    if (!ledger) {\n      return null;\n    }\n\n    return {\n      peer: ledger.partner,\n      value: ledger.debtRatio(),\n      sent: ledger.accounting.bytesSent,\n      recv: ledger.accounting.bytesRecv,\n      exchanged: ledger.exchangeCount\n    };\n  }\n\n  peers() {\n    return Array.from(this.ledgerMap.values()).map(l => l.partner);\n  }\n\n  receivedBlocks(blocks) {\n    if (!blocks.length) {\n      return;\n    }\n\n    for (const ledger of this.ledgerMap.values()) {\n      for (const block of blocks) {\n        const want = ledger.wantlistContains(block.cid);\n\n        if (!want) {\n          continue;\n        }\n\n        const blockSize = block.data.length;\n\n        const isWantBlock = this._sendAsBlock(want.wantType, blockSize);\n\n        let entrySize = blockSize;\n\n        if (!isWantBlock) {\n          entrySize = index.BitswapMessage.blockPresenceSize(want.cid);\n        }\n\n        this._requestQueue.pushTasks(ledger.partner, [{\n          topic: want.cid.toString(base58.base58btc),\n          priority: want.priority,\n          size: entrySize,\n          data: {\n            blockSize,\n            isWantBlock,\n            haveBlock: true,\n            sendDontHave: false\n          }\n        }]);\n      }\n    }\n\n    this._scheduleProcessTasks();\n  }\n\n  async messageReceived(peerId, msg) {\n    const ledger = this._findOrCreate(peerId);\n\n    if (msg.empty) {\n      return;\n    }\n\n    if (msg.full) {\n      ledger.wantlist = new index$2.Wantlist();\n    }\n\n    this._updateBlockAccounting(msg.blocks, ledger);\n\n    if (msg.wantlist.size === 0) {\n      this._scheduleProcessTasks();\n\n      return;\n    }\n\n    const cancels = [];\n    const wants = [];\n    msg.wantlist.forEach(entry => {\n      if (entry.cancel) {\n        ledger.cancelWant(entry.cid);\n        cancels.push(entry.cid);\n      } else {\n        ledger.wants(entry.cid, entry.priority, entry.wantType);\n        wants.push(entry);\n      }\n    });\n\n    this._cancelWants(peerId, cancels);\n\n    await this._addWants(peerId, wants);\n\n    this._scheduleProcessTasks();\n  }\n\n  _cancelWants(peerId, cids) {\n    for (const c of cids) {\n      this._requestQueue.remove(c.toString(base58.base58btc), peerId);\n    }\n  }\n\n  async _addWants(peerId, wants) {\n    const blockSizes = await this._getBlockSizes(wants.map(w => w.cid));\n    const tasks = [];\n\n    for (const want of wants) {\n      const id = want.cid.toString(base58.base58btc);\n      const blockSize = blockSizes.get(id);\n\n      if (blockSize == null) {\n        if (want.sendDontHave) {\n          tasks.push({\n            topic: id,\n            priority: want.priority,\n            size: index.BitswapMessage.blockPresenceSize(want.cid),\n            data: {\n              isWantBlock: want.wantType === WantType.Block,\n              blockSize: 0,\n              haveBlock: false,\n              sendDontHave: want.sendDontHave\n            }\n          });\n        }\n      } else {\n        const isWantBlock = this._sendAsBlock(want.wantType, blockSize);\n\n        let entrySize = blockSize;\n\n        if (!isWantBlock) {\n          entrySize = index.BitswapMessage.blockPresenceSize(want.cid);\n        }\n\n        tasks.push({\n          topic: id,\n          priority: want.priority,\n          size: entrySize,\n          data: {\n            isWantBlock,\n            blockSize,\n            haveBlock: true,\n            sendDontHave: want.sendDontHave\n          }\n        });\n      }\n\n      this._requestQueue.pushTasks(peerId, tasks);\n    }\n  }\n\n  _sendAsBlock(wantType, blockSize) {\n    return wantType === WantType.Block || blockSize <= this._opts.maxSizeReplaceHasWithBlock;\n  }\n\n  async _getBlockSizes(cids) {\n    const blocks = await this._getBlocks(cids);\n    return new Map([...blocks].map(_ref => {\n      let [k, v] = _ref;\n      return [k, v.length];\n    }));\n  }\n\n  async _getBlocks(cids) {\n    const res = new Map();\n    await Promise.all(cids.map(async cid => {\n      try {\n        const block = await this.blockstore.get(cid);\n        res.set(cid.toString(base58.base58btc), block);\n      } catch (e) {\n        if (e.code !== 'ERR_NOT_FOUND') {\n          this._log.error('failed to query blockstore for %s: %s', cid, e);\n        }\n      }\n    }));\n    return res;\n  }\n\n  _updateBlockAccounting(blocksMap, ledger) {\n    for (const block of blocksMap.values()) {\n      this._log('got block (%s bytes)', block.length);\n\n      ledger.receivedBytes(block.length);\n    }\n  }\n\n  messageSent(peerId, cid, block) {\n    const ledger = this._findOrCreate(peerId);\n\n    ledger.sentBytes(block.length);\n    ledger.wantlist.remove(cid);\n  }\n\n  numBytesSentTo(peerId) {\n    return this._findOrCreate(peerId).accounting.bytesSent;\n  }\n\n  numBytesReceivedFrom(peerId) {\n    return this._findOrCreate(peerId).accounting.bytesRecv;\n  }\n\n  peerDisconnected(peerId) {\n    this.ledgerMap.delete(peerId.toB58String());\n  }\n\n  _findOrCreate(peerId) {\n    const peerIdStr = peerId.toB58String();\n    const ledger$1 = this.ledgerMap.get(peerIdStr);\n\n    if (ledger$1) {\n      return ledger$1;\n    }\n\n    const l = new ledger.Ledger(peerId);\n    this.ledgerMap.set(peerIdStr, l);\n\n    if (this._stats) {\n      this._stats.push(peerIdStr, 'peerCount', 1);\n    }\n\n    return l;\n  }\n\n  start() {\n    this._running = true;\n  }\n\n  stop() {\n    this._running = false;\n  }\n\n}\n\nexports.DecisionEngine = DecisionEngine;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-bitswap/cjs/src/decision-engine/index.js"],"names":["Object","defineProperty","exports","value","cid","require","base58","index","index$2","ledger","reqQueue","taskMerger","index$1","trackedMap","_interopDefaultLegacy","e","trackedMap__default","WantType","BitswapMessage","TARGET_MESSAGE_SIZE","MAX_SIZE_REPLACE_HAS_WITH_BLOCK","DecisionEngine","constructor","peerId","blockstore","network","stats","libp2p","opts","_log","logger","_stats","_opts","_processOpts","ledgerMap","system","component","metric","metrics","_running","_requestQueue","RequestQueue","TaskMerger","maxSizeReplaceHasWithBlock","targetMessageSize","_scheduleProcessTasks","setTimeout","_processTasks","tasks","pendingSize","popTasks","length","msg","setPendingBytes","blockCids","blockTasks","Map","task","cid$1","CID","parse","topic","data","haveBlock","isWantBlock","push","set","addHave","addDontHave","blocks","_getBlocks","taskData","blk","get","addBlock","sendDontHave","empty","tasksDone","sendMessage","cidStr","block","entries","messageSent","err","error","wantlistForPeer","peerIdStr","toB58String","wantlist","sortedEntries","ledgerForPeer","peer","partner","debtRatio","sent","accounting","bytesSent","recv","bytesRecv","exchanged","exchangeCount","peers","Array","from","values","map","l","receivedBlocks","want","wantlistContains","blockSize","_sendAsBlock","wantType","entrySize","blockPresenceSize","pushTasks","toString","base58btc","priority","size","messageReceived","_findOrCreate","full","Wantlist","_updateBlockAccounting","cancels","wants","forEach","entry","cancel","cancelWant","_cancelWants","_addWants","cids","c","remove","blockSizes","_getBlockSizes","w","id","Block","k","v","res","Promise","all","code","blocksMap","receivedBytes","sentBytes","numBytesSentTo","numBytesReceivedFrom","peerDisconnected","delete","ledger$1","Ledger","start","stop"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar cid = require('multiformats/cid');\nvar base58 = require('multiformats/bases/base58');\nvar index = require('../message/index.js');\nvar index$2 = require('../wantlist/index.js');\nvar ledger = require('./ledger.js');\nvar reqQueue = require('./req-queue.js');\nvar taskMerger = require('./task-merger.js');\nvar index$1 = require('../utils/index.js');\nvar trackedMap = require('libp2p/src/metrics/tracked-map.js');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar trackedMap__default = /*#__PURE__*/_interopDefaultLegacy(trackedMap);\n\nconst WantType = index.BitswapMessage.WantType;\nconst TARGET_MESSAGE_SIZE = 16 * 1024;\nconst MAX_SIZE_REPLACE_HAS_WITH_BLOCK = 1024;\nclass DecisionEngine {\n  constructor(peerId, blockstore, network, stats, libp2p, opts = {}) {\n    this._log = index$1.logger(peerId, 'engine');\n    this.blockstore = blockstore;\n    this.network = network;\n    this._stats = stats;\n    this._opts = this._processOpts(opts);\n    this.ledgerMap = trackedMap__default[\"default\"]({\n      system: 'ipfs',\n      component: 'bitswap',\n      metric: 'ledger-map',\n      metrics: libp2p.metrics\n    });\n    this._running = false;\n    this._requestQueue = new reqQueue.RequestQueue(taskMerger.TaskMerger);\n  }\n  _processOpts(opts) {\n    return {\n      maxSizeReplaceHasWithBlock: MAX_SIZE_REPLACE_HAS_WITH_BLOCK,\n      targetMessageSize: TARGET_MESSAGE_SIZE,\n      ...opts\n    };\n  }\n  _scheduleProcessTasks() {\n    setTimeout(() => {\n      this._processTasks();\n    });\n  }\n  async _processTasks() {\n    if (!this._running) {\n      return;\n    }\n    const {peerId, tasks, pendingSize} = this._requestQueue.popTasks(this._opts.targetMessageSize);\n    if (tasks.length === 0) {\n      return;\n    }\n    const msg = new index.BitswapMessage(false);\n    msg.setPendingBytes(pendingSize);\n    const blockCids = [];\n    const blockTasks = new Map();\n    for (const task of tasks) {\n      const cid$1 = cid.CID.parse(task.topic);\n      if (task.data.haveBlock) {\n        if (task.data.isWantBlock) {\n          blockCids.push(cid$1);\n          blockTasks.set(task.topic, task.data);\n        } else {\n          msg.addHave(cid$1);\n        }\n      } else {\n        msg.addDontHave(cid$1);\n      }\n    }\n    const blocks = await this._getBlocks(blockCids);\n    for (const [topic, taskData] of blockTasks) {\n      const cid$1 = cid.CID.parse(topic);\n      const blk = blocks.get(topic);\n      if (blk) {\n        msg.addBlock(cid$1, blk);\n      } else {\n        if (taskData.sendDontHave) {\n          msg.addDontHave(cid$1);\n        }\n      }\n    }\n    if (msg.empty) {\n      peerId && this._requestQueue.tasksDone(peerId, tasks);\n      this._scheduleProcessTasks();\n      return;\n    }\n    try {\n      peerId && await this.network.sendMessage(peerId, msg);\n      for (const [cidStr, block] of blocks.entries()) {\n        peerId && this.messageSent(peerId, cid.CID.parse(cidStr), block);\n      }\n    } catch (err) {\n      this._log.error(err);\n    }\n    peerId && this._requestQueue.tasksDone(peerId, tasks);\n    this._scheduleProcessTasks();\n  }\n  wantlistForPeer(peerId) {\n    const peerIdStr = peerId.toB58String();\n    const ledger = this.ledgerMap.get(peerIdStr);\n    return ledger ? ledger.wantlist.sortedEntries() : new Map();\n  }\n  ledgerForPeer(peerId) {\n    const peerIdStr = peerId.toB58String();\n    const ledger = this.ledgerMap.get(peerIdStr);\n    if (!ledger) {\n      return null;\n    }\n    return {\n      peer: ledger.partner,\n      value: ledger.debtRatio(),\n      sent: ledger.accounting.bytesSent,\n      recv: ledger.accounting.bytesRecv,\n      exchanged: ledger.exchangeCount\n    };\n  }\n  peers() {\n    return Array.from(this.ledgerMap.values()).map(l => l.partner);\n  }\n  receivedBlocks(blocks) {\n    if (!blocks.length) {\n      return;\n    }\n    for (const ledger of this.ledgerMap.values()) {\n      for (const block of blocks) {\n        const want = ledger.wantlistContains(block.cid);\n        if (!want) {\n          continue;\n        }\n        const blockSize = block.data.length;\n        const isWantBlock = this._sendAsBlock(want.wantType, blockSize);\n        let entrySize = blockSize;\n        if (!isWantBlock) {\n          entrySize = index.BitswapMessage.blockPresenceSize(want.cid);\n        }\n        this._requestQueue.pushTasks(ledger.partner, [{\n            topic: want.cid.toString(base58.base58btc),\n            priority: want.priority,\n            size: entrySize,\n            data: {\n              blockSize,\n              isWantBlock,\n              haveBlock: true,\n              sendDontHave: false\n            }\n          }]);\n      }\n    }\n    this._scheduleProcessTasks();\n  }\n  async messageReceived(peerId, msg) {\n    const ledger = this._findOrCreate(peerId);\n    if (msg.empty) {\n      return;\n    }\n    if (msg.full) {\n      ledger.wantlist = new index$2.Wantlist();\n    }\n    this._updateBlockAccounting(msg.blocks, ledger);\n    if (msg.wantlist.size === 0) {\n      this._scheduleProcessTasks();\n      return;\n    }\n    const cancels = [];\n    const wants = [];\n    msg.wantlist.forEach(entry => {\n      if (entry.cancel) {\n        ledger.cancelWant(entry.cid);\n        cancels.push(entry.cid);\n      } else {\n        ledger.wants(entry.cid, entry.priority, entry.wantType);\n        wants.push(entry);\n      }\n    });\n    this._cancelWants(peerId, cancels);\n    await this._addWants(peerId, wants);\n    this._scheduleProcessTasks();\n  }\n  _cancelWants(peerId, cids) {\n    for (const c of cids) {\n      this._requestQueue.remove(c.toString(base58.base58btc), peerId);\n    }\n  }\n  async _addWants(peerId, wants) {\n    const blockSizes = await this._getBlockSizes(wants.map(w => w.cid));\n    const tasks = [];\n    for (const want of wants) {\n      const id = want.cid.toString(base58.base58btc);\n      const blockSize = blockSizes.get(id);\n      if (blockSize == null) {\n        if (want.sendDontHave) {\n          tasks.push({\n            topic: id,\n            priority: want.priority,\n            size: index.BitswapMessage.blockPresenceSize(want.cid),\n            data: {\n              isWantBlock: want.wantType === WantType.Block,\n              blockSize: 0,\n              haveBlock: false,\n              sendDontHave: want.sendDontHave\n            }\n          });\n        }\n      } else {\n        const isWantBlock = this._sendAsBlock(want.wantType, blockSize);\n        let entrySize = blockSize;\n        if (!isWantBlock) {\n          entrySize = index.BitswapMessage.blockPresenceSize(want.cid);\n        }\n        tasks.push({\n          topic: id,\n          priority: want.priority,\n          size: entrySize,\n          data: {\n            isWantBlock,\n            blockSize,\n            haveBlock: true,\n            sendDontHave: want.sendDontHave\n          }\n        });\n      }\n      this._requestQueue.pushTasks(peerId, tasks);\n    }\n  }\n  _sendAsBlock(wantType, blockSize) {\n    return wantType === WantType.Block || blockSize <= this._opts.maxSizeReplaceHasWithBlock;\n  }\n  async _getBlockSizes(cids) {\n    const blocks = await this._getBlocks(cids);\n    return new Map([...blocks].map(([k, v]) => [\n      k,\n      v.length\n    ]));\n  }\n  async _getBlocks(cids) {\n    const res = new Map();\n    await Promise.all(cids.map(async cid => {\n      try {\n        const block = await this.blockstore.get(cid);\n        res.set(cid.toString(base58.base58btc), block);\n      } catch (e) {\n        if (e.code !== 'ERR_NOT_FOUND') {\n          this._log.error('failed to query blockstore for %s: %s', cid, e);\n        }\n      }\n    }));\n    return res;\n  }\n  _updateBlockAccounting(blocksMap, ledger) {\n    for (const block of blocksMap.values()) {\n      this._log('got block (%s bytes)', block.length);\n      ledger.receivedBytes(block.length);\n    }\n  }\n  messageSent(peerId, cid, block) {\n    const ledger = this._findOrCreate(peerId);\n    ledger.sentBytes(block.length);\n    ledger.wantlist.remove(cid);\n  }\n  numBytesSentTo(peerId) {\n    return this._findOrCreate(peerId).accounting.bytesSent;\n  }\n  numBytesReceivedFrom(peerId) {\n    return this._findOrCreate(peerId).accounting.bytesRecv;\n  }\n  peerDisconnected(peerId) {\n    this.ledgerMap.delete(peerId.toB58String());\n  }\n  _findOrCreate(peerId) {\n    const peerIdStr = peerId.toB58String();\n    const ledger$1 = this.ledgerMap.get(peerIdStr);\n    if (ledger$1) {\n      return ledger$1;\n    }\n    const l = new ledger.Ledger(peerId);\n    this.ledgerMap.set(peerIdStr, l);\n    if (this._stats) {\n      this._stats.push(peerIdStr, 'peerCount', 1);\n    }\n    return l;\n  }\n  start() {\n    this._running = true;\n  }\n  stop() {\n    this._running = false;\n  }\n}\n\nexports.DecisionEngine = DecisionEngine;\n"]},"metadata":{},"sourceType":"script"}