{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar debug = require('debug');\n\nvar parseDuration = require('parse-duration');\n\nvar crypto = require('libp2p-crypto');\n\nvar errCode = require('err-code');\n\nvar fromString = require('uint8arrays/from-string');\n\nvar toString = require('uint8arrays/to-string');\n\nvar utils = require('../../utils.js');\n\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\n\nvar utils$1 = require('./utils.js');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\n\nvar parseDuration__default = /*#__PURE__*/_interopDefaultLegacy(parseDuration);\n\nvar crypto__default = /*#__PURE__*/_interopDefaultLegacy(crypto);\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\n\nconst log = Object.assign(debug__default[\"default\"]('ipfs:name:publish'), {\n  error: debug__default[\"default\"]('ipfs:name:publish:error')\n});\n\nfunction createPublish(_ref) {\n  let {\n    ipns,\n    repo,\n    codecs,\n    peerId,\n    isOnline,\n    keychain\n  } = _ref;\n\n  const lookupKey = async keyName => {\n    if (keyName === 'self') {\n      return peerId.privKey;\n    }\n\n    try {\n      const pem = await keychain.exportKey(keyName, 'temp');\n      const privateKey = await crypto__default[\"default\"].keys.import(pem, 'temp');\n      return privateKey;\n    } catch (err) {\n      log.error(err);\n      throw errCode__default[\"default\"](err, 'ERR_CANNOT_GET_KEY');\n    }\n  };\n\n  async function publish(value) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const resolve = !(options.resolve === false);\n    const lifetime = options.lifetime || '24h';\n    const key = options.key || 'self';\n\n    if (!isOnline()) {\n      throw errCode__default[\"default\"](new Error(utils.OFFLINE_ERROR), 'OFFLINE_ERROR');\n    }\n\n    try {\n      value = utils.normalizePath(value);\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n\n    let pubLifetime = 0;\n\n    try {\n      pubLifetime = parseDuration__default[\"default\"](lifetime) || 0;\n      pubLifetime = parseFloat(pubLifetime.toFixed(6));\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n\n    const results = await Promise.all([lookupKey(key), resolve ? utils$1.resolvePath({\n      ipns,\n      repo,\n      codecs\n    }, value) : Promise.resolve()]);\n    const bytes = fromString.fromString(value);\n    const result = await ipns.publish(results[0], bytes, pubLifetime);\n    return {\n      name: result.name,\n      value: toString.toString(result.value)\n    };\n  }\n\n  return withTimeoutOption.withTimeoutOption(publish);\n}\n\nexports.createPublish = createPublish;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-core/cjs/src/components/name/publish.js"],"names":["Object","defineProperty","exports","value","debug","require","parseDuration","crypto","errCode","fromString","toString","utils","withTimeoutOption","utils$1","_interopDefaultLegacy","e","debug__default","parseDuration__default","crypto__default","errCode__default","log","assign","error","createPublish","ipns","repo","codecs","peerId","isOnline","keychain","lookupKey","keyName","privKey","pem","exportKey","privateKey","keys","import","err","publish","options","resolve","lifetime","key","Error","OFFLINE_ERROR","normalizePath","pubLifetime","parseFloat","toFixed","results","Promise","all","resolvePath","bytes","result","name"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar debug = require('debug');\nvar parseDuration = require('parse-duration');\nvar crypto = require('libp2p-crypto');\nvar errCode = require('err-code');\nvar fromString = require('uint8arrays/from-string');\nvar toString = require('uint8arrays/to-string');\nvar utils = require('../../utils.js');\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\nvar utils$1 = require('./utils.js');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\nvar parseDuration__default = /*#__PURE__*/_interopDefaultLegacy(parseDuration);\nvar crypto__default = /*#__PURE__*/_interopDefaultLegacy(crypto);\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\n\nconst log = Object.assign(debug__default[\"default\"]('ipfs:name:publish'), { error: debug__default[\"default\"]('ipfs:name:publish:error') });\nfunction createPublish({ipns, repo, codecs, peerId, isOnline, keychain}) {\n  const lookupKey = async keyName => {\n    if (keyName === 'self') {\n      return peerId.privKey;\n    }\n    try {\n      const pem = await keychain.exportKey(keyName, 'temp');\n      const privateKey = await crypto__default[\"default\"].keys.import(pem, 'temp');\n      return privateKey;\n    } catch (err) {\n      log.error(err);\n      throw errCode__default[\"default\"](err, 'ERR_CANNOT_GET_KEY');\n    }\n  };\n  async function publish(value, options = {}) {\n    const resolve = !(options.resolve === false);\n    const lifetime = options.lifetime || '24h';\n    const key = options.key || 'self';\n    if (!isOnline()) {\n      throw errCode__default[\"default\"](new Error(utils.OFFLINE_ERROR), 'OFFLINE_ERROR');\n    }\n    try {\n      value = utils.normalizePath(value);\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n    let pubLifetime = 0;\n    try {\n      pubLifetime = parseDuration__default[\"default\"](lifetime) || 0;\n      pubLifetime = parseFloat(pubLifetime.toFixed(6));\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n    const results = await Promise.all([\n      lookupKey(key),\n      resolve ? utils$1.resolvePath({\n        ipns,\n        repo,\n        codecs\n      }, value) : Promise.resolve()\n    ]);\n    const bytes = fromString.fromString(value);\n    const result = await ipns.publish(results[0], bytes, pubLifetime);\n    return {\n      name: result.name,\n      value: toString.toString(result.value)\n    };\n  }\n  return withTimeoutOption.withTimeoutOption(publish);\n}\n\nexports.createPublish = createPublish;\n"]},"metadata":{},"sourceType":"script"}