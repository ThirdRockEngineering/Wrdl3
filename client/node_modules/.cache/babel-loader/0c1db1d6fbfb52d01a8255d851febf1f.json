{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst errcode = require('err-code');\n\nconst {\n  codes\n} = require('../errors');\n\nconst PeerId = require('peer-id');\n\nconst {\n  equals: uint8arrayEquals\n} = require('uint8arrays/equals');\n/**\n * @typedef {import('./types').PeerStore} PeerStore\n * @typedef {import('./types').KeyBook} KeyBook\n * @typedef {import('libp2p-interfaces/src/keys/types').PublicKey} PublicKey\n */\n\n\nconst log = Object.assign(debug('libp2p:peer-store:key-book'), {\n  error: debug('libp2p:peer-store:key-book:err')\n});\nconst EVENT_NAME = 'change:pubkey';\n/**\n * @implements {KeyBook}\n */\n\nclass PeerStoreKeyBook {\n  /**\n   * The KeyBook is responsible for keeping the known public keys of a peer.\n   *\n   * @param {PeerStore[\"emit\"]} emit\n   * @param {import('./types').Store} store\n   */\n  constructor(emit, store) {\n    this._emit = emit;\n    this._store = store;\n  }\n  /**\n   * Set the Peer public key\n   *\n   * @param {PeerId} peerId\n   * @param {PublicKey} publicKey\n   */\n\n\n  async set(peerId, publicKey) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    if (!publicKey) {\n      log.error('publicKey must be an instance of PublicKey to store data');\n      throw errcode(new Error('publicKey must be an instance of PublicKey'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log('set await write lock');\n    const release = await this._store.lock.writeLock();\n    log('set got write lock');\n    let updatedKey = false;\n\n    try {\n      try {\n        const existing = await this._store.load(peerId);\n\n        if (existing.pubKey && uint8arrayEquals(existing.pubKey.bytes, publicKey.bytes)) {\n          return;\n        }\n      } catch (\n      /** @type {any} */\n      err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err;\n        }\n      }\n\n      await this._store.patchOrCreate(peerId, {\n        pubKey: publicKey\n      });\n      updatedKey = true;\n    } finally {\n      log('set release write lock');\n      release();\n    }\n\n    if (updatedKey) {\n      this._emit(EVENT_NAME, {\n        peerId,\n        pubKey: publicKey\n      });\n    }\n  }\n  /**\n   * Get Public key of the given PeerId, if stored\n   *\n   * @param {PeerId} peerId\n   */\n\n\n  async get(peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log('get await write lock');\n    const release = await this._store.lock.readLock();\n    log('get got write lock');\n\n    try {\n      const peer = await this._store.load(peerId);\n      return peer.pubKey;\n    } catch (\n    /** @type {any} */\n    err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err;\n      }\n    } finally {\n      log('get release write lock');\n      release();\n    }\n  }\n  /**\n   * @param {PeerId} peerId\n   */\n\n\n  async delete(peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log('delete await write lock');\n    const release = await this._store.lock.writeLock();\n    log('delete got write lock');\n\n    try {\n      await this._store.patchOrCreate(peerId, {\n        pubKey: undefined\n      });\n    } finally {\n      log('delete release write lock');\n      release();\n    }\n\n    this._emit(EVENT_NAME, {\n      peerId,\n      pubKey: undefined\n    });\n  }\n\n}\n\nmodule.exports = PeerStoreKeyBook;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p/src/peer-store/key-book.js"],"names":["debug","require","errcode","codes","PeerId","equals","uint8arrayEquals","log","Object","assign","error","EVENT_NAME","PeerStoreKeyBook","constructor","emit","store","_emit","_store","set","peerId","publicKey","isPeerId","Error","ERR_INVALID_PARAMETERS","release","lock","writeLock","updatedKey","existing","load","pubKey","bytes","err","code","ERR_NOT_FOUND","patchOrCreate","get","readLock","peer","delete","undefined","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst errcode = require('err-code')\nconst { codes } = require('../errors')\nconst PeerId = require('peer-id')\nconst { equals: uint8arrayEquals } = require('uint8arrays/equals')\n\n/**\n * @typedef {import('./types').PeerStore} PeerStore\n * @typedef {import('./types').KeyBook} KeyBook\n * @typedef {import('libp2p-interfaces/src/keys/types').PublicKey} PublicKey\n */\n\nconst log = Object.assign(debug('libp2p:peer-store:key-book'), {\n  error: debug('libp2p:peer-store:key-book:err')\n})\n\nconst EVENT_NAME = 'change:pubkey'\n\n/**\n * @implements {KeyBook}\n */\nclass PeerStoreKeyBook {\n  /**\n   * The KeyBook is responsible for keeping the known public keys of a peer.\n   *\n   * @param {PeerStore[\"emit\"]} emit\n   * @param {import('./types').Store} store\n   */\n  constructor (emit, store) {\n    this._emit = emit\n    this._store = store\n  }\n\n  /**\n   * Set the Peer public key\n   *\n   * @param {PeerId} peerId\n   * @param {PublicKey} publicKey\n   */\n  async set (peerId, publicKey) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    if (!publicKey) {\n      log.error('publicKey must be an instance of PublicKey to store data')\n      throw errcode(new Error('publicKey must be an instance of PublicKey'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log('set await write lock')\n    const release = await this._store.lock.writeLock()\n    log('set got write lock')\n\n    let updatedKey = false\n\n    try {\n      try {\n        const existing = await this._store.load(peerId)\n\n        if (existing.pubKey && uint8arrayEquals(existing.pubKey.bytes, publicKey.bytes)) {\n          return\n        }\n      } catch (/** @type {any} */ err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err\n        }\n      }\n\n      await this._store.patchOrCreate(peerId, {\n        pubKey: publicKey\n      })\n      updatedKey = true\n    } finally {\n      log('set release write lock')\n      release()\n    }\n\n    if (updatedKey) {\n      this._emit(EVENT_NAME, { peerId, pubKey: publicKey })\n    }\n  }\n\n  /**\n   * Get Public key of the given PeerId, if stored\n   *\n   * @param {PeerId} peerId\n   */\n  async get (peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log('get await write lock')\n    const release = await this._store.lock.readLock()\n    log('get got write lock')\n\n    try {\n      const peer = await this._store.load(peerId)\n\n      return peer.pubKey\n    } catch (/** @type {any} */ err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err\n      }\n    } finally {\n      log('get release write lock')\n      release()\n    }\n  }\n\n  /**\n   * @param {PeerId} peerId\n   */\n  async delete (peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log('delete await write lock')\n    const release = await this._store.lock.writeLock()\n    log('delete got write lock')\n\n    try {\n      await this._store.patchOrCreate(peerId, {\n        pubKey: undefined\n      })\n    } finally {\n      log('delete release write lock')\n      release()\n    }\n\n    this._emit(EVENT_NAME, { peerId, pubKey: undefined })\n  }\n}\n\nmodule.exports = PeerStoreKeyBook\n"]},"metadata":{},"sourceType":"script"}