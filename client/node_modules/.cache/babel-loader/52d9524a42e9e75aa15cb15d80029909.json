{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar cid = require('multiformats/cid');\n\nvar sha2 = require('multiformats/hashes/sha2');\n\nvar base58 = require('multiformats/bases/base58');\n\nvar varintDecoder = require('varint-decoder');\n\nvar varintEncoder = require('../utils/varint-encoder.js');\n\nvar index = require('../utils/index.js');\n\nvar message = require('./message.js');\n\nvar entry = require('./entry.js');\n\nvar errcode = require('err-code');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar varintDecoder__default = /*#__PURE__*/_interopDefaultLegacy(varintDecoder);\n\nvar errcode__default = /*#__PURE__*/_interopDefaultLegacy(errcode);\n\nclass BitswapMessage {\n  constructor(full) {\n    this.full = full;\n    this.wantlist = new Map();\n    this.blocks = new Map();\n    this.blockPresences = new Map();\n    this.pendingBytes = 0;\n  }\n\n  get empty() {\n    return this.blocks.size === 0 && this.wantlist.size === 0 && this.blockPresences.size === 0;\n  }\n\n  addEntry(cid, priority, wantType, cancel, sendDontHave) {\n    if (wantType == null) {\n      wantType = BitswapMessage.WantType.Block;\n    }\n\n    const cidStr = cid.toString(base58.base58btc);\n    const entry$1 = this.wantlist.get(cidStr);\n\n    if (entry$1) {\n      if (entry$1.wantType === wantType) {\n        entry$1.priority = priority;\n      }\n\n      if (cancel) {\n        entry$1.cancel = Boolean(cancel);\n      }\n\n      if (sendDontHave) {\n        entry$1.sendDontHave = Boolean(sendDontHave);\n      }\n\n      if (wantType === BitswapMessage.WantType.Block && entry$1.wantType === BitswapMessage.WantType.Have) {\n        entry$1.wantType = wantType;\n      }\n    } else {\n      this.wantlist.set(cidStr, new entry.BitswapMessageEntry(cid, priority, wantType, cancel, sendDontHave));\n    }\n  }\n\n  addBlock(cid, block) {\n    const cidStr = cid.toString(base58.base58btc);\n    this.blocks.set(cidStr, block);\n  }\n\n  addHave(cid) {\n    const cidStr = cid.toString(base58.base58btc);\n\n    if (!this.blockPresences.has(cidStr)) {\n      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.Have);\n    }\n  }\n\n  addDontHave(cid) {\n    const cidStr = cid.toString(base58.base58btc);\n\n    if (!this.blockPresences.has(cidStr)) {\n      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.DontHave);\n    }\n  }\n\n  cancel(cid) {\n    const cidStr = cid.toString(base58.base58btc);\n    this.wantlist.delete(cidStr);\n    this.addEntry(cid, 0, BitswapMessage.WantType.Block, true, false);\n  }\n\n  setPendingBytes(size) {\n    this.pendingBytes = size;\n  }\n\n  serializeToBitswap100() {\n    const msg = {\n      wantlist: {\n        entries: Array.from(this.wantlist.values()).map(entry => {\n          return {\n            block: entry.cid.bytes,\n            priority: Number(entry.priority),\n            cancel: Boolean(entry.cancel)\n          };\n        }),\n        full: this.full ? true : undefined\n      },\n      blocks: Array.from(this.blocks.values())\n    };\n    return message.Message.encode(msg).finish();\n  }\n\n  serializeToBitswap110() {\n    const msg = {\n      wantlist: {\n        entries: Array.from(this.wantlist.values()).map(entry => {\n          return {\n            block: entry.cid.bytes,\n            priority: Number(entry.priority),\n            wantType: entry.wantType,\n            cancel: Boolean(entry.cancel),\n            sendDontHave: Boolean(entry.sendDontHave)\n          };\n        }),\n        full: this.full ? true : undefined\n      },\n      blockPresences: [],\n      payload: [],\n      pendingBytes: this.pendingBytes\n    };\n\n    for (const [cidStr, data] of this.blocks.entries()) {\n      const cid$1 = cid.CID.parse(cidStr);\n      const version = cid$1.version;\n      const codec = cid$1.code;\n      const multihash = cid$1.multihash.code;\n      const digestLength = cid$1.multihash.digest.length;\n      const prefix = varintEncoder([version, codec, multihash, digestLength]);\n      msg.payload.push(new message.Message.Block({\n        prefix,\n        data\n      }));\n    }\n\n    for (const [cidStr, bpType] of this.blockPresences) {\n      msg.blockPresences.push(new message.Message.BlockPresence({\n        cid: cid.CID.parse(cidStr).bytes,\n        type: bpType\n      }));\n    }\n\n    if (this.pendingBytes > 0) {\n      msg.pendingBytes = this.pendingBytes;\n    }\n\n    return message.Message.encode(msg).finish();\n  }\n\n  equals(other) {\n    if (this.full !== other.full || this.pendingBytes !== other.pendingBytes || !index.isMapEqual(this.wantlist, other.wantlist) || !index.isMapEqual(this.blocks, other.blocks) || !index.isMapEqual(this.blockPresences, other.blockPresences)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  get [Symbol.toStringTag]() {\n    const list = Array.from(this.wantlist.keys());\n    const blocks = Array.from(this.blocks.keys());\n    return `BitswapMessage <full: ${this.full}, list: ${list}, blocks: ${blocks}>`;\n  }\n\n}\n\nBitswapMessage.deserialize = async (raw, hashLoader) => {\n  const decoded = message.Message.decode(raw);\n  const isFull = decoded.wantlist && decoded.wantlist.full || false;\n  const msg = new BitswapMessage(isFull);\n\n  if (decoded.wantlist && decoded.wantlist.entries) {\n    decoded.wantlist.entries.forEach(entry => {\n      if (!entry.block) {\n        return;\n      }\n\n      const cid$1 = cid.CID.decode(entry.block);\n      msg.addEntry(cid$1, entry.priority || 0, entry.wantType, Boolean(entry.cancel), Boolean(entry.sendDontHave));\n    });\n  }\n\n  if (decoded.blockPresences) {\n    decoded.blockPresences.forEach(blockPresence => {\n      if (!blockPresence.cid) {\n        return;\n      }\n\n      const cid$1 = cid.CID.decode(blockPresence.cid);\n\n      if (blockPresence.type === BitswapMessage.BlockPresenceType.Have) {\n        msg.addHave(cid$1);\n      } else {\n        msg.addDontHave(cid$1);\n      }\n    });\n  }\n\n  if (decoded.blocks.length > 0) {\n    await Promise.all(decoded.blocks.map(async b => {\n      const hash = await sha2.sha256.digest(b);\n      const cid$1 = cid.CID.createV0(hash);\n      msg.addBlock(cid$1, b);\n    }));\n    return msg;\n  }\n\n  if (decoded.payload.length > 0) {\n    await Promise.all(decoded.payload.map(async p => {\n      if (!p.prefix || !p.data) {\n        return;\n      }\n\n      const values = varintDecoder__default[\"default\"](p.prefix);\n      const cidVersion = values[0];\n      const multicodec = values[1];\n      const hashAlg = values[2];\n      const hasher = hashAlg === sha2.sha256.code ? sha2.sha256 : hashLoader && (await hashLoader.getHasher(hashAlg));\n\n      if (!hasher) {\n        throw errcode__default[\"default\"](new Error('Unknown hash algorithm'), 'ERR_UNKNOWN_HASH_ALG');\n      }\n\n      const hash = await hasher.digest(p.data);\n      const cid$1 = cid.CID.create(cidVersion, multicodec, hash);\n      msg.addBlock(cid$1, p.data);\n    }));\n    msg.setPendingBytes(decoded.pendingBytes);\n    return msg;\n  }\n\n  return msg;\n};\n\nBitswapMessage.blockPresenceSize = cid => {\n  return cid.bytes.length + 1;\n};\n\nBitswapMessage.Entry = entry.BitswapMessageEntry;\nBitswapMessage.WantType = {\n  Block: message.Message.Wantlist.WantType.Block,\n  Have: message.Message.Wantlist.WantType.Have\n};\nBitswapMessage.BlockPresenceType = {\n  Have: message.Message.BlockPresenceType.Have,\n  DontHave: message.Message.BlockPresenceType.DontHave\n};\nexports.BitswapMessage = BitswapMessage;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-bitswap/cjs/src/message/index.js"],"names":["Object","defineProperty","exports","value","cid","require","sha2","base58","varintDecoder","varintEncoder","index","message","entry","errcode","_interopDefaultLegacy","e","varintDecoder__default","errcode__default","BitswapMessage","constructor","full","wantlist","Map","blocks","blockPresences","pendingBytes","empty","size","addEntry","priority","wantType","cancel","sendDontHave","WantType","Block","cidStr","toString","base58btc","entry$1","get","Boolean","Have","set","BitswapMessageEntry","addBlock","block","addHave","has","BlockPresenceType","addDontHave","DontHave","delete","setPendingBytes","serializeToBitswap100","msg","entries","Array","from","values","map","bytes","Number","undefined","Message","encode","finish","serializeToBitswap110","payload","data","cid$1","CID","parse","version","codec","code","multihash","digestLength","digest","length","prefix","push","bpType","BlockPresence","type","equals","other","isMapEqual","Symbol","toStringTag","list","keys","deserialize","raw","hashLoader","decoded","decode","isFull","forEach","blockPresence","Promise","all","b","hash","sha256","createV0","p","cidVersion","multicodec","hashAlg","hasher","getHasher","Error","create","blockPresenceSize","Entry","Wantlist"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar cid = require('multiformats/cid');\nvar sha2 = require('multiformats/hashes/sha2');\nvar base58 = require('multiformats/bases/base58');\nvar varintDecoder = require('varint-decoder');\nvar varintEncoder = require('../utils/varint-encoder.js');\nvar index = require('../utils/index.js');\nvar message = require('./message.js');\nvar entry = require('./entry.js');\nvar errcode = require('err-code');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar varintDecoder__default = /*#__PURE__*/_interopDefaultLegacy(varintDecoder);\nvar errcode__default = /*#__PURE__*/_interopDefaultLegacy(errcode);\n\nclass BitswapMessage {\n  constructor(full) {\n    this.full = full;\n    this.wantlist = new Map();\n    this.blocks = new Map();\n    this.blockPresences = new Map();\n    this.pendingBytes = 0;\n  }\n  get empty() {\n    return this.blocks.size === 0 && this.wantlist.size === 0 && this.blockPresences.size === 0;\n  }\n  addEntry(cid, priority, wantType, cancel, sendDontHave) {\n    if (wantType == null) {\n      wantType = BitswapMessage.WantType.Block;\n    }\n    const cidStr = cid.toString(base58.base58btc);\n    const entry$1 = this.wantlist.get(cidStr);\n    if (entry$1) {\n      if (entry$1.wantType === wantType) {\n        entry$1.priority = priority;\n      }\n      if (cancel) {\n        entry$1.cancel = Boolean(cancel);\n      }\n      if (sendDontHave) {\n        entry$1.sendDontHave = Boolean(sendDontHave);\n      }\n      if (wantType === BitswapMessage.WantType.Block && entry$1.wantType === BitswapMessage.WantType.Have) {\n        entry$1.wantType = wantType;\n      }\n    } else {\n      this.wantlist.set(cidStr, new entry.BitswapMessageEntry(cid, priority, wantType, cancel, sendDontHave));\n    }\n  }\n  addBlock(cid, block) {\n    const cidStr = cid.toString(base58.base58btc);\n    this.blocks.set(cidStr, block);\n  }\n  addHave(cid) {\n    const cidStr = cid.toString(base58.base58btc);\n    if (!this.blockPresences.has(cidStr)) {\n      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.Have);\n    }\n  }\n  addDontHave(cid) {\n    const cidStr = cid.toString(base58.base58btc);\n    if (!this.blockPresences.has(cidStr)) {\n      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.DontHave);\n    }\n  }\n  cancel(cid) {\n    const cidStr = cid.toString(base58.base58btc);\n    this.wantlist.delete(cidStr);\n    this.addEntry(cid, 0, BitswapMessage.WantType.Block, true, false);\n  }\n  setPendingBytes(size) {\n    this.pendingBytes = size;\n  }\n  serializeToBitswap100() {\n    const msg = {\n      wantlist: {\n        entries: Array.from(this.wantlist.values()).map(entry => {\n          return {\n            block: entry.cid.bytes,\n            priority: Number(entry.priority),\n            cancel: Boolean(entry.cancel)\n          };\n        }),\n        full: this.full ? true : undefined\n      },\n      blocks: Array.from(this.blocks.values())\n    };\n    return message.Message.encode(msg).finish();\n  }\n  serializeToBitswap110() {\n    const msg = {\n      wantlist: {\n        entries: Array.from(this.wantlist.values()).map(entry => {\n          return {\n            block: entry.cid.bytes,\n            priority: Number(entry.priority),\n            wantType: entry.wantType,\n            cancel: Boolean(entry.cancel),\n            sendDontHave: Boolean(entry.sendDontHave)\n          };\n        }),\n        full: this.full ? true : undefined\n      },\n      blockPresences: [],\n      payload: [],\n      pendingBytes: this.pendingBytes\n    };\n    for (const [cidStr, data] of this.blocks.entries()) {\n      const cid$1 = cid.CID.parse(cidStr);\n      const version = cid$1.version;\n      const codec = cid$1.code;\n      const multihash = cid$1.multihash.code;\n      const digestLength = cid$1.multihash.digest.length;\n      const prefix = varintEncoder([\n        version,\n        codec,\n        multihash,\n        digestLength\n      ]);\n      msg.payload.push(new message.Message.Block({\n        prefix,\n        data\n      }));\n    }\n    for (const [cidStr, bpType] of this.blockPresences) {\n      msg.blockPresences.push(new message.Message.BlockPresence({\n        cid: cid.CID.parse(cidStr).bytes,\n        type: bpType\n      }));\n    }\n    if (this.pendingBytes > 0) {\n      msg.pendingBytes = this.pendingBytes;\n    }\n    return message.Message.encode(msg).finish();\n  }\n  equals(other) {\n    if (this.full !== other.full || this.pendingBytes !== other.pendingBytes || !index.isMapEqual(this.wantlist, other.wantlist) || !index.isMapEqual(this.blocks, other.blocks) || !index.isMapEqual(this.blockPresences, other.blockPresences)) {\n      return false;\n    }\n    return true;\n  }\n  get [Symbol.toStringTag]() {\n    const list = Array.from(this.wantlist.keys());\n    const blocks = Array.from(this.blocks.keys());\n    return `BitswapMessage <full: ${ this.full }, list: ${ list }, blocks: ${ blocks }>`;\n  }\n}\nBitswapMessage.deserialize = async (raw, hashLoader) => {\n  const decoded = message.Message.decode(raw);\n  const isFull = decoded.wantlist && decoded.wantlist.full || false;\n  const msg = new BitswapMessage(isFull);\n  if (decoded.wantlist && decoded.wantlist.entries) {\n    decoded.wantlist.entries.forEach(entry => {\n      if (!entry.block) {\n        return;\n      }\n      const cid$1 = cid.CID.decode(entry.block);\n      msg.addEntry(cid$1, entry.priority || 0, entry.wantType, Boolean(entry.cancel), Boolean(entry.sendDontHave));\n    });\n  }\n  if (decoded.blockPresences) {\n    decoded.blockPresences.forEach(blockPresence => {\n      if (!blockPresence.cid) {\n        return;\n      }\n      const cid$1 = cid.CID.decode(blockPresence.cid);\n      if (blockPresence.type === BitswapMessage.BlockPresenceType.Have) {\n        msg.addHave(cid$1);\n      } else {\n        msg.addDontHave(cid$1);\n      }\n    });\n  }\n  if (decoded.blocks.length > 0) {\n    await Promise.all(decoded.blocks.map(async b => {\n      const hash = await sha2.sha256.digest(b);\n      const cid$1 = cid.CID.createV0(hash);\n      msg.addBlock(cid$1, b);\n    }));\n    return msg;\n  }\n  if (decoded.payload.length > 0) {\n    await Promise.all(decoded.payload.map(async p => {\n      if (!p.prefix || !p.data) {\n        return;\n      }\n      const values = varintDecoder__default[\"default\"](p.prefix);\n      const cidVersion = values[0];\n      const multicodec = values[1];\n      const hashAlg = values[2];\n      const hasher = hashAlg === sha2.sha256.code ? sha2.sha256 : hashLoader && await hashLoader.getHasher(hashAlg);\n      if (!hasher) {\n        throw errcode__default[\"default\"](new Error('Unknown hash algorithm'), 'ERR_UNKNOWN_HASH_ALG');\n      }\n      const hash = await hasher.digest(p.data);\n      const cid$1 = cid.CID.create(cidVersion, multicodec, hash);\n      msg.addBlock(cid$1, p.data);\n    }));\n    msg.setPendingBytes(decoded.pendingBytes);\n    return msg;\n  }\n  return msg;\n};\nBitswapMessage.blockPresenceSize = cid => {\n  return cid.bytes.length + 1;\n};\nBitswapMessage.Entry = entry.BitswapMessageEntry;\nBitswapMessage.WantType = {\n  Block: message.Message.Wantlist.WantType.Block,\n  Have: message.Message.Wantlist.WantType.Have\n};\nBitswapMessage.BlockPresenceType = {\n  Have: message.Message.BlockPresenceType.Have,\n  DontHave: message.Message.BlockPresenceType.DontHave\n};\n\nexports.BitswapMessage = BitswapMessage;\n"]},"metadata":{},"sourceType":"script"}