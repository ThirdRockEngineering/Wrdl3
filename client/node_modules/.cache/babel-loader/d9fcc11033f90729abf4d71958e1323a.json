{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar debug = require('debug');\n\nvar repo = require('ipfs-core-config/repo');\n\nvar getDefaultConfig = require('ipfs-core-config/config');\n\nvar fromString = require('uint8arrays/from-string');\n\nvar toString = require('uint8arrays/to-string');\n\nvar PeerId = require('peer-id');\n\nvar mergeOpts = require('merge-options');\n\nvar profiles = require('./config/profiles.js');\n\nvar errors$1 = require('../errors.js');\n\nvar libp2p = require('./libp2p.js');\n\nvar errors = require('ipfs-repo/errors');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\n\nvar getDefaultConfig__default = /*#__PURE__*/_interopDefaultLegacy(getDefaultConfig);\n\nvar PeerId__default = /*#__PURE__*/_interopDefaultLegacy(PeerId);\n\nvar mergeOpts__default = /*#__PURE__*/_interopDefaultLegacy(mergeOpts);\n\nconst mergeOptions = mergeOpts__default[\"default\"].bind({\n  ignoreUndefined: true\n});\nconst log = debug__default[\"default\"]('ipfs:components:peer:storage');\n\nclass Storage {\n  constructor(peerId, keychain, repo, print, isNew) {\n    this.print = print;\n    this.peerId = peerId;\n    this.keychain = keychain;\n    this.repo = repo;\n    this.print = print;\n    this.isNew = isNew;\n  }\n\n  static async start(print, codecs, options) {\n    const {\n      repoAutoMigrate,\n      repo: inputRepo,\n      onMigrationProgress\n    } = options;\n    const repo$1 = typeof inputRepo === 'string' || inputRepo == null ? repo.createRepo(print, codecs, {\n      path: inputRepo,\n      autoMigrate: repoAutoMigrate,\n      onMigrationProgress: onMigrationProgress\n    }) : inputRepo;\n    const {\n      peerId,\n      keychain,\n      isNew\n    } = await loadRepo(print, repo$1, options);\n    return new Storage(peerId, keychain, repo$1, print, isNew);\n  }\n\n}\n\nconst loadRepo = async (print, repo, options) => {\n  if (!repo.closed) {\n    return { ...(await configureRepo(repo, options)),\n      isNew: false\n    };\n  }\n\n  try {\n    await repo.open();\n    return { ...(await configureRepo(repo, options)),\n      isNew: false\n    };\n  } catch (err) {\n    if (err.code !== errors.ERR_REPO_NOT_INITIALIZED) {\n      throw err;\n    }\n\n    if (options.init && options.init.allowNew === false) {\n      throw new errors$1.NotEnabledError('Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it');\n    }\n\n    return { ...(await initRepo(print, repo, options)),\n      isNew: true\n    };\n  }\n};\n\nconst initRepo = async (print, repo, options) => {\n  const initOptions = options.init || {};\n  const exists = await repo.exists();\n  log('repo exists?', exists);\n\n  if (exists === true) {\n    throw new Error('repo already exists');\n  }\n\n  const peerId = initOptions.privateKey ? await decodePeerId(initOptions.privateKey) : await initPeerId(print, initOptions);\n  const identity = peerIdToIdentity(peerId);\n  log('peer identity: %s', identity.PeerID);\n  const config = { ...mergeOptions(applyProfiles(getDefaultConfig__default[\"default\"](), initOptions.profiles), options.config),\n    Identity: identity\n  };\n  await repo.init(config);\n  await repo.open();\n  log('repo opened');\n  const keychainConfig = {\n    pass: options.pass\n  };\n\n  try {\n    keychainConfig.dek = await repo.config.get('Keychain.DEK');\n  } catch (err) {\n    if (err.code !== 'ERR_NOT_FOUND') {\n      throw err;\n    }\n  }\n\n  const libp2p$1 = await libp2p.createLibp2p({\n    options: undefined,\n    multiaddrs: undefined,\n    peerId,\n    repo,\n    config,\n    keychainConfig\n  });\n\n  if (libp2p$1.keychain && libp2p$1.keychain.opts) {\n    await libp2p$1.loadKeychain();\n    await repo.config.set('Keychain', {\n      DEK: libp2p$1.keychain.opts.dek\n    });\n  }\n\n  return {\n    peerId,\n    keychain: libp2p$1.keychain\n  };\n};\n\nconst decodePeerId = peerId => {\n  log('using user-supplied private-key');\n  return typeof peerId === 'object' ? peerId : PeerId__default[\"default\"].createFromPrivKey(fromString.fromString(peerId, 'base64pad'));\n};\n\nconst initPeerId = (print, _ref) => {\n  let {\n    algorithm = 'Ed25519',\n    bits = 2048\n  } = _ref;\n  print('generating %s keypair...', algorithm);\n  return PeerId__default[\"default\"].create({\n    keyType: algorithm,\n    bits\n  });\n};\n\nconst peerIdToIdentity = peerId => ({\n  PeerID: peerId.toB58String(),\n  PrivKey: toString.toString(peerId.privKey.bytes, 'base64pad')\n});\n\nconst configureRepo = async (repo, options) => {\n  const config = options.config;\n  const profiles = options.init && options.init.profiles || [];\n  const pass = options.pass;\n  const original = await repo.config.getAll();\n  const changed = mergeConfigs(applyProfiles(original, profiles), config);\n\n  if (original !== changed) {\n    await repo.config.replace(changed);\n  }\n\n  if (!changed.Identity || !changed.Identity.PrivKey) {\n    throw new errors$1.NotInitializedError('No private key was found in the config, please intialize the repo');\n  }\n\n  const peerId = await PeerId__default[\"default\"].createFromPrivKey(changed.Identity.PrivKey);\n  const libp2p$1 = await libp2p.createLibp2p({\n    options: undefined,\n    multiaddrs: undefined,\n    peerId,\n    repo,\n    config: changed,\n    keychainConfig: {\n      pass,\n      ...changed.Keychain\n    }\n  });\n\n  if (libp2p$1.keychain) {\n    await libp2p$1.loadKeychain();\n  }\n\n  return {\n    peerId,\n    keychain: libp2p$1.keychain\n  };\n};\n\nconst mergeConfigs = (config, changes) => changes ? mergeOptions(config, changes) : config;\n\nconst applyProfiles = (config, profiles$1) => {\n  return (profiles$1 || []).reduce((config, name) => {\n    const profile = profiles.profiles[name];\n\n    if (!profile) {\n      throw new Error(`Could not find profile with name '${name}'`);\n    }\n\n    log('applying profile %s', name);\n    return profile.transform(config);\n  }, config);\n};\n\nexports.Storage = Storage;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-core/cjs/src/components/storage.js"],"names":["Object","defineProperty","exports","value","debug","require","repo","getDefaultConfig","fromString","toString","PeerId","mergeOpts","profiles","errors$1","libp2p","errors","_interopDefaultLegacy","e","debug__default","getDefaultConfig__default","PeerId__default","mergeOpts__default","mergeOptions","bind","ignoreUndefined","log","Storage","constructor","peerId","keychain","print","isNew","start","codecs","options","repoAutoMigrate","inputRepo","onMigrationProgress","repo$1","createRepo","path","autoMigrate","loadRepo","closed","configureRepo","open","err","code","ERR_REPO_NOT_INITIALIZED","init","allowNew","NotEnabledError","initRepo","initOptions","exists","Error","privateKey","decodePeerId","initPeerId","identity","peerIdToIdentity","PeerID","config","applyProfiles","Identity","keychainConfig","pass","dek","get","libp2p$1","createLibp2p","undefined","multiaddrs","opts","loadKeychain","set","DEK","createFromPrivKey","algorithm","bits","create","keyType","toB58String","PrivKey","privKey","bytes","original","getAll","changed","mergeConfigs","replace","NotInitializedError","Keychain","changes","profiles$1","reduce","name","profile","transform"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AAEA,IAAIC,KAAK,GAAGC,OAAO,CAAC,OAAD,CAAnB;;AACA,IAAIC,IAAI,GAAGD,OAAO,CAAC,uBAAD,CAAlB;;AACA,IAAIE,gBAAgB,GAAGF,OAAO,CAAC,yBAAD,CAA9B;;AACA,IAAIG,UAAU,GAAGH,OAAO,CAAC,yBAAD,CAAxB;;AACA,IAAII,QAAQ,GAAGJ,OAAO,CAAC,uBAAD,CAAtB;;AACA,IAAIK,MAAM,GAAGL,OAAO,CAAC,SAAD,CAApB;;AACA,IAAIM,SAAS,GAAGN,OAAO,CAAC,eAAD,CAAvB;;AACA,IAAIO,QAAQ,GAAGP,OAAO,CAAC,sBAAD,CAAtB;;AACA,IAAIQ,QAAQ,GAAGR,OAAO,CAAC,cAAD,CAAtB;;AACA,IAAIS,MAAM,GAAGT,OAAO,CAAC,aAAD,CAApB;;AACA,IAAIU,MAAM,GAAGV,OAAO,CAAC,kBAAD,CAApB;;AAEA,SAASW,qBAAT,CAAgCC,CAAhC,EAAmC;AAAE,SAAOA,CAAC,IAAI,OAAOA,CAAP,KAAa,QAAlB,IAA8B,aAAaA,CAA3C,GAA+CA,CAA/C,GAAmD;AAAE,eAAWA;AAAb,GAA1D;AAA6E;;AAElH,IAAIC,cAAc,GAAG,aAAaF,qBAAqB,CAACZ,KAAD,CAAvD;;AACA,IAAIe,yBAAyB,GAAG,aAAaH,qBAAqB,CAACT,gBAAD,CAAlE;;AACA,IAAIa,eAAe,GAAG,aAAaJ,qBAAqB,CAACN,MAAD,CAAxD;;AACA,IAAIW,kBAAkB,GAAG,aAAaL,qBAAqB,CAACL,SAAD,CAA3D;;AAEA,MAAMW,YAAY,GAAGD,kBAAkB,CAAC,SAAD,CAAlB,CAA8BE,IAA9B,CAAmC;AAAEC,EAAAA,eAAe,EAAE;AAAnB,CAAnC,CAArB;AACA,MAAMC,GAAG,GAAGP,cAAc,CAAC,SAAD,CAAd,CAA0B,8BAA1B,CAAZ;;AACA,MAAMQ,OAAN,CAAc;AACZC,EAAAA,WAAW,CAACC,MAAD,EAASC,QAAT,EAAmBvB,IAAnB,EAAyBwB,KAAzB,EAAgCC,KAAhC,EAAuC;AAChD,SAAKD,KAAL,GAAaA,KAAb;AACA,SAAKF,MAAL,GAAcA,MAAd;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKvB,IAAL,GAAYA,IAAZ;AACA,SAAKwB,KAAL,GAAaA,KAAb;AACA,SAAKC,KAAL,GAAaA,KAAb;AACD;;AACiB,eAALC,KAAK,CAACF,KAAD,EAAQG,MAAR,EAAgBC,OAAhB,EAAyB;AACzC,UAAM;AACJC,MAAAA,eADI;AAEJ7B,MAAAA,IAAI,EAAE8B,SAFF;AAGJC,MAAAA;AAHI,QAIFH,OAJJ;AAKA,UAAMI,MAAM,GAAG,OAAOF,SAAP,KAAqB,QAArB,IAAiCA,SAAS,IAAI,IAA9C,GAAqD9B,IAAI,CAACiC,UAAL,CAAgBT,KAAhB,EAAuBG,MAAvB,EAA+B;AACjGO,MAAAA,IAAI,EAAEJ,SAD2F;AAEjGK,MAAAA,WAAW,EAAEN,eAFoF;AAGjGE,MAAAA,mBAAmB,EAAEA;AAH4E,KAA/B,CAArD,GAIVD,SAJL;AAKA,UAAM;AAACR,MAAAA,MAAD;AAASC,MAAAA,QAAT;AAAmBE,MAAAA;AAAnB,QAA4B,MAAMW,QAAQ,CAACZ,KAAD,EAAQQ,MAAR,EAAgBJ,OAAhB,CAAhD;AACA,WAAO,IAAIR,OAAJ,CAAYE,MAAZ,EAAoBC,QAApB,EAA8BS,MAA9B,EAAsCR,KAAtC,EAA6CC,KAA7C,CAAP;AACD;;AAtBW;;AAwBd,MAAMW,QAAQ,GAAG,OAAOZ,KAAP,EAAcxB,IAAd,EAAoB4B,OAApB,KAAgC;AAC/C,MAAI,CAAC5B,IAAI,CAACqC,MAAV,EAAkB;AAChB,WAAO,EACL,IAAG,MAAMC,aAAa,CAACtC,IAAD,EAAO4B,OAAP,CAAtB,CADK;AAELH,MAAAA,KAAK,EAAE;AAFF,KAAP;AAID;;AACD,MAAI;AACF,UAAMzB,IAAI,CAACuC,IAAL,EAAN;AACA,WAAO,EACL,IAAG,MAAMD,aAAa,CAACtC,IAAD,EAAO4B,OAAP,CAAtB,CADK;AAELH,MAAAA,KAAK,EAAE;AAFF,KAAP;AAID,GAND,CAME,OAAOe,GAAP,EAAY;AACZ,QAAIA,GAAG,CAACC,IAAJ,KAAahC,MAAM,CAACiC,wBAAxB,EAAkD;AAChD,YAAMF,GAAN;AACD;;AACD,QAAIZ,OAAO,CAACe,IAAR,IAAgBf,OAAO,CAACe,IAAR,CAAaC,QAAb,KAA0B,KAA9C,EAAqD;AACnD,YAAM,IAAIrC,QAAQ,CAACsC,eAAb,CAA6B,6FAA7B,CAAN;AACD;;AACD,WAAO,EACL,IAAG,MAAMC,QAAQ,CAACtB,KAAD,EAAQxB,IAAR,EAAc4B,OAAd,CAAjB,CADK;AAELH,MAAAA,KAAK,EAAE;AAFF,KAAP;AAID;AACF,CAzBD;;AA0BA,MAAMqB,QAAQ,GAAG,OAAOtB,KAAP,EAAcxB,IAAd,EAAoB4B,OAApB,KAAgC;AAC/C,QAAMmB,WAAW,GAAGnB,OAAO,CAACe,IAAR,IAAgB,EAApC;AACA,QAAMK,MAAM,GAAG,MAAMhD,IAAI,CAACgD,MAAL,EAArB;AACA7B,EAAAA,GAAG,CAAC,cAAD,EAAiB6B,MAAjB,CAAH;;AACA,MAAIA,MAAM,KAAK,IAAf,EAAqB;AACnB,UAAM,IAAIC,KAAJ,CAAU,qBAAV,CAAN;AACD;;AACD,QAAM3B,MAAM,GAAGyB,WAAW,CAACG,UAAZ,GAAyB,MAAMC,YAAY,CAACJ,WAAW,CAACG,UAAb,CAA3C,GAAsE,MAAME,UAAU,CAAC5B,KAAD,EAAQuB,WAAR,CAArG;AACA,QAAMM,QAAQ,GAAGC,gBAAgB,CAAChC,MAAD,CAAjC;AACAH,EAAAA,GAAG,CAAC,mBAAD,EAAsBkC,QAAQ,CAACE,MAA/B,CAAH;AACA,QAAMC,MAAM,GAAG,EACb,GAAGxC,YAAY,CAACyC,aAAa,CAAC5C,yBAAyB,CAAC,SAAD,CAAzB,EAAD,EAAyCkC,WAAW,CAACzC,QAArD,CAAd,EAA8EsB,OAAO,CAAC4B,MAAtF,CADF;AAEbE,IAAAA,QAAQ,EAAEL;AAFG,GAAf;AAIA,QAAMrD,IAAI,CAAC2C,IAAL,CAAUa,MAAV,CAAN;AACA,QAAMxD,IAAI,CAACuC,IAAL,EAAN;AACApB,EAAAA,GAAG,CAAC,aAAD,CAAH;AACA,QAAMwC,cAAc,GAAG;AAAEC,IAAAA,IAAI,EAAEhC,OAAO,CAACgC;AAAhB,GAAvB;;AACA,MAAI;AACFD,IAAAA,cAAc,CAACE,GAAf,GAAqB,MAAM7D,IAAI,CAACwD,MAAL,CAAYM,GAAZ,CAAgB,cAAhB,CAA3B;AACD,GAFD,CAEE,OAAOtB,GAAP,EAAY;AACZ,QAAIA,GAAG,CAACC,IAAJ,KAAa,eAAjB,EAAkC;AAChC,YAAMD,GAAN;AACD;AACF;;AACD,QAAMuB,QAAQ,GAAG,MAAMvD,MAAM,CAACwD,YAAP,CAAoB;AACzCpC,IAAAA,OAAO,EAAEqC,SADgC;AAEzCC,IAAAA,UAAU,EAAED,SAF6B;AAGzC3C,IAAAA,MAHyC;AAIzCtB,IAAAA,IAJyC;AAKzCwD,IAAAA,MALyC;AAMzCG,IAAAA;AANyC,GAApB,CAAvB;;AAQA,MAAII,QAAQ,CAACxC,QAAT,IAAqBwC,QAAQ,CAACxC,QAAT,CAAkB4C,IAA3C,EAAiD;AAC/C,UAAMJ,QAAQ,CAACK,YAAT,EAAN;AACA,UAAMpE,IAAI,CAACwD,MAAL,CAAYa,GAAZ,CAAgB,UAAhB,EAA4B;AAAEC,MAAAA,GAAG,EAAEP,QAAQ,CAACxC,QAAT,CAAkB4C,IAAlB,CAAuBN;AAA9B,KAA5B,CAAN;AACD;;AACD,SAAO;AACLvC,IAAAA,MADK;AAELC,IAAAA,QAAQ,EAAEwC,QAAQ,CAACxC;AAFd,GAAP;AAID,CAzCD;;AA0CA,MAAM4B,YAAY,GAAG7B,MAAM,IAAI;AAC7BH,EAAAA,GAAG,CAAC,iCAAD,CAAH;AACA,SAAO,OAAOG,MAAP,KAAkB,QAAlB,GAA6BA,MAA7B,GAAsCR,eAAe,CAAC,SAAD,CAAf,CAA2ByD,iBAA3B,CAA6CrE,UAAU,CAACA,UAAX,CAAsBoB,MAAtB,EAA8B,WAA9B,CAA7C,CAA7C;AACD,CAHD;;AAIA,MAAM8B,UAAU,GAAG,CAAC5B,KAAD,WAAiD;AAAA,MAAzC;AAACgD,IAAAA,SAAS,GAAG,SAAb;AAAwBC,IAAAA,IAAI,GAAG;AAA/B,GAAyC;AAClEjD,EAAAA,KAAK,CAAC,0BAAD,EAA6BgD,SAA7B,CAAL;AACA,SAAO1D,eAAe,CAAC,SAAD,CAAf,CAA2B4D,MAA3B,CAAkC;AACvCC,IAAAA,OAAO,EAAEH,SAD8B;AAEvCC,IAAAA;AAFuC,GAAlC,CAAP;AAID,CAND;;AAOA,MAAMnB,gBAAgB,GAAGhC,MAAM,KAAK;AAClCiC,EAAAA,MAAM,EAAEjC,MAAM,CAACsD,WAAP,EAD0B;AAElCC,EAAAA,OAAO,EAAE1E,QAAQ,CAACA,QAAT,CAAkBmB,MAAM,CAACwD,OAAP,CAAeC,KAAjC,EAAwC,WAAxC;AAFyB,CAAL,CAA/B;;AAIA,MAAMzC,aAAa,GAAG,OAAOtC,IAAP,EAAa4B,OAAb,KAAyB;AAC7C,QAAM4B,MAAM,GAAG5B,OAAO,CAAC4B,MAAvB;AACA,QAAMlD,QAAQ,GAAGsB,OAAO,CAACe,IAAR,IAAgBf,OAAO,CAACe,IAAR,CAAarC,QAA7B,IAAyC,EAA1D;AACA,QAAMsD,IAAI,GAAGhC,OAAO,CAACgC,IAArB;AACA,QAAMoB,QAAQ,GAAG,MAAMhF,IAAI,CAACwD,MAAL,CAAYyB,MAAZ,EAAvB;AACA,QAAMC,OAAO,GAAGC,YAAY,CAAC1B,aAAa,CAACuB,QAAD,EAAW1E,QAAX,CAAd,EAAoCkD,MAApC,CAA5B;;AACA,MAAIwB,QAAQ,KAAKE,OAAjB,EAA0B;AACxB,UAAMlF,IAAI,CAACwD,MAAL,CAAY4B,OAAZ,CAAoBF,OAApB,CAAN;AACD;;AACD,MAAI,CAACA,OAAO,CAACxB,QAAT,IAAqB,CAACwB,OAAO,CAACxB,QAAR,CAAiBmB,OAA3C,EAAoD;AAClD,UAAM,IAAItE,QAAQ,CAAC8E,mBAAb,CAAiC,mEAAjC,CAAN;AACD;;AACD,QAAM/D,MAAM,GAAG,MAAMR,eAAe,CAAC,SAAD,CAAf,CAA2ByD,iBAA3B,CAA6CW,OAAO,CAACxB,QAAR,CAAiBmB,OAA9D,CAArB;AACA,QAAMd,QAAQ,GAAG,MAAMvD,MAAM,CAACwD,YAAP,CAAoB;AACzCpC,IAAAA,OAAO,EAAEqC,SADgC;AAEzCC,IAAAA,UAAU,EAAED,SAF6B;AAGzC3C,IAAAA,MAHyC;AAIzCtB,IAAAA,IAJyC;AAKzCwD,IAAAA,MAAM,EAAE0B,OALiC;AAMzCvB,IAAAA,cAAc,EAAE;AACdC,MAAAA,IADc;AAEd,SAAGsB,OAAO,CAACI;AAFG;AANyB,GAApB,CAAvB;;AAWA,MAAIvB,QAAQ,CAACxC,QAAb,EAAuB;AACrB,UAAMwC,QAAQ,CAACK,YAAT,EAAN;AACD;;AACD,SAAO;AACL9C,IAAAA,MADK;AAELC,IAAAA,QAAQ,EAAEwC,QAAQ,CAACxC;AAFd,GAAP;AAID,CA/BD;;AAgCA,MAAM4D,YAAY,GAAG,CAAC3B,MAAD,EAAS+B,OAAT,KAAqBA,OAAO,GAAGvE,YAAY,CAACwC,MAAD,EAAS+B,OAAT,CAAf,GAAmC/B,MAApF;;AACA,MAAMC,aAAa,GAAG,CAACD,MAAD,EAASgC,UAAT,KAAwB;AAC5C,SAAO,CAACA,UAAU,IAAI,EAAf,EAAmBC,MAAnB,CAA0B,CAACjC,MAAD,EAASkC,IAAT,KAAkB;AACjD,UAAMC,OAAO,GAAGrF,QAAQ,CAACA,QAAT,CAAkBoF,IAAlB,CAAhB;;AACA,QAAI,CAACC,OAAL,EAAc;AACZ,YAAM,IAAI1C,KAAJ,CAAW,qCAAqCyC,IAAM,GAAtD,CAAN;AACD;;AACDvE,IAAAA,GAAG,CAAC,qBAAD,EAAwBuE,IAAxB,CAAH;AACA,WAAOC,OAAO,CAACC,SAAR,CAAkBpC,MAAlB,CAAP;AACD,GAPM,EAOJA,MAPI,CAAP;AAQD,CATD;;AAWA5D,OAAO,CAACwB,OAAR,GAAkBA,OAAlB","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar debug = require('debug');\nvar repo = require('ipfs-core-config/repo');\nvar getDefaultConfig = require('ipfs-core-config/config');\nvar fromString = require('uint8arrays/from-string');\nvar toString = require('uint8arrays/to-string');\nvar PeerId = require('peer-id');\nvar mergeOpts = require('merge-options');\nvar profiles = require('./config/profiles.js');\nvar errors$1 = require('../errors.js');\nvar libp2p = require('./libp2p.js');\nvar errors = require('ipfs-repo/errors');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\nvar getDefaultConfig__default = /*#__PURE__*/_interopDefaultLegacy(getDefaultConfig);\nvar PeerId__default = /*#__PURE__*/_interopDefaultLegacy(PeerId);\nvar mergeOpts__default = /*#__PURE__*/_interopDefaultLegacy(mergeOpts);\n\nconst mergeOptions = mergeOpts__default[\"default\"].bind({ ignoreUndefined: true });\nconst log = debug__default[\"default\"]('ipfs:components:peer:storage');\nclass Storage {\n  constructor(peerId, keychain, repo, print, isNew) {\n    this.print = print;\n    this.peerId = peerId;\n    this.keychain = keychain;\n    this.repo = repo;\n    this.print = print;\n    this.isNew = isNew;\n  }\n  static async start(print, codecs, options) {\n    const {\n      repoAutoMigrate,\n      repo: inputRepo,\n      onMigrationProgress\n    } = options;\n    const repo$1 = typeof inputRepo === 'string' || inputRepo == null ? repo.createRepo(print, codecs, {\n      path: inputRepo,\n      autoMigrate: repoAutoMigrate,\n      onMigrationProgress: onMigrationProgress\n    }) : inputRepo;\n    const {peerId, keychain, isNew} = await loadRepo(print, repo$1, options);\n    return new Storage(peerId, keychain, repo$1, print, isNew);\n  }\n}\nconst loadRepo = async (print, repo, options) => {\n  if (!repo.closed) {\n    return {\n      ...await configureRepo(repo, options),\n      isNew: false\n    };\n  }\n  try {\n    await repo.open();\n    return {\n      ...await configureRepo(repo, options),\n      isNew: false\n    };\n  } catch (err) {\n    if (err.code !== errors.ERR_REPO_NOT_INITIALIZED) {\n      throw err;\n    }\n    if (options.init && options.init.allowNew === false) {\n      throw new errors$1.NotEnabledError('Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it');\n    }\n    return {\n      ...await initRepo(print, repo, options),\n      isNew: true\n    };\n  }\n};\nconst initRepo = async (print, repo, options) => {\n  const initOptions = options.init || {};\n  const exists = await repo.exists();\n  log('repo exists?', exists);\n  if (exists === true) {\n    throw new Error('repo already exists');\n  }\n  const peerId = initOptions.privateKey ? await decodePeerId(initOptions.privateKey) : await initPeerId(print, initOptions);\n  const identity = peerIdToIdentity(peerId);\n  log('peer identity: %s', identity.PeerID);\n  const config = {\n    ...mergeOptions(applyProfiles(getDefaultConfig__default[\"default\"](), initOptions.profiles), options.config),\n    Identity: identity\n  };\n  await repo.init(config);\n  await repo.open();\n  log('repo opened');\n  const keychainConfig = { pass: options.pass };\n  try {\n    keychainConfig.dek = await repo.config.get('Keychain.DEK');\n  } catch (err) {\n    if (err.code !== 'ERR_NOT_FOUND') {\n      throw err;\n    }\n  }\n  const libp2p$1 = await libp2p.createLibp2p({\n    options: undefined,\n    multiaddrs: undefined,\n    peerId,\n    repo,\n    config,\n    keychainConfig\n  });\n  if (libp2p$1.keychain && libp2p$1.keychain.opts) {\n    await libp2p$1.loadKeychain();\n    await repo.config.set('Keychain', { DEK: libp2p$1.keychain.opts.dek });\n  }\n  return {\n    peerId,\n    keychain: libp2p$1.keychain\n  };\n};\nconst decodePeerId = peerId => {\n  log('using user-supplied private-key');\n  return typeof peerId === 'object' ? peerId : PeerId__default[\"default\"].createFromPrivKey(fromString.fromString(peerId, 'base64pad'));\n};\nconst initPeerId = (print, {algorithm = 'Ed25519', bits = 2048}) => {\n  print('generating %s keypair...', algorithm);\n  return PeerId__default[\"default\"].create({\n    keyType: algorithm,\n    bits\n  });\n};\nconst peerIdToIdentity = peerId => ({\n  PeerID: peerId.toB58String(),\n  PrivKey: toString.toString(peerId.privKey.bytes, 'base64pad')\n});\nconst configureRepo = async (repo, options) => {\n  const config = options.config;\n  const profiles = options.init && options.init.profiles || [];\n  const pass = options.pass;\n  const original = await repo.config.getAll();\n  const changed = mergeConfigs(applyProfiles(original, profiles), config);\n  if (original !== changed) {\n    await repo.config.replace(changed);\n  }\n  if (!changed.Identity || !changed.Identity.PrivKey) {\n    throw new errors$1.NotInitializedError('No private key was found in the config, please intialize the repo');\n  }\n  const peerId = await PeerId__default[\"default\"].createFromPrivKey(changed.Identity.PrivKey);\n  const libp2p$1 = await libp2p.createLibp2p({\n    options: undefined,\n    multiaddrs: undefined,\n    peerId,\n    repo,\n    config: changed,\n    keychainConfig: {\n      pass,\n      ...changed.Keychain\n    }\n  });\n  if (libp2p$1.keychain) {\n    await libp2p$1.loadKeychain();\n  }\n  return {\n    peerId,\n    keychain: libp2p$1.keychain\n  };\n};\nconst mergeConfigs = (config, changes) => changes ? mergeOptions(config, changes) : config;\nconst applyProfiles = (config, profiles$1) => {\n  return (profiles$1 || []).reduce((config, name) => {\n    const profile = profiles.profiles[name];\n    if (!profile) {\n      throw new Error(`Could not find profile with name '${ name }'`);\n    }\n    log('applying profile %s', name);\n    return profile.transform(config);\n  }, config);\n};\n\nexports.Storage = Storage;\n"]},"metadata":{},"sourceType":"script"}