{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar dagPB = require('@ipld/dag-pb');\n\nvar hamtSharding = require('hamt-sharding');\n\nvar dirSharded = require('./dir-sharded.js');\n\nvar debug = require('debug');\n\nvar ipfsUnixfs = require('ipfs-unixfs');\n\nvar last = require('it-last');\n\nvar cid = require('multiformats/cid');\n\nvar hamtConstants = require('./hamt-constants.js');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar dagPB__namespace = /*#__PURE__*/_interopNamespace(dagPB);\n\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\n\nvar last__default = /*#__PURE__*/_interopDefaultLegacy(last);\n\nconst log = debug__default[\"default\"]('ipfs:mfs:core:utils:hamt-utils');\n\nconst updateHamtDirectory = async (context, links, bucket, options) => {\n  if (!options.parent.Data) {\n    throw new Error('Could not update HAMT directory because parent had no data');\n  }\n\n  const data = Uint8Array.from(bucket._children.bitField().reverse());\n  const node = ipfsUnixfs.UnixFS.unmarshal(options.parent.Data);\n  const dir = new ipfsUnixfs.UnixFS({\n    type: 'hamt-sharded-directory',\n    data,\n    fanout: bucket.tableSize(),\n    hashType: hamtConstants.hamtHashCode,\n    mode: node.mode,\n    mtime: node.mtime\n  });\n  const hasher = await context.hashers.getHasher(options.hashAlg);\n  const parent = {\n    Data: dir.marshal(),\n    Links: links.sort((a, b) => (a.Name || '').localeCompare(b.Name || ''))\n  };\n  const buf = dagPB__namespace.encode(parent);\n  const hash = await hasher.digest(buf);\n  const cid$1 = cid.CID.create(options.cidVersion, dagPB__namespace.code, hash);\n\n  if (options.flush) {\n    await context.repo.blocks.put(cid$1, buf);\n  }\n\n  return {\n    node: parent,\n    cid: cid$1,\n    size: links.reduce((sum, link) => sum + (link.Tsize || 0), buf.length)\n  };\n};\n\nconst recreateHamtLevel = async (context, links, rootBucket, parentBucket, positionAtParent) => {\n  const bucket = new hamtSharding.Bucket({\n    hash: rootBucket._options.hash,\n    bits: rootBucket._options.bits\n  }, parentBucket, positionAtParent);\n\n  parentBucket._putObjectAt(positionAtParent, bucket);\n\n  await addLinksToHamtBucket(context, links, bucket, rootBucket);\n  return bucket;\n};\n\nconst recreateInitialHamtLevel = async links => {\n  const bucket = hamtSharding.createHAMT({\n    hashFn: hamtConstants.hamtHashFn,\n    bits: hamtConstants.hamtBucketBits\n  });\n  await Promise.all(links.map(async link => {\n    const linkName = link.Name || '';\n\n    if (linkName.length === 2) {\n      const pos = parseInt(linkName, 16);\n      const subBucket = new hamtSharding.Bucket({\n        hash: bucket._options.hash,\n        bits: bucket._options.bits\n      }, bucket, pos);\n\n      bucket._putObjectAt(pos, subBucket);\n\n      return Promise.resolve();\n    }\n\n    return bucket.put(linkName.substring(2), {\n      size: link.Tsize,\n      cid: link.Hash\n    });\n  }));\n  return bucket;\n};\n\nconst addLinksToHamtBucket = async (context, links, bucket, rootBucket) => {\n  await Promise.all(links.map(async link => {\n    const linkName = link.Name || '';\n\n    if (linkName.length === 2) {\n      log('Populating sub bucket', linkName);\n      const pos = parseInt(linkName, 16);\n      const block = await context.repo.blocks.get(link.Hash);\n      const node = dagPB__namespace.decode(block);\n      const subBucket = new hamtSharding.Bucket({\n        hash: rootBucket._options.hash,\n        bits: rootBucket._options.bits\n      }, bucket, pos);\n\n      bucket._putObjectAt(pos, subBucket);\n\n      await addLinksToHamtBucket(context, node.Links, subBucket, rootBucket);\n      return Promise.resolve();\n    }\n\n    return rootBucket.put(linkName.substring(2), {\n      size: link.Tsize,\n      cid: link.Hash\n    });\n  }));\n};\n\nconst toPrefix = position => {\n  return position.toString(16).toUpperCase().padStart(2, '0').substring(0, 2);\n};\n\nconst generatePath = async (context, fileName, rootNode) => {\n  const rootBucket = await recreateInitialHamtLevel(rootNode.Links);\n  const position = await rootBucket._findNewBucketAndPos(fileName);\n  const path = [{\n    bucket: position.bucket,\n    prefix: toPrefix(position.pos)\n  }];\n  let currentBucket = position.bucket;\n\n  while (currentBucket !== rootBucket) {\n    path.push({\n      bucket: currentBucket,\n      prefix: toPrefix(currentBucket._posAtParent)\n    });\n    currentBucket = currentBucket._parent;\n  }\n\n  path.reverse();\n  path[0].node = rootNode;\n\n  for (let i = 0; i < path.length; i++) {\n    const segment = path[i];\n\n    if (!segment.node) {\n      throw new Error('Could not generate HAMT path');\n    }\n\n    const link = segment.node.Links.filter(link => (link.Name || '').substring(0, 2) === segment.prefix).pop();\n\n    if (!link) {\n      log(`Link ${segment.prefix}${fileName} will be added`);\n      continue;\n    }\n\n    if (link.Name === `${segment.prefix}${fileName}`) {\n      log(`Link ${segment.prefix}${fileName} will be replaced`);\n      continue;\n    }\n\n    log(`Found subshard ${segment.prefix}`);\n    const block = await context.repo.blocks.get(link.Hash);\n    const node = dagPB__namespace.decode(block);\n\n    if (!path[i + 1]) {\n      log(`Loaded new subshard ${segment.prefix}`);\n      await recreateHamtLevel(context, node.Links, rootBucket, segment.bucket, parseInt(segment.prefix, 16));\n      const position = await rootBucket._findNewBucketAndPos(fileName);\n      path.push({\n        bucket: position.bucket,\n        prefix: toPrefix(position.pos),\n        node: node\n      });\n      continue;\n    }\n\n    const nextSegment = path[i + 1];\n    await addLinksToHamtBucket(context, node.Links, nextSegment.bucket, rootBucket);\n    nextSegment.node = node;\n  }\n\n  await rootBucket.put(fileName, true);\n  path.reverse();\n  return {\n    rootBucket,\n    path\n  };\n};\n\nconst createShard = async function (context, contents) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const shard = new dirSharded.DirSharded({\n    root: true,\n    dir: true,\n    parent: undefined,\n    parentKey: undefined,\n    path: '',\n    dirty: true,\n    flat: false,\n    mtime: options.mtime,\n    mode: options.mode\n  }, options);\n\n  for (let i = 0; i < contents.length; i++) {\n    await shard._bucket.put(contents[i].name, {\n      size: contents[i].size,\n      cid: contents[i].cid\n    });\n  }\n\n  const res = await last__default[\"default\"](shard.flush(context.repo.blocks));\n\n  if (!res) {\n    throw new Error('Flushing shard yielded no result');\n  }\n\n  return res;\n};\n\nexports.addLinksToHamtBucket = addLinksToHamtBucket;\nexports.createShard = createShard;\nexports.generatePath = generatePath;\nexports.recreateHamtLevel = recreateHamtLevel;\nexports.recreateInitialHamtLevel = recreateInitialHamtLevel;\nexports.toPrefix = toPrefix;\nexports.updateHamtDirectory = updateHamtDirectory;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-core/cjs/src/components/files/utils/hamt-utils.js"],"names":["Object","defineProperty","exports","value","dagPB","require","hamtSharding","dirSharded","debug","ipfsUnixfs","last","cid","hamtConstants","_interopDefaultLegacy","e","_interopNamespace","__esModule","n","create","keys","forEach","k","d","getOwnPropertyDescriptor","get","enumerable","freeze","dagPB__namespace","debug__default","last__default","log","updateHamtDirectory","context","links","bucket","options","parent","Data","Error","data","Uint8Array","from","_children","bitField","reverse","node","UnixFS","unmarshal","dir","type","fanout","tableSize","hashType","hamtHashCode","mode","mtime","hasher","hashers","getHasher","hashAlg","marshal","Links","sort","a","b","Name","localeCompare","buf","encode","hash","digest","cid$1","CID","cidVersion","code","flush","repo","blocks","put","size","reduce","sum","link","Tsize","length","recreateHamtLevel","rootBucket","parentBucket","positionAtParent","Bucket","_options","bits","_putObjectAt","addLinksToHamtBucket","recreateInitialHamtLevel","createHAMT","hashFn","hamtHashFn","hamtBucketBits","Promise","all","map","linkName","pos","parseInt","subBucket","resolve","substring","Hash","block","decode","toPrefix","position","toString","toUpperCase","padStart","generatePath","fileName","rootNode","_findNewBucketAndPos","path","prefix","currentBucket","push","_posAtParent","_parent","i","segment","filter","pop","nextSegment","createShard","contents","shard","DirSharded","root","undefined","parentKey","dirty","flat","_bucket","name","res"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AAEA,IAAIC,KAAK,GAAGC,OAAO,CAAC,cAAD,CAAnB;;AACA,IAAIC,YAAY,GAAGD,OAAO,CAAC,eAAD,CAA1B;;AACA,IAAIE,UAAU,GAAGF,OAAO,CAAC,kBAAD,CAAxB;;AACA,IAAIG,KAAK,GAAGH,OAAO,CAAC,OAAD,CAAnB;;AACA,IAAII,UAAU,GAAGJ,OAAO,CAAC,aAAD,CAAxB;;AACA,IAAIK,IAAI,GAAGL,OAAO,CAAC,SAAD,CAAlB;;AACA,IAAIM,GAAG,GAAGN,OAAO,CAAC,kBAAD,CAAjB;;AACA,IAAIO,aAAa,GAAGP,OAAO,CAAC,qBAAD,CAA3B;;AAEA,SAASQ,qBAAT,CAAgCC,CAAhC,EAAmC;AAAE,SAAOA,CAAC,IAAI,OAAOA,CAAP,KAAa,QAAlB,IAA8B,aAAaA,CAA3C,GAA+CA,CAA/C,GAAmD;AAAE,eAAWA;AAAb,GAA1D;AAA6E;;AAElH,SAASC,iBAAT,CAA2BD,CAA3B,EAA8B;AAC5B,MAAIA,CAAC,IAAIA,CAAC,CAACE,UAAX,EAAuB,OAAOF,CAAP;AACvB,MAAIG,CAAC,GAAGjB,MAAM,CAACkB,MAAP,CAAc,IAAd,CAAR;;AACA,MAAIJ,CAAJ,EAAO;AACLd,IAAAA,MAAM,CAACmB,IAAP,CAAYL,CAAZ,EAAeM,OAAf,CAAuB,UAAUC,CAAV,EAAa;AAClC,UAAIA,CAAC,KAAK,SAAV,EAAqB;AACnB,YAAIC,CAAC,GAAGtB,MAAM,CAACuB,wBAAP,CAAgCT,CAAhC,EAAmCO,CAAnC,CAAR;AACArB,QAAAA,MAAM,CAACC,cAAP,CAAsBgB,CAAtB,EAAyBI,CAAzB,EAA4BC,CAAC,CAACE,GAAF,GAAQF,CAAR,GAAY;AACtCG,UAAAA,UAAU,EAAE,IAD0B;AAEtCD,UAAAA,GAAG,EAAE,YAAY;AAAE,mBAAOV,CAAC,CAACO,CAAD,CAAR;AAAc;AAFK,SAAxC;AAID;AACF,KARD;AASD;;AACDJ,EAAAA,CAAC,CAAC,SAAD,CAAD,GAAeH,CAAf;AACA,SAAOd,MAAM,CAAC0B,MAAP,CAAcT,CAAd,CAAP;AACD;;AAED,IAAIU,gBAAgB,GAAG,aAAaZ,iBAAiB,CAACX,KAAD,CAArD;;AACA,IAAIwB,cAAc,GAAG,aAAaf,qBAAqB,CAACL,KAAD,CAAvD;;AACA,IAAIqB,aAAa,GAAG,aAAahB,qBAAqB,CAACH,IAAD,CAAtD;;AAEA,MAAMoB,GAAG,GAAGF,cAAc,CAAC,SAAD,CAAd,CAA0B,gCAA1B,CAAZ;;AACA,MAAMG,mBAAmB,GAAG,OAAOC,OAAP,EAAgBC,KAAhB,EAAuBC,MAAvB,EAA+BC,OAA/B,KAA2C;AACrE,MAAI,CAACA,OAAO,CAACC,MAAR,CAAeC,IAApB,EAA0B;AACxB,UAAM,IAAIC,KAAJ,CAAU,4DAAV,CAAN;AACD;;AACD,QAAMC,IAAI,GAAGC,UAAU,CAACC,IAAX,CAAgBP,MAAM,CAACQ,SAAP,CAAiBC,QAAjB,GAA4BC,OAA5B,EAAhB,CAAb;AACA,QAAMC,IAAI,GAAGpC,UAAU,CAACqC,MAAX,CAAkBC,SAAlB,CAA4BZ,OAAO,CAACC,MAAR,CAAeC,IAA3C,CAAb;AACA,QAAMW,GAAG,GAAG,IAAIvC,UAAU,CAACqC,MAAf,CAAsB;AAChCG,IAAAA,IAAI,EAAE,wBAD0B;AAEhCV,IAAAA,IAFgC;AAGhCW,IAAAA,MAAM,EAAEhB,MAAM,CAACiB,SAAP,EAHwB;AAIhCC,IAAAA,QAAQ,EAAExC,aAAa,CAACyC,YAJQ;AAKhCC,IAAAA,IAAI,EAAET,IAAI,CAACS,IALqB;AAMhCC,IAAAA,KAAK,EAAEV,IAAI,CAACU;AANoB,GAAtB,CAAZ;AAQA,QAAMC,MAAM,GAAG,MAAMxB,OAAO,CAACyB,OAAR,CAAgBC,SAAhB,CAA0BvB,OAAO,CAACwB,OAAlC,CAArB;AACA,QAAMvB,MAAM,GAAG;AACbC,IAAAA,IAAI,EAAEW,GAAG,CAACY,OAAJ,EADO;AAEbC,IAAAA,KAAK,EAAE5B,KAAK,CAAC6B,IAAN,CAAW,CAACC,CAAD,EAAIC,CAAJ,KAAU,CAACD,CAAC,CAACE,IAAF,IAAU,EAAX,EAAeC,aAAf,CAA6BF,CAAC,CAACC,IAAF,IAAU,EAAvC,CAArB;AAFM,GAAf;AAIA,QAAME,GAAG,GAAGxC,gBAAgB,CAACyC,MAAjB,CAAwBhC,MAAxB,CAAZ;AACA,QAAMiC,IAAI,GAAG,MAAMb,MAAM,CAACc,MAAP,CAAcH,GAAd,CAAnB;AACA,QAAMI,KAAK,GAAG5D,GAAG,CAAC6D,GAAJ,CAAQtD,MAAR,CAAeiB,OAAO,CAACsC,UAAvB,EAAmC9C,gBAAgB,CAAC+C,IAApD,EAA0DL,IAA1D,CAAd;;AACA,MAAIlC,OAAO,CAACwC,KAAZ,EAAmB;AACjB,UAAM3C,OAAO,CAAC4C,IAAR,CAAaC,MAAb,CAAoBC,GAApB,CAAwBP,KAAxB,EAA+BJ,GAA/B,CAAN;AACD;;AACD,SAAO;AACLtB,IAAAA,IAAI,EAAET,MADD;AAELzB,IAAAA,GAAG,EAAE4D,KAFA;AAGLQ,IAAAA,IAAI,EAAE9C,KAAK,CAAC+C,MAAN,CAAa,CAACC,GAAD,EAAMC,IAAN,KAAeD,GAAG,IAAIC,IAAI,CAACC,KAAL,IAAc,CAAlB,CAA/B,EAAqDhB,GAAG,CAACiB,MAAzD;AAHD,GAAP;AAKD,CA9BD;;AA+BA,MAAMC,iBAAiB,GAAG,OAAOrD,OAAP,EAAgBC,KAAhB,EAAuBqD,UAAvB,EAAmCC,YAAnC,EAAiDC,gBAAjD,KAAsE;AAC9F,QAAMtD,MAAM,GAAG,IAAI5B,YAAY,CAACmF,MAAjB,CAAwB;AACrCpB,IAAAA,IAAI,EAAEiB,UAAU,CAACI,QAAX,CAAoBrB,IADW;AAErCsB,IAAAA,IAAI,EAAEL,UAAU,CAACI,QAAX,CAAoBC;AAFW,GAAxB,EAGZJ,YAHY,EAGEC,gBAHF,CAAf;;AAIAD,EAAAA,YAAY,CAACK,YAAb,CAA0BJ,gBAA1B,EAA4CtD,MAA5C;;AACA,QAAM2D,oBAAoB,CAAC7D,OAAD,EAAUC,KAAV,EAAiBC,MAAjB,EAAyBoD,UAAzB,CAA1B;AACA,SAAOpD,MAAP;AACD,CARD;;AASA,MAAM4D,wBAAwB,GAAG,MAAM7D,KAAN,IAAe;AAC9C,QAAMC,MAAM,GAAG5B,YAAY,CAACyF,UAAb,CAAwB;AACrCC,IAAAA,MAAM,EAAEpF,aAAa,CAACqF,UADe;AAErCN,IAAAA,IAAI,EAAE/E,aAAa,CAACsF;AAFiB,GAAxB,CAAf;AAIA,QAAMC,OAAO,CAACC,GAAR,CAAYnE,KAAK,CAACoE,GAAN,CAAU,MAAMnB,IAAN,IAAc;AACxC,UAAMoB,QAAQ,GAAGpB,IAAI,CAACjB,IAAL,IAAa,EAA9B;;AACA,QAAIqC,QAAQ,CAAClB,MAAT,KAAoB,CAAxB,EAA2B;AACzB,YAAMmB,GAAG,GAAGC,QAAQ,CAACF,QAAD,EAAW,EAAX,CAApB;AACA,YAAMG,SAAS,GAAG,IAAInG,YAAY,CAACmF,MAAjB,CAAwB;AACxCpB,QAAAA,IAAI,EAAEnC,MAAM,CAACwD,QAAP,CAAgBrB,IADkB;AAExCsB,QAAAA,IAAI,EAAEzD,MAAM,CAACwD,QAAP,CAAgBC;AAFkB,OAAxB,EAGfzD,MAHe,EAGPqE,GAHO,CAAlB;;AAIArE,MAAAA,MAAM,CAAC0D,YAAP,CAAoBW,GAApB,EAAyBE,SAAzB;;AACA,aAAON,OAAO,CAACO,OAAR,EAAP;AACD;;AACD,WAAOxE,MAAM,CAAC4C,GAAP,CAAWwB,QAAQ,CAACK,SAAT,CAAmB,CAAnB,CAAX,EAAkC;AACvC5B,MAAAA,IAAI,EAAEG,IAAI,CAACC,KAD4B;AAEvCxE,MAAAA,GAAG,EAAEuE,IAAI,CAAC0B;AAF6B,KAAlC,CAAP;AAID,GAfiB,CAAZ,CAAN;AAgBA,SAAO1E,MAAP;AACD,CAtBD;;AAuBA,MAAM2D,oBAAoB,GAAG,OAAO7D,OAAP,EAAgBC,KAAhB,EAAuBC,MAAvB,EAA+BoD,UAA/B,KAA8C;AACzE,QAAMa,OAAO,CAACC,GAAR,CAAYnE,KAAK,CAACoE,GAAN,CAAU,MAAMnB,IAAN,IAAc;AACxC,UAAMoB,QAAQ,GAAGpB,IAAI,CAACjB,IAAL,IAAa,EAA9B;;AACA,QAAIqC,QAAQ,CAAClB,MAAT,KAAoB,CAAxB,EAA2B;AACzBtD,MAAAA,GAAG,CAAC,uBAAD,EAA0BwE,QAA1B,CAAH;AACA,YAAMC,GAAG,GAAGC,QAAQ,CAACF,QAAD,EAAW,EAAX,CAApB;AACA,YAAMO,KAAK,GAAG,MAAM7E,OAAO,CAAC4C,IAAR,CAAaC,MAAb,CAAoBrD,GAApB,CAAwB0D,IAAI,CAAC0B,IAA7B,CAApB;AACA,YAAM/D,IAAI,GAAGlB,gBAAgB,CAACmF,MAAjB,CAAwBD,KAAxB,CAAb;AACA,YAAMJ,SAAS,GAAG,IAAInG,YAAY,CAACmF,MAAjB,CAAwB;AACxCpB,QAAAA,IAAI,EAAEiB,UAAU,CAACI,QAAX,CAAoBrB,IADc;AAExCsB,QAAAA,IAAI,EAAEL,UAAU,CAACI,QAAX,CAAoBC;AAFc,OAAxB,EAGfzD,MAHe,EAGPqE,GAHO,CAAlB;;AAIArE,MAAAA,MAAM,CAAC0D,YAAP,CAAoBW,GAApB,EAAyBE,SAAzB;;AACA,YAAMZ,oBAAoB,CAAC7D,OAAD,EAAUa,IAAI,CAACgB,KAAf,EAAsB4C,SAAtB,EAAiCnB,UAAjC,CAA1B;AACA,aAAOa,OAAO,CAACO,OAAR,EAAP;AACD;;AACD,WAAOpB,UAAU,CAACR,GAAX,CAAewB,QAAQ,CAACK,SAAT,CAAmB,CAAnB,CAAf,EAAsC;AAC3C5B,MAAAA,IAAI,EAAEG,IAAI,CAACC,KADgC;AAE3CxE,MAAAA,GAAG,EAAEuE,IAAI,CAAC0B;AAFiC,KAAtC,CAAP;AAID,GAnBiB,CAAZ,CAAN;AAoBD,CArBD;;AAsBA,MAAMG,QAAQ,GAAGC,QAAQ,IAAI;AAC3B,SAAOA,QAAQ,CAACC,QAAT,CAAkB,EAAlB,EAAsBC,WAAtB,GAAoCC,QAApC,CAA6C,CAA7C,EAAgD,GAAhD,EAAqDR,SAArD,CAA+D,CAA/D,EAAkE,CAAlE,CAAP;AACD,CAFD;;AAGA,MAAMS,YAAY,GAAG,OAAOpF,OAAP,EAAgBqF,QAAhB,EAA0BC,QAA1B,KAAuC;AAC1D,QAAMhC,UAAU,GAAG,MAAMQ,wBAAwB,CAACwB,QAAQ,CAACzD,KAAV,CAAjD;AACA,QAAMmD,QAAQ,GAAG,MAAM1B,UAAU,CAACiC,oBAAX,CAAgCF,QAAhC,CAAvB;AACA,QAAMG,IAAI,GAAG,CAAC;AACVtF,IAAAA,MAAM,EAAE8E,QAAQ,CAAC9E,MADP;AAEVuF,IAAAA,MAAM,EAAEV,QAAQ,CAACC,QAAQ,CAACT,GAAV;AAFN,GAAD,CAAb;AAIA,MAAImB,aAAa,GAAGV,QAAQ,CAAC9E,MAA7B;;AACA,SAAOwF,aAAa,KAAKpC,UAAzB,EAAqC;AACnCkC,IAAAA,IAAI,CAACG,IAAL,CAAU;AACRzF,MAAAA,MAAM,EAAEwF,aADA;AAERD,MAAAA,MAAM,EAAEV,QAAQ,CAACW,aAAa,CAACE,YAAf;AAFR,KAAV;AAIAF,IAAAA,aAAa,GAAGA,aAAa,CAACG,OAA9B;AACD;;AACDL,EAAAA,IAAI,CAAC5E,OAAL;AACA4E,EAAAA,IAAI,CAAC,CAAD,CAAJ,CAAQ3E,IAAR,GAAeyE,QAAf;;AACA,OAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,IAAI,CAACpC,MAAzB,EAAiC0C,CAAC,EAAlC,EAAsC;AACpC,UAAMC,OAAO,GAAGP,IAAI,CAACM,CAAD,CAApB;;AACA,QAAI,CAACC,OAAO,CAAClF,IAAb,EAAmB;AACjB,YAAM,IAAIP,KAAJ,CAAU,8BAAV,CAAN;AACD;;AACD,UAAM4C,IAAI,GAAG6C,OAAO,CAAClF,IAAR,CAAagB,KAAb,CAAmBmE,MAAnB,CAA0B9C,IAAI,IAAI,CAACA,IAAI,CAACjB,IAAL,IAAa,EAAd,EAAkB0C,SAAlB,CAA4B,CAA5B,EAA+B,CAA/B,MAAsCoB,OAAO,CAACN,MAAhF,EAAwFQ,GAAxF,EAAb;;AACA,QAAI,CAAC/C,IAAL,EAAW;AACTpD,MAAAA,GAAG,CAAE,QAAQiG,OAAO,CAACN,MAAQ,GAAGJ,QAAU,gBAAvC,CAAH;AACA;AACD;;AACD,QAAInC,IAAI,CAACjB,IAAL,KAAe,GAAG8D,OAAO,CAACN,MAAQ,GAAGJ,QAAU,EAAnD,EAAsD;AACpDvF,MAAAA,GAAG,CAAE,QAAQiG,OAAO,CAACN,MAAQ,GAAGJ,QAAU,mBAAvC,CAAH;AACA;AACD;;AACDvF,IAAAA,GAAG,CAAE,kBAAkBiG,OAAO,CAACN,MAAQ,EAApC,CAAH;AACA,UAAMZ,KAAK,GAAG,MAAM7E,OAAO,CAAC4C,IAAR,CAAaC,MAAb,CAAoBrD,GAApB,CAAwB0D,IAAI,CAAC0B,IAA7B,CAApB;AACA,UAAM/D,IAAI,GAAGlB,gBAAgB,CAACmF,MAAjB,CAAwBD,KAAxB,CAAb;;AACA,QAAI,CAACW,IAAI,CAACM,CAAC,GAAG,CAAL,CAAT,EAAkB;AAChBhG,MAAAA,GAAG,CAAE,uBAAuBiG,OAAO,CAACN,MAAQ,EAAzC,CAAH;AACA,YAAMpC,iBAAiB,CAACrD,OAAD,EAAUa,IAAI,CAACgB,KAAf,EAAsByB,UAAtB,EAAkCyC,OAAO,CAAC7F,MAA1C,EAAkDsE,QAAQ,CAACuB,OAAO,CAACN,MAAT,EAAiB,EAAjB,CAA1D,CAAvB;AACA,YAAMT,QAAQ,GAAG,MAAM1B,UAAU,CAACiC,oBAAX,CAAgCF,QAAhC,CAAvB;AACAG,MAAAA,IAAI,CAACG,IAAL,CAAU;AACRzF,QAAAA,MAAM,EAAE8E,QAAQ,CAAC9E,MADT;AAERuF,QAAAA,MAAM,EAAEV,QAAQ,CAACC,QAAQ,CAACT,GAAV,CAFR;AAGR1D,QAAAA,IAAI,EAAEA;AAHE,OAAV;AAKA;AACD;;AACD,UAAMqF,WAAW,GAAGV,IAAI,CAACM,CAAC,GAAG,CAAL,CAAxB;AACA,UAAMjC,oBAAoB,CAAC7D,OAAD,EAAUa,IAAI,CAACgB,KAAf,EAAsBqE,WAAW,CAAChG,MAAlC,EAA0CoD,UAA1C,CAA1B;AACA4C,IAAAA,WAAW,CAACrF,IAAZ,GAAmBA,IAAnB;AACD;;AACD,QAAMyC,UAAU,CAACR,GAAX,CAAeuC,QAAf,EAAyB,IAAzB,CAAN;AACAG,EAAAA,IAAI,CAAC5E,OAAL;AACA,SAAO;AACL0C,IAAAA,UADK;AAELkC,IAAAA;AAFK,GAAP;AAID,CAvDD;;AAwDA,MAAMW,WAAW,GAAG,gBAAOnG,OAAP,EAAgBoG,QAAhB,EAA2C;AAAA,MAAjBjG,OAAiB,uEAAP,EAAO;AAC7D,QAAMkG,KAAK,GAAG,IAAI9H,UAAU,CAAC+H,UAAf,CAA0B;AACtCC,IAAAA,IAAI,EAAE,IADgC;AAEtCvF,IAAAA,GAAG,EAAE,IAFiC;AAGtCZ,IAAAA,MAAM,EAAEoG,SAH8B;AAItCC,IAAAA,SAAS,EAAED,SAJ2B;AAKtChB,IAAAA,IAAI,EAAE,EALgC;AAMtCkB,IAAAA,KAAK,EAAE,IAN+B;AAOtCC,IAAAA,IAAI,EAAE,KAPgC;AAQtCpF,IAAAA,KAAK,EAAEpB,OAAO,CAACoB,KARuB;AAStCD,IAAAA,IAAI,EAAEnB,OAAO,CAACmB;AATwB,GAA1B,EAUXnB,OAVW,CAAd;;AAWA,OAAK,IAAI2F,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGM,QAAQ,CAAChD,MAA7B,EAAqC0C,CAAC,EAAtC,EAA0C;AACxC,UAAMO,KAAK,CAACO,OAAN,CAAc9D,GAAd,CAAkBsD,QAAQ,CAACN,CAAD,CAAR,CAAYe,IAA9B,EAAoC;AACxC9D,MAAAA,IAAI,EAAEqD,QAAQ,CAACN,CAAD,CAAR,CAAY/C,IADsB;AAExCpE,MAAAA,GAAG,EAAEyH,QAAQ,CAACN,CAAD,CAAR,CAAYnH;AAFuB,KAApC,CAAN;AAID;;AACD,QAAMmI,GAAG,GAAG,MAAMjH,aAAa,CAAC,SAAD,CAAb,CAAyBwG,KAAK,CAAC1D,KAAN,CAAY3C,OAAO,CAAC4C,IAAR,CAAaC,MAAzB,CAAzB,CAAlB;;AACA,MAAI,CAACiE,GAAL,EAAU;AACR,UAAM,IAAIxG,KAAJ,CAAU,kCAAV,CAAN;AACD;;AACD,SAAOwG,GAAP;AACD,CAvBD;;AAyBA5I,OAAO,CAAC2F,oBAAR,GAA+BA,oBAA/B;AACA3F,OAAO,CAACiI,WAAR,GAAsBA,WAAtB;AACAjI,OAAO,CAACkH,YAAR,GAAuBA,YAAvB;AACAlH,OAAO,CAACmF,iBAAR,GAA4BA,iBAA5B;AACAnF,OAAO,CAAC4F,wBAAR,GAAmCA,wBAAnC;AACA5F,OAAO,CAAC6G,QAAR,GAAmBA,QAAnB;AACA7G,OAAO,CAAC6B,mBAAR,GAA8BA,mBAA9B","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar dagPB = require('@ipld/dag-pb');\nvar hamtSharding = require('hamt-sharding');\nvar dirSharded = require('./dir-sharded.js');\nvar debug = require('debug');\nvar ipfsUnixfs = require('ipfs-unixfs');\nvar last = require('it-last');\nvar cid = require('multiformats/cid');\nvar hamtConstants = require('./hamt-constants.js');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar dagPB__namespace = /*#__PURE__*/_interopNamespace(dagPB);\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\nvar last__default = /*#__PURE__*/_interopDefaultLegacy(last);\n\nconst log = debug__default[\"default\"]('ipfs:mfs:core:utils:hamt-utils');\nconst updateHamtDirectory = async (context, links, bucket, options) => {\n  if (!options.parent.Data) {\n    throw new Error('Could not update HAMT directory because parent had no data');\n  }\n  const data = Uint8Array.from(bucket._children.bitField().reverse());\n  const node = ipfsUnixfs.UnixFS.unmarshal(options.parent.Data);\n  const dir = new ipfsUnixfs.UnixFS({\n    type: 'hamt-sharded-directory',\n    data,\n    fanout: bucket.tableSize(),\n    hashType: hamtConstants.hamtHashCode,\n    mode: node.mode,\n    mtime: node.mtime\n  });\n  const hasher = await context.hashers.getHasher(options.hashAlg);\n  const parent = {\n    Data: dir.marshal(),\n    Links: links.sort((a, b) => (a.Name || '').localeCompare(b.Name || ''))\n  };\n  const buf = dagPB__namespace.encode(parent);\n  const hash = await hasher.digest(buf);\n  const cid$1 = cid.CID.create(options.cidVersion, dagPB__namespace.code, hash);\n  if (options.flush) {\n    await context.repo.blocks.put(cid$1, buf);\n  }\n  return {\n    node: parent,\n    cid: cid$1,\n    size: links.reduce((sum, link) => sum + (link.Tsize || 0), buf.length)\n  };\n};\nconst recreateHamtLevel = async (context, links, rootBucket, parentBucket, positionAtParent) => {\n  const bucket = new hamtSharding.Bucket({\n    hash: rootBucket._options.hash,\n    bits: rootBucket._options.bits\n  }, parentBucket, positionAtParent);\n  parentBucket._putObjectAt(positionAtParent, bucket);\n  await addLinksToHamtBucket(context, links, bucket, rootBucket);\n  return bucket;\n};\nconst recreateInitialHamtLevel = async links => {\n  const bucket = hamtSharding.createHAMT({\n    hashFn: hamtConstants.hamtHashFn,\n    bits: hamtConstants.hamtBucketBits\n  });\n  await Promise.all(links.map(async link => {\n    const linkName = link.Name || '';\n    if (linkName.length === 2) {\n      const pos = parseInt(linkName, 16);\n      const subBucket = new hamtSharding.Bucket({\n        hash: bucket._options.hash,\n        bits: bucket._options.bits\n      }, bucket, pos);\n      bucket._putObjectAt(pos, subBucket);\n      return Promise.resolve();\n    }\n    return bucket.put(linkName.substring(2), {\n      size: link.Tsize,\n      cid: link.Hash\n    });\n  }));\n  return bucket;\n};\nconst addLinksToHamtBucket = async (context, links, bucket, rootBucket) => {\n  await Promise.all(links.map(async link => {\n    const linkName = link.Name || '';\n    if (linkName.length === 2) {\n      log('Populating sub bucket', linkName);\n      const pos = parseInt(linkName, 16);\n      const block = await context.repo.blocks.get(link.Hash);\n      const node = dagPB__namespace.decode(block);\n      const subBucket = new hamtSharding.Bucket({\n        hash: rootBucket._options.hash,\n        bits: rootBucket._options.bits\n      }, bucket, pos);\n      bucket._putObjectAt(pos, subBucket);\n      await addLinksToHamtBucket(context, node.Links, subBucket, rootBucket);\n      return Promise.resolve();\n    }\n    return rootBucket.put(linkName.substring(2), {\n      size: link.Tsize,\n      cid: link.Hash\n    });\n  }));\n};\nconst toPrefix = position => {\n  return position.toString(16).toUpperCase().padStart(2, '0').substring(0, 2);\n};\nconst generatePath = async (context, fileName, rootNode) => {\n  const rootBucket = await recreateInitialHamtLevel(rootNode.Links);\n  const position = await rootBucket._findNewBucketAndPos(fileName);\n  const path = [{\n      bucket: position.bucket,\n      prefix: toPrefix(position.pos)\n    }];\n  let currentBucket = position.bucket;\n  while (currentBucket !== rootBucket) {\n    path.push({\n      bucket: currentBucket,\n      prefix: toPrefix(currentBucket._posAtParent)\n    });\n    currentBucket = currentBucket._parent;\n  }\n  path.reverse();\n  path[0].node = rootNode;\n  for (let i = 0; i < path.length; i++) {\n    const segment = path[i];\n    if (!segment.node) {\n      throw new Error('Could not generate HAMT path');\n    }\n    const link = segment.node.Links.filter(link => (link.Name || '').substring(0, 2) === segment.prefix).pop();\n    if (!link) {\n      log(`Link ${ segment.prefix }${ fileName } will be added`);\n      continue;\n    }\n    if (link.Name === `${ segment.prefix }${ fileName }`) {\n      log(`Link ${ segment.prefix }${ fileName } will be replaced`);\n      continue;\n    }\n    log(`Found subshard ${ segment.prefix }`);\n    const block = await context.repo.blocks.get(link.Hash);\n    const node = dagPB__namespace.decode(block);\n    if (!path[i + 1]) {\n      log(`Loaded new subshard ${ segment.prefix }`);\n      await recreateHamtLevel(context, node.Links, rootBucket, segment.bucket, parseInt(segment.prefix, 16));\n      const position = await rootBucket._findNewBucketAndPos(fileName);\n      path.push({\n        bucket: position.bucket,\n        prefix: toPrefix(position.pos),\n        node: node\n      });\n      continue;\n    }\n    const nextSegment = path[i + 1];\n    await addLinksToHamtBucket(context, node.Links, nextSegment.bucket, rootBucket);\n    nextSegment.node = node;\n  }\n  await rootBucket.put(fileName, true);\n  path.reverse();\n  return {\n    rootBucket,\n    path\n  };\n};\nconst createShard = async (context, contents, options = {}) => {\n  const shard = new dirSharded.DirSharded({\n    root: true,\n    dir: true,\n    parent: undefined,\n    parentKey: undefined,\n    path: '',\n    dirty: true,\n    flat: false,\n    mtime: options.mtime,\n    mode: options.mode\n  }, options);\n  for (let i = 0; i < contents.length; i++) {\n    await shard._bucket.put(contents[i].name, {\n      size: contents[i].size,\n      cid: contents[i].cid\n    });\n  }\n  const res = await last__default[\"default\"](shard.flush(context.repo.blocks));\n  if (!res) {\n    throw new Error('Flushing shard yielded no result');\n  }\n  return res;\n};\n\nexports.addLinksToHamtBucket = addLinksToHamtBucket;\nexports.createShard = createShard;\nexports.generatePath = generatePath;\nexports.recreateHamtLevel = recreateHamtLevel;\nexports.recreateInitialHamtLevel = recreateInitialHamtLevel;\nexports.toPrefix = toPrefix;\nexports.updateHamtDirectory = updateHamtDirectory;\n"]},"metadata":{},"sourceType":"script"}