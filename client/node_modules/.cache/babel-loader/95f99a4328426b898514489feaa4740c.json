{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar ipns = require('ipns');\n\nvar PeerId = require('peer-id');\n\nvar errCode = require('err-code');\n\nvar debug = require('debug');\n\nvar toString = require('uint8arrays/to-string');\n\nvar Errors = require('datastore-core/errors');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar ipns__namespace = /*#__PURE__*/_interopNamespace(ipns);\n\nvar PeerId__default = /*#__PURE__*/_interopDefaultLegacy(PeerId);\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\n\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\n\nvar Errors__namespace = /*#__PURE__*/_interopNamespace(Errors);\n\nconst log = Object.assign(debug__default[\"default\"]('ipfs:ipns:resolver'), {\n  error: debug__default[\"default\"]('ipfs:ipns:resolver:error')\n});\nconst ERR_NOT_FOUND = Errors__namespace.notFoundError().code;\nconst defaultMaximumRecursiveDepth = 32;\n\nclass IpnsResolver {\n  constructor(routing) {\n    this._routing = routing;\n  }\n\n  async resolve(name) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (typeof name !== 'string') {\n      throw errCode__default[\"default\"](new Error('invalid name'), 'ERR_INVALID_NAME');\n    }\n\n    const recursive = options.recursive && options.recursive.toString() === 'true';\n    const nameSegments = name.split('/');\n\n    if (nameSegments.length !== 3 || nameSegments[0] !== '') {\n      throw errCode__default[\"default\"](new Error('invalid name'), 'ERR_INVALID_NAME');\n    }\n\n    const key = nameSegments[2];\n    let depth = Infinity;\n\n    if (recursive) {\n      depth = defaultMaximumRecursiveDepth;\n    }\n\n    const res = await this.resolver(key, depth);\n    log(`${name} was locally resolved correctly`);\n    return res;\n  }\n\n  async resolver(name, depth) {\n    if (depth === 0) {\n      const errMsg = `could not resolve name (recursion limit of ${defaultMaximumRecursiveDepth} exceeded)`;\n      log.error(errMsg);\n      throw errCode__default[\"default\"](new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT');\n    }\n\n    const res = await this._resolveName(name);\n    const nameSegments = res.split('/');\n\n    if (nameSegments[1] === 'ipfs' || !depth) {\n      return res;\n    }\n\n    return this.resolver(nameSegments[2], depth - 1);\n  }\n\n  async _resolveName(name) {\n    const peerId = PeerId__default[\"default\"].parse(name);\n    const {\n      routingKey\n    } = ipns__namespace.getIdKeys(peerId.toBytes());\n    let record;\n\n    try {\n      record = await this._routing.get(routingKey.uint8Array());\n    } catch (err) {\n      log.error('could not get record from routing', err);\n\n      if (err.code === ERR_NOT_FOUND) {\n        throw errCode__default[\"default\"](new Error(`record requested for ${name} was not found in the network`), 'ERR_NO_RECORD_FOUND');\n      }\n\n      throw errCode__default[\"default\"](new Error(`unexpected error getting the ipns record ${peerId.toString()}`), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');\n    }\n\n    let ipnsEntry;\n\n    try {\n      ipnsEntry = ipns__namespace.unmarshal(record);\n    } catch (err) {\n      log.error('could not unmarshal record', err);\n      throw errCode__default[\"default\"](new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_RECORD_RECEIVED');\n    }\n\n    return this._validateRecord(peerId, ipnsEntry);\n  }\n\n  async _validateRecord(peerId, ipnsEntry) {\n    const pubKey = await ipns__namespace.extractPublicKey(peerId, ipnsEntry);\n    await ipns__namespace.validate(pubKey, ipnsEntry);\n    return toString.toString(ipnsEntry.value);\n  }\n\n}\n\nexports.IpnsResolver = IpnsResolver;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-core/cjs/src/ipns/resolver.js"],"names":["Object","defineProperty","exports","value","ipns","require","PeerId","errCode","debug","toString","Errors","_interopDefaultLegacy","e","_interopNamespace","__esModule","n","create","keys","forEach","k","d","getOwnPropertyDescriptor","get","enumerable","freeze","ipns__namespace","PeerId__default","errCode__default","debug__default","Errors__namespace","log","assign","error","ERR_NOT_FOUND","notFoundError","code","defaultMaximumRecursiveDepth","IpnsResolver","constructor","routing","_routing","resolve","name","options","Error","recursive","nameSegments","split","length","key","depth","Infinity","res","resolver","errMsg","_resolveName","peerId","parse","routingKey","getIdKeys","toBytes","record","uint8Array","err","ipnsEntry","unmarshal","_validateRecord","pubKey","extractPublicKey","validate"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar ipns = require('ipns');\nvar PeerId = require('peer-id');\nvar errCode = require('err-code');\nvar debug = require('debug');\nvar toString = require('uint8arrays/to-string');\nvar Errors = require('datastore-core/errors');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar ipns__namespace = /*#__PURE__*/_interopNamespace(ipns);\nvar PeerId__default = /*#__PURE__*/_interopDefaultLegacy(PeerId);\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\nvar Errors__namespace = /*#__PURE__*/_interopNamespace(Errors);\n\nconst log = Object.assign(debug__default[\"default\"]('ipfs:ipns:resolver'), { error: debug__default[\"default\"]('ipfs:ipns:resolver:error') });\nconst ERR_NOT_FOUND = Errors__namespace.notFoundError().code;\nconst defaultMaximumRecursiveDepth = 32;\nclass IpnsResolver {\n  constructor(routing) {\n    this._routing = routing;\n  }\n  async resolve(name, options = {}) {\n    if (typeof name !== 'string') {\n      throw errCode__default[\"default\"](new Error('invalid name'), 'ERR_INVALID_NAME');\n    }\n    const recursive = options.recursive && options.recursive.toString() === 'true';\n    const nameSegments = name.split('/');\n    if (nameSegments.length !== 3 || nameSegments[0] !== '') {\n      throw errCode__default[\"default\"](new Error('invalid name'), 'ERR_INVALID_NAME');\n    }\n    const key = nameSegments[2];\n    let depth = Infinity;\n    if (recursive) {\n      depth = defaultMaximumRecursiveDepth;\n    }\n    const res = await this.resolver(key, depth);\n    log(`${ name } was locally resolved correctly`);\n    return res;\n  }\n  async resolver(name, depth) {\n    if (depth === 0) {\n      const errMsg = `could not resolve name (recursion limit of ${ defaultMaximumRecursiveDepth } exceeded)`;\n      log.error(errMsg);\n      throw errCode__default[\"default\"](new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT');\n    }\n    const res = await this._resolveName(name);\n    const nameSegments = res.split('/');\n    if (nameSegments[1] === 'ipfs' || !depth) {\n      return res;\n    }\n    return this.resolver(nameSegments[2], depth - 1);\n  }\n  async _resolveName(name) {\n    const peerId = PeerId__default[\"default\"].parse(name);\n    const {routingKey} = ipns__namespace.getIdKeys(peerId.toBytes());\n    let record;\n    try {\n      record = await this._routing.get(routingKey.uint8Array());\n    } catch (err) {\n      log.error('could not get record from routing', err);\n      if (err.code === ERR_NOT_FOUND) {\n        throw errCode__default[\"default\"](new Error(`record requested for ${ name } was not found in the network`), 'ERR_NO_RECORD_FOUND');\n      }\n      throw errCode__default[\"default\"](new Error(`unexpected error getting the ipns record ${ peerId.toString() }`), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');\n    }\n    let ipnsEntry;\n    try {\n      ipnsEntry = ipns__namespace.unmarshal(record);\n    } catch (err) {\n      log.error('could not unmarshal record', err);\n      throw errCode__default[\"default\"](new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_RECORD_RECEIVED');\n    }\n    return this._validateRecord(peerId, ipnsEntry);\n  }\n  async _validateRecord(peerId, ipnsEntry) {\n    const pubKey = await ipns__namespace.extractPublicKey(peerId, ipnsEntry);\n    await ipns__namespace.validate(pubKey, ipnsEntry);\n    return toString.toString(ipnsEntry.value);\n  }\n}\n\nexports.IpnsResolver = IpnsResolver;\n"]},"metadata":{},"sourceType":"script"}