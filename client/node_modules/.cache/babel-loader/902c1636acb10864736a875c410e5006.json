{"ast":null,"code":"'use strict';\n\nconst ed = require('@noble/ed25519');\n\nconst PUBLIC_KEY_BYTE_LENGTH = 32;\nconst PRIVATE_KEY_BYTE_LENGTH = 64; // private key is actually 32 bytes but for historical reasons we concat private and public keys\n\nconst KEYS_BYTE_LENGTH = 32;\nexports.publicKeyLength = PUBLIC_KEY_BYTE_LENGTH;\nexports.privateKeyLength = PRIVATE_KEY_BYTE_LENGTH;\n\nexports.generateKey = async function () {\n  // the actual private key (32 bytes)\n  const privateKeyRaw = ed.utils.randomPrivateKey();\n  const publicKey = await ed.getPublicKey(privateKeyRaw); // concatenated the public key to the private key\n\n  const privateKey = concatKeys(privateKeyRaw, publicKey);\n  return {\n    privateKey,\n    publicKey\n  };\n};\n/**\n * Generate keypair from a seed\n *\n * @param {Uint8Array} seed - seed should be a 32 byte uint8array\n * @returns\n */\n\n\nexports.generateKeyFromSeed = async function (seed) {\n  if (seed.length !== KEYS_BYTE_LENGTH) {\n    throw new TypeError('\"seed\" must be 32 bytes in length.');\n  } else if (!(seed instanceof Uint8Array)) {\n    throw new TypeError('\"seed\" must be a node.js Buffer, or Uint8Array.');\n  } // based on node forges algorithm, the seed is used directly as private key\n\n\n  const privateKeyRaw = seed;\n  const publicKey = await ed.getPublicKey(privateKeyRaw);\n  const privateKey = concatKeys(privateKeyRaw, publicKey);\n  return {\n    privateKey,\n    publicKey\n  };\n};\n\nexports.hashAndSign = function (privateKey, msg) {\n  const privateKeyRaw = privateKey.slice(0, KEYS_BYTE_LENGTH);\n  return ed.sign(msg, privateKeyRaw);\n};\n\nexports.hashAndVerify = function (publicKey, sig, msg) {\n  return ed.verify(sig, msg, publicKey);\n};\n\nfunction concatKeys(privateKeyRaw, publicKey) {\n  const privateKey = new Uint8Array(exports.privateKeyLength);\n\n  for (let i = 0; i < KEYS_BYTE_LENGTH; i++) {\n    privateKey[i] = privateKeyRaw[i];\n    privateKey[KEYS_BYTE_LENGTH + i] = publicKey[i];\n  }\n\n  return privateKey;\n}","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p-crypto/src/keys/ed25519.js"],"names":["ed","require","PUBLIC_KEY_BYTE_LENGTH","PRIVATE_KEY_BYTE_LENGTH","KEYS_BYTE_LENGTH","exports","publicKeyLength","privateKeyLength","generateKey","privateKeyRaw","utils","randomPrivateKey","publicKey","getPublicKey","privateKey","concatKeys","generateKeyFromSeed","seed","length","TypeError","Uint8Array","hashAndSign","msg","slice","sign","hashAndVerify","sig","verify","i"],"mappings":"AAAA;;AAEA,MAAMA,EAAE,GAAGC,OAAO,CAAC,gBAAD,CAAlB;;AAEA,MAAMC,sBAAsB,GAAG,EAA/B;AACA,MAAMC,uBAAuB,GAAG,EAAhC,C,CAAmC;;AACnC,MAAMC,gBAAgB,GAAG,EAAzB;AAEAC,OAAO,CAACC,eAAR,GAA0BJ,sBAA1B;AACAG,OAAO,CAACE,gBAAR,GAA2BJ,uBAA3B;;AAEAE,OAAO,CAACG,WAAR,GAAsB,kBAAkB;AACtC;AACA,QAAMC,aAAa,GAAGT,EAAE,CAACU,KAAH,CAASC,gBAAT,EAAtB;AACA,QAAMC,SAAS,GAAG,MAAMZ,EAAE,CAACa,YAAH,CAAgBJ,aAAhB,CAAxB,CAHsC,CAKtC;;AACA,QAAMK,UAAU,GAAGC,UAAU,CAACN,aAAD,EAAgBG,SAAhB,CAA7B;AAEA,SAAO;AACLE,IAAAA,UADK;AAELF,IAAAA;AAFK,GAAP;AAID,CAZD;AAcA;AACA;AACA;AACA;AACA;AACA;;;AACAP,OAAO,CAACW,mBAAR,GAA8B,gBAAgBC,IAAhB,EAAsB;AAClD,MAAIA,IAAI,CAACC,MAAL,KAAgBd,gBAApB,EAAsC;AACpC,UAAM,IAAIe,SAAJ,CAAc,oCAAd,CAAN;AACD,GAFD,MAEO,IAAI,EAAEF,IAAI,YAAYG,UAAlB,CAAJ,EAAmC;AACxC,UAAM,IAAID,SAAJ,CAAc,iDAAd,CAAN;AACD,GALiD,CAOlD;;;AACA,QAAMV,aAAa,GAAGQ,IAAtB;AACA,QAAML,SAAS,GAAG,MAAMZ,EAAE,CAACa,YAAH,CAAgBJ,aAAhB,CAAxB;AAEA,QAAMK,UAAU,GAAGC,UAAU,CAACN,aAAD,EAAgBG,SAAhB,CAA7B;AAEA,SAAO;AACLE,IAAAA,UADK;AAELF,IAAAA;AAFK,GAAP;AAID,CAjBD;;AAmBAP,OAAO,CAACgB,WAAR,GAAsB,UAAUP,UAAV,EAAsBQ,GAAtB,EAA2B;AAC/C,QAAMb,aAAa,GAAGK,UAAU,CAACS,KAAX,CAAiB,CAAjB,EAAoBnB,gBAApB,CAAtB;AAEA,SAAOJ,EAAE,CAACwB,IAAH,CAAQF,GAAR,EAAab,aAAb,CAAP;AACD,CAJD;;AAMAJ,OAAO,CAACoB,aAAR,GAAwB,UAAUb,SAAV,EAAqBc,GAArB,EAA0BJ,GAA1B,EAA+B;AACrD,SAAOtB,EAAE,CAAC2B,MAAH,CAAUD,GAAV,EAAeJ,GAAf,EAAoBV,SAApB,CAAP;AACD,CAFD;;AAIA,SAASG,UAAT,CAAqBN,aAArB,EAAoCG,SAApC,EAA+C;AAC7C,QAAME,UAAU,GAAG,IAAIM,UAAJ,CAAef,OAAO,CAACE,gBAAvB,CAAnB;;AACA,OAAK,IAAIqB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGxB,gBAApB,EAAsCwB,CAAC,EAAvC,EAA2C;AACzCd,IAAAA,UAAU,CAACc,CAAD,CAAV,GAAgBnB,aAAa,CAACmB,CAAD,CAA7B;AACAd,IAAAA,UAAU,CAACV,gBAAgB,GAAGwB,CAApB,CAAV,GAAmChB,SAAS,CAACgB,CAAD,CAA5C;AACD;;AACD,SAAOd,UAAP;AACD","sourcesContent":["'use strict'\n\nconst ed = require('@noble/ed25519')\n\nconst PUBLIC_KEY_BYTE_LENGTH = 32\nconst PRIVATE_KEY_BYTE_LENGTH = 64 // private key is actually 32 bytes but for historical reasons we concat private and public keys\nconst KEYS_BYTE_LENGTH = 32\n\nexports.publicKeyLength = PUBLIC_KEY_BYTE_LENGTH\nexports.privateKeyLength = PRIVATE_KEY_BYTE_LENGTH\n\nexports.generateKey = async function () {\n  // the actual private key (32 bytes)\n  const privateKeyRaw = ed.utils.randomPrivateKey()\n  const publicKey = await ed.getPublicKey(privateKeyRaw)\n\n  // concatenated the public key to the private key\n  const privateKey = concatKeys(privateKeyRaw, publicKey)\n\n  return {\n    privateKey,\n    publicKey\n  }\n}\n\n/**\n * Generate keypair from a seed\n *\n * @param {Uint8Array} seed - seed should be a 32 byte uint8array\n * @returns\n */\nexports.generateKeyFromSeed = async function (seed) {\n  if (seed.length !== KEYS_BYTE_LENGTH) {\n    throw new TypeError('\"seed\" must be 32 bytes in length.')\n  } else if (!(seed instanceof Uint8Array)) {\n    throw new TypeError('\"seed\" must be a node.js Buffer, or Uint8Array.')\n  }\n\n  // based on node forges algorithm, the seed is used directly as private key\n  const privateKeyRaw = seed\n  const publicKey = await ed.getPublicKey(privateKeyRaw)\n\n  const privateKey = concatKeys(privateKeyRaw, publicKey)\n\n  return {\n    privateKey,\n    publicKey\n  }\n}\n\nexports.hashAndSign = function (privateKey, msg) {\n  const privateKeyRaw = privateKey.slice(0, KEYS_BYTE_LENGTH)\n\n  return ed.sign(msg, privateKeyRaw)\n}\n\nexports.hashAndVerify = function (publicKey, sig, msg) {\n  return ed.verify(sig, msg, publicKey)\n}\n\nfunction concatKeys (privateKeyRaw, publicKey) {\n  const privateKey = new Uint8Array(exports.privateKeyLength)\n  for (let i = 0; i < KEYS_BYTE_LENGTH; i++) {\n    privateKey[i] = privateKeyRaw[i]\n    privateKey[KEYS_BYTE_LENGTH + i] = publicKey[i]\n  }\n  return privateKey\n}\n"]},"metadata":{},"sourceType":"script"}