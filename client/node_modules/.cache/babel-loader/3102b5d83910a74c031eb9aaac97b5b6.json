{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar dagPB = require('@ipld/dag-pb');\n\nvar ipfsUnixfs = require('ipfs-unixfs');\n\nvar persist = require('./persist.js');\n\nvar hamtSharding = require('hamt-sharding');\n\nvar hamtConstants = require('./hamt-constants.js');\n\nclass Dir {\n  constructor(props, options) {\n    this.options = options || {};\n    this.root = props.root;\n    this.dir = props.dir;\n    this.path = props.path;\n    this.dirty = props.dirty;\n    this.flat = props.flat;\n    this.parent = props.parent;\n    this.parentKey = props.parentKey;\n    this.unixfs = props.unixfs;\n    this.mode = props.mode;\n    this.mtime = props.mtime;\n    this.cid = undefined;\n    this.size = undefined;\n  }\n\n  async put(name, value) {}\n\n  get(name) {\n    return Promise.resolve(this);\n  }\n\n  async *eachChildSeries() {}\n\n  async *flush(blockstore) {}\n\n}\n\nclass DirSharded extends Dir {\n  constructor(props, options) {\n    super(props, options);\n    this._bucket = hamtSharding.createHAMT({\n      hashFn: hamtConstants.hamtHashFn,\n      bits: hamtConstants.hamtBucketBits\n    });\n  }\n\n  async put(name, value) {\n    await this._bucket.put(name, value);\n  }\n\n  get(name) {\n    return this._bucket.get(name);\n  }\n\n  childCount() {\n    return this._bucket.leafCount();\n  }\n\n  directChildrenCount() {\n    return this._bucket.childrenCount();\n  }\n\n  onlyChild() {\n    return this._bucket.onlyChild();\n  }\n\n  async *eachChildSeries() {\n    for await (const {\n      key,\n      value\n    } of this._bucket.eachLeafSeries()) {\n      yield {\n        key,\n        child: value\n      };\n    }\n  }\n\n  async *flush(blockstore) {\n    yield* flush(this._bucket, blockstore, this, this.options);\n  }\n\n}\n\nasync function* flush(bucket, blockstore, shardRoot, options) {\n  const children = bucket._children;\n  const links = [];\n  let childrenSize = 0;\n\n  for (let i = 0; i < children.length; i++) {\n    const child = children.get(i);\n\n    if (!child) {\n      continue;\n    }\n\n    const labelPrefix = i.toString(16).toUpperCase().padStart(2, '0');\n\n    if (child instanceof hamtSharding.Bucket) {\n      let shard;\n\n      for await (const subShard of await flush(child, blockstore, null, options)) {\n        shard = subShard;\n      }\n\n      if (!shard) {\n        throw new Error('Could not flush sharded directory, no subshard found');\n      }\n\n      links.push({\n        Name: labelPrefix,\n        Tsize: shard.size,\n        Hash: shard.cid\n      });\n      childrenSize += shard.size;\n    } else if (typeof child.value.flush === 'function') {\n      const dir = child.value;\n      let flushedDir;\n\n      for await (const entry of dir.flush(blockstore)) {\n        flushedDir = entry;\n        yield flushedDir;\n      }\n\n      const label = labelPrefix + child.key;\n      links.push({\n        Name: label,\n        Tsize: flushedDir.size,\n        Hash: flushedDir.cid\n      });\n      childrenSize += flushedDir.size;\n    } else {\n      const value = child.value;\n\n      if (!value.cid) {\n        continue;\n      }\n\n      const label = labelPrefix + child.key;\n      const size = value.size;\n      links.push({\n        Name: label,\n        Tsize: size,\n        Hash: value.cid\n      });\n      childrenSize += size;\n    }\n  }\n\n  const data = Uint8Array.from(children.bitField().reverse());\n  const dir = new ipfsUnixfs.UnixFS({\n    type: 'hamt-sharded-directory',\n    data,\n    fanout: bucket.tableSize(),\n    hashType: hamtConstants.hamtHashCode,\n    mtime: shardRoot && shardRoot.mtime,\n    mode: shardRoot && shardRoot.mode\n  });\n  const node = {\n    Data: dir.marshal(),\n    Links: links\n  };\n  const buffer = dagPB.encode(dagPB.prepare(node));\n  const cid = await persist.persist(buffer, blockstore, options);\n  const size = buffer.length + childrenSize;\n  yield {\n    cid,\n    node,\n    size\n  };\n}\n\nexports.Dir = Dir;\nexports.DirSharded = DirSharded;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-core/cjs/src/components/files/utils/dir-sharded.js"],"names":["Object","defineProperty","exports","value","dagPB","require","ipfsUnixfs","persist","hamtSharding","hamtConstants","Dir","constructor","props","options","root","dir","path","dirty","flat","parent","parentKey","unixfs","mode","mtime","cid","undefined","size","put","name","get","Promise","resolve","eachChildSeries","flush","blockstore","DirSharded","_bucket","createHAMT","hashFn","hamtHashFn","bits","hamtBucketBits","childCount","leafCount","directChildrenCount","childrenCount","onlyChild","key","eachLeafSeries","child","bucket","shardRoot","children","_children","links","childrenSize","i","length","labelPrefix","toString","toUpperCase","padStart","Bucket","shard","subShard","Error","push","Name","Tsize","Hash","flushedDir","entry","label","data","Uint8Array","from","bitField","reverse","UnixFS","type","fanout","tableSize","hashType","hamtHashCode","node","Data","marshal","Links","buffer","encode","prepare"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar dagPB = require('@ipld/dag-pb');\nvar ipfsUnixfs = require('ipfs-unixfs');\nvar persist = require('./persist.js');\nvar hamtSharding = require('hamt-sharding');\nvar hamtConstants = require('./hamt-constants.js');\n\nclass Dir {\n  constructor(props, options) {\n    this.options = options || {};\n    this.root = props.root;\n    this.dir = props.dir;\n    this.path = props.path;\n    this.dirty = props.dirty;\n    this.flat = props.flat;\n    this.parent = props.parent;\n    this.parentKey = props.parentKey;\n    this.unixfs = props.unixfs;\n    this.mode = props.mode;\n    this.mtime = props.mtime;\n    this.cid = undefined;\n    this.size = undefined;\n  }\n  async put(name, value) {\n  }\n  get(name) {\n    return Promise.resolve(this);\n  }\n  async *eachChildSeries() {\n  }\n  async *flush(blockstore) {\n  }\n}\nclass DirSharded extends Dir {\n  constructor(props, options) {\n    super(props, options);\n    this._bucket = hamtSharding.createHAMT({\n      hashFn: hamtConstants.hamtHashFn,\n      bits: hamtConstants.hamtBucketBits\n    });\n  }\n  async put(name, value) {\n    await this._bucket.put(name, value);\n  }\n  get(name) {\n    return this._bucket.get(name);\n  }\n  childCount() {\n    return this._bucket.leafCount();\n  }\n  directChildrenCount() {\n    return this._bucket.childrenCount();\n  }\n  onlyChild() {\n    return this._bucket.onlyChild();\n  }\n  async *eachChildSeries() {\n    for await (const {key, value} of this._bucket.eachLeafSeries()) {\n      yield {\n        key,\n        child: value\n      };\n    }\n  }\n  async *flush(blockstore) {\n    yield* flush(this._bucket, blockstore, this, this.options);\n  }\n}\nasync function* flush(bucket, blockstore, shardRoot, options) {\n  const children = bucket._children;\n  const links = [];\n  let childrenSize = 0;\n  for (let i = 0; i < children.length; i++) {\n    const child = children.get(i);\n    if (!child) {\n      continue;\n    }\n    const labelPrefix = i.toString(16).toUpperCase().padStart(2, '0');\n    if (child instanceof hamtSharding.Bucket) {\n      let shard;\n      for await (const subShard of await flush(child, blockstore, null, options)) {\n        shard = subShard;\n      }\n      if (!shard) {\n        throw new Error('Could not flush sharded directory, no subshard found');\n      }\n      links.push({\n        Name: labelPrefix,\n        Tsize: shard.size,\n        Hash: shard.cid\n      });\n      childrenSize += shard.size;\n    } else if (typeof child.value.flush === 'function') {\n      const dir = child.value;\n      let flushedDir;\n      for await (const entry of dir.flush(blockstore)) {\n        flushedDir = entry;\n        yield flushedDir;\n      }\n      const label = labelPrefix + child.key;\n      links.push({\n        Name: label,\n        Tsize: flushedDir.size,\n        Hash: flushedDir.cid\n      });\n      childrenSize += flushedDir.size;\n    } else {\n      const value = child.value;\n      if (!value.cid) {\n        continue;\n      }\n      const label = labelPrefix + child.key;\n      const size = value.size;\n      links.push({\n        Name: label,\n        Tsize: size,\n        Hash: value.cid\n      });\n      childrenSize += size;\n    }\n  }\n  const data = Uint8Array.from(children.bitField().reverse());\n  const dir = new ipfsUnixfs.UnixFS({\n    type: 'hamt-sharded-directory',\n    data,\n    fanout: bucket.tableSize(),\n    hashType: hamtConstants.hamtHashCode,\n    mtime: shardRoot && shardRoot.mtime,\n    mode: shardRoot && shardRoot.mode\n  });\n  const node = {\n    Data: dir.marshal(),\n    Links: links\n  };\n  const buffer = dagPB.encode(dagPB.prepare(node));\n  const cid = await persist.persist(buffer, blockstore, options);\n  const size = buffer.length + childrenSize;\n  yield {\n    cid,\n    node,\n    size\n  };\n}\n\nexports.Dir = Dir;\nexports.DirSharded = DirSharded;\n"]},"metadata":{},"sourceType":"script"}