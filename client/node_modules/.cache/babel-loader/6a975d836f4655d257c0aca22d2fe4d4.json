{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar ipfsUnixfsExporter = require('ipfs-unixfs-exporter');\n\nvar errCode = require('err-code');\n\nvar utils = require('../utils.js');\n\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\n\nvar cid = require('multiformats/cid');\n\nvar itTar = require('it-tar');\n\nvar itPipe = require('it-pipe');\n\nvar Pako = require('pako');\n\nvar map = require('it-map');\n\nvar toBuffer = require('it-to-buffer');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\n\nvar Pako__default = /*#__PURE__*/_interopDefaultLegacy(Pako);\n\nvar map__default = /*#__PURE__*/_interopDefaultLegacy(map);\n\nvar toBuffer__default = /*#__PURE__*/_interopDefaultLegacy(toBuffer);\n\nconst DEFAULT_COMPRESSION_LEVEL = 6;\n\nfunction createGet(_ref) {\n  let {\n    repo,\n    preload\n  } = _ref;\n\n  async function* get(ipfsPath) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (options.compressionLevel != null && (options.compressionLevel < -1 || options.compressionLevel > 9)) {\n      throw errCode__default[\"default\"](new Error('Compression level must be between -1 and 9'), 'ERR_INVALID_PARAMS');\n    }\n\n    if (options.preload !== false) {\n      let pathComponents;\n\n      try {\n        pathComponents = utils.normalizeCidPath(ipfsPath).split('/');\n      } catch (err) {\n        throw errCode__default[\"default\"](err, 'ERR_INVALID_PATH');\n      }\n\n      preload(cid.CID.parse(pathComponents[0]));\n    }\n\n    const ipfsPathOrCid = cid.CID.asCID(ipfsPath) || ipfsPath;\n    const file = await ipfsUnixfsExporter.exporter(ipfsPathOrCid, repo.blocks, options);\n\n    if (file.type === 'file' || file.type === 'raw') {\n      const args = [];\n\n      if (!options.compress || options.archive === true) {\n        args.push([{\n          header: {\n            name: file.path,\n            mode: file.type === 'file' && file.unixfs.mode,\n            mtime: file.type === 'file' && file.unixfs.mtime ? new Date(file.unixfs.mtime.secs * 1000) : undefined,\n            size: file.size,\n            type: 'file'\n          },\n          body: file.content()\n        }], itTar.pack(), source => map__default[\"default\"](source, buf => buf.slice()));\n      } else {\n        args.push(file.content);\n      }\n\n      if (options.compress) {\n        args.push(async function* (source) {\n          const buf = await toBuffer__default[\"default\"](source);\n          yield Pako__default[\"default\"].gzip(buf, {\n            level: options.compressionLevel || DEFAULT_COMPRESSION_LEVEL\n          });\n        });\n      }\n\n      yield* itPipe.pipe(...args);\n      return;\n    }\n\n    if (file.type === 'directory') {\n      const args = [ipfsUnixfsExporter.recursive(ipfsPathOrCid, repo.blocks, options), async function* (source) {\n        for await (const entry of source) {\n          const output = {\n            header: {\n              name: entry.path,\n              size: entry.size\n            }\n          };\n\n          if (entry.type === 'file') {\n            output.header.type = 'file';\n            output.header.mode = entry.unixfs.mode != null ? entry.unixfs.mode : undefined;\n            output.header.mtime = entry.unixfs.mtime ? new Date(entry.unixfs.mtime.secs * 1000) : undefined;\n            output.body = entry.content();\n          } else if (entry.type === 'raw') {\n            output.header.type = 'file';\n            output.body = entry.content();\n          } else if (entry.type === 'directory') {\n            output.header.type = 'directory';\n            output.header.mode = entry.unixfs.mode != null ? entry.unixfs.mode : undefined;\n            output.header.mtime = entry.unixfs.mtime ? new Date(entry.unixfs.mtime.secs * 1000) : undefined;\n          } else {\n            throw errCode__default[\"default\"](new Error('Not a UnixFS node'), 'ERR_NOT_UNIXFS');\n          }\n\n          yield output;\n        }\n      }, itTar.pack(), source => map__default[\"default\"](source, buf => buf.slice())];\n\n      if (options.compress) {\n        if (!options.archive) {\n          throw errCode__default[\"default\"](new Error('file is not regular'), 'ERR_INVALID_PATH');\n        }\n\n        if (options.compress) {\n          args.push(async function* (source) {\n            const buf = await toBuffer__default[\"default\"](source);\n            yield Pako__default[\"default\"].gzip(buf, {\n              level: options.compressionLevel || DEFAULT_COMPRESSION_LEVEL\n            });\n          });\n        }\n      }\n\n      yield* itPipe.pipe(...args);\n      return;\n    }\n\n    throw errCode__default[\"default\"](new Error('Not a UnixFS node'), 'ERR_NOT_UNIXFS');\n  }\n\n  return withTimeoutOption.withTimeoutOption(get);\n}\n\nexports.createGet = createGet;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-core/cjs/src/components/get.js"],"names":["Object","defineProperty","exports","value","ipfsUnixfsExporter","require","errCode","utils","withTimeoutOption","cid","itTar","itPipe","Pako","map","toBuffer","_interopDefaultLegacy","e","errCode__default","Pako__default","map__default","toBuffer__default","DEFAULT_COMPRESSION_LEVEL","createGet","repo","preload","get","ipfsPath","options","compressionLevel","Error","pathComponents","normalizeCidPath","split","err","CID","parse","ipfsPathOrCid","asCID","file","exporter","blocks","type","args","compress","archive","push","header","name","path","mode","unixfs","mtime","Date","secs","undefined","size","body","content","pack","source","buf","slice","gzip","level","pipe","recursive","entry","output"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar ipfsUnixfsExporter = require('ipfs-unixfs-exporter');\nvar errCode = require('err-code');\nvar utils = require('../utils.js');\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\nvar cid = require('multiformats/cid');\nvar itTar = require('it-tar');\nvar itPipe = require('it-pipe');\nvar Pako = require('pako');\nvar map = require('it-map');\nvar toBuffer = require('it-to-buffer');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\nvar Pako__default = /*#__PURE__*/_interopDefaultLegacy(Pako);\nvar map__default = /*#__PURE__*/_interopDefaultLegacy(map);\nvar toBuffer__default = /*#__PURE__*/_interopDefaultLegacy(toBuffer);\n\nconst DEFAULT_COMPRESSION_LEVEL = 6;\nfunction createGet({repo, preload}) {\n  async function* get(ipfsPath, options = {}) {\n    if (options.compressionLevel != null && (options.compressionLevel < -1 || options.compressionLevel > 9)) {\n      throw errCode__default[\"default\"](new Error('Compression level must be between -1 and 9'), 'ERR_INVALID_PARAMS');\n    }\n    if (options.preload !== false) {\n      let pathComponents;\n      try {\n        pathComponents = utils.normalizeCidPath(ipfsPath).split('/');\n      } catch (err) {\n        throw errCode__default[\"default\"](err, 'ERR_INVALID_PATH');\n      }\n      preload(cid.CID.parse(pathComponents[0]));\n    }\n    const ipfsPathOrCid = cid.CID.asCID(ipfsPath) || ipfsPath;\n    const file = await ipfsUnixfsExporter.exporter(ipfsPathOrCid, repo.blocks, options);\n    if (file.type === 'file' || file.type === 'raw') {\n      const args = [];\n      if (!options.compress || options.archive === true) {\n        args.push([{\n            header: {\n              name: file.path,\n              mode: file.type === 'file' && file.unixfs.mode,\n              mtime: file.type === 'file' && file.unixfs.mtime ? new Date(file.unixfs.mtime.secs * 1000) : undefined,\n              size: file.size,\n              type: 'file'\n            },\n            body: file.content()\n          }], itTar.pack(), source => map__default[\"default\"](source, buf => buf.slice()));\n      } else {\n        args.push(file.content);\n      }\n      if (options.compress) {\n        args.push(async function* (source) {\n          const buf = await toBuffer__default[\"default\"](source);\n          yield Pako__default[\"default\"].gzip(buf, { level: options.compressionLevel || DEFAULT_COMPRESSION_LEVEL });\n        });\n      }\n      yield* itPipe.pipe(...args);\n      return;\n    }\n    if (file.type === 'directory') {\n      const args = [\n        ipfsUnixfsExporter.recursive(ipfsPathOrCid, repo.blocks, options),\n        async function* (source) {\n          for await (const entry of source) {\n            const output = {\n              header: {\n                name: entry.path,\n                size: entry.size\n              }\n            };\n            if (entry.type === 'file') {\n              output.header.type = 'file';\n              output.header.mode = entry.unixfs.mode != null ? entry.unixfs.mode : undefined;\n              output.header.mtime = entry.unixfs.mtime ? new Date(entry.unixfs.mtime.secs * 1000) : undefined;\n              output.body = entry.content();\n            } else if (entry.type === 'raw') {\n              output.header.type = 'file';\n              output.body = entry.content();\n            } else if (entry.type === 'directory') {\n              output.header.type = 'directory';\n              output.header.mode = entry.unixfs.mode != null ? entry.unixfs.mode : undefined;\n              output.header.mtime = entry.unixfs.mtime ? new Date(entry.unixfs.mtime.secs * 1000) : undefined;\n            } else {\n              throw errCode__default[\"default\"](new Error('Not a UnixFS node'), 'ERR_NOT_UNIXFS');\n            }\n            yield output;\n          }\n        },\n        itTar.pack(),\n        source => map__default[\"default\"](source, buf => buf.slice())\n      ];\n      if (options.compress) {\n        if (!options.archive) {\n          throw errCode__default[\"default\"](new Error('file is not regular'), 'ERR_INVALID_PATH');\n        }\n        if (options.compress) {\n          args.push(async function* (source) {\n            const buf = await toBuffer__default[\"default\"](source);\n            yield Pako__default[\"default\"].gzip(buf, { level: options.compressionLevel || DEFAULT_COMPRESSION_LEVEL });\n          });\n        }\n      }\n      yield* itPipe.pipe(...args);\n      return;\n    }\n    throw errCode__default[\"default\"](new Error('Not a UnixFS node'), 'ERR_NOT_UNIXFS');\n  }\n  return withTimeoutOption.withTimeoutOption(get);\n}\n\nexports.createGet = createGet;\n"]},"metadata":{},"sourceType":"script"}