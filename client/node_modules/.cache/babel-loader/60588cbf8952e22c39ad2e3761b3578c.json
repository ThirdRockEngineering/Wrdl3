{"ast":null,"code":"'use strict';\n\nconst {\n  Record\n} = require('libp2p-record');\n\nconst errcode = require('err-code');\n\nconst {\n  Message\n} = require('../../message');\n\nconst {\n  MAX_RECORD_AGE\n} = require('../../constants');\n\nconst utils = require('../../utils');\n\nconst log = utils.logger('libp2p:kad-dht:rpc:handlers:get-value');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../types').DHTMessageHandler} DHTMessageHandler\n * @typedef {import('libp2p-interfaces/src/keys/types').PublicKey} PublicKey\n */\n\n/**\n * @implements {DHTMessageHandler}\n */\n\nclass GetValueHandler {\n  /**\n   * @param {object} params\n   * @param {PeerId} params.peerId\n   * @param {import('libp2p/src/peer-store/types').PeerStore} params.peerStore\n   * @param {import('../../peer-routing').PeerRouting} params.peerRouting\n   * @param {import('interface-datastore').Datastore} params.records\n   */\n  constructor(_ref) {\n    let {\n      peerId,\n      peerStore,\n      peerRouting,\n      records\n    } = _ref;\n    this._peerId = peerId;\n    this._peerStore = peerStore;\n    this._peerRouting = peerRouting;\n    this._records = records;\n  }\n  /**\n   * Process `GetValue` DHT messages.\n   *\n   * @param {PeerId} peerId\n   * @param {Message} msg\n   */\n\n\n  async handle(peerId, msg) {\n    const key = msg.key;\n    log('%p asked for key %b', peerId, key);\n\n    if (!key || key.length === 0) {\n      throw errcode(new Error('Invalid key'), 'ERR_INVALID_KEY');\n    }\n\n    const response = new Message(Message.TYPES.GET_VALUE, key, msg.clusterLevel);\n\n    if (utils.isPublicKeyKey(key)) {\n      log('is public key');\n      const idFromKey = utils.fromPublicKeyKey(key);\n      /** @type {PublicKey | undefined} */\n\n      let pubKey;\n\n      if (this._peerId.equals(idFromKey)) {\n        pubKey = this._peerId.pubKey;\n      } else {\n        try {\n          pubKey = await this._peerStore.keyBook.get(idFromKey);\n        } catch (\n        /** @type {any} */\n        err) {\n          if (err.code !== 'ERR_NOT_FOUND') {\n            throw err;\n          }\n        }\n      }\n\n      if (pubKey != null) {\n        log('returning found public key');\n        response.record = new Record(key, pubKey.bytes);\n        return response;\n      }\n    }\n\n    const [record, closer] = await Promise.all([this._checkLocalDatastore(key), this._peerRouting.getCloserPeersOffline(msg.key, peerId)]);\n\n    if (record) {\n      log('had record for %b in local datastore', key);\n      response.record = record;\n    }\n\n    if (closer.length > 0) {\n      log('had %s closer peers in routing table', closer.length);\n      response.closerPeers = closer;\n    }\n\n    return response;\n  }\n  /**\n   * Try to fetch a given record by from the local datastore.\n   * Returns the record iff it is still valid, meaning\n   * - it was either authored by this node, or\n   * - it was received less than `MAX_RECORD_AGE` ago.\n   *\n   * @param {Uint8Array} key\n   */\n\n\n  async _checkLocalDatastore(key) {\n    log('checkLocalDatastore looking for %b', key);\n    const dsKey = utils.bufferToKey(key); // Fetch value from ds\n\n    let rawRecord;\n\n    try {\n      rawRecord = await this._records.get(dsKey);\n    } catch (\n    /** @type {any} */\n    err) {\n      if (err.code === 'ERR_NOT_FOUND') {\n        return undefined;\n      }\n\n      throw err;\n    } // Create record from the returned bytes\n\n\n    const record = Record.deserialize(rawRecord);\n\n    if (!record) {\n      throw errcode(new Error('Invalid record'), 'ERR_INVALID_RECORD');\n    } // Check validity: compare time received with max record age\n\n\n    if (record.timeReceived == null || Date.now() - record.timeReceived.getTime() > MAX_RECORD_AGE) {\n      // If record is bad delete it and return\n      await this._records.delete(dsKey);\n      return undefined;\n    } // Record is valid\n\n\n    return record;\n  }\n\n}\n\nmodule.exports.GetValueHandler = GetValueHandler;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p-kad-dht/src/rpc/handlers/get-value.js"],"names":["Record","require","errcode","Message","MAX_RECORD_AGE","utils","log","logger","GetValueHandler","constructor","peerId","peerStore","peerRouting","records","_peerId","_peerStore","_peerRouting","_records","handle","msg","key","length","Error","response","TYPES","GET_VALUE","clusterLevel","isPublicKeyKey","idFromKey","fromPublicKeyKey","pubKey","equals","keyBook","get","err","code","record","bytes","closer","Promise","all","_checkLocalDatastore","getCloserPeersOffline","closerPeers","dsKey","bufferToKey","rawRecord","undefined","deserialize","timeReceived","Date","now","getTime","delete","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Record } = require('libp2p-record')\nconst errcode = require('err-code')\nconst { Message } = require('../../message')\nconst {\n  MAX_RECORD_AGE\n} = require('../../constants')\nconst utils = require('../../utils')\n\nconst log = utils.logger('libp2p:kad-dht:rpc:handlers:get-value')\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../types').DHTMessageHandler} DHTMessageHandler\n * @typedef {import('libp2p-interfaces/src/keys/types').PublicKey} PublicKey\n */\n\n/**\n * @implements {DHTMessageHandler}\n */\nclass GetValueHandler {\n  /**\n   * @param {object} params\n   * @param {PeerId} params.peerId\n   * @param {import('libp2p/src/peer-store/types').PeerStore} params.peerStore\n   * @param {import('../../peer-routing').PeerRouting} params.peerRouting\n   * @param {import('interface-datastore').Datastore} params.records\n   */\n  constructor ({ peerId, peerStore, peerRouting, records }) {\n    this._peerId = peerId\n    this._peerStore = peerStore\n    this._peerRouting = peerRouting\n    this._records = records\n  }\n\n  /**\n   * Process `GetValue` DHT messages.\n   *\n   * @param {PeerId} peerId\n   * @param {Message} msg\n   */\n  async handle (peerId, msg) {\n    const key = msg.key\n\n    log('%p asked for key %b', peerId, key)\n\n    if (!key || key.length === 0) {\n      throw errcode(new Error('Invalid key'), 'ERR_INVALID_KEY')\n    }\n\n    const response = new Message(Message.TYPES.GET_VALUE, key, msg.clusterLevel)\n\n    if (utils.isPublicKeyKey(key)) {\n      log('is public key')\n      const idFromKey = utils.fromPublicKeyKey(key)\n      /** @type {PublicKey | undefined} */\n      let pubKey\n\n      if (this._peerId.equals(idFromKey)) {\n        pubKey = this._peerId.pubKey\n      } else {\n        try {\n          pubKey = await this._peerStore.keyBook.get(idFromKey)\n        } catch (/** @type {any} */ err) {\n          if (err.code !== 'ERR_NOT_FOUND') {\n            throw err\n          }\n        }\n      }\n\n      if (pubKey != null) {\n        log('returning found public key')\n        response.record = new Record(key, pubKey.bytes)\n        return response\n      }\n    }\n\n    const [record, closer] = await Promise.all([\n      this._checkLocalDatastore(key),\n      this._peerRouting.getCloserPeersOffline(msg.key, peerId)\n    ])\n\n    if (record) {\n      log('had record for %b in local datastore', key)\n      response.record = record\n    }\n\n    if (closer.length > 0) {\n      log('had %s closer peers in routing table', closer.length)\n      response.closerPeers = closer\n    }\n\n    return response\n  }\n\n  /**\n   * Try to fetch a given record by from the local datastore.\n   * Returns the record iff it is still valid, meaning\n   * - it was either authored by this node, or\n   * - it was received less than `MAX_RECORD_AGE` ago.\n   *\n   * @param {Uint8Array} key\n   */\n  async _checkLocalDatastore (key) {\n    log('checkLocalDatastore looking for %b', key)\n    const dsKey = utils.bufferToKey(key)\n\n    // Fetch value from ds\n    let rawRecord\n    try {\n      rawRecord = await this._records.get(dsKey)\n    } catch (/** @type {any} */ err) {\n      if (err.code === 'ERR_NOT_FOUND') {\n        return undefined\n      }\n      throw err\n    }\n\n    // Create record from the returned bytes\n    const record = Record.deserialize(rawRecord)\n\n    if (!record) {\n      throw errcode(new Error('Invalid record'), 'ERR_INVALID_RECORD')\n    }\n\n    // Check validity: compare time received with max record age\n    if (record.timeReceived == null ||\n      Date.now() - record.timeReceived.getTime() > MAX_RECORD_AGE) {\n      // If record is bad delete it and return\n      await this._records.delete(dsKey)\n      return undefined\n    }\n\n    // Record is valid\n    return record\n  }\n}\n\nmodule.exports.GetValueHandler = GetValueHandler\n"]},"metadata":{},"sourceType":"script"}