{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar $protobuf = require('protobufjs/minimal.js');\n\nvar key = require('interface-datastore/key');\n\nvar protoBook = require('./pb/proto-book.js');\n\nvar addressBook = require('./pb/address-book.js');\n\nvar peer = require('./pb/peer.js');\n\nvar envelope = require('./pb/envelope.js');\n\nvar peerRecord = require('./pb/peer-record.js');\n\nvar multiaddr = require('multiaddr');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar $protobuf__default = /*#__PURE__*/_interopDefaultLegacy($protobuf);\n\n$protobuf__default[\"default\"].util.Long = undefined;\n$protobuf__default[\"default\"].configure();\n\nasync function storePeerUnderSingleDatastoreKey(backends) {\n  let onProgress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};\n  onProgress(0, 'Storing each peerstore key under a single datastore key');\n  await backends.datastore.open();\n  const peers = {};\n  const keys = [];\n\n  for await (const {\n    key,\n    value\n  } of backends.datastore.query({\n    prefix: '/peers'\n  })) {\n    keys.push(key);\n    const keyStr = key.toString();\n    const [_, prefix, type, peerId, metadataKey] = keyStr.split('/');\n\n    if (prefix !== 'peers') {\n      continue;\n    }\n\n    if (!['protos', 'addrs', 'metadata', 'keys'].includes(type)) {\n      continue;\n    }\n\n    if (!peerId) {\n      continue;\n    }\n\n    peers[peerId] = peers[peerId] || {\n      addresses: [],\n      protocols: [],\n      metadata: []\n    };\n\n    if (type === 'protos') {\n      const protos = protoBook.Protocols.decode(value);\n      peers[peerId].protocols = protos.protocols.sort();\n    } else if (type === 'addrs') {\n      const addrs = addressBook.Addresses.decode(value);\n      peers[peerId].addresses = addrs.addrs.sort((a, b) => {\n        return new multiaddr.Multiaddr(a.multiaddr).toString().localeCompare(new multiaddr.Multiaddr(b.multiaddr).toString());\n      });\n\n      if (addrs.certifiedRecord && addrs.certifiedRecord.raw) {\n        peers[peerId].peerRecordEnvelope = addrs.certifiedRecord.raw;\n      }\n    } else if (type === 'metadata') {\n      peers[peerId].metadata.push({\n        key: metadataKey,\n        value\n      });\n    } else if (type === 'keys') {\n      peers[peerId].pubKey = value;\n    }\n  }\n\n  onProgress(33, 'Read peer data from store');\n\n  for (const key of keys) {\n    await backends.datastore.delete(key);\n  }\n\n  onProgress(66, 'Removed existing peer data from store');\n\n  for (const peerId of Object.keys(peers)) {\n    const peer$1 = peers[peerId];\n    peer$1.metadata = peer$1.metadata.sort((a, b) => a.key.localeCompare(b.key));\n    const data = peer.Peer.encode(peer$1).finish();\n    await backends.datastore.put(new key.Key(`/peers/${peerId}`), data);\n  }\n\n  await backends.datastore.close();\n  onProgress(100, 'Stored each peerstore key under a single datastore key');\n}\n\nasync function storePeerUnderMultipleDatastoreKeys(backends) {\n  let onProgress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};\n  onProgress(0, 'Storing each peerstore key under a multiple datastore keys');\n  await backends.datastore.open();\n  const peers = {};\n  const keys = [];\n\n  for await (const {\n    key,\n    value\n  } of backends.datastore.query({\n    prefix: '/peers'\n  })) {\n    keys.push(key);\n    const keyStr = key.toString();\n    const [_, _prefix, peerId] = keyStr.split('/');\n    peers[peerId] = peer.Peer.decode(value);\n  }\n\n  onProgress(33, 'Read peer data from store');\n\n  for (const key of keys) {\n    await backends.datastore.delete(key);\n  }\n\n  onProgress(66, 'Removed existing peer data from store');\n\n  for (const [peerId, peer] of Object.entries(peers)) {\n    if (peer.protocols && peer.protocols.length > 0) {\n      await backends.datastore.put(new key.Key(`/peers/protos/${peerId}`), protoBook.Protocols.encode({\n        protocols: peer.protocols\n      }).finish());\n    }\n\n    if (peer.addresses && peer.addresses.length > 0) {\n      const peerRecordEnvelope = peer.peerRecordEnvelope;\n      let certifiedRecord;\n\n      if (peerRecordEnvelope) {\n        const envelope$1 = envelope.Envelope.decode(peerRecordEnvelope);\n        const record = peerRecord.PeerRecord.decode(envelope$1.payload);\n        certifiedRecord = {\n          raw: peerRecordEnvelope,\n          seq: record.seq\n        };\n      }\n\n      await backends.datastore.put(new key.Key(`/peers/addrs/${peerId}`), addressBook.Addresses.encode({\n        addrs: peer.addresses,\n        certifiedRecord\n      }).finish());\n    }\n\n    if (peer.metadata && peer.metadata.length > 0) {\n      for (const {\n        key: key$1,\n        value\n      } of peer.metadata) {\n        await backends.datastore.put(new key.Key(`/peers/metadata/${peerId}/${key$1}`), value);\n      }\n    }\n\n    if (peer.pubKey) {\n      await backends.datastore.put(new key.Key(`/peers/keys/${peerId}`), peer.pubKey);\n    }\n  }\n\n  await backends.datastore.close();\n  onProgress(100, 'Stored each peerstore key under multiple datastore keys');\n}\n\nconst migration = {\n  version: 12,\n  description: 'Store each peerstore peer under a single datastore key',\n  migrate: storePeerUnderSingleDatastoreKey,\n  revert: storePeerUnderMultipleDatastoreKeys\n};\nexports.migration = migration;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-repo-migrations/cjs/migrations/migration-12/index.js"],"names":["Object","defineProperty","exports","value","$protobuf","require","key","protoBook","addressBook","peer","envelope","peerRecord","multiaddr","_interopDefaultLegacy","e","$protobuf__default","util","Long","undefined","configure","storePeerUnderSingleDatastoreKey","backends","onProgress","datastore","open","peers","keys","query","prefix","push","keyStr","toString","_","type","peerId","metadataKey","split","includes","addresses","protocols","metadata","protos","Protocols","decode","sort","addrs","Addresses","a","b","Multiaddr","localeCompare","certifiedRecord","raw","peerRecordEnvelope","pubKey","delete","peer$1","data","Peer","encode","finish","put","Key","close","storePeerUnderMultipleDatastoreKeys","_prefix","entries","length","envelope$1","Envelope","record","PeerRecord","payload","seq","key$1","migration","version","description","migrate","revert"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar $protobuf = require('protobufjs/minimal.js');\nvar key = require('interface-datastore/key');\nvar protoBook = require('./pb/proto-book.js');\nvar addressBook = require('./pb/address-book.js');\nvar peer = require('./pb/peer.js');\nvar envelope = require('./pb/envelope.js');\nvar peerRecord = require('./pb/peer-record.js');\nvar multiaddr = require('multiaddr');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar $protobuf__default = /*#__PURE__*/_interopDefaultLegacy($protobuf);\n\n$protobuf__default[\"default\"].util.Long = undefined;\n$protobuf__default[\"default\"].configure();\nasync function storePeerUnderSingleDatastoreKey(backends, onProgress = () => {\n}) {\n  onProgress(0, 'Storing each peerstore key under a single datastore key');\n  await backends.datastore.open();\n  const peers = {};\n  const keys = [];\n  for await (const {key, value} of backends.datastore.query({ prefix: '/peers' })) {\n    keys.push(key);\n    const keyStr = key.toString();\n    const [_, prefix, type, peerId, metadataKey] = keyStr.split('/');\n    if (prefix !== 'peers') {\n      continue;\n    }\n    if (![\n        'protos',\n        'addrs',\n        'metadata',\n        'keys'\n      ].includes(type)) {\n      continue;\n    }\n    if (!peerId) {\n      continue;\n    }\n    peers[peerId] = peers[peerId] || {\n      addresses: [],\n      protocols: [],\n      metadata: []\n    };\n    if (type === 'protos') {\n      const protos = protoBook.Protocols.decode(value);\n      peers[peerId].protocols = protos.protocols.sort();\n    } else if (type === 'addrs') {\n      const addrs = addressBook.Addresses.decode(value);\n      peers[peerId].addresses = addrs.addrs.sort((a, b) => {\n        return new multiaddr.Multiaddr(a.multiaddr).toString().localeCompare(new multiaddr.Multiaddr(b.multiaddr).toString());\n      });\n      if (addrs.certifiedRecord && addrs.certifiedRecord.raw) {\n        peers[peerId].peerRecordEnvelope = addrs.certifiedRecord.raw;\n      }\n    } else if (type === 'metadata') {\n      peers[peerId].metadata.push({\n        key: metadataKey,\n        value\n      });\n    } else if (type === 'keys') {\n      peers[peerId].pubKey = value;\n    }\n  }\n  onProgress(33, 'Read peer data from store');\n  for (const key of keys) {\n    await backends.datastore.delete(key);\n  }\n  onProgress(66, 'Removed existing peer data from store');\n  for (const peerId of Object.keys(peers)) {\n    const peer$1 = peers[peerId];\n    peer$1.metadata = peer$1.metadata.sort((a, b) => a.key.localeCompare(b.key));\n    const data = peer.Peer.encode(peer$1).finish();\n    await backends.datastore.put(new key.Key(`/peers/${ peerId }`), data);\n  }\n  await backends.datastore.close();\n  onProgress(100, 'Stored each peerstore key under a single datastore key');\n}\nasync function storePeerUnderMultipleDatastoreKeys(backends, onProgress = () => {\n}) {\n  onProgress(0, 'Storing each peerstore key under a multiple datastore keys');\n  await backends.datastore.open();\n  const peers = {};\n  const keys = [];\n  for await (const {key, value} of backends.datastore.query({ prefix: '/peers' })) {\n    keys.push(key);\n    const keyStr = key.toString();\n    const [_, _prefix, peerId] = keyStr.split('/');\n    peers[peerId] = peer.Peer.decode(value);\n  }\n  onProgress(33, 'Read peer data from store');\n  for (const key of keys) {\n    await backends.datastore.delete(key);\n  }\n  onProgress(66, 'Removed existing peer data from store');\n  for (const [peerId, peer] of Object.entries(peers)) {\n    if (peer.protocols && peer.protocols.length > 0) {\n      await backends.datastore.put(new key.Key(`/peers/protos/${ peerId }`), protoBook.Protocols.encode({ protocols: peer.protocols }).finish());\n    }\n    if (peer.addresses && peer.addresses.length > 0) {\n      const peerRecordEnvelope = peer.peerRecordEnvelope;\n      let certifiedRecord;\n      if (peerRecordEnvelope) {\n        const envelope$1 = envelope.Envelope.decode(peerRecordEnvelope);\n        const record = peerRecord.PeerRecord.decode(envelope$1.payload);\n        certifiedRecord = {\n          raw: peerRecordEnvelope,\n          seq: record.seq\n        };\n      }\n      await backends.datastore.put(new key.Key(`/peers/addrs/${ peerId }`), addressBook.Addresses.encode({\n        addrs: peer.addresses,\n        certifiedRecord\n      }).finish());\n    }\n    if (peer.metadata && peer.metadata.length > 0) {\n      for (const {key: key$1, value} of peer.metadata) {\n        await backends.datastore.put(new key.Key(`/peers/metadata/${ peerId }/${ key$1 }`), value);\n      }\n    }\n    if (peer.pubKey) {\n      await backends.datastore.put(new key.Key(`/peers/keys/${ peerId }`), peer.pubKey);\n    }\n  }\n  await backends.datastore.close();\n  onProgress(100, 'Stored each peerstore key under multiple datastore keys');\n}\nconst migration = {\n  version: 12,\n  description: 'Store each peerstore peer under a single datastore key',\n  migrate: storePeerUnderSingleDatastoreKey,\n  revert: storePeerUnderMultipleDatastoreKeys\n};\n\nexports.migration = migration;\n"]},"metadata":{},"sourceType":"script"}