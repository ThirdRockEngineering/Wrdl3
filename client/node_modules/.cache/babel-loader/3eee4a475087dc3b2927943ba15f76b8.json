{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar normaliseInput = require('ipfs-core-utils/pins/normalise-input');\n\nvar utils = require('../../utils.js');\n\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\n\nvar pinTypes = require('ipfs-repo/pin-types');\n\nfunction createRmAll(_ref) {\n  let {\n    repo,\n    codecs\n  } = _ref;\n\n  async function* rmAll(source) {\n    let _options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    const release = await repo.gcLock.readLock();\n\n    try {\n      for await (const {\n        path,\n        recursive\n      } of normaliseInput.normaliseInput(source)) {\n        const {\n          cid\n        } = await utils.resolvePath(repo, codecs, path);\n        const {\n          pinned,\n          reason\n        } = await repo.pins.isPinnedWithType(cid, pinTypes.PinTypes.all);\n\n        if (!pinned) {\n          throw new Error(`${cid} is not pinned`);\n        }\n\n        switch (reason) {\n          case pinTypes.PinTypes.recursive:\n            if (!recursive) {\n              throw new Error(`${cid} is pinned recursively`);\n            }\n\n            await repo.pins.unpin(cid);\n            yield cid;\n            break;\n\n          case pinTypes.PinTypes.direct:\n            await repo.pins.unpin(cid);\n            yield cid;\n            break;\n\n          default:\n            throw new Error(`${cid} is pinned indirectly under ${reason}`);\n        }\n      }\n    } finally {\n      release();\n    }\n  }\n\n  return withTimeoutOption.withTimeoutOption(rmAll);\n}\n\nexports.createRmAll = createRmAll;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-core/cjs/src/components/pin/rm-all.js"],"names":["Object","defineProperty","exports","value","normaliseInput","require","utils","withTimeoutOption","pinTypes","createRmAll","repo","codecs","rmAll","source","_options","release","gcLock","readLock","path","recursive","cid","resolvePath","pinned","reason","pins","isPinnedWithType","PinTypes","all","Error","unpin","direct"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AAEA,IAAIC,cAAc,GAAGC,OAAO,CAAC,sCAAD,CAA5B;;AACA,IAAIC,KAAK,GAAGD,OAAO,CAAC,gBAAD,CAAnB;;AACA,IAAIE,iBAAiB,GAAGF,OAAO,CAAC,qCAAD,CAA/B;;AACA,IAAIG,QAAQ,GAAGH,OAAO,CAAC,qBAAD,CAAtB;;AAEA,SAASI,WAAT,OAAqC;AAAA,MAAhB;AAACC,IAAAA,IAAD;AAAOC,IAAAA;AAAP,GAAgB;;AACnC,kBAAgBC,KAAhB,CAAsBC,MAAtB,EAA6C;AAAA,QAAfC,QAAe,uEAAJ,EAAI;;AAC3C,UAAMC,OAAO,GAAG,MAAML,IAAI,CAACM,MAAL,CAAYC,QAAZ,EAAtB;;AACA,QAAI;AACF,iBAAW,MAAM;AAACC,QAAAA,IAAD;AAAOC,QAAAA;AAAP,OAAjB,IAAsCf,cAAc,CAACA,cAAf,CAA8BS,MAA9B,CAAtC,EAA6E;AAC3E,cAAM;AAACO,UAAAA;AAAD,YAAQ,MAAMd,KAAK,CAACe,WAAN,CAAkBX,IAAlB,EAAwBC,MAAxB,EAAgCO,IAAhC,CAApB;AACA,cAAM;AAACI,UAAAA,MAAD;AAASC,UAAAA;AAAT,YAAmB,MAAMb,IAAI,CAACc,IAAL,CAAUC,gBAAV,CAA2BL,GAA3B,EAAgCZ,QAAQ,CAACkB,QAAT,CAAkBC,GAAlD,CAA/B;;AACA,YAAI,CAACL,MAAL,EAAa;AACX,gBAAM,IAAIM,KAAJ,CAAW,GAAGR,GAAK,gBAAnB,CAAN;AACD;;AACD,gBAAQG,MAAR;AACA,eAAKf,QAAQ,CAACkB,QAAT,CAAkBP,SAAvB;AACE,gBAAI,CAACA,SAAL,EAAgB;AACd,oBAAM,IAAIS,KAAJ,CAAW,GAAGR,GAAK,wBAAnB,CAAN;AACD;;AACD,kBAAMV,IAAI,CAACc,IAAL,CAAUK,KAAV,CAAgBT,GAAhB,CAAN;AACA,kBAAMA,GAAN;AACA;;AACF,eAAKZ,QAAQ,CAACkB,QAAT,CAAkBI,MAAvB;AACE,kBAAMpB,IAAI,CAACc,IAAL,CAAUK,KAAV,CAAgBT,GAAhB,CAAN;AACA,kBAAMA,GAAN;AACA;;AACF;AACE,kBAAM,IAAIQ,KAAJ,CAAW,GAAGR,GAAK,+BAA+BG,MAAQ,EAA1D,CAAN;AAbF;AAeD;AACF,KAvBD,SAuBU;AACRR,MAAAA,OAAO;AACR;AACF;;AACD,SAAOR,iBAAiB,CAACA,iBAAlB,CAAoCK,KAApC,CAAP;AACD;;AAEDV,OAAO,CAACO,WAAR,GAAsBA,WAAtB","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar normaliseInput = require('ipfs-core-utils/pins/normalise-input');\nvar utils = require('../../utils.js');\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\nvar pinTypes = require('ipfs-repo/pin-types');\n\nfunction createRmAll({repo, codecs}) {\n  async function* rmAll(source, _options = {}) {\n    const release = await repo.gcLock.readLock();\n    try {\n      for await (const {path, recursive} of normaliseInput.normaliseInput(source)) {\n        const {cid} = await utils.resolvePath(repo, codecs, path);\n        const {pinned, reason} = await repo.pins.isPinnedWithType(cid, pinTypes.PinTypes.all);\n        if (!pinned) {\n          throw new Error(`${ cid } is not pinned`);\n        }\n        switch (reason) {\n        case pinTypes.PinTypes.recursive:\n          if (!recursive) {\n            throw new Error(`${ cid } is pinned recursively`);\n          }\n          await repo.pins.unpin(cid);\n          yield cid;\n          break;\n        case pinTypes.PinTypes.direct:\n          await repo.pins.unpin(cid);\n          yield cid;\n          break;\n        default:\n          throw new Error(`${ cid } is pinned indirectly under ${ reason }`);\n        }\n      }\n    } finally {\n      release();\n    }\n  }\n  return withTimeoutOption.withTimeoutOption(rmAll);\n}\n\nexports.createRmAll = createRmAll;\n"]},"metadata":{},"sourceType":"script"}