{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar debug = require('debug');\n\nvar ipfsUnixfsImporter = require('ipfs-unixfs-importer');\n\nvar dagPB = require('@ipld/dag-pb');\n\nvar stat = require('./stat.js');\n\nvar mkdir = require('./mkdir.js');\n\nvar addLink = require('./utils/add-link.js');\n\nvar mergeOpts = require('merge-options');\n\nvar createLock = require('./utils/create-lock.js');\n\nvar toAsyncIterator = require('./utils/to-async-iterator.js');\n\nvar toMfsPath = require('./utils/to-mfs-path.js');\n\nvar toPathComponents = require('./utils/to-path-components.js');\n\nvar toTrail = require('./utils/to-trail.js');\n\nvar updateTree = require('./utils/update-tree.js');\n\nvar updateMfsRoot = require('./utils/update-mfs-root.js');\n\nvar errCode = require('err-code');\n\nvar utils = require('../../utils.js');\n\nvar last = require('it-last');\n\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\n\nvar ipfsUnixfs = require('ipfs-unixfs');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\n\nvar mergeOpts__default = /*#__PURE__*/_interopDefaultLegacy(mergeOpts);\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\n\nvar last__default = /*#__PURE__*/_interopDefaultLegacy(last);\n\nconst mergeOptions = mergeOpts__default[\"default\"].bind({\n  ignoreUndefined: true\n});\nconst log = debug__default[\"default\"]('ipfs:mfs:write');\nconst defaultOptions = {\n  offset: 0,\n  length: Infinity,\n  create: false,\n  truncate: false,\n  rawLeaves: false,\n  reduceSingleLeafToSelf: false,\n  cidVersion: 0,\n  hashAlg: 'sha2-256',\n  parents: false,\n  progress: (bytes, path) => {},\n  strategy: 'trickle',\n  flush: true,\n  leafType: 'raw',\n  shardSplitThreshold: 1000\n};\n\nfunction createWrite(context) {\n  async function mfsWrite(path, content) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const options = mergeOptions(defaultOptions, opts);\n    let source;\n    let destination;\n    let parent;\n    log('Reading source, destination and parent');\n    await createLock.createLock().readLock(async () => {\n      source = await toAsyncIterator.toAsyncIterator(content);\n      destination = await toMfsPath.toMfsPath(context, path, options);\n      parent = await toMfsPath.toMfsPath(context, destination.mfsDirectory, options);\n    })();\n    log('Read source, destination and parent');\n\n    if (!options.parents && !parent.exists) {\n      throw errCode__default[\"default\"](new Error('directory does not exist'), 'ERR_NO_EXIST');\n    }\n\n    if (source == null) {\n      throw errCode__default[\"default\"](new Error('could not create source'), 'ERR_NO_SOURCE');\n    }\n\n    if (destination == null) {\n      throw errCode__default[\"default\"](new Error('could not create destination'), 'ERR_NO_DESTINATION');\n    }\n\n    if (!options.create && !destination.exists) {\n      throw errCode__default[\"default\"](new Error('file does not exist'), 'ERR_NO_EXIST');\n    }\n\n    if (destination.entryType !== 'file') {\n      throw errCode__default[\"default\"](new Error('not a file'), 'ERR_NOT_A_FILE');\n    }\n\n    return updateOrImport(context, path, source, destination, options);\n  }\n\n  return withTimeoutOption.withTimeoutOption(mfsWrite);\n}\n\nconst updateOrImport = async (context, path, source, destination, options) => {\n  const child = await write(context, source, destination, options);\n  await createLock.createLock().writeLock(async () => {\n    const pathComponents = toPathComponents.toPathComponents(path);\n    const fileName = pathComponents.pop();\n\n    if (fileName == null) {\n      throw errCode__default[\"default\"](new Error('source does not exist'), 'ERR_NO_EXIST');\n    }\n\n    let parentExists = false;\n\n    try {\n      await stat.createStat(context)(`/${pathComponents.join('/')}`, options);\n      parentExists = true;\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        throw err;\n      }\n    }\n\n    if (!parentExists) {\n      await mkdir.createMkdir(context)(`/${pathComponents.join('/')}`, options);\n    }\n\n    const updatedPath = await toMfsPath.toMfsPath(context, path, options);\n    const trail = await toTrail.toTrail(context, updatedPath.mfsDirectory);\n    const parent = trail[trail.length - 1];\n\n    if (!parent) {\n      throw errCode__default[\"default\"](new Error('directory does not exist'), 'ERR_NO_EXIST');\n    }\n\n    if (!parent.type || !parent.type.includes('directory')) {\n      throw errCode__default[\"default\"](new Error(`cannot write to ${parent.name}: Not a directory`), 'ERR_NOT_A_DIRECTORY');\n    }\n\n    const parentBlock = await context.repo.blocks.get(parent.cid);\n    const parentNode = dagPB.decode(parentBlock);\n    const result = await addLink.addLink(context, {\n      parent: parentNode,\n      name: fileName,\n      cid: child.cid,\n      size: child.size,\n      flush: options.flush,\n      shardSplitThreshold: options.shardSplitThreshold,\n      hashAlg: options.hashAlg,\n      cidVersion: options.cidVersion\n    });\n    parent.cid = result.cid;\n    const newRootCid = await updateTree.updateTree(context, trail, options);\n    await updateMfsRoot.updateMfsRoot(context, newRootCid, options);\n  })();\n};\n\nconst write = async (context, source, destination, options) => {\n  if (destination.exists) {\n    log(`Overwriting file ${destination.cid} offset ${options.offset} length ${options.length}`);\n  } else {\n    log(`Writing file offset ${options.offset} length ${options.length}`);\n  }\n\n  const sources = [];\n\n  if (options.offset > 0) {\n    if (destination.unixfs) {\n      log(`Writing first ${options.offset} bytes of original file`);\n      sources.push(() => {\n        return destination.content({\n          offset: 0,\n          length: options.offset\n        });\n      });\n\n      if (destination.unixfs.fileSize() < options.offset) {\n        const extra = options.offset - destination.unixfs.fileSize();\n        log(`Writing zeros for extra ${extra} bytes`);\n        sources.push(asyncZeroes(extra));\n      }\n    } else {\n      log(`Writing zeros for first ${options.offset} bytes`);\n      sources.push(asyncZeroes(options.offset));\n    }\n  }\n\n  sources.push(limitAsyncStreamBytes(source, options.length));\n  const content = countBytesStreamed(catAsyncIterators(sources), bytesWritten => {\n    if (destination.unixfs && !options.truncate) {\n      const fileSize = destination.unixfs.fileSize();\n\n      if (fileSize > bytesWritten) {\n        log(`Writing last ${fileSize - bytesWritten} of ${fileSize} bytes from original file starting at offset ${bytesWritten}`);\n        return destination.content({\n          offset: bytesWritten\n        });\n      } else {\n        log('Not writing last bytes from original file');\n      }\n    }\n\n    return {\n      [Symbol.asyncIterator]: async function* () {}\n    };\n  });\n  let mode;\n\n  if (options.mode !== undefined && options.mode !== null) {\n    mode = ipfsUnixfs.parseMode(options.mode);\n  } else if (destination && destination.unixfs) {\n    mode = destination.unixfs.mode;\n  }\n\n  let mtime;\n\n  if (options.mtime != null) {\n    mtime = ipfsUnixfs.parseMtime(options.mtime);\n  } else if (destination && destination.unixfs) {\n    mtime = destination.unixfs.mtime;\n  }\n\n  const hasher = await context.hashers.getHasher(options.hashAlg);\n  const result = await last__default[\"default\"](ipfsUnixfsImporter.importer([{\n    content: content,\n    mode,\n    mtime\n  }], context.repo.blocks, {\n    progress: options.progress,\n    hasher,\n    cidVersion: options.cidVersion,\n    strategy: options.strategy,\n    rawLeaves: options.rawLeaves,\n    reduceSingleLeafToSelf: options.reduceSingleLeafToSelf,\n    leafType: options.leafType\n  }));\n\n  if (!result) {\n    throw errCode__default[\"default\"](new Error(`cannot write to ${parent.name}`), 'ERR_COULD_NOT_WRITE');\n  }\n\n  log(`Wrote ${result.cid}`);\n  return {\n    cid: result.cid,\n    size: result.size\n  };\n};\n\nconst limitAsyncStreamBytes = (stream, limit) => {\n  return async function* _limitAsyncStreamBytes() {\n    let emitted = 0;\n\n    for await (const buf of stream) {\n      emitted += buf.length;\n\n      if (emitted > limit) {\n        yield buf.slice(0, limit - emitted);\n        return;\n      }\n\n      yield buf;\n    }\n  };\n};\n\nconst asyncZeroes = function (count) {\n  let chunkSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : utils.MFS_MAX_CHUNK_SIZE;\n  const buf = new Uint8Array(chunkSize);\n\n  async function* _asyncZeroes() {\n    while (true) {\n      yield buf.slice();\n    }\n  }\n\n  return limitAsyncStreamBytes(_asyncZeroes(), count);\n};\n\nconst catAsyncIterators = async function* (sources) {\n  for (let i = 0; i < sources.length; i++) {\n    yield* sources[i]();\n  }\n};\n\nconst countBytesStreamed = async function* (source, notify) {\n  let wrote = 0;\n\n  for await (const buf of source) {\n    wrote += buf.length;\n    yield buf;\n  }\n\n  for await (const buf of notify(wrote)) {\n    wrote += buf.length;\n    yield buf;\n  }\n};\n\nexports.createWrite = createWrite;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-core/cjs/src/components/files/write.js"],"names":["Object","defineProperty","exports","value","debug","require","ipfsUnixfsImporter","dagPB","stat","mkdir","addLink","mergeOpts","createLock","toAsyncIterator","toMfsPath","toPathComponents","toTrail","updateTree","updateMfsRoot","errCode","utils","last","withTimeoutOption","ipfsUnixfs","_interopDefaultLegacy","e","debug__default","mergeOpts__default","errCode__default","last__default","mergeOptions","bind","ignoreUndefined","log","defaultOptions","offset","length","Infinity","create","truncate","rawLeaves","reduceSingleLeafToSelf","cidVersion","hashAlg","parents","progress","bytes","path","strategy","flush","leafType","shardSplitThreshold","createWrite","context","mfsWrite","content","opts","options","source","destination","parent","readLock","mfsDirectory","exists","Error","entryType","updateOrImport","child","write","writeLock","pathComponents","fileName","pop","parentExists","createStat","join","err","code","createMkdir","updatedPath","trail","type","includes","name","parentBlock","repo","blocks","get","cid","parentNode","decode","result","size","newRootCid","sources","unixfs","push","fileSize","extra","asyncZeroes","limitAsyncStreamBytes","countBytesStreamed","catAsyncIterators","bytesWritten","Symbol","asyncIterator","mode","undefined","parseMode","mtime","parseMtime","hasher","hashers","getHasher","importer","stream","limit","_limitAsyncStreamBytes","emitted","buf","slice","count","chunkSize","MFS_MAX_CHUNK_SIZE","Uint8Array","_asyncZeroes","i","notify","wrote"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar debug = require('debug');\nvar ipfsUnixfsImporter = require('ipfs-unixfs-importer');\nvar dagPB = require('@ipld/dag-pb');\nvar stat = require('./stat.js');\nvar mkdir = require('./mkdir.js');\nvar addLink = require('./utils/add-link.js');\nvar mergeOpts = require('merge-options');\nvar createLock = require('./utils/create-lock.js');\nvar toAsyncIterator = require('./utils/to-async-iterator.js');\nvar toMfsPath = require('./utils/to-mfs-path.js');\nvar toPathComponents = require('./utils/to-path-components.js');\nvar toTrail = require('./utils/to-trail.js');\nvar updateTree = require('./utils/update-tree.js');\nvar updateMfsRoot = require('./utils/update-mfs-root.js');\nvar errCode = require('err-code');\nvar utils = require('../../utils.js');\nvar last = require('it-last');\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\nvar ipfsUnixfs = require('ipfs-unixfs');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\nvar mergeOpts__default = /*#__PURE__*/_interopDefaultLegacy(mergeOpts);\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\nvar last__default = /*#__PURE__*/_interopDefaultLegacy(last);\n\nconst mergeOptions = mergeOpts__default[\"default\"].bind({ ignoreUndefined: true });\nconst log = debug__default[\"default\"]('ipfs:mfs:write');\nconst defaultOptions = {\n  offset: 0,\n  length: Infinity,\n  create: false,\n  truncate: false,\n  rawLeaves: false,\n  reduceSingleLeafToSelf: false,\n  cidVersion: 0,\n  hashAlg: 'sha2-256',\n  parents: false,\n  progress: (bytes, path) => {\n  },\n  strategy: 'trickle',\n  flush: true,\n  leafType: 'raw',\n  shardSplitThreshold: 1000\n};\nfunction createWrite(context) {\n  async function mfsWrite(path, content, opts = {}) {\n    const options = mergeOptions(defaultOptions, opts);\n    let source;\n    let destination;\n    let parent;\n    log('Reading source, destination and parent');\n    await createLock.createLock().readLock(async () => {\n      source = await toAsyncIterator.toAsyncIterator(content);\n      destination = await toMfsPath.toMfsPath(context, path, options);\n      parent = await toMfsPath.toMfsPath(context, destination.mfsDirectory, options);\n    })();\n    log('Read source, destination and parent');\n    if (!options.parents && !parent.exists) {\n      throw errCode__default[\"default\"](new Error('directory does not exist'), 'ERR_NO_EXIST');\n    }\n    if (source == null) {\n      throw errCode__default[\"default\"](new Error('could not create source'), 'ERR_NO_SOURCE');\n    }\n    if (destination == null) {\n      throw errCode__default[\"default\"](new Error('could not create destination'), 'ERR_NO_DESTINATION');\n    }\n    if (!options.create && !destination.exists) {\n      throw errCode__default[\"default\"](new Error('file does not exist'), 'ERR_NO_EXIST');\n    }\n    if (destination.entryType !== 'file') {\n      throw errCode__default[\"default\"](new Error('not a file'), 'ERR_NOT_A_FILE');\n    }\n    return updateOrImport(context, path, source, destination, options);\n  }\n  return withTimeoutOption.withTimeoutOption(mfsWrite);\n}\nconst updateOrImport = async (context, path, source, destination, options) => {\n  const child = await write(context, source, destination, options);\n  await createLock.createLock().writeLock(async () => {\n    const pathComponents = toPathComponents.toPathComponents(path);\n    const fileName = pathComponents.pop();\n    if (fileName == null) {\n      throw errCode__default[\"default\"](new Error('source does not exist'), 'ERR_NO_EXIST');\n    }\n    let parentExists = false;\n    try {\n      await stat.createStat(context)(`/${ pathComponents.join('/') }`, options);\n      parentExists = true;\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        throw err;\n      }\n    }\n    if (!parentExists) {\n      await mkdir.createMkdir(context)(`/${ pathComponents.join('/') }`, options);\n    }\n    const updatedPath = await toMfsPath.toMfsPath(context, path, options);\n    const trail = await toTrail.toTrail(context, updatedPath.mfsDirectory);\n    const parent = trail[trail.length - 1];\n    if (!parent) {\n      throw errCode__default[\"default\"](new Error('directory does not exist'), 'ERR_NO_EXIST');\n    }\n    if (!parent.type || !parent.type.includes('directory')) {\n      throw errCode__default[\"default\"](new Error(`cannot write to ${ parent.name }: Not a directory`), 'ERR_NOT_A_DIRECTORY');\n    }\n    const parentBlock = await context.repo.blocks.get(parent.cid);\n    const parentNode = dagPB.decode(parentBlock);\n    const result = await addLink.addLink(context, {\n      parent: parentNode,\n      name: fileName,\n      cid: child.cid,\n      size: child.size,\n      flush: options.flush,\n      shardSplitThreshold: options.shardSplitThreshold,\n      hashAlg: options.hashAlg,\n      cidVersion: options.cidVersion\n    });\n    parent.cid = result.cid;\n    const newRootCid = await updateTree.updateTree(context, trail, options);\n    await updateMfsRoot.updateMfsRoot(context, newRootCid, options);\n  })();\n};\nconst write = async (context, source, destination, options) => {\n  if (destination.exists) {\n    log(`Overwriting file ${ destination.cid } offset ${ options.offset } length ${ options.length }`);\n  } else {\n    log(`Writing file offset ${ options.offset } length ${ options.length }`);\n  }\n  const sources = [];\n  if (options.offset > 0) {\n    if (destination.unixfs) {\n      log(`Writing first ${ options.offset } bytes of original file`);\n      sources.push(() => {\n        return destination.content({\n          offset: 0,\n          length: options.offset\n        });\n      });\n      if (destination.unixfs.fileSize() < options.offset) {\n        const extra = options.offset - destination.unixfs.fileSize();\n        log(`Writing zeros for extra ${ extra } bytes`);\n        sources.push(asyncZeroes(extra));\n      }\n    } else {\n      log(`Writing zeros for first ${ options.offset } bytes`);\n      sources.push(asyncZeroes(options.offset));\n    }\n  }\n  sources.push(limitAsyncStreamBytes(source, options.length));\n  const content = countBytesStreamed(catAsyncIterators(sources), bytesWritten => {\n    if (destination.unixfs && !options.truncate) {\n      const fileSize = destination.unixfs.fileSize();\n      if (fileSize > bytesWritten) {\n        log(`Writing last ${ fileSize - bytesWritten } of ${ fileSize } bytes from original file starting at offset ${ bytesWritten }`);\n        return destination.content({ offset: bytesWritten });\n      } else {\n        log('Not writing last bytes from original file');\n      }\n    }\n    return {\n      [Symbol.asyncIterator]: async function* () {\n      }\n    };\n  });\n  let mode;\n  if (options.mode !== undefined && options.mode !== null) {\n    mode = ipfsUnixfs.parseMode(options.mode);\n  } else if (destination && destination.unixfs) {\n    mode = destination.unixfs.mode;\n  }\n  let mtime;\n  if (options.mtime != null) {\n    mtime = ipfsUnixfs.parseMtime(options.mtime);\n  } else if (destination && destination.unixfs) {\n    mtime = destination.unixfs.mtime;\n  }\n  const hasher = await context.hashers.getHasher(options.hashAlg);\n  const result = await last__default[\"default\"](ipfsUnixfsImporter.importer([{\n      content: content,\n      mode,\n      mtime\n    }], context.repo.blocks, {\n    progress: options.progress,\n    hasher,\n    cidVersion: options.cidVersion,\n    strategy: options.strategy,\n    rawLeaves: options.rawLeaves,\n    reduceSingleLeafToSelf: options.reduceSingleLeafToSelf,\n    leafType: options.leafType\n  }));\n  if (!result) {\n    throw errCode__default[\"default\"](new Error(`cannot write to ${ parent.name }`), 'ERR_COULD_NOT_WRITE');\n  }\n  log(`Wrote ${ result.cid }`);\n  return {\n    cid: result.cid,\n    size: result.size\n  };\n};\nconst limitAsyncStreamBytes = (stream, limit) => {\n  return async function* _limitAsyncStreamBytes() {\n    let emitted = 0;\n    for await (const buf of stream) {\n      emitted += buf.length;\n      if (emitted > limit) {\n        yield buf.slice(0, limit - emitted);\n        return;\n      }\n      yield buf;\n    }\n  };\n};\nconst asyncZeroes = (count, chunkSize = utils.MFS_MAX_CHUNK_SIZE) => {\n  const buf = new Uint8Array(chunkSize);\n  async function* _asyncZeroes() {\n    while (true) {\n      yield buf.slice();\n    }\n  }\n  return limitAsyncStreamBytes(_asyncZeroes(), count);\n};\nconst catAsyncIterators = async function* (sources) {\n  for (let i = 0; i < sources.length; i++) {\n    yield* sources[i]();\n  }\n};\nconst countBytesStreamed = async function* (source, notify) {\n  let wrote = 0;\n  for await (const buf of source) {\n    wrote += buf.length;\n    yield buf;\n  }\n  for await (const buf of notify(wrote)) {\n    wrote += buf.length;\n    yield buf;\n  }\n};\n\nexports.createWrite = createWrite;\n"]},"metadata":{},"sourceType":"script"}