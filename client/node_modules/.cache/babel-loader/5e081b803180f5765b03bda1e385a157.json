{"ast":null,"code":"'use strict';\n\nconst errcode = require('err-code');\n\nconst secp = require('@noble/secp256k1');\n\nconst {\n  sha256\n} = require('multiformats/hashes/sha2');\n\nmodule.exports = () => {\n  const privateKeyLength = 32;\n\n  function generateKey() {\n    return secp.utils.randomPrivateKey();\n  }\n  /**\n   * Hash and sign message with private key\n   *\n   * @param {number | bigint | (string | Uint8Array)} key\n   * @param {Uint8Array} msg\n   */\n\n\n  async function hashAndSign(key, msg) {\n    const {\n      digest\n    } = await sha256.digest(msg);\n\n    try {\n      return await secp.sign(digest, key);\n    } catch (err) {\n      throw errcode(err, 'ERR_INVALID_INPUT');\n    }\n  }\n  /**\n   * Hash message and verify signature with public key\n   *\n   * @param {secp.Point | (string | Uint8Array)} key\n   * @param {(string | Uint8Array) | secp.Signature} sig\n   * @param {Uint8Array} msg\n   */\n\n\n  async function hashAndVerify(key, sig, msg) {\n    try {\n      const {\n        digest\n      } = await sha256.digest(msg);\n      return secp.verify(sig, digest, key);\n    } catch (err) {\n      throw errcode(err, 'ERR_INVALID_INPUT');\n    }\n  }\n\n  function compressPublicKey(key) {\n    const point = secp.Point.fromHex(key).toRawBytes(true);\n    return point;\n  }\n\n  function decompressPublicKey(key) {\n    const point = secp.Point.fromHex(key).toRawBytes(false);\n    return point;\n  }\n\n  function validatePrivateKey(key) {\n    try {\n      secp.getPublicKey(key, true);\n    } catch (err) {\n      throw errcode(err, 'ERR_INVALID_PRIVATE_KEY');\n    }\n  }\n\n  function validatePublicKey(key) {\n    try {\n      secp.Point.fromHex(key);\n    } catch (err) {\n      throw errcode(err, 'ERR_INVALID_PUBLIC_KEY');\n    }\n  }\n\n  function computePublicKey(privateKey) {\n    try {\n      return secp.getPublicKey(privateKey, true);\n    } catch (err) {\n      throw errcode(err, 'ERR_INVALID_PRIVATE_KEY');\n    }\n  }\n\n  return {\n    generateKey,\n    privateKeyLength,\n    hashAndSign,\n    hashAndVerify,\n    compressPublicKey,\n    decompressPublicKey,\n    validatePrivateKey,\n    validatePublicKey,\n    computePublicKey\n  };\n};","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p-crypto/src/keys/secp256k1.js"],"names":["errcode","require","secp","sha256","module","exports","privateKeyLength","generateKey","utils","randomPrivateKey","hashAndSign","key","msg","digest","sign","err","hashAndVerify","sig","verify","compressPublicKey","point","Point","fromHex","toRawBytes","decompressPublicKey","validatePrivateKey","getPublicKey","validatePublicKey","computePublicKey","privateKey"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,kBAAD,CAApB;;AACA,MAAM;AAAEE,EAAAA;AAAF,IAAaF,OAAO,CAAC,0BAAD,CAA1B;;AAEAG,MAAM,CAACC,OAAP,GAAiB,MAAM;AACrB,QAAMC,gBAAgB,GAAG,EAAzB;;AAEA,WAASC,WAAT,GAAwB;AACtB,WAAOL,IAAI,CAACM,KAAL,CAAWC,gBAAX,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACE,iBAAeC,WAAf,CAA4BC,GAA5B,EAAiCC,GAAjC,EAAsC;AACpC,UAAM;AAAEC,MAAAA;AAAF,QAAa,MAAMV,MAAM,CAACU,MAAP,CAAcD,GAAd,CAAzB;;AACA,QAAI;AACF,aAAO,MAAMV,IAAI,CAACY,IAAL,CAAUD,MAAV,EAAkBF,GAAlB,CAAb;AACD,KAFD,CAEE,OAAOI,GAAP,EAAY;AACZ,YAAMf,OAAO,CAACe,GAAD,EAAM,mBAAN,CAAb;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACE,iBAAeC,aAAf,CAA8BL,GAA9B,EAAmCM,GAAnC,EAAwCL,GAAxC,EAA6C;AAC3C,QAAI;AACF,YAAM;AAAEC,QAAAA;AAAF,UAAa,MAAMV,MAAM,CAACU,MAAP,CAAcD,GAAd,CAAzB;AACA,aAAOV,IAAI,CAACgB,MAAL,CAAYD,GAAZ,EAAiBJ,MAAjB,EAAyBF,GAAzB,CAAP;AACD,KAHD,CAGE,OAAOI,GAAP,EAAY;AACZ,YAAMf,OAAO,CAACe,GAAD,EAAM,mBAAN,CAAb;AACD;AACF;;AAED,WAASI,iBAAT,CAA4BR,GAA5B,EAAiC;AAC/B,UAAMS,KAAK,GAAGlB,IAAI,CAACmB,KAAL,CAAWC,OAAX,CAAmBX,GAAnB,EAAwBY,UAAxB,CAAmC,IAAnC,CAAd;AACA,WAAOH,KAAP;AACD;;AAED,WAASI,mBAAT,CAA8Bb,GAA9B,EAAmC;AACjC,UAAMS,KAAK,GAAGlB,IAAI,CAACmB,KAAL,CAAWC,OAAX,CAAmBX,GAAnB,EAAwBY,UAAxB,CAAmC,KAAnC,CAAd;AACA,WAAOH,KAAP;AACD;;AAED,WAASK,kBAAT,CAA6Bd,GAA7B,EAAkC;AAChC,QAAI;AACFT,MAAAA,IAAI,CAACwB,YAAL,CAAkBf,GAAlB,EAAuB,IAAvB;AACD,KAFD,CAEE,OAAOI,GAAP,EAAY;AACZ,YAAMf,OAAO,CAACe,GAAD,EAAM,yBAAN,CAAb;AACD;AACF;;AAED,WAASY,iBAAT,CAA4BhB,GAA5B,EAAiC;AAC/B,QAAI;AACFT,MAAAA,IAAI,CAACmB,KAAL,CAAWC,OAAX,CAAmBX,GAAnB;AACD,KAFD,CAEE,OAAOI,GAAP,EAAY;AACZ,YAAMf,OAAO,CAACe,GAAD,EAAM,wBAAN,CAAb;AACD;AACF;;AAED,WAASa,gBAAT,CAA2BC,UAA3B,EAAuC;AACrC,QAAI;AACF,aAAO3B,IAAI,CAACwB,YAAL,CAAkBG,UAAlB,EAA8B,IAA9B,CAAP;AACD,KAFD,CAEE,OAAOd,GAAP,EAAY;AACZ,YAAMf,OAAO,CAACe,GAAD,EAAM,yBAAN,CAAb;AACD;AACF;;AAED,SAAO;AACLR,IAAAA,WADK;AAELD,IAAAA,gBAFK;AAGLI,IAAAA,WAHK;AAILM,IAAAA,aAJK;AAKLG,IAAAA,iBALK;AAMLK,IAAAA,mBANK;AAOLC,IAAAA,kBAPK;AAQLE,IAAAA,iBARK;AASLC,IAAAA;AATK,GAAP;AAWD,CAnFD","sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst secp = require('@noble/secp256k1')\nconst { sha256 } = require('multiformats/hashes/sha2')\n\nmodule.exports = () => {\n  const privateKeyLength = 32\n\n  function generateKey () {\n    return secp.utils.randomPrivateKey()\n  }\n\n  /**\n   * Hash and sign message with private key\n   *\n   * @param {number | bigint | (string | Uint8Array)} key\n   * @param {Uint8Array} msg\n   */\n  async function hashAndSign (key, msg) {\n    const { digest } = await sha256.digest(msg)\n    try {\n      return await secp.sign(digest, key)\n    } catch (err) {\n      throw errcode(err, 'ERR_INVALID_INPUT')\n    }\n  }\n\n  /**\n   * Hash message and verify signature with public key\n   *\n   * @param {secp.Point | (string | Uint8Array)} key\n   * @param {(string | Uint8Array) | secp.Signature} sig\n   * @param {Uint8Array} msg\n   */\n  async function hashAndVerify (key, sig, msg) {\n    try {\n      const { digest } = await sha256.digest(msg)\n      return secp.verify(sig, digest, key)\n    } catch (err) {\n      throw errcode(err, 'ERR_INVALID_INPUT')\n    }\n  }\n\n  function compressPublicKey (key) {\n    const point = secp.Point.fromHex(key).toRawBytes(true)\n    return point\n  }\n\n  function decompressPublicKey (key) {\n    const point = secp.Point.fromHex(key).toRawBytes(false)\n    return point\n  }\n\n  function validatePrivateKey (key) {\n    try {\n      secp.getPublicKey(key, true)\n    } catch (err) {\n      throw errcode(err, 'ERR_INVALID_PRIVATE_KEY')\n    }\n  }\n\n  function validatePublicKey (key) {\n    try {\n      secp.Point.fromHex(key)\n    } catch (err) {\n      throw errcode(err, 'ERR_INVALID_PUBLIC_KEY')\n    }\n  }\n\n  function computePublicKey (privateKey) {\n    try {\n      return secp.getPublicKey(privateKey, true)\n    } catch (err) {\n      throw errcode(err, 'ERR_INVALID_PRIVATE_KEY')\n    }\n  }\n\n  return {\n    generateKey,\n    privateKeyLength,\n    hashAndSign,\n    hashAndVerify,\n    compressPublicKey,\n    decompressPublicKey,\n    validatePrivateKey,\n    validatePublicKey,\n    computePublicKey\n  }\n}\n"]},"metadata":{},"sourceType":"script"}