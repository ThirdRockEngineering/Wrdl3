{"ast":null,"code":"'use strict';\n\nconst errcode = require('err-code');\n\nconst {\n  equals: uint8ArrayEquals\n} = require('uint8arrays/equals');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst Libp2pRecord = require('libp2p-record');\n\nconst {\n  ALPHA\n} = require('../constants');\n\nconst utils = require('../utils');\n\nconst Record = Libp2pRecord.Record;\n\nconst parallel = require('it-parallel');\n\nconst map = require('it-map');\n\nconst {\n  valueEvent,\n  queryErrorEvent\n} = require('../query/events');\n\nconst {\n  Message\n} = require('../message');\n\nconst {\n  pipe\n} = require('it-pipe');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../types').ValueEvent} ValueEvent\n */\n\n\nclass ContentFetching {\n  /**\n   * @param {object} params\n   * @param {import('peer-id')} params.peerId\n   * @param {import('interface-datastore').Datastore} params.records\n   * @param {import('libp2p-interfaces/src/types').DhtValidators} params.validators\n   * @param {import('libp2p-interfaces/src/types').DhtSelectors} params.selectors\n   * @param {import('../peer-routing').PeerRouting} params.peerRouting\n   * @param {import('../query/manager').QueryManager} params.queryManager\n   * @param {import('../routing-table').RoutingTable} params.routingTable\n   * @param {import('../network').Network} params.network\n   * @param {boolean} params.lan\n   */\n  constructor(_ref) {\n    let {\n      peerId,\n      records,\n      validators,\n      selectors,\n      peerRouting,\n      queryManager,\n      routingTable,\n      network,\n      lan\n    } = _ref;\n    this._log = utils.logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}:content-fetching`);\n    this._peerId = peerId;\n    this._records = records;\n    this._validators = validators;\n    this._selectors = selectors;\n    this._peerRouting = peerRouting;\n    this._queryManager = queryManager;\n    this._routingTable = routingTable;\n    this._network = network;\n  }\n  /**\n   * @param {Uint8Array} key\n   * @param {Uint8Array} rec\n   */\n\n\n  async putLocal(key, rec) {\n    // eslint-disable-line require-await\n    return this._records.put(utils.bufferToKey(key), rec);\n  }\n  /**\n   * Attempt to retrieve the value for the given key from\n   * the local datastore.\n   *\n   * @param {Uint8Array} key\n   */\n\n\n  async getLocal(key) {\n    this._log(`getLocal ${uint8ArrayToString(key, 'base32')}`);\n\n    const dsKey = utils.bufferToKey(key);\n\n    this._log(`fetching record for key ${dsKey}`);\n\n    const raw = await this._records.get(dsKey);\n\n    this._log(`found ${dsKey} in local datastore`);\n\n    const rec = Record.deserialize(raw);\n    await Libp2pRecord.validator.verifyRecord(this._validators, rec);\n    return rec;\n  }\n  /**\n   * Send the best record found to any peers that have an out of date record.\n   *\n   * @param {Uint8Array} key\n   * @param {ValueEvent[]} vals - values retrieved from the DHT\n   * @param {Uint8Array} best - the best record that was found\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  async *sendCorrectionRecord(key, vals, best) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    this._log('sendCorrection for %b', key);\n\n    const fixupRec = await utils.createPutRecord(key, best);\n\n    for (const {\n      value,\n      from\n    } of vals) {\n      // no need to do anything\n      if (uint8ArrayEquals(value, best)) {\n        this._log('record was ok');\n\n        continue;\n      } // correct ourself\n\n\n      if (this._peerId.equals(from)) {\n        try {\n          const dsKey = utils.bufferToKey(key);\n\n          this._log(`Storing corrected record for key ${dsKey}`);\n\n          await this._records.put(dsKey, fixupRec);\n        } catch (\n        /** @type {any} */\n        err) {\n          this._log.error('Failed error correcting self', err);\n        }\n\n        continue;\n      } // send correction\n\n\n      let sentCorrection = false;\n      const request = new Message(Message.TYPES.PUT_VALUE, key, 0);\n      request.record = Record.deserialize(fixupRec);\n\n      for await (const event of this._network.sendRequest(from, request, options)) {\n        if (event.name === 'PEER_RESPONSE' && event.record && uint8ArrayEquals(event.record.value, Record.deserialize(fixupRec).value)) {\n          sentCorrection = true;\n        }\n\n        yield event;\n      }\n\n      if (!sentCorrection) {\n        yield queryErrorEvent({\n          from,\n          error: errcode(new Error('value not put correctly'), 'ERR_PUT_VALUE_INVALID')\n        });\n      }\n\n      this._log.error('Failed error correcting entry');\n    }\n  }\n  /**\n   * Store the given key/value pair in the DHT\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} value\n   * @param {object} [options] - put options\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  async *put(key, value) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    this._log('put key %b value %b', key, value); // create record in the dht format\n\n\n    const record = await utils.createPutRecord(key, value); // store the record locally\n\n    const dsKey = utils.bufferToKey(key);\n\n    this._log(`storing record for key ${dsKey}`);\n\n    await this._records.put(dsKey, record); // put record to the closest peers\n\n    yield* pipe(this._peerRouting.getClosestPeers(key, {\n      signal: options.signal\n    }), source => map(source, event => {\n      return async () => {\n        if (event.name !== 'FINAL_PEER') {\n          return [event];\n        }\n\n        const events = [];\n        const msg = new Message(Message.TYPES.PUT_VALUE, key, 0);\n        msg.record = Record.deserialize(record);\n\n        for await (const putEvent of this._network.sendRequest(event.peer.id, msg, options)) {\n          events.push(putEvent);\n\n          if (putEvent.name !== 'PEER_RESPONSE') {\n            continue;\n          }\n\n          if (putEvent.record && uint8ArrayEquals(putEvent.record.value, Record.deserialize(record).value)) {} else {\n            events.push(queryErrorEvent({\n              from: event.peer.id,\n              error: errcode(new Error('value not put correctly'), 'ERR_PUT_VALUE_INVALID')\n            }));\n          }\n        }\n\n        return events;\n      };\n    }), source => parallel(source, {\n      ordered: false,\n      concurrency: ALPHA\n    }), async function* (source) {\n      for await (const events of source) {\n        yield* events;\n      }\n    });\n  }\n  /**\n   * Get the value to the given key\n   *\n   * @param {Uint8Array} key\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.queryFuncTimeout]\n   */\n\n\n  async *get(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    this._log('get %b', key);\n    /** @type {ValueEvent[]} */\n\n\n    const vals = [];\n\n    for await (const event of this.getMany(key, options)) {\n      if (event.name === 'VALUE') {\n        vals.push(event);\n      }\n\n      yield event;\n    }\n\n    if (!vals.length) {\n      return;\n    }\n\n    const records = vals.map(v => v.value);\n    let i = 0;\n\n    try {\n      i = Libp2pRecord.selection.bestRecord(this._selectors, key, records);\n    } catch (\n    /** @type {any} */\n    err) {\n      // Assume the first record if no selector available\n      if (err.code !== 'ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY') {\n        throw err;\n      }\n    }\n\n    const best = records[i];\n\n    this._log('GetValue %b %b', key, best);\n\n    if (!best) {\n      throw errcode(new Error('best value was not found'), 'ERR_NOT_FOUND');\n    }\n\n    yield* this.sendCorrectionRecord(key, vals, best, options);\n    yield vals[i];\n  }\n  /**\n   * Get the `n` values to the given key without sorting.\n   *\n   * @param {Uint8Array} key\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.queryFuncTimeout]\n   */\n\n\n  async *getMany(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    this._log('getMany values for %t', key);\n\n    try {\n      const localRec = await this.getLocal(key);\n      yield valueEvent({\n        value: localRec.value,\n        from: this._peerId\n      });\n    } catch (\n    /** @type {any} */\n    err) {\n      this._log('error getting local value for %b', key, err);\n    }\n\n    const id = await utils.convertBuffer(key);\n\n    const rtp = this._routingTable.closestPeers(id);\n\n    this._log('found %d peers in routing table', rtp.length);\n\n    const self = this;\n    /**\n     * @type {import('../query/types').QueryFunc}\n     */\n\n    const getValueQuery = async function* (_ref2) {\n      let {\n        peer,\n        signal\n      } = _ref2;\n\n      for await (const event of self._peerRouting.getValueOrPeers(peer, key, {\n        signal\n      })) {\n        yield event;\n\n        if (event.name === 'PEER_RESPONSE' && event.record) {\n          yield valueEvent({\n            from: peer,\n            value: event.record.value\n          });\n        }\n      }\n    }; // we have peers, lets send the actual query to them\n\n\n    yield* this._queryManager.run(key, rtp, getValueQuery, options);\n  }\n\n}\n\nmodule.exports.ContentFetching = ContentFetching;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p-kad-dht/src/content-fetching/index.js"],"names":["errcode","require","equals","uint8ArrayEquals","toString","uint8ArrayToString","Libp2pRecord","ALPHA","utils","Record","parallel","map","valueEvent","queryErrorEvent","Message","pipe","ContentFetching","constructor","peerId","records","validators","selectors","peerRouting","queryManager","routingTable","network","lan","_log","logger","_peerId","_records","_validators","_selectors","_peerRouting","_queryManager","_routingTable","_network","putLocal","key","rec","put","bufferToKey","getLocal","dsKey","raw","get","deserialize","validator","verifyRecord","sendCorrectionRecord","vals","best","options","fixupRec","createPutRecord","value","from","err","error","sentCorrection","request","TYPES","PUT_VALUE","record","event","sendRequest","name","Error","getClosestPeers","signal","source","events","msg","putEvent","peer","id","push","ordered","concurrency","getMany","length","v","i","selection","bestRecord","code","localRec","convertBuffer","rtp","closestPeers","self","getValueQuery","getValueOrPeers","run","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst Libp2pRecord = require('libp2p-record')\nconst {\n  ALPHA\n} = require('../constants')\nconst utils = require('../utils')\nconst Record = Libp2pRecord.Record\nconst parallel = require('it-parallel')\nconst map = require('it-map')\nconst {\n  valueEvent,\n  queryErrorEvent\n} = require('../query/events')\nconst { Message } = require('../message')\nconst { pipe } = require('it-pipe')\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../types').ValueEvent} ValueEvent\n */\n\nclass ContentFetching {\n  /**\n   * @param {object} params\n   * @param {import('peer-id')} params.peerId\n   * @param {import('interface-datastore').Datastore} params.records\n   * @param {import('libp2p-interfaces/src/types').DhtValidators} params.validators\n   * @param {import('libp2p-interfaces/src/types').DhtSelectors} params.selectors\n   * @param {import('../peer-routing').PeerRouting} params.peerRouting\n   * @param {import('../query/manager').QueryManager} params.queryManager\n   * @param {import('../routing-table').RoutingTable} params.routingTable\n   * @param {import('../network').Network} params.network\n   * @param {boolean} params.lan\n   */\n  constructor ({ peerId, records, validators, selectors, peerRouting, queryManager, routingTable, network, lan }) {\n    this._log = utils.logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}:content-fetching`)\n    this._peerId = peerId\n    this._records = records\n    this._validators = validators\n    this._selectors = selectors\n    this._peerRouting = peerRouting\n    this._queryManager = queryManager\n    this._routingTable = routingTable\n    this._network = network\n  }\n\n  /**\n   * @param {Uint8Array} key\n   * @param {Uint8Array} rec\n   */\n  async putLocal (key, rec) { // eslint-disable-line require-await\n    return this._records.put(utils.bufferToKey(key), rec)\n  }\n\n  /**\n   * Attempt to retrieve the value for the given key from\n   * the local datastore.\n   *\n   * @param {Uint8Array} key\n   */\n  async getLocal (key) {\n    this._log(`getLocal ${uint8ArrayToString(key, 'base32')}`)\n\n    const dsKey = utils.bufferToKey(key)\n\n    this._log(`fetching record for key ${dsKey}`)\n    const raw = await this._records.get(dsKey)\n    this._log(`found ${dsKey} in local datastore`)\n\n    const rec = Record.deserialize(raw)\n\n    await Libp2pRecord.validator.verifyRecord(this._validators, rec)\n\n    return rec\n  }\n\n  /**\n   * Send the best record found to any peers that have an out of date record.\n   *\n   * @param {Uint8Array} key\n   * @param {ValueEvent[]} vals - values retrieved from the DHT\n   * @param {Uint8Array} best - the best record that was found\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async * sendCorrectionRecord (key, vals, best, options = {}) {\n    this._log('sendCorrection for %b', key)\n    const fixupRec = await utils.createPutRecord(key, best)\n\n    for (const { value, from } of vals) {\n      // no need to do anything\n      if (uint8ArrayEquals(value, best)) {\n        this._log('record was ok')\n        continue\n      }\n\n      // correct ourself\n      if (this._peerId.equals(from)) {\n        try {\n          const dsKey = utils.bufferToKey(key)\n          this._log(`Storing corrected record for key ${dsKey}`)\n          await this._records.put(dsKey, fixupRec)\n        } catch (/** @type {any} */ err) {\n          this._log.error('Failed error correcting self', err)\n        }\n\n        continue\n      }\n\n      // send correction\n      let sentCorrection = false\n      const request = new Message(Message.TYPES.PUT_VALUE, key, 0)\n      request.record = Record.deserialize(fixupRec)\n\n      for await (const event of this._network.sendRequest(from, request, options)) {\n        if (event.name === 'PEER_RESPONSE' && event.record && uint8ArrayEquals(event.record.value, Record.deserialize(fixupRec).value)) {\n          sentCorrection = true\n        }\n\n        yield event\n      }\n\n      if (!sentCorrection) {\n        yield queryErrorEvent({ from, error: errcode(new Error('value not put correctly'), 'ERR_PUT_VALUE_INVALID') })\n      }\n\n      this._log.error('Failed error correcting entry')\n    }\n  }\n\n  /**\n   * Store the given key/value pair in the DHT\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} value\n   * @param {object} [options] - put options\n   * @param {AbortSignal} [options.signal]\n   */\n  async * put (key, value, options = {}) {\n    this._log('put key %b value %b', key, value)\n\n    // create record in the dht format\n    const record = await utils.createPutRecord(key, value)\n\n    // store the record locally\n    const dsKey = utils.bufferToKey(key)\n    this._log(`storing record for key ${dsKey}`)\n    await this._records.put(dsKey, record)\n\n    // put record to the closest peers\n    yield * pipe(\n      this._peerRouting.getClosestPeers(key, { signal: options.signal }),\n      (source) => map(source, (event) => {\n        return async () => {\n          if (event.name !== 'FINAL_PEER') {\n            return [event]\n          }\n\n          const events = []\n\n          const msg = new Message(Message.TYPES.PUT_VALUE, key, 0)\n          msg.record = Record.deserialize(record)\n\n          for await (const putEvent of this._network.sendRequest(event.peer.id, msg, options)) {\n            events.push(putEvent)\n\n            if (putEvent.name !== 'PEER_RESPONSE') {\n              continue\n            }\n\n            if (putEvent.record && uint8ArrayEquals(putEvent.record.value, Record.deserialize(record).value)) {\n            } else {\n              events.push(queryErrorEvent({ from: event.peer.id, error: errcode(new Error('value not put correctly'), 'ERR_PUT_VALUE_INVALID') }))\n            }\n          }\n\n          return events\n        }\n      }),\n      (source) => parallel(source, {\n        ordered: false,\n        concurrency: ALPHA\n      }),\n      async function * (source) {\n        for await (const events of source) {\n          yield * events\n        }\n      }\n    )\n  }\n\n  /**\n   * Get the value to the given key\n   *\n   * @param {Uint8Array} key\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.queryFuncTimeout]\n   */\n  async * get (key, options = {}) {\n    this._log('get %b', key)\n\n    /** @type {ValueEvent[]} */\n    const vals = []\n\n    for await (const event of this.getMany(key, options)) {\n      if (event.name === 'VALUE') {\n        vals.push(event)\n      }\n\n      yield event\n    }\n\n    if (!vals.length) {\n      return\n    }\n\n    const records = vals.map((v) => v.value)\n    let i = 0\n\n    try {\n      i = Libp2pRecord.selection.bestRecord(this._selectors, key, records)\n    } catch (/** @type {any} */ err) {\n      // Assume the first record if no selector available\n      if (err.code !== 'ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY') {\n        throw err\n      }\n    }\n\n    const best = records[i]\n    this._log('GetValue %b %b', key, best)\n\n    if (!best) {\n      throw errcode(new Error('best value was not found'), 'ERR_NOT_FOUND')\n    }\n\n    yield * this.sendCorrectionRecord(key, vals, best, options)\n\n    yield vals[i]\n  }\n\n  /**\n   * Get the `n` values to the given key without sorting.\n   *\n   * @param {Uint8Array} key\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.queryFuncTimeout]\n   */\n  async * getMany (key, options = {}) {\n    this._log('getMany values for %t', key)\n\n    try {\n      const localRec = await this.getLocal(key)\n\n      yield valueEvent({\n        value: localRec.value,\n        from: this._peerId\n      })\n    } catch (/** @type {any} */ err) {\n      this._log('error getting local value for %b', key, err)\n    }\n\n    const id = await utils.convertBuffer(key)\n    const rtp = this._routingTable.closestPeers(id)\n\n    this._log('found %d peers in routing table', rtp.length)\n\n    const self = this\n\n    /**\n     * @type {import('../query/types').QueryFunc}\n     */\n    const getValueQuery = async function * ({ peer, signal }) {\n      for await (const event of self._peerRouting.getValueOrPeers(peer, key, { signal })) {\n        yield event\n\n        if (event.name === 'PEER_RESPONSE' && event.record) {\n          yield valueEvent({ from: peer, value: event.record.value })\n        }\n      }\n    }\n\n    // we have peers, lets send the actual query to them\n    yield * this._queryManager.run(key, rtp, getValueQuery, options)\n  }\n}\n\nmodule.exports.ContentFetching = ContentFetching\n"]},"metadata":{},"sourceType":"script"}