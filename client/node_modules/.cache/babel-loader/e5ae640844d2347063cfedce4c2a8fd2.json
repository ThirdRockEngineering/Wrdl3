{"ast":null,"code":"'use strict';\n\nconst PeerId = require('peer-id');\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst {\n  Record\n} = require('libp2p-record');\n\nconst Proto = require('./dht');\n\nconst MESSAGE_TYPE = Proto.Message.MessageType;\nconst CONNECTION_TYPE = Proto.Message.ConnectionType;\nconst MESSAGE_TYPE_LOOKUP = Object.keys(MESSAGE_TYPE);\n/**\n * @typedef {0|1|2|3|4} ConnectionType\n *\n * @typedef {object} PBPeer\n * @property {Uint8Array} id\n * @property {Uint8Array[]} addrs\n * @property {ConnectionType} connection\n *\n * @typedef {import('../types').PeerData} PeerData\n */\n\n/**\n * Represents a single DHT control message.\n */\n\nclass Message {\n  /**\n   * @param {import('./dht').Message.MessageType} type\n   * @param {Uint8Array} key\n   * @param {number} level\n   */\n  constructor(type, key, level) {\n    if (key && !(key instanceof Uint8Array)) {\n      throw new Error('Key must be a Uint8Array');\n    }\n\n    this.type = type;\n    this.key = key;\n    this._clusterLevelRaw = level;\n    /** @type {PeerData[]} */\n\n    this.closerPeers = [];\n    /** @type {PeerData[]} */\n\n    this.providerPeers = [];\n    /** @type {import('libp2p-record').Record | undefined} */\n\n    this.record = undefined;\n  }\n  /**\n   * @type {number}\n   */\n\n\n  get clusterLevel() {\n    const level = this._clusterLevelRaw - 1;\n\n    if (level < 0) {\n      return 0;\n    }\n\n    return level;\n  }\n\n  set clusterLevel(level) {\n    this._clusterLevelRaw = level;\n  }\n  /**\n   * Encode into protobuf\n   */\n\n\n  serialize() {\n    const obj = {\n      key: this.key,\n      type: this.type,\n      clusterLevelRaw: this._clusterLevelRaw,\n      closerPeers: this.closerPeers.map(toPbPeer),\n      providerPeers: this.providerPeers.map(toPbPeer),\n\n      /** @type {Uint8Array | undefined} */\n      record: undefined\n    };\n\n    if (this.record) {\n      if (this.record instanceof Uint8Array) {\n        obj.record = this.record;\n      } else {\n        obj.record = this.record.serialize();\n      }\n    }\n\n    return Proto.Message.encode(obj).finish();\n  }\n  /**\n   * Decode from protobuf\n   *\n   * @param {Uint8Array} raw\n   */\n\n\n  static deserialize(raw) {\n    const dec = Proto.Message.decode(raw);\n    const msg = new Message(dec.type || 0, dec.key || Uint8Array.from([]), dec.clusterLevelRaw || 0);\n    msg.closerPeers = dec.closerPeers.map(fromPbPeer);\n    msg.providerPeers = dec.providerPeers.map(fromPbPeer);\n\n    if (dec.record && dec.record.length) {\n      msg.record = Record.deserialize(dec.record);\n    }\n\n    return msg;\n  }\n\n}\n\nMessage.TYPES = MESSAGE_TYPE;\nMessage.CONNECTION_TYPES = CONNECTION_TYPE;\n/**\n * @param {PeerData} peer\n */\n\nfunction toPbPeer(peer) {\n  /** @type {PBPeer} */\n  const output = {\n    id: peer.id.id,\n    addrs: (peer.multiaddrs || []).map(m => m.bytes),\n    connection: CONNECTION_TYPE.CONNECTED\n  };\n  return output;\n}\n/**\n * @param {import('./dht').Message.IPeer} peer\n */\n\n\nfunction fromPbPeer(peer) {\n  return {\n    // @ts-ignore id is optional on protobuf, but it will exist?\n    id: new PeerId(peer.id),\n    multiaddrs: (peer.addrs || []).map(a => new Multiaddr(a))\n  };\n}\n\nmodule.exports.Message = Message;\nmodule.exports.MESSAGE_TYPE = MESSAGE_TYPE;\nmodule.exports.MESSAGE_TYPE_LOOKUP = MESSAGE_TYPE_LOOKUP;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p-kad-dht/src/message/index.js"],"names":["PeerId","require","Multiaddr","Record","Proto","MESSAGE_TYPE","Message","MessageType","CONNECTION_TYPE","ConnectionType","MESSAGE_TYPE_LOOKUP","Object","keys","constructor","type","key","level","Uint8Array","Error","_clusterLevelRaw","closerPeers","providerPeers","record","undefined","clusterLevel","serialize","obj","clusterLevelRaw","map","toPbPeer","encode","finish","deserialize","raw","dec","decode","msg","from","fromPbPeer","length","TYPES","CONNECTION_TYPES","peer","output","id","addrs","multiaddrs","m","bytes","connection","CONNECTED","a","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst { Multiaddr } = require('multiaddr')\nconst { Record } = require('libp2p-record')\nconst Proto = require('./dht')\n\nconst MESSAGE_TYPE = Proto.Message.MessageType\nconst CONNECTION_TYPE = Proto.Message.ConnectionType\nconst MESSAGE_TYPE_LOOKUP = Object.keys(MESSAGE_TYPE)\n\n/**\n * @typedef {0|1|2|3|4} ConnectionType\n *\n * @typedef {object} PBPeer\n * @property {Uint8Array} id\n * @property {Uint8Array[]} addrs\n * @property {ConnectionType} connection\n *\n * @typedef {import('../types').PeerData} PeerData\n */\n\n/**\n * Represents a single DHT control message.\n */\nclass Message {\n  /**\n   * @param {import('./dht').Message.MessageType} type\n   * @param {Uint8Array} key\n   * @param {number} level\n   */\n  constructor (type, key, level) {\n    if (key && !(key instanceof Uint8Array)) {\n      throw new Error('Key must be a Uint8Array')\n    }\n\n    this.type = type\n    this.key = key\n    this._clusterLevelRaw = level\n\n    /** @type {PeerData[]} */\n    this.closerPeers = []\n    /** @type {PeerData[]} */\n    this.providerPeers = []\n    /** @type {import('libp2p-record').Record | undefined} */\n    this.record = undefined\n  }\n\n  /**\n   * @type {number}\n   */\n  get clusterLevel () {\n    const level = this._clusterLevelRaw - 1\n    if (level < 0) {\n      return 0\n    }\n\n    return level\n  }\n\n  set clusterLevel (level) {\n    this._clusterLevelRaw = level\n  }\n\n  /**\n   * Encode into protobuf\n   */\n  serialize () {\n    const obj = {\n      key: this.key,\n      type: this.type,\n      clusterLevelRaw: this._clusterLevelRaw,\n      closerPeers: this.closerPeers.map(toPbPeer),\n      providerPeers: this.providerPeers.map(toPbPeer),\n\n      /** @type {Uint8Array | undefined} */\n      record: undefined\n    }\n\n    if (this.record) {\n      if (this.record instanceof Uint8Array) {\n        obj.record = this.record\n      } else {\n        obj.record = this.record.serialize()\n      }\n    }\n\n    return Proto.Message.encode(obj).finish()\n  }\n\n  /**\n   * Decode from protobuf\n   *\n   * @param {Uint8Array} raw\n   */\n  static deserialize (raw) {\n    const dec = Proto.Message.decode(raw)\n\n    const msg = new Message(dec.type || 0, dec.key || Uint8Array.from([]), dec.clusterLevelRaw || 0)\n\n    msg.closerPeers = dec.closerPeers.map(fromPbPeer)\n    msg.providerPeers = dec.providerPeers.map(fromPbPeer)\n\n    if (dec.record && dec.record.length) {\n      msg.record = Record.deserialize(dec.record)\n    }\n\n    return msg\n  }\n}\n\nMessage.TYPES = MESSAGE_TYPE\nMessage.CONNECTION_TYPES = CONNECTION_TYPE\n\n/**\n * @param {PeerData} peer\n */\nfunction toPbPeer (peer) {\n  /** @type {PBPeer} */\n  const output = {\n    id: peer.id.id,\n    addrs: (peer.multiaddrs || []).map((m) => m.bytes),\n    connection: CONNECTION_TYPE.CONNECTED\n  }\n\n  return output\n}\n\n/**\n * @param {import('./dht').Message.IPeer} peer\n */\nfunction fromPbPeer (peer) {\n  return {\n    // @ts-ignore id is optional on protobuf, but it will exist?\n    id: new PeerId(peer.id),\n    multiaddrs: (peer.addrs || []).map((a) => new Multiaddr(a))\n  }\n}\n\nmodule.exports.Message = Message\nmodule.exports.MESSAGE_TYPE = MESSAGE_TYPE\nmodule.exports.MESSAGE_TYPE_LOOKUP = MESSAGE_TYPE_LOOKUP\n"]},"metadata":{},"sourceType":"script"}