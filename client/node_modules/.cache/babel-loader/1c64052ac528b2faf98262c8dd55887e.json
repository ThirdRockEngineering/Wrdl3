{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst mergeOptions = require('merge-options'); // @ts-ignore retimer does not have types\n\n\nconst retimer = require('retimer');\n\nconst all = require('it-all');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst filter = require('it-filter');\n\nconst sort = require('it-sort');\n\nconst log = Object.assign(debug('libp2p:connection-manager:auto-dialler'), {\n  error: debug('libp2p:connection-manager:auto-dialler:err')\n});\nconst defaultOptions = {\n  enabled: true,\n  minConnections: 0,\n  autoDialInterval: 10000\n};\n/**\n * @typedef {import('../index')} Libp2p\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n */\n\n/**\n * @typedef {Object} AutoDiallerOptions\n * @property {boolean} [enabled = true] - Should preemptively guarantee connections are above the low watermark\n * @property {number} [minConnections = 0] - The minimum number of connections to avoid pruning\n * @property {number} [autoDialInterval = 10000] - How often, in milliseconds, it should preemptively guarantee connections are above the low watermark\n */\n\nclass AutoDialler {\n  /**\n   * Proactively tries to connect to known peers stored in the PeerStore.\n   * It will keep the number of connections below the upper limit and sort\n   * the peers to connect based on wether we know their keys and protocols.\n   *\n   * @class\n   * @param {Libp2p} libp2p\n   * @param {AutoDiallerOptions} options\n   */\n  constructor(libp2p) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this._options = mergeOptions.call({\n      ignoreUndefined: true\n    }, defaultOptions, options);\n    this._libp2p = libp2p;\n    this._running = false;\n    this._autoDialTimeout = null;\n    this._autoDial = this._autoDial.bind(this);\n    log('options: %j', this._options);\n  }\n  /**\n   * Starts the auto dialer\n   */\n\n\n  async start() {\n    if (!this._options.enabled) {\n      log('not enabled');\n      return;\n    }\n\n    this._running = true;\n\n    this._autoDial().catch(err => {\n      log.error('could start autodial', err);\n    });\n\n    log('started');\n  }\n  /**\n   * Stops the auto dialler\n   */\n\n\n  async stop() {\n    if (!this._options.enabled) {\n      log('not enabled');\n      return;\n    }\n\n    this._running = false;\n    this._autoDialTimeout && this._autoDialTimeout.clear();\n    log('stopped');\n  }\n\n  async _autoDial() {\n    const minConnections = this._options.minConnections; // Already has enough connections\n\n    if (this._libp2p.connections.size >= minConnections) {\n      this._autoDialTimeout = retimer(this._autoDial, this._options.autoDialInterval);\n      return;\n    } // Sort peers on whether we know protocols of public keys for them\n    // TODO: assuming the `peerStore.getPeers()` order is stable this will mean\n    // we keep trying to connect to the same peers?\n\n\n    const peers = await pipe(this._libp2p.peerStore.getPeers(), source => filter(source, peer => !peer.id.equals(this._libp2p.peerId)), source => sort(source, (a, b) => {\n      if (b.protocols && b.protocols.length && (!a.protocols || !a.protocols.length)) {\n        return 1;\n      } else if (b.id.pubKey && !a.id.pubKey) {\n        return 1;\n      }\n\n      return -1;\n    }), source => all(source));\n\n    for (let i = 0; this._running && i < peers.length && this._libp2p.connections.size < minConnections; i++) {\n      const peer = peers[i];\n\n      if (!this._libp2p.connectionManager.get(peer.id)) {\n        log('connecting to a peerStore stored peer %s', peer.id.toB58String());\n\n        try {\n          await this._libp2p.dialer.connectToPeer(peer.id);\n        } catch (\n        /** @type {any} */\n        err) {\n          log.error('could not connect to peerStore stored peer', err);\n        }\n      }\n    } // Connection Manager was stopped\n\n\n    if (!this._running) {\n      return;\n    }\n\n    this._autoDialTimeout = retimer(this._autoDial, this._options.autoDialInterval);\n  }\n\n}\n\nmodule.exports = AutoDialler;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p/src/connection-manager/auto-dialler.js"],"names":["debug","require","mergeOptions","retimer","all","pipe","filter","sort","log","Object","assign","error","defaultOptions","enabled","minConnections","autoDialInterval","AutoDialler","constructor","libp2p","options","_options","call","ignoreUndefined","_libp2p","_running","_autoDialTimeout","_autoDial","bind","start","catch","err","stop","clear","connections","size","peers","peerStore","getPeers","source","peer","id","equals","peerId","a","b","protocols","length","pubKey","i","connectionManager","get","toB58String","dialer","connectToPeer","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMC,YAAY,GAAGD,OAAO,CAAC,eAAD,CAA5B,C,CACA;;;AACA,MAAME,OAAO,GAAGF,OAAO,CAAC,SAAD,CAAvB;;AACA,MAAMG,GAAG,GAAGH,OAAO,CAAC,QAAD,CAAnB;;AACA,MAAM;AAAEI,EAAAA;AAAF,IAAWJ,OAAO,CAAC,SAAD,CAAxB;;AACA,MAAMK,MAAM,GAAGL,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAMM,IAAI,GAAGN,OAAO,CAAC,SAAD,CAApB;;AAEA,MAAMO,GAAG,GAAGC,MAAM,CAACC,MAAP,CAAcV,KAAK,CAAC,wCAAD,CAAnB,EAA+D;AACzEW,EAAAA,KAAK,EAAEX,KAAK,CAAC,4CAAD;AAD6D,CAA/D,CAAZ;AAIA,MAAMY,cAAc,GAAG;AACrBC,EAAAA,OAAO,EAAE,IADY;AAErBC,EAAAA,cAAc,EAAE,CAFK;AAGrBC,EAAAA,gBAAgB,EAAE;AAHG,CAAvB;AAMA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,WAAN,CAAkB;AAChB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEC,EAAAA,WAAW,CAAEC,MAAF,EAAwB;AAAA,QAAdC,OAAc,uEAAJ,EAAI;AACjC,SAAKC,QAAL,GAAgBlB,YAAY,CAACmB,IAAb,CAAkB;AAAEC,MAAAA,eAAe,EAAE;AAAnB,KAAlB,EAA6CV,cAA7C,EAA6DO,OAA7D,CAAhB;AACA,SAAKI,OAAL,GAAeL,MAAf;AACA,SAAKM,QAAL,GAAgB,KAAhB;AACA,SAAKC,gBAAL,GAAwB,IAAxB;AACA,SAAKC,SAAL,GAAiB,KAAKA,SAAL,CAAeC,IAAf,CAAoB,IAApB,CAAjB;AAEAnB,IAAAA,GAAG,CAAC,aAAD,EAAgB,KAAKY,QAArB,CAAH;AACD;AAED;AACF;AACA;;;AACa,QAALQ,KAAK,GAAI;AACb,QAAI,CAAC,KAAKR,QAAL,CAAcP,OAAnB,EAA4B;AAC1BL,MAAAA,GAAG,CAAC,aAAD,CAAH;AACA;AACD;;AAED,SAAKgB,QAAL,GAAgB,IAAhB;;AACA,SAAKE,SAAL,GAAiBG,KAAjB,CAAuBC,GAAG,IAAI;AAC5BtB,MAAAA,GAAG,CAACG,KAAJ,CAAU,sBAAV,EAAkCmB,GAAlC;AACD,KAFD;;AAGAtB,IAAAA,GAAG,CAAC,SAAD,CAAH;AACD;AAED;AACF;AACA;;;AACY,QAAJuB,IAAI,GAAI;AACZ,QAAI,CAAC,KAAKX,QAAL,CAAcP,OAAnB,EAA4B;AAC1BL,MAAAA,GAAG,CAAC,aAAD,CAAH;AACA;AACD;;AAED,SAAKgB,QAAL,GAAgB,KAAhB;AACA,SAAKC,gBAAL,IAAyB,KAAKA,gBAAL,CAAsBO,KAAtB,EAAzB;AACAxB,IAAAA,GAAG,CAAC,SAAD,CAAH;AACD;;AAEc,QAATkB,SAAS,GAAI;AACjB,UAAMZ,cAAc,GAAG,KAAKM,QAAL,CAAcN,cAArC,CADiB,CAGjB;;AACA,QAAI,KAAKS,OAAL,CAAaU,WAAb,CAAyBC,IAAzB,IAAiCpB,cAArC,EAAqD;AACnD,WAAKW,gBAAL,GAAwBtB,OAAO,CAAC,KAAKuB,SAAN,EAAiB,KAAKN,QAAL,CAAcL,gBAA/B,CAA/B;AACA;AACD,KAPgB,CASjB;AACA;AACA;;;AACA,UAAMoB,KAAK,GAAG,MAAM9B,IAAI,CACtB,KAAKkB,OAAL,CAAaa,SAAb,CAAuBC,QAAvB,EADsB,EAErBC,MAAD,IAAYhC,MAAM,CAACgC,MAAD,EAAUC,IAAD,IAAU,CAACA,IAAI,CAACC,EAAL,CAAQC,MAAR,CAAe,KAAKlB,OAAL,CAAamB,MAA5B,CAApB,CAFI,EAGrBJ,MAAD,IAAY/B,IAAI,CAAC+B,MAAD,EAAS,CAACK,CAAD,EAAIC,CAAJ,KAAU;AACjC,UAAIA,CAAC,CAACC,SAAF,IAAeD,CAAC,CAACC,SAAF,CAAYC,MAA3B,KAAsC,CAACH,CAAC,CAACE,SAAH,IAAgB,CAACF,CAAC,CAACE,SAAF,CAAYC,MAAnE,CAAJ,EAAgF;AAC9E,eAAO,CAAP;AACD,OAFD,MAEO,IAAIF,CAAC,CAACJ,EAAF,CAAKO,MAAL,IAAe,CAACJ,CAAC,CAACH,EAAF,CAAKO,MAAzB,EAAiC;AACtC,eAAO,CAAP;AACD;;AACD,aAAO,CAAC,CAAR;AACD,KAPe,CAHM,EAWrBT,MAAD,IAAYlC,GAAG,CAACkC,MAAD,CAXO,CAAxB;;AAcA,SAAK,IAAIU,CAAC,GAAG,CAAb,EAAgB,KAAKxB,QAAL,IAAiBwB,CAAC,GAAGb,KAAK,CAACW,MAA3B,IAAqC,KAAKvB,OAAL,CAAaU,WAAb,CAAyBC,IAAzB,GAAgCpB,cAArF,EAAqGkC,CAAC,EAAtG,EAA0G;AACxG,YAAMT,IAAI,GAAGJ,KAAK,CAACa,CAAD,CAAlB;;AAEA,UAAI,CAAC,KAAKzB,OAAL,CAAa0B,iBAAb,CAA+BC,GAA/B,CAAmCX,IAAI,CAACC,EAAxC,CAAL,EAAkD;AAChDhC,QAAAA,GAAG,CAAC,0CAAD,EAA6C+B,IAAI,CAACC,EAAL,CAAQW,WAAR,EAA7C,CAAH;;AACA,YAAI;AACF,gBAAM,KAAK5B,OAAL,CAAa6B,MAAb,CAAoBC,aAApB,CAAkCd,IAAI,CAACC,EAAvC,CAAN;AACD,SAFD,CAEE;AAAO;AAAmBV,QAAAA,GAA1B,EAA+B;AAC/BtB,UAAAA,GAAG,CAACG,KAAJ,CAAU,4CAAV,EAAwDmB,GAAxD;AACD;AACF;AACF,KArCgB,CAuCjB;;;AACA,QAAI,CAAC,KAAKN,QAAV,EAAoB;AAClB;AACD;;AAED,SAAKC,gBAAL,GAAwBtB,OAAO,CAAC,KAAKuB,SAAN,EAAiB,KAAKN,QAAL,CAAcL,gBAA/B,CAA/B;AACD;;AA/Fe;;AAkGlBuC,MAAM,CAACC,OAAP,GAAiBvC,WAAjB","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst mergeOptions = require('merge-options')\n// @ts-ignore retimer does not have types\nconst retimer = require('retimer')\nconst all = require('it-all')\nconst { pipe } = require('it-pipe')\nconst filter = require('it-filter')\nconst sort = require('it-sort')\n\nconst log = Object.assign(debug('libp2p:connection-manager:auto-dialler'), {\n  error: debug('libp2p:connection-manager:auto-dialler:err')\n})\n\nconst defaultOptions = {\n  enabled: true,\n  minConnections: 0,\n  autoDialInterval: 10000\n}\n\n/**\n * @typedef {import('../index')} Libp2p\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n */\n\n/**\n * @typedef {Object} AutoDiallerOptions\n * @property {boolean} [enabled = true] - Should preemptively guarantee connections are above the low watermark\n * @property {number} [minConnections = 0] - The minimum number of connections to avoid pruning\n * @property {number} [autoDialInterval = 10000] - How often, in milliseconds, it should preemptively guarantee connections are above the low watermark\n */\n\nclass AutoDialler {\n  /**\n   * Proactively tries to connect to known peers stored in the PeerStore.\n   * It will keep the number of connections below the upper limit and sort\n   * the peers to connect based on wether we know their keys and protocols.\n   *\n   * @class\n   * @param {Libp2p} libp2p\n   * @param {AutoDiallerOptions} options\n   */\n  constructor (libp2p, options = {}) {\n    this._options = mergeOptions.call({ ignoreUndefined: true }, defaultOptions, options)\n    this._libp2p = libp2p\n    this._running = false\n    this._autoDialTimeout = null\n    this._autoDial = this._autoDial.bind(this)\n\n    log('options: %j', this._options)\n  }\n\n  /**\n   * Starts the auto dialer\n   */\n  async start () {\n    if (!this._options.enabled) {\n      log('not enabled')\n      return\n    }\n\n    this._running = true\n    this._autoDial().catch(err => {\n      log.error('could start autodial', err)\n    })\n    log('started')\n  }\n\n  /**\n   * Stops the auto dialler\n   */\n  async stop () {\n    if (!this._options.enabled) {\n      log('not enabled')\n      return\n    }\n\n    this._running = false\n    this._autoDialTimeout && this._autoDialTimeout.clear()\n    log('stopped')\n  }\n\n  async _autoDial () {\n    const minConnections = this._options.minConnections\n\n    // Already has enough connections\n    if (this._libp2p.connections.size >= minConnections) {\n      this._autoDialTimeout = retimer(this._autoDial, this._options.autoDialInterval)\n      return\n    }\n\n    // Sort peers on whether we know protocols of public keys for them\n    // TODO: assuming the `peerStore.getPeers()` order is stable this will mean\n    // we keep trying to connect to the same peers?\n    const peers = await pipe(\n      this._libp2p.peerStore.getPeers(),\n      (source) => filter(source, (peer) => !peer.id.equals(this._libp2p.peerId)),\n      (source) => sort(source, (a, b) => {\n        if (b.protocols && b.protocols.length && (!a.protocols || !a.protocols.length)) {\n          return 1\n        } else if (b.id.pubKey && !a.id.pubKey) {\n          return 1\n        }\n        return -1\n      }),\n      (source) => all(source)\n    )\n\n    for (let i = 0; this._running && i < peers.length && this._libp2p.connections.size < minConnections; i++) {\n      const peer = peers[i]\n\n      if (!this._libp2p.connectionManager.get(peer.id)) {\n        log('connecting to a peerStore stored peer %s', peer.id.toB58String())\n        try {\n          await this._libp2p.dialer.connectToPeer(peer.id)\n        } catch (/** @type {any} */ err) {\n          log.error('could not connect to peerStore stored peer', err)\n        }\n      }\n    }\n\n    // Connection Manager was stopped\n    if (!this._running) {\n      return\n    }\n\n    this._autoDialTimeout = retimer(this._autoDial, this._options.autoDialInterval)\n  }\n}\n\nmodule.exports = AutoDialler\n"]},"metadata":{},"sourceType":"script"}