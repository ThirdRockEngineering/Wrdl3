{"ast":null,"code":"'use strict';\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst take = require('it-take');\n\nconst length = require('it-length');\n\nconst {\n  QUERY_SELF_INTERVAL,\n  QUERY_SELF_TIMEOUT,\n  K\n} = require('./constants');\n\nconst utils = require('./utils');\n\nconst {\n  TimeoutController\n} = require('timeout-abort-controller');\n\nconst {\n  anySignal\n} = require('any-signal'); // @ts-expect-error setMaxListeners is missing from the types\n\n\nconst {\n  setMaxListeners\n} = require('events');\n/**\n * Receives notifications of new peers joining the network that support the DHT protocol\n */\n\n\nclass QuerySelf extends EventEmitter {\n  /**\n   * Create a new network\n   *\n   * @param {object} params\n   * @param {import('peer-id')} params.peerId\n   * @param {import('./peer-routing').PeerRouting} params.peerRouting\n   * @param {number} [params.count] - how many peers to find\n   * @param {number} [params.interval] - how often to find them\n   * @param {number} [params.queryTimeout] - how long to let queries run\n   * @param {boolean} params.lan\n   */\n  constructor(_ref) {\n    let {\n      peerId,\n      peerRouting,\n      lan,\n      count = K,\n      interval = QUERY_SELF_INTERVAL,\n      queryTimeout = QUERY_SELF_TIMEOUT\n    } = _ref;\n    super();\n    this._log = utils.logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}:query-self`);\n    this._running = false;\n    this._peerId = peerId;\n    this._peerRouting = peerRouting;\n    this._count = count || K;\n    this._interval = interval || QUERY_SELF_INTERVAL;\n    this._queryTimeout = queryTimeout || QUERY_SELF_TIMEOUT;\n  }\n  /**\n   * Start the network\n   */\n\n\n  start() {\n    if (this._running) {\n      return;\n    }\n\n    this._running = true;\n\n    this._querySelf();\n  }\n  /**\n   * Stop all network activity\n   */\n\n\n  stop() {\n    this._running = false;\n\n    if (this._timeoutId) {\n      clearTimeout(this._timeoutId);\n    }\n\n    if (this._controller) {\n      this._controller.abort();\n    }\n  }\n\n  async _querySelf() {\n    const timeoutController = new TimeoutController(this._queryTimeout);\n\n    try {\n      this._controller = new AbortController();\n      const signal = anySignal([this._controller.signal, timeoutController.signal]); // this controller will get used for lots of dial attempts so make sure we don't cause warnings to be logged\n\n      try {\n        setMaxListeners && setMaxListeners(Infinity, signal);\n      } catch {} // fails on node < 15.4\n\n\n      const found = await length(await take(this._peerRouting.getClosestPeers(this._peerId.toBytes(), {\n        signal\n      }), this._count));\n\n      this._log('query ran successfully - found %d peers', found);\n    } catch (\n    /** @type {any} */\n    err) {\n      this._log('query error', err);\n    } finally {\n      this._timeoutId = setTimeout(this._querySelf.bind(this), this._interval);\n      timeoutController.clear();\n    }\n  }\n\n}\n\nmodule.exports.QuerySelf = QuerySelf;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p-kad-dht/src/query-self.js"],"names":["EventEmitter","require","take","length","QUERY_SELF_INTERVAL","QUERY_SELF_TIMEOUT","K","utils","TimeoutController","anySignal","setMaxListeners","QuerySelf","constructor","peerId","peerRouting","lan","count","interval","queryTimeout","_log","logger","_running","_peerId","_peerRouting","_count","_interval","_queryTimeout","start","_querySelf","stop","_timeoutId","clearTimeout","_controller","abort","timeoutController","AbortController","signal","Infinity","found","getClosestPeers","toBytes","err","setTimeout","bind","clear","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { EventEmitter } = require('events')\nconst take = require('it-take')\nconst length = require('it-length')\nconst { QUERY_SELF_INTERVAL, QUERY_SELF_TIMEOUT, K } = require('./constants')\nconst utils = require('./utils')\nconst { TimeoutController } = require('timeout-abort-controller')\nconst { anySignal } = require('any-signal')\n// @ts-expect-error setMaxListeners is missing from the types\nconst { setMaxListeners } = require('events')\n\n/**\n * Receives notifications of new peers joining the network that support the DHT protocol\n */\nclass QuerySelf extends EventEmitter {\n  /**\n   * Create a new network\n   *\n   * @param {object} params\n   * @param {import('peer-id')} params.peerId\n   * @param {import('./peer-routing').PeerRouting} params.peerRouting\n   * @param {number} [params.count] - how many peers to find\n   * @param {number} [params.interval] - how often to find them\n   * @param {number} [params.queryTimeout] - how long to let queries run\n   * @param {boolean} params.lan\n   */\n  constructor ({ peerId, peerRouting, lan, count = K, interval = QUERY_SELF_INTERVAL, queryTimeout = QUERY_SELF_TIMEOUT }) {\n    super()\n\n    this._log = utils.logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}:query-self`)\n    this._running = false\n    this._peerId = peerId\n    this._peerRouting = peerRouting\n    this._count = count || K\n    this._interval = interval || QUERY_SELF_INTERVAL\n    this._queryTimeout = queryTimeout || QUERY_SELF_TIMEOUT\n  }\n\n  /**\n   * Start the network\n   */\n  start () {\n    if (this._running) {\n      return\n    }\n\n    this._running = true\n    this._querySelf()\n  }\n\n  /**\n   * Stop all network activity\n   */\n  stop () {\n    this._running = false\n\n    if (this._timeoutId) {\n      clearTimeout(this._timeoutId)\n    }\n\n    if (this._controller) {\n      this._controller.abort()\n    }\n  }\n\n  async _querySelf () {\n    const timeoutController = new TimeoutController(this._queryTimeout)\n\n    try {\n      this._controller = new AbortController()\n      const signal = anySignal([this._controller.signal, timeoutController.signal])\n      // this controller will get used for lots of dial attempts so make sure we don't cause warnings to be logged\n      try {\n        setMaxListeners && setMaxListeners(Infinity, signal)\n      } catch {} // fails on node < 15.4\n      const found = await length(await take(this._peerRouting.getClosestPeers(this._peerId.toBytes(), {\n        signal\n      }), this._count))\n\n      this._log('query ran successfully - found %d peers', found)\n    } catch (/** @type {any} */ err) {\n      this._log('query error', err)\n    } finally {\n      this._timeoutId = setTimeout(this._querySelf.bind(this), this._interval)\n      timeoutController.clear()\n    }\n  }\n}\n\nmodule.exports.QuerySelf = QuerySelf\n"]},"metadata":{},"sourceType":"script"}