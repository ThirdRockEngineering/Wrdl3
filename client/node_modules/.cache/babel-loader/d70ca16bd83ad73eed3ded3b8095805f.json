{"ast":null,"code":"'use strict';\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst lp = require('it-length-prefixed');\n\nconst {\n  Message,\n  MESSAGE_TYPE_LOOKUP\n} = require('../message');\n\nconst handlers = require('./handlers');\n\nconst utils = require('../utils');\n\nconst log = utils.logger('libp2p:kad-dht:rpc');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n */\n\n/**\n * @param {import('../types').DHT} dht\n */\n\nclass RPC {\n  /**\n   * @param {object} params\n   * @param {import('../routing-table').RoutingTable} params.routingTable\n   * @param {import('peer-id')} params.peerId\n   * @param {import('../providers').Providers} params.providers\n   * @param {import('libp2p/src/peer-store/types').PeerStore} params.peerStore\n   * @param {import('../types').Addressable} params.addressable\n   * @param {import('../peer-routing').PeerRouting} params.peerRouting\n   * @param {import('interface-datastore').Datastore} params.records\n   * @param {import('libp2p-interfaces/src/types').DhtValidators} params.validators\n   * @param {boolean} [params.lan]\n   */\n  constructor(params) {\n    this._messageHandler = handlers(params);\n    this._routingTable = params.routingTable;\n  }\n  /**\n   * Process incoming DHT messages.\n   *\n   * @param {PeerId} peerId\n   * @param {Message} msg\n   */\n\n\n  async handleMessage(peerId, msg) {\n    // get handler & execute it\n    const handler = this._messageHandler(msg.type);\n\n    try {\n      await this._routingTable.add(peerId);\n    } catch (\n    /** @type {any} */\n    err) {\n      log.error('Failed to update the kbucket store', err);\n    }\n\n    if (!handler) {\n      log.error(`no handler found for message type: ${msg.type}`);\n      return;\n    }\n\n    return handler.handle(peerId, msg);\n  }\n  /**\n   * Handle incoming streams on the dht protocol\n   *\n   * @param {object} props\n   * @param {MuxedStream} props.stream\n   * @param {import('libp2p-interfaces/src/connection').Connection} props.connection\n   */\n\n\n  async onIncomingStream(_ref) {\n    let {\n      stream,\n      connection\n    } = _ref;\n    const peerId = connection.remotePeer;\n\n    try {\n      await this._routingTable.add(peerId);\n    } catch (\n    /** @type {any} */\n    err) {\n      log.error(err);\n    }\n\n    const self = this;\n    await pipe(stream.source, lp.decode(),\n    /**\n     * @param {AsyncIterable<Uint8Array>} source\n     */\n    source => async function* () {\n      for await (const msg of source) {\n        // handle the message\n        const desMessage = Message.deserialize(msg.slice());\n        log('incoming %s from %p', MESSAGE_TYPE_LOOKUP[desMessage.type], peerId);\n        const res = await self.handleMessage(peerId, desMessage); // Not all handlers will return a response\n\n        if (res) {\n          yield res.serialize();\n        }\n      }\n    }(), lp.encode(), stream.sink);\n  }\n\n}\n\nmodule.exports.RPC = RPC;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p-kad-dht/src/rpc/index.js"],"names":["pipe","require","lp","Message","MESSAGE_TYPE_LOOKUP","handlers","utils","log","logger","RPC","constructor","params","_messageHandler","_routingTable","routingTable","handleMessage","peerId","msg","handler","type","add","err","error","handle","onIncomingStream","stream","connection","remotePeer","self","source","decode","desMessage","deserialize","slice","res","serialize","encode","sink","module","exports"],"mappings":"AAAA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAWC,OAAO,CAAC,SAAD,CAAxB;;AACA,MAAMC,EAAE,GAAGD,OAAO,CAAC,oBAAD,CAAlB;;AAEA,MAAM;AAAEE,EAAAA,OAAF;AAAWC,EAAAA;AAAX,IAAmCH,OAAO,CAAC,YAAD,CAAhD;;AACA,MAAMI,QAAQ,GAAGJ,OAAO,CAAC,YAAD,CAAxB;;AACA,MAAMK,KAAK,GAAGL,OAAO,CAAC,UAAD,CAArB;;AAEA,MAAMM,GAAG,GAAGD,KAAK,CAACE,MAAN,CAAa,oBAAb,CAAZ;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA,MAAMC,GAAN,CAAU;AACR;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEC,EAAAA,WAAW,CAAEC,MAAF,EAAU;AACnB,SAAKC,eAAL,GAAuBP,QAAQ,CAACM,MAAD,CAA/B;AACA,SAAKE,aAAL,GAAqBF,MAAM,CAACG,YAA5B;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACqB,QAAbC,aAAa,CAAEC,MAAF,EAAUC,GAAV,EAAe;AAChC;AACA,UAAMC,OAAO,GAAG,KAAKN,eAAL,CAAqBK,GAAG,CAACE,IAAzB,CAAhB;;AAEA,QAAI;AACF,YAAM,KAAKN,aAAL,CAAmBO,GAAnB,CAAuBJ,MAAvB,CAAN;AACD,KAFD,CAEE;AAAO;AAAmBK,IAAAA,GAA1B,EAA+B;AAC/Bd,MAAAA,GAAG,CAACe,KAAJ,CAAU,oCAAV,EAAgDD,GAAhD;AACD;;AAED,QAAI,CAACH,OAAL,EAAc;AACZX,MAAAA,GAAG,CAACe,KAAJ,CAAW,sCAAqCL,GAAG,CAACE,IAAK,EAAzD;AACA;AACD;;AAED,WAAOD,OAAO,CAACK,MAAR,CAAeP,MAAf,EAAuBC,GAAvB,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACwB,QAAhBO,gBAAgB,OAA0B;AAAA,QAAxB;AAAEC,MAAAA,MAAF;AAAUC,MAAAA;AAAV,KAAwB;AAC9C,UAAMV,MAAM,GAAGU,UAAU,CAACC,UAA1B;;AAEA,QAAI;AACF,YAAM,KAAKd,aAAL,CAAmBO,GAAnB,CAAuBJ,MAAvB,CAAN;AACD,KAFD,CAEE;AAAO;AAAmBK,IAAAA,GAA1B,EAA+B;AAC/Bd,MAAAA,GAAG,CAACe,KAAJ,CAAUD,GAAV;AACD;;AAED,UAAMO,IAAI,GAAG,IAAb;AAEA,UAAM5B,IAAI,CACRyB,MAAM,CAACI,MADC,EAER3B,EAAE,CAAC4B,MAAH,EAFQ;AAGR;AACN;AACA;AACMD,IAAAA,MAAM,IAAK,mBAAoB;AAC7B,iBAAW,MAAMZ,GAAjB,IAAwBY,MAAxB,EAAgC;AAC9B;AACA,cAAME,UAAU,GAAG5B,OAAO,CAAC6B,WAAR,CAAoBf,GAAG,CAACgB,KAAJ,EAApB,CAAnB;AACA1B,QAAAA,GAAG,CAAC,qBAAD,EAAwBH,mBAAmB,CAAC2B,UAAU,CAACZ,IAAZ,CAA3C,EAA8DH,MAA9D,CAAH;AACA,cAAMkB,GAAG,GAAG,MAAMN,IAAI,CAACb,aAAL,CAAmBC,MAAnB,EAA2Be,UAA3B,CAAlB,CAJ8B,CAM9B;;AACA,YAAIG,GAAJ,EAAS;AACP,gBAAMA,GAAG,CAACC,SAAJ,EAAN;AACD;AACF;AACF,KAZS,EANF,EAmBRjC,EAAE,CAACkC,MAAH,EAnBQ,EAoBRX,MAAM,CAACY,IApBC,CAAV;AAsBD;;AAlFO;;AAqFVC,MAAM,CAACC,OAAP,CAAe9B,GAAf,GAAqBA,GAArB","sourcesContent":["'use strict'\n\nconst { pipe } = require('it-pipe')\nconst lp = require('it-length-prefixed')\n\nconst { Message, MESSAGE_TYPE_LOOKUP } = require('../message')\nconst handlers = require('./handlers')\nconst utils = require('../utils')\n\nconst log = utils.logger('libp2p:kad-dht:rpc')\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n */\n\n/**\n * @param {import('../types').DHT} dht\n */\nclass RPC {\n  /**\n   * @param {object} params\n   * @param {import('../routing-table').RoutingTable} params.routingTable\n   * @param {import('peer-id')} params.peerId\n   * @param {import('../providers').Providers} params.providers\n   * @param {import('libp2p/src/peer-store/types').PeerStore} params.peerStore\n   * @param {import('../types').Addressable} params.addressable\n   * @param {import('../peer-routing').PeerRouting} params.peerRouting\n   * @param {import('interface-datastore').Datastore} params.records\n   * @param {import('libp2p-interfaces/src/types').DhtValidators} params.validators\n   * @param {boolean} [params.lan]\n   */\n  constructor (params) {\n    this._messageHandler = handlers(params)\n    this._routingTable = params.routingTable\n  }\n\n  /**\n   * Process incoming DHT messages.\n   *\n   * @param {PeerId} peerId\n   * @param {Message} msg\n   */\n  async handleMessage (peerId, msg) {\n    // get handler & execute it\n    const handler = this._messageHandler(msg.type)\n\n    try {\n      await this._routingTable.add(peerId)\n    } catch (/** @type {any} */ err) {\n      log.error('Failed to update the kbucket store', err)\n    }\n\n    if (!handler) {\n      log.error(`no handler found for message type: ${msg.type}`)\n      return\n    }\n\n    return handler.handle(peerId, msg)\n  }\n\n  /**\n   * Handle incoming streams on the dht protocol\n   *\n   * @param {object} props\n   * @param {MuxedStream} props.stream\n   * @param {import('libp2p-interfaces/src/connection').Connection} props.connection\n   */\n  async onIncomingStream ({ stream, connection }) {\n    const peerId = connection.remotePeer\n\n    try {\n      await this._routingTable.add(peerId)\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n    }\n\n    const self = this\n\n    await pipe(\n      stream.source,\n      lp.decode(),\n      /**\n       * @param {AsyncIterable<Uint8Array>} source\n       */\n      source => (async function * () {\n        for await (const msg of source) {\n          // handle the message\n          const desMessage = Message.deserialize(msg.slice())\n          log('incoming %s from %p', MESSAGE_TYPE_LOOKUP[desMessage.type], peerId)\n          const res = await self.handleMessage(peerId, desMessage)\n\n          // Not all handlers will return a response\n          if (res) {\n            yield res.serialize()\n          }\n        }\n      })(),\n      lp.encode(),\n      stream.sink\n    )\n  }\n}\n\nmodule.exports.RPC = RPC\n"]},"metadata":{},"sourceType":"script"}