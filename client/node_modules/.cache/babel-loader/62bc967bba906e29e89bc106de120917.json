{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst errcode = require('err-code');\n\nconst {\n  codes\n} = require('../errors');\n\nconst PeerId = require('peer-id');\n\nconst {\n  equals: uint8ArrayEquals\n} = require('uint8arrays/equals');\n\nconst log = Object.assign(debug('libp2p:peer-store:metadata-book'), {\n  error: debug('libp2p:peer-store:metadata-book:err')\n});\n/**\n * @typedef {import('./types').PeerStore} PeerStore\n * @typedef {import('./types').MetadataBook} MetadataBook\n */\n\nconst EVENT_NAME = 'change:metadata';\n/**\n * @implements {MetadataBook}\n */\n\nclass PeerStoreMetadataBook {\n  /**\n   * The MetadataBook is responsible for keeping the known supported\n   * protocols of a peer\n   *\n   * @param {PeerStore[\"emit\"]} emit\n   * @param {import('./types').Store} store\n   */\n  constructor(emit, store) {\n    this._emit = emit;\n    this._store = store;\n  }\n  /**\n   * Get the known data of a provided peer\n   *\n   * @param {PeerId} peerId\n   */\n\n\n  async get(peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log('get await read lock');\n    const release = await this._store.lock.readLock();\n    log('get got read lock');\n\n    try {\n      const peer = await this._store.load(peerId);\n      return peer.metadata;\n    } catch (\n    /** @type {any} */\n    err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err;\n      }\n    } finally {\n      log('get release read lock');\n      release();\n    }\n\n    return new Map();\n  }\n  /**\n   * Get specific metadata value, if it exists\n   *\n   * @param {PeerId} peerId\n   * @param {string} key\n   */\n\n\n  async getValue(peerId, key) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log('getValue await read lock');\n    const release = await this._store.lock.readLock();\n    log('getValue got read lock');\n\n    try {\n      const peer = await this._store.load(peerId);\n      return peer.metadata.get(key);\n    } catch (\n    /** @type {any} */\n    err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err;\n      }\n    } finally {\n      log('getValue release write lock');\n      release();\n    }\n  }\n  /**\n   * @param {PeerId} peerId\n   * @param {Map<string, Uint8Array>} metadata\n   */\n\n\n  async set(peerId, metadata) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    if (!metadata || !(metadata instanceof Map)) {\n      log.error('valid metadata must be provided to store data');\n      throw errcode(new Error('valid metadata must be provided'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log('set await write lock');\n    const release = await this._store.lock.writeLock();\n    log('set got write lock');\n\n    try {\n      await this._store.mergeOrCreate(peerId, {\n        metadata\n      });\n    } finally {\n      log('set release write lock');\n      release();\n    }\n\n    this._emit(EVENT_NAME, {\n      peerId,\n      metadata\n    });\n  }\n  /**\n   * Set metadata key and value of a provided peer\n   *\n   * @param {PeerId} peerId\n   * @param {string} key - metadata key\n   * @param {Uint8Array} value - metadata value\n   */\n\n\n  async setValue(peerId, key, value) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    if (typeof key !== 'string' || !(value instanceof Uint8Array)) {\n      log.error('valid key and value must be provided to store data');\n      throw errcode(new Error('valid key and value must be provided'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log('setValue await write lock');\n    const release = await this._store.lock.writeLock();\n    log('setValue got write lock');\n    let updatedPeer;\n\n    try {\n      try {\n        const existingPeer = await this._store.load(peerId);\n        const existingValue = existingPeer.metadata.get(key);\n\n        if (existingValue != null && uint8ArrayEquals(value, existingValue)) {\n          return;\n        }\n      } catch (\n      /** @type {any} */\n      err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err;\n        }\n      }\n\n      updatedPeer = await this._store.mergeOrCreate(peerId, {\n        metadata: new Map([[key, value]])\n      });\n    } finally {\n      log('setValue release write lock');\n      release();\n    }\n\n    this._emit(EVENT_NAME, {\n      peerId,\n      metadata: updatedPeer.metadata\n    });\n  }\n  /**\n   * @param {PeerId} peerId\n   */\n\n\n  async delete(peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log('delete await write lock');\n    const release = await this._store.lock.writeLock();\n    log('delete got write lock');\n    let has;\n\n    try {\n      has = await this._store.has(peerId);\n\n      if (has) {\n        await this._store.patch(peerId, {\n          metadata: new Map()\n        });\n      }\n    } finally {\n      log('delete release write lock');\n      release();\n    }\n\n    if (has) {\n      this._emit(EVENT_NAME, {\n        peerId,\n        metadata: new Map()\n      });\n    }\n  }\n  /**\n   * @param {PeerId} peerId\n   * @param {string} key\n   */\n\n\n  async deleteValue(peerId, key) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log('deleteValue await write lock');\n    const release = await this._store.lock.writeLock();\n    log('deleteValue got write lock');\n    let metadata;\n\n    try {\n      const peer = await this._store.load(peerId);\n      metadata = peer.metadata;\n      metadata.delete(key);\n      await this._store.patch(peerId, {\n        metadata\n      });\n    } catch (\n    /** @type {any} **/\n    err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err;\n      }\n    } finally {\n      log('deleteValue release write lock');\n      release();\n    }\n\n    if (metadata) {\n      this._emit(EVENT_NAME, {\n        peerId,\n        metadata\n      });\n    }\n  }\n\n}\n\nmodule.exports = PeerStoreMetadataBook;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p/src/peer-store/metadata-book.js"],"names":["debug","require","errcode","codes","PeerId","equals","uint8ArrayEquals","log","Object","assign","error","EVENT_NAME","PeerStoreMetadataBook","constructor","emit","store","_emit","_store","get","peerId","isPeerId","Error","ERR_INVALID_PARAMETERS","release","lock","readLock","peer","load","metadata","err","code","ERR_NOT_FOUND","Map","getValue","key","set","writeLock","mergeOrCreate","setValue","value","Uint8Array","updatedPeer","existingPeer","existingValue","delete","has","patch","deleteValue","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst errcode = require('err-code')\nconst { codes } = require('../errors')\nconst PeerId = require('peer-id')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\n\nconst log = Object.assign(debug('libp2p:peer-store:metadata-book'), {\n  error: debug('libp2p:peer-store:metadata-book:err')\n})\n\n/**\n * @typedef {import('./types').PeerStore} PeerStore\n * @typedef {import('./types').MetadataBook} MetadataBook\n */\n\nconst EVENT_NAME = 'change:metadata'\n\n/**\n * @implements {MetadataBook}\n */\nclass PeerStoreMetadataBook {\n  /**\n   * The MetadataBook is responsible for keeping the known supported\n   * protocols of a peer\n   *\n   * @param {PeerStore[\"emit\"]} emit\n   * @param {import('./types').Store} store\n   */\n  constructor (emit, store) {\n    this._emit = emit\n    this._store = store\n  }\n\n  /**\n   * Get the known data of a provided peer\n   *\n   * @param {PeerId} peerId\n   */\n  async get (peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log('get await read lock')\n    const release = await this._store.lock.readLock()\n    log('get got read lock')\n\n    try {\n      const peer = await this._store.load(peerId)\n\n      return peer.metadata\n    } catch (/** @type {any} */ err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err\n      }\n    } finally {\n      log('get release read lock')\n      release()\n    }\n\n    return new Map()\n  }\n\n  /**\n   * Get specific metadata value, if it exists\n   *\n   * @param {PeerId} peerId\n   * @param {string} key\n   */\n  async getValue (peerId, key) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log('getValue await read lock')\n    const release = await this._store.lock.readLock()\n    log('getValue got read lock')\n\n    try {\n      const peer = await this._store.load(peerId)\n\n      return peer.metadata.get(key)\n    } catch (/** @type {any} */ err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err\n      }\n    } finally {\n      log('getValue release write lock')\n      release()\n    }\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {Map<string, Uint8Array>} metadata\n   */\n  async set (peerId, metadata) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    if (!metadata || !(metadata instanceof Map)) {\n      log.error('valid metadata must be provided to store data')\n      throw errcode(new Error('valid metadata must be provided'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log('set await write lock')\n    const release = await this._store.lock.writeLock()\n    log('set got write lock')\n\n    try {\n      await this._store.mergeOrCreate(peerId, {\n        metadata\n      })\n    } finally {\n      log('set release write lock')\n      release()\n    }\n\n    this._emit(EVENT_NAME, { peerId, metadata })\n  }\n\n  /**\n   * Set metadata key and value of a provided peer\n   *\n   * @param {PeerId} peerId\n   * @param {string} key - metadata key\n   * @param {Uint8Array} value - metadata value\n   */\n  async setValue (peerId, key, value) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    if (typeof key !== 'string' || !(value instanceof Uint8Array)) {\n      log.error('valid key and value must be provided to store data')\n      throw errcode(new Error('valid key and value must be provided'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log('setValue await write lock')\n    const release = await this._store.lock.writeLock()\n    log('setValue got write lock')\n\n    let updatedPeer\n\n    try {\n      try {\n        const existingPeer = await this._store.load(peerId)\n        const existingValue = existingPeer.metadata.get(key)\n\n        if (existingValue != null && uint8ArrayEquals(value, existingValue)) {\n          return\n        }\n      } catch (/** @type {any} */ err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err\n        }\n      }\n\n      updatedPeer = await this._store.mergeOrCreate(peerId, {\n        metadata: new Map([[key, value]])\n      })\n    } finally {\n      log('setValue release write lock')\n      release()\n    }\n\n    this._emit(EVENT_NAME, { peerId, metadata: updatedPeer.metadata })\n  }\n\n  /**\n   * @param {PeerId} peerId\n   */\n  async delete (peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log('delete await write lock')\n    const release = await this._store.lock.writeLock()\n    log('delete got write lock')\n\n    let has\n\n    try {\n      has = await this._store.has(peerId)\n\n      if (has) {\n        await this._store.patch(peerId, {\n          metadata: new Map()\n        })\n      }\n    } finally {\n      log('delete release write lock')\n      release()\n    }\n\n    if (has) {\n      this._emit(EVENT_NAME, { peerId, metadata: new Map() })\n    }\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {string} key\n   */\n  async deleteValue (peerId, key) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log('deleteValue await write lock')\n    const release = await this._store.lock.writeLock()\n    log('deleteValue got write lock')\n\n    let metadata\n\n    try {\n      const peer = await this._store.load(peerId)\n      metadata = peer.metadata\n\n      metadata.delete(key)\n\n      await this._store.patch(peerId, {\n        metadata\n      })\n    } catch (/** @type {any} **/ err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err\n      }\n    } finally {\n      log('deleteValue release write lock')\n      release()\n    }\n\n    if (metadata) {\n      this._emit(EVENT_NAME, { peerId, metadata })\n    }\n  }\n}\n\nmodule.exports = PeerStoreMetadataBook\n"]},"metadata":{},"sourceType":"script"}