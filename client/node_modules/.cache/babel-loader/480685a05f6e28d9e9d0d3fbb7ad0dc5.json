{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst BufferList = require('bl/BufferList');\n\nconst multistream = require('./multistream'); // @ts-expect-error no types\n\n\nconst handshake = require('it-handshake');\n\nconst {\n  PROTOCOL_ID\n} = require('./constants');\n\nconst log = Object.assign(debug('mss:handle'), {\n  error: debug('mss:handle:error')\n});\n/**\n * @typedef {import('./types').DuplexStream<Uint8Array | BufferList>} DuplexStream\n * @typedef {import('./types').AbortOptions} AbortOptions\n */\n\n/**\n * @param {DuplexStream} stream\n * @param {string | string[]} protocols\n * @param {AbortOptions} [options]\n */\n\nmodule.exports = async function handle(stream, protocols, options) {\n  protocols = Array.isArray(protocols) ? protocols : [protocols];\n  const {\n    writer,\n    reader,\n    rest,\n    stream: shakeStream\n  } = handshake(stream);\n\n  while (true) {\n    const protocol = (await multistream.read(reader, options)).toString();\n    log('read \"%s\"', protocol);\n\n    if (protocol === PROTOCOL_ID) {\n      log('respond with \"%s\" for \"%s\"', PROTOCOL_ID, protocol);\n      multistream.write(writer, PROTOCOL_ID);\n      continue;\n    }\n\n    if (protocols.includes(protocol)) {\n      multistream.write(writer, protocol);\n      log('respond with \"%s\" for \"%s\"', protocol, protocol);\n      rest();\n      return {\n        stream: shakeStream,\n        protocol\n      };\n    }\n\n    if (protocol === 'ls') {\n      // <varint-msg-len><varint-proto-name-len><proto-name>\\n<varint-proto-name-len><proto-name>\\n\\n\n      multistream.write(writer, new BufferList( // @ts-expect-error BufferList does not accept Uint8Array[] as a constructor arg\n      protocols.map(p => multistream.encode(p))));\n      log('respond with \"%s\" for %s', protocols, protocol);\n      continue;\n    }\n\n    multistream.write(writer, 'na');\n    log('respond with \"na\" for \"%s\"', protocol);\n  }\n};","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/multistream-select/src/handle.js"],"names":["debug","require","BufferList","multistream","handshake","PROTOCOL_ID","log","Object","assign","error","module","exports","handle","stream","protocols","options","Array","isArray","writer","reader","rest","shakeStream","protocol","read","toString","write","includes","map","p","encode"],"mappings":"AAAA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,eAAD,CAA1B;;AACA,MAAME,WAAW,GAAGF,OAAO,CAAC,eAAD,CAA3B,C,CACA;;;AACA,MAAMG,SAAS,GAAGH,OAAO,CAAC,cAAD,CAAzB;;AACA,MAAM;AAAEI,EAAAA;AAAF,IAAkBJ,OAAO,CAAC,aAAD,CAA/B;;AAEA,MAAMK,GAAG,GAAGC,MAAM,CAACC,MAAP,CAAcR,KAAK,CAAC,YAAD,CAAnB,EAAmC;AAC7CS,EAAAA,KAAK,EAAET,KAAK,CAAC,kBAAD;AADiC,CAAnC,CAAZ;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACAU,MAAM,CAACC,OAAP,GAAiB,eAAeC,MAAf,CAAuBC,MAAvB,EAA+BC,SAA/B,EAA0CC,OAA1C,EAAmD;AAClED,EAAAA,SAAS,GAAGE,KAAK,CAACC,OAAN,CAAcH,SAAd,IAA2BA,SAA3B,GAAuC,CAACA,SAAD,CAAnD;AACA,QAAM;AAAEI,IAAAA,MAAF;AAAUC,IAAAA,MAAV;AAAkBC,IAAAA,IAAlB;AAAwBP,IAAAA,MAAM,EAAEQ;AAAhC,MAAgDjB,SAAS,CAACS,MAAD,CAA/D;;AAEA,SAAO,IAAP,EAAa;AACX,UAAMS,QAAQ,GAAG,CAAC,MAAMnB,WAAW,CAACoB,IAAZ,CAAiBJ,MAAjB,EAAyBJ,OAAzB,CAAP,EAA0CS,QAA1C,EAAjB;AACAlB,IAAAA,GAAG,CAAC,WAAD,EAAcgB,QAAd,CAAH;;AAEA,QAAIA,QAAQ,KAAKjB,WAAjB,EAA8B;AAC5BC,MAAAA,GAAG,CAAC,4BAAD,EAA+BD,WAA/B,EAA4CiB,QAA5C,CAAH;AACAnB,MAAAA,WAAW,CAACsB,KAAZ,CAAkBP,MAAlB,EAA0Bb,WAA1B;AACA;AACD;;AAED,QAAIS,SAAS,CAACY,QAAV,CAAmBJ,QAAnB,CAAJ,EAAkC;AAChCnB,MAAAA,WAAW,CAACsB,KAAZ,CAAkBP,MAAlB,EAA0BI,QAA1B;AACAhB,MAAAA,GAAG,CAAC,4BAAD,EAA+BgB,QAA/B,EAAyCA,QAAzC,CAAH;AACAF,MAAAA,IAAI;AACJ,aAAO;AAAEP,QAAAA,MAAM,EAAEQ,WAAV;AAAuBC,QAAAA;AAAvB,OAAP;AACD;;AAED,QAAIA,QAAQ,KAAK,IAAjB,EAAuB;AACrB;AACAnB,MAAAA,WAAW,CAACsB,KAAZ,CAAkBP,MAAlB,EAA0B,IAAIhB,UAAJ,EACxB;AACAY,MAAAA,SAAS,CAACa,GAAV,CAAcC,CAAC,IAAIzB,WAAW,CAAC0B,MAAZ,CAAmBD,CAAnB,CAAnB,CAFwB,CAA1B;AAIAtB,MAAAA,GAAG,CAAC,0BAAD,EAA6BQ,SAA7B,EAAwCQ,QAAxC,CAAH;AACA;AACD;;AAEDnB,IAAAA,WAAW,CAACsB,KAAZ,CAAkBP,MAAlB,EAA0B,IAA1B;AACAZ,IAAAA,GAAG,CAAC,4BAAD,EAA+BgB,QAA/B,CAAH;AACD;AACF,CAlCD","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst BufferList = require('bl/BufferList')\nconst multistream = require('./multistream')\n// @ts-expect-error no types\nconst handshake = require('it-handshake')\nconst { PROTOCOL_ID } = require('./constants')\n\nconst log = Object.assign(debug('mss:handle'), {\n  error: debug('mss:handle:error')\n})\n\n/**\n * @typedef {import('./types').DuplexStream<Uint8Array | BufferList>} DuplexStream\n * @typedef {import('./types').AbortOptions} AbortOptions\n */\n\n/**\n * @param {DuplexStream} stream\n * @param {string | string[]} protocols\n * @param {AbortOptions} [options]\n */\nmodule.exports = async function handle (stream, protocols, options) {\n  protocols = Array.isArray(protocols) ? protocols : [protocols]\n  const { writer, reader, rest, stream: shakeStream } = handshake(stream)\n\n  while (true) {\n    const protocol = (await multistream.read(reader, options)).toString()\n    log('read \"%s\"', protocol)\n\n    if (protocol === PROTOCOL_ID) {\n      log('respond with \"%s\" for \"%s\"', PROTOCOL_ID, protocol)\n      multistream.write(writer, PROTOCOL_ID)\n      continue\n    }\n\n    if (protocols.includes(protocol)) {\n      multistream.write(writer, protocol)\n      log('respond with \"%s\" for \"%s\"', protocol, protocol)\n      rest()\n      return { stream: shakeStream, protocol }\n    }\n\n    if (protocol === 'ls') {\n      // <varint-msg-len><varint-proto-name-len><proto-name>\\n<varint-proto-name-len><proto-name>\\n\\n\n      multistream.write(writer, new BufferList(\n        // @ts-expect-error BufferList does not accept Uint8Array[] as a constructor arg\n        protocols.map(p => multistream.encode(p))\n      ))\n      log('respond with \"%s\" for %s', protocols, protocol)\n      continue\n    }\n\n    multistream.write(writer, 'na')\n    log('respond with \"na\" for \"%s\"', protocol)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}