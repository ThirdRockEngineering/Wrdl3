{"ast":null,"code":"'use strict';\n\nconst PeerId = require('peer-id');\n\nconst {\n  base58btc\n} = require('multiformats/bases/base58');\n\nconst {\n  default: PQueue\n} = require('p-queue');\n\nconst defer = require('p-defer');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p-delegated-peer-routing');\nlog.error = debug('libp2p-delegated-peer-routing:error');\nconst DEFAULT_TIMEOUT = 30e3; // 30 second default\n\nconst CONCURRENT_HTTP_REQUESTS = 4;\n\nclass DelegatedPeerRouting {\n  /**\n   * Create a new DelegatedPeerRouting instance.\n   *\n   * @param {object} client - an instance of the ipfs-http-client module\n   */\n  constructor(client) {\n    if (client == null) {\n      throw new Error('missing ipfs http client');\n    }\n\n    this._client = client; // limit concurrency to avoid request flood in web browser\n    // https://github.com/libp2p/js-libp2p-delegated-content-routing/issues/12\n\n    this._httpQueue = new PQueue({\n      concurrency: CONCURRENT_HTTP_REQUESTS\n    });\n    const {\n      protocol,\n      host,\n      port\n    } = client.getEndpointConfig();\n    log(`enabled DelegatedPeerRouting via ${protocol}://${host}:${port}`);\n  }\n  /**\n   * Attempts to find the given peer\n   *\n   * @param {PeerID} id\n   * @param {object} options\n   * @param {number} options.timeout - How long the query can take. Defaults to 30 seconds\n   * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n\n\n  async findPeer(id) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let idStr = id;\n\n    if (PeerId.isPeerId(idStr)) {\n      idStr = id.toB58String();\n    }\n\n    log('findPeer starts: ' + id);\n    options.timeout = options.timeout || DEFAULT_TIMEOUT;\n\n    try {\n      return await this._httpQueue.add(async () => {\n        const {\n          addrs\n        } = await this._client.dht.findPeer(idStr, {\n          timeout: options.timeout\n        });\n        return {\n          id,\n          multiaddrs: addrs\n        };\n      });\n    } catch (err) {\n      if (err.message.includes('not found')) {\n        return undefined;\n      }\n\n      throw err;\n    } finally {\n      log('findPeer finished: ' + id);\n    }\n  }\n  /**\n   * Attempt to find the closest peers on the network to the given key\n   *\n   * @param {Uint8Array} key - A CID like key\n   * @param {object} [options]\n   * @param {number} [options.timeout=30e3] - How long the query can take.\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n\n\n  async *getClosestPeers(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const keyStr = base58btc.encode(key).substring(1);\n    log('getClosestPeers starts:', keyStr);\n    options.timeout = options.timeout || DEFAULT_TIMEOUT;\n    const onStart = defer();\n    const onFinish = defer();\n\n    this._httpQueue.add(() => {\n      onStart.resolve();\n      return onFinish.promise;\n    });\n\n    try {\n      await onStart.promise;\n\n      for await (const result of this._client.dht.query(keyStr, {\n        timeout: options.timeout\n      })) {\n        switch (result.type) {\n          case 1:\n            // Found Closer\n            for (const response of result.responses) {\n              yield {\n                id: PeerId.parse(response.id),\n                multiaddrs: response.addrs\n              };\n            }\n\n            break;\n\n          default:\n            log('getClosestPeers unhandled response', result);\n        }\n      }\n    } catch (err) {\n      log.error('getClosestPeers errored:', err);\n      throw err;\n    } finally {\n      onFinish.resolve();\n      log('getClosestPeers finished:', keyStr);\n    }\n  }\n\n}\n\nmodule.exports = DelegatedPeerRouting;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p-delegated-peer-routing/src/index.js"],"names":["PeerId","require","base58btc","default","PQueue","defer","debug","log","error","DEFAULT_TIMEOUT","CONCURRENT_HTTP_REQUESTS","DelegatedPeerRouting","constructor","client","Error","_client","_httpQueue","concurrency","protocol","host","port","getEndpointConfig","findPeer","id","options","idStr","isPeerId","toB58String","timeout","add","addrs","dht","multiaddrs","err","message","includes","undefined","getClosestPeers","key","keyStr","encode","substring","onStart","onFinish","resolve","promise","result","query","type","response","responses","parse","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst { base58btc } = require('multiformats/bases/base58')\nconst { default: PQueue } = require('p-queue')\nconst defer = require('p-defer')\nconst debug = require('debug')\n\nconst log = debug('libp2p-delegated-peer-routing')\nlog.error = debug('libp2p-delegated-peer-routing:error')\n\nconst DEFAULT_TIMEOUT = 30e3 // 30 second default\nconst CONCURRENT_HTTP_REQUESTS = 4\n\nclass DelegatedPeerRouting {\n  /**\n   * Create a new DelegatedPeerRouting instance.\n   *\n   * @param {object} client - an instance of the ipfs-http-client module\n   */\n  constructor (client) {\n    if (client == null) {\n      throw new Error('missing ipfs http client')\n    }\n\n    this._client = client\n\n    // limit concurrency to avoid request flood in web browser\n    // https://github.com/libp2p/js-libp2p-delegated-content-routing/issues/12\n    this._httpQueue = new PQueue({\n      concurrency: CONCURRENT_HTTP_REQUESTS\n    })\n\n    const {\n      protocol,\n      host,\n      port\n    } = client.getEndpointConfig()\n\n    log(`enabled DelegatedPeerRouting via ${protocol}://${host}:${port}`)\n  }\n\n  /**\n   * Attempts to find the given peer\n   *\n   * @param {PeerID} id\n   * @param {object} options\n   * @param {number} options.timeout - How long the query can take. Defaults to 30 seconds\n   * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n  async findPeer (id, options = {}) {\n    let idStr = id\n    if (PeerId.isPeerId(idStr)) {\n      idStr = id.toB58String()\n    }\n\n    log('findPeer starts: ' + id)\n\n    options.timeout = options.timeout || DEFAULT_TIMEOUT\n\n    try {\n      return await this._httpQueue.add(async () => {\n        const { addrs } = await this._client.dht.findPeer(idStr, {\n          timeout: options.timeout\n        })\n\n        return {\n          id,\n          multiaddrs: addrs\n        }\n      })\n    } catch (err) {\n      if (err.message.includes('not found')) {\n        return undefined\n      }\n\n      throw err\n    } finally {\n      log('findPeer finished: ' + id)\n    }\n  }\n\n  /**\n   * Attempt to find the closest peers on the network to the given key\n   *\n   * @param {Uint8Array} key - A CID like key\n   * @param {object} [options]\n   * @param {number} [options.timeout=30e3] - How long the query can take.\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n  async * getClosestPeers (key, options = {}) {\n    const keyStr = base58btc.encode(key).substring(1)\n\n    log('getClosestPeers starts:', keyStr)\n    options.timeout = options.timeout || DEFAULT_TIMEOUT\n\n    const onStart = defer()\n    const onFinish = defer()\n\n    this._httpQueue.add(() => {\n      onStart.resolve()\n      return onFinish.promise\n    })\n\n    try {\n      await onStart.promise\n\n      for await (const result of this._client.dht.query(keyStr, {\n        timeout: options.timeout\n      })) {\n        switch (result.type) {\n          case 1: // Found Closer\n            for (const response of result.responses) {\n              yield {\n                id: PeerId.parse(response.id),\n                multiaddrs: response.addrs\n              }\n            }\n            break\n          default:\n            log('getClosestPeers unhandled response', result)\n        }\n      }\n    } catch (err) {\n      log.error('getClosestPeers errored:', err)\n      throw err\n    } finally {\n      onFinish.resolve()\n      log('getClosestPeers finished:', keyStr)\n    }\n  }\n}\n\nmodule.exports = DelegatedPeerRouting\n"]},"metadata":{},"sourceType":"script"}