{"ast":null,"code":"'use strict';\n\nconst errcode = require('err-code');\n\nconst {\n  validator\n} = require('libp2p-record');\n\nconst PeerId = require('peer-id');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst {\n  Message\n} = require('../message');\n\nconst utils = require('../utils');\n\nconst {\n  queryErrorEvent,\n  finalPeerEvent,\n  valueEvent\n} = require('../query/events');\n\nconst PeerDistanceList = require('../peer-list/peer-distance-list');\n\nconst {\n  Record\n} = require('libp2p-record');\n/**\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('../types').PeerData} PeerData\n */\n\n\nclass PeerRouting {\n  /**\n   * @param {object} params\n   * @param {import('peer-id')} params.peerId\n   * @param {import('../routing-table').RoutingTable} params.routingTable\n   * @param {import('libp2p/src/peer-store/types').PeerStore} params.peerStore\n   * @param {import('../network').Network} params.network\n   * @param {import('libp2p-interfaces/src/types').DhtValidators} params.validators\n   * @param {import('../query/manager').QueryManager} params.queryManager\n   * @param {boolean} params.lan\n   */\n  constructor(_ref) {\n    let {\n      peerId,\n      routingTable,\n      peerStore,\n      network,\n      validators,\n      queryManager,\n      lan\n    } = _ref;\n    this._peerId = peerId;\n    this._routingTable = routingTable;\n    this._peerStore = peerStore;\n    this._network = network;\n    this._validators = validators;\n    this._queryManager = queryManager;\n    this._log = utils.logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}:peer-routing`);\n  }\n  /**\n   * Look if we are connected to a peer with the given id.\n   * Returns its id and addresses, if found, otherwise `undefined`.\n   *\n   * @param {PeerId} peer\n   */\n\n\n  async findPeerLocal(peer) {\n    let peerData;\n    const p = await this._routingTable.find(peer);\n\n    if (p) {\n      this._log('findPeerLocal found %p in routing table', peer);\n\n      try {\n        peerData = await this._peerStore.get(p);\n      } catch (\n      /** @type {any} */\n      err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err;\n        }\n      }\n    }\n\n    if (!peerData) {\n      try {\n        peerData = await this._peerStore.get(peer);\n      } catch (\n      /** @type {any} */\n      err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err;\n        }\n      }\n    }\n\n    if (peerData) {\n      this._log('findPeerLocal found %p in peer store', peer);\n\n      return {\n        id: peerData.id,\n        multiaddrs: peerData.addresses.map(address => address.multiaddr)\n      };\n    }\n  }\n  /**\n   * Get a value via rpc call for the given parameters.\n   *\n   * @param {PeerId} peer\n   * @param {Uint8Array} key\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  async *_getValueSingle(peer, key) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // eslint-disable-line require-await\n    const msg = new Message(Message.TYPES.GET_VALUE, key, 0);\n    yield* this._network.sendRequest(peer, msg, options);\n  }\n  /**\n   * Get the public key directly from a node.\n   *\n   * @param {PeerId} peer\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  async *getPublicKeyFromNode(peer, options) {\n    const pkKey = utils.keyForPublicKey(peer);\n\n    for await (const event of this._getValueSingle(peer, pkKey, options)) {\n      yield event;\n\n      if (event.name === 'PEER_RESPONSE' && event.record) {\n        const recPeer = await PeerId.createFromPubKey(event.record.value); // compare hashes of the pub key\n\n        if (!recPeer.equals(peer)) {\n          throw errcode(new Error('public key does not match id'), 'ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID');\n        }\n\n        yield valueEvent({\n          from: peer,\n          value: recPeer.pubKey.bytes\n        });\n      }\n    }\n\n    throw errcode(new Error(`Node not responding with its public key: ${peer.toB58String()}`), 'ERR_INVALID_RECORD');\n  }\n  /**\n   * Search for a peer with the given ID.\n   *\n   * @param {PeerId} id\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.queryFuncTimeout]\n   */\n\n\n  async *findPeer(id) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    this._log('findPeer %p', id); // Try to find locally\n\n\n    const pi = await this.findPeerLocal(id); // already got it\n\n    if (pi != null) {\n      this._log('found local');\n\n      yield finalPeerEvent({\n        from: this._peerId,\n        peer: pi\n      });\n      return;\n    }\n\n    const key = await utils.convertPeerId(id);\n\n    const peers = this._routingTable.closestPeers(key); // sanity check\n\n\n    const match = peers.find(p => p.equals(id));\n\n    if (match) {\n      try {\n        const peer = await this._peerStore.get(id);\n\n        this._log('found in peerStore');\n\n        yield finalPeerEvent({\n          from: this._peerId,\n          peer: {\n            id: peer.id,\n            multiaddrs: peer.addresses.map(address => address.multiaddr)\n          }\n        });\n        return;\n      } catch (\n      /** @type {any} */\n      err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err;\n        }\n      }\n    }\n\n    const self = this;\n    /**\n     * @type {import('../query/types').QueryFunc}\n     */\n\n    const findPeerQuery = async function* (_ref2) {\n      let {\n        peer,\n        signal\n      } = _ref2;\n      const request = new Message(Message.TYPES.FIND_NODE, id.toBytes(), 0);\n\n      for await (const event of self._network.sendRequest(peer, request, {\n        signal\n      })) {\n        yield event;\n\n        if (event.name === 'PEER_RESPONSE') {\n          const match = event.closer.find(p => p.id.equals(id)); // found the peer\n\n          if (match) {\n            yield finalPeerEvent({\n              from: event.from,\n              peer: match\n            });\n          }\n        }\n      }\n    };\n\n    let foundPeer = false;\n\n    for await (const event of this._queryManager.run(id.id, peers, findPeerQuery, options)) {\n      if (event.name === 'FINAL_PEER') {\n        foundPeer = true;\n      }\n\n      yield event;\n    }\n\n    if (!foundPeer) {\n      yield queryErrorEvent({\n        from: this._peerId,\n        error: errcode(new Error('Not found'), 'ERR_NOT_FOUND')\n      });\n    }\n  }\n  /**\n   * Kademlia 'node lookup' operation\n   *\n   * @param {Uint8Array} key - the key to look up, could be a the bytes from a multihash or a peer ID\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.queryFuncTimeout]\n   */\n\n\n  async *getClosestPeers(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    this._log('getClosestPeers to %b', key);\n\n    const id = await utils.convertBuffer(key);\n\n    const tablePeers = this._routingTable.closestPeers(id);\n\n    const self = this;\n    const peers = new PeerDistanceList(id, this._routingTable._kBucketSize);\n    tablePeers.forEach(peer => peers.add(peer));\n    /**\n     * @type {import('../query/types').QueryFunc}\n     */\n\n    const getCloserPeersQuery = async function* (_ref3) {\n      let {\n        peer,\n        signal\n      } = _ref3;\n\n      self._log('closerPeersSingle %s from %p', uint8ArrayToString(key, 'base32'), peer);\n\n      const request = new Message(Message.TYPES.FIND_NODE, key, 0);\n      yield* self._network.sendRequest(peer, request, {\n        signal\n      });\n    };\n\n    for await (const event of this._queryManager.run(key, tablePeers, getCloserPeersQuery, options)) {\n      yield event;\n\n      if (event.name === 'PEER_RESPONSE') {\n        event.closer.forEach(peerData => {\n          peers.add(peerData.id);\n        });\n      }\n    }\n\n    this._log('found %d peers close to %b', peers.length, key);\n\n    for (const peer of peers.peers) {\n      yield finalPeerEvent({\n        from: this._peerId,\n        peer: {\n          id: peer,\n          multiaddrs: ((await this._peerStore.addressBook.get(peer)) || []).map(addr => addr.multiaddr)\n        }\n      });\n    }\n  }\n  /**\n   * Query a particular peer for the value for the given key.\n   * It will either return the value or a list of closer peers.\n   *\n   * Note: The peerStore is updated with new addresses found for the given peer.\n   *\n   * @param {PeerId} peer\n   * @param {Uint8Array} key\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  async *getValueOrPeers(peer, key) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    for await (const event of this._getValueSingle(peer, key, options)) {\n      if (event.name === 'PEER_RESPONSE') {\n        if (event.record) {\n          // We have a record\n          try {\n            await this._verifyRecordOnline(event.record);\n          } catch (\n          /** @type {any} */\n          err) {\n            const errMsg = 'invalid record received, discarded';\n\n            this._log(errMsg);\n\n            yield queryErrorEvent({\n              from: event.from,\n              error: errcode(new Error(errMsg), 'ERR_INVALID_RECORD')\n            });\n            continue;\n          }\n        }\n      }\n\n      yield event;\n    }\n  }\n  /**\n   * Verify a record, fetching missing public keys from the network.\n   * Calls back with an error if the record is invalid.\n   *\n   * @param {import('../types').DHTRecord} record\n   * @returns {Promise<void>}\n   */\n\n\n  async _verifyRecordOnline(_ref4) {\n    let {\n      key,\n      value,\n      timeReceived\n    } = _ref4;\n    await validator.verifyRecord(this._validators, new Record(key, value, timeReceived));\n  }\n  /**\n   * Get the nearest peers to the given query, but if closer\n   * than self\n   *\n   * @param {Uint8Array} key\n   * @param {PeerId} closerThan\n   */\n\n\n  async getCloserPeersOffline(key, closerThan) {\n    const id = await utils.convertBuffer(key);\n\n    const ids = this._routingTable.closestPeers(id);\n\n    const output = [];\n\n    for (const peerId of ids) {\n      if (peerId.equals(closerThan)) {\n        continue;\n      }\n\n      try {\n        const addresses = await this._peerStore.addressBook.get(peerId);\n        output.push({\n          id: peerId,\n          multiaddrs: addresses.map(address => address.multiaddr)\n        });\n      } catch (\n      /** @type {any} */\n      err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err;\n        }\n      }\n    }\n\n    if (output.length) {\n      this._log('getCloserPeersOffline found %d peer(s) closer to %b than %p', output.length, key, closerThan);\n    } else {\n      this._log('getCloserPeersOffline could not find peer closer to %b than %p', key, closerThan);\n    }\n\n    return output;\n  }\n\n}\n\nmodule.exports.PeerRouting = PeerRouting;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p-kad-dht/src/peer-routing/index.js"],"names":["errcode","require","validator","PeerId","toString","uint8ArrayToString","Message","utils","queryErrorEvent","finalPeerEvent","valueEvent","PeerDistanceList","Record","PeerRouting","constructor","peerId","routingTable","peerStore","network","validators","queryManager","lan","_peerId","_routingTable","_peerStore","_network","_validators","_queryManager","_log","logger","findPeerLocal","peer","peerData","p","find","get","err","code","id","multiaddrs","addresses","map","address","multiaddr","_getValueSingle","key","options","msg","TYPES","GET_VALUE","sendRequest","getPublicKeyFromNode","pkKey","keyForPublicKey","event","name","record","recPeer","createFromPubKey","value","equals","Error","from","pubKey","bytes","toB58String","findPeer","pi","convertPeerId","peers","closestPeers","match","self","findPeerQuery","signal","request","FIND_NODE","toBytes","closer","foundPeer","run","error","getClosestPeers","convertBuffer","tablePeers","_kBucketSize","forEach","add","getCloserPeersQuery","length","addressBook","addr","getValueOrPeers","_verifyRecordOnline","errMsg","timeReceived","verifyRecord","getCloserPeersOffline","closerThan","ids","output","push","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst { validator } = require('libp2p-record')\nconst PeerId = require('peer-id')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst { Message } = require('../message')\nconst utils = require('../utils')\nconst {\n  queryErrorEvent,\n  finalPeerEvent,\n  valueEvent\n} = require('../query/events')\nconst PeerDistanceList = require('../peer-list/peer-distance-list')\nconst { Record } = require('libp2p-record')\n\n/**\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('../types').PeerData} PeerData\n */\n\nclass PeerRouting {\n  /**\n   * @param {object} params\n   * @param {import('peer-id')} params.peerId\n   * @param {import('../routing-table').RoutingTable} params.routingTable\n   * @param {import('libp2p/src/peer-store/types').PeerStore} params.peerStore\n   * @param {import('../network').Network} params.network\n   * @param {import('libp2p-interfaces/src/types').DhtValidators} params.validators\n   * @param {import('../query/manager').QueryManager} params.queryManager\n   * @param {boolean} params.lan\n   */\n  constructor ({ peerId, routingTable, peerStore, network, validators, queryManager, lan }) {\n    this._peerId = peerId\n    this._routingTable = routingTable\n    this._peerStore = peerStore\n    this._network = network\n    this._validators = validators\n    this._queryManager = queryManager\n    this._log = utils.logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}:peer-routing`)\n  }\n\n  /**\n   * Look if we are connected to a peer with the given id.\n   * Returns its id and addresses, if found, otherwise `undefined`.\n   *\n   * @param {PeerId} peer\n   */\n  async findPeerLocal (peer) {\n    let peerData\n    const p = await this._routingTable.find(peer)\n\n    if (p) {\n      this._log('findPeerLocal found %p in routing table', peer)\n\n      try {\n        peerData = await this._peerStore.get(p)\n      } catch (/** @type {any} */ err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err\n        }\n      }\n    }\n\n    if (!peerData) {\n      try {\n        peerData = await this._peerStore.get(peer)\n      } catch (/** @type {any} */ err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err\n        }\n      }\n    }\n\n    if (peerData) {\n      this._log('findPeerLocal found %p in peer store', peer)\n\n      return {\n        id: peerData.id,\n        multiaddrs: peerData.addresses.map((address) => address.multiaddr)\n      }\n    }\n  }\n\n  /**\n   * Get a value via rpc call for the given parameters.\n   *\n   * @param {PeerId} peer\n   * @param {Uint8Array} key\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async * _getValueSingle (peer, key, options = {}) { // eslint-disable-line require-await\n    const msg = new Message(Message.TYPES.GET_VALUE, key, 0)\n    yield * this._network.sendRequest(peer, msg, options)\n  }\n\n  /**\n   * Get the public key directly from a node.\n   *\n   * @param {PeerId} peer\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async * getPublicKeyFromNode (peer, options) {\n    const pkKey = utils.keyForPublicKey(peer)\n\n    for await (const event of this._getValueSingle(peer, pkKey, options)) {\n      yield event\n\n      if (event.name === 'PEER_RESPONSE' && event.record) {\n        const recPeer = await PeerId.createFromPubKey(event.record.value)\n\n        // compare hashes of the pub key\n        if (!recPeer.equals(peer)) {\n          throw errcode(new Error('public key does not match id'), 'ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID')\n        }\n\n        yield valueEvent({ from: peer, value: recPeer.pubKey.bytes })\n      }\n    }\n\n    throw errcode(new Error(`Node not responding with its public key: ${peer.toB58String()}`), 'ERR_INVALID_RECORD')\n  }\n\n  /**\n   * Search for a peer with the given ID.\n   *\n   * @param {PeerId} id\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.queryFuncTimeout]\n   */\n  async * findPeer (id, options = {}) {\n    this._log('findPeer %p', id)\n\n    // Try to find locally\n    const pi = await this.findPeerLocal(id)\n\n    // already got it\n    if (pi != null) {\n      this._log('found local')\n      yield finalPeerEvent({\n        from: this._peerId,\n        peer: pi\n      })\n      return\n    }\n\n    const key = await utils.convertPeerId(id)\n    const peers = this._routingTable.closestPeers(key)\n\n    // sanity check\n    const match = peers.find((p) => p.equals(id))\n\n    if (match) {\n      try {\n        const peer = await this._peerStore.get(id)\n\n        this._log('found in peerStore')\n        yield finalPeerEvent({\n          from: this._peerId,\n          peer: {\n            id: peer.id,\n            multiaddrs: peer.addresses.map((address) => address.multiaddr)\n          }\n        })\n\n        return\n      } catch (/** @type {any} */ err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err\n        }\n      }\n    }\n\n    const self = this\n\n    /**\n     * @type {import('../query/types').QueryFunc}\n     */\n    const findPeerQuery = async function * ({ peer, signal }) {\n      const request = new Message(Message.TYPES.FIND_NODE, id.toBytes(), 0)\n\n      for await (const event of self._network.sendRequest(peer, request, { signal })) {\n        yield event\n\n        if (event.name === 'PEER_RESPONSE') {\n          const match = event.closer.find((p) => p.id.equals(id))\n\n          // found the peer\n          if (match) {\n            yield finalPeerEvent({ from: event.from, peer: match })\n          }\n        }\n      }\n    }\n\n    let foundPeer = false\n\n    for await (const event of this._queryManager.run(id.id, peers, findPeerQuery, options)) {\n      if (event.name === 'FINAL_PEER') {\n        foundPeer = true\n      }\n\n      yield event\n    }\n\n    if (!foundPeer) {\n      yield queryErrorEvent({ from: this._peerId, error: errcode(new Error('Not found'), 'ERR_NOT_FOUND') })\n    }\n  }\n\n  /**\n   * Kademlia 'node lookup' operation\n   *\n   * @param {Uint8Array} key - the key to look up, could be a the bytes from a multihash or a peer ID\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.queryFuncTimeout]\n   */\n  async * getClosestPeers (key, options = {}) {\n    this._log('getClosestPeers to %b', key)\n    const id = await utils.convertBuffer(key)\n    const tablePeers = this._routingTable.closestPeers(id)\n    const self = this\n\n    const peers = new PeerDistanceList(id, this._routingTable._kBucketSize)\n    tablePeers.forEach(peer => peers.add(peer))\n\n    /**\n     * @type {import('../query/types').QueryFunc}\n     */\n    const getCloserPeersQuery = async function * ({ peer, signal }) {\n      self._log('closerPeersSingle %s from %p', uint8ArrayToString(key, 'base32'), peer)\n      const request = new Message(Message.TYPES.FIND_NODE, key, 0)\n\n      yield * self._network.sendRequest(peer, request, { signal })\n    }\n\n    for await (const event of this._queryManager.run(key, tablePeers, getCloserPeersQuery, options)) {\n      yield event\n\n      if (event.name === 'PEER_RESPONSE') {\n        event.closer.forEach(peerData => {\n          peers.add(peerData.id)\n        })\n      }\n    }\n\n    this._log('found %d peers close to %b', peers.length, key)\n\n    for (const peer of peers.peers) {\n      yield finalPeerEvent({\n        from: this._peerId,\n        peer: {\n          id: peer,\n          multiaddrs: (await (this._peerStore.addressBook.get(peer)) || []).map(addr => addr.multiaddr)\n        }\n      })\n    }\n  }\n\n  /**\n   * Query a particular peer for the value for the given key.\n   * It will either return the value or a list of closer peers.\n   *\n   * Note: The peerStore is updated with new addresses found for the given peer.\n   *\n   * @param {PeerId} peer\n   * @param {Uint8Array} key\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async * getValueOrPeers (peer, key, options = {}) {\n    for await (const event of this._getValueSingle(peer, key, options)) {\n      if (event.name === 'PEER_RESPONSE') {\n        if (event.record) {\n          // We have a record\n          try {\n            await this._verifyRecordOnline(event.record)\n          } catch (/** @type {any} */ err) {\n            const errMsg = 'invalid record received, discarded'\n            this._log(errMsg)\n\n            yield queryErrorEvent({ from: event.from, error: errcode(new Error(errMsg), 'ERR_INVALID_RECORD') })\n            continue\n          }\n        }\n      }\n\n      yield event\n    }\n  }\n\n  /**\n   * Verify a record, fetching missing public keys from the network.\n   * Calls back with an error if the record is invalid.\n   *\n   * @param {import('../types').DHTRecord} record\n   * @returns {Promise<void>}\n   */\n  async _verifyRecordOnline ({ key, value, timeReceived }) {\n    await validator.verifyRecord(this._validators, new Record(key, value, timeReceived))\n  }\n\n  /**\n   * Get the nearest peers to the given query, but if closer\n   * than self\n   *\n   * @param {Uint8Array} key\n   * @param {PeerId} closerThan\n   */\n  async getCloserPeersOffline (key, closerThan) {\n    const id = await utils.convertBuffer(key)\n    const ids = this._routingTable.closestPeers(id)\n    const output = []\n\n    for (const peerId of ids) {\n      if (peerId.equals(closerThan)) {\n        continue\n      }\n\n      try {\n        const addresses = await this._peerStore.addressBook.get(peerId)\n\n        output.push({\n          id: peerId,\n          multiaddrs: addresses.map((address) => address.multiaddr)\n        })\n      } catch (/** @type {any} */ err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err\n        }\n      }\n    }\n\n    if (output.length) {\n      this._log('getCloserPeersOffline found %d peer(s) closer to %b than %p', output.length, key, closerThan)\n    } else {\n      this._log('getCloserPeersOffline could not find peer closer to %b than %p', key, closerThan)\n    }\n\n    return output\n  }\n}\n\nmodule.exports.PeerRouting = PeerRouting\n"]},"metadata":{},"sourceType":"script"}