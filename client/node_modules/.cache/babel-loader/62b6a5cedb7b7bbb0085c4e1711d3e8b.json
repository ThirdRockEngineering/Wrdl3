{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst parseChunkerString = chunker => {\n  if (!chunker) {\n    return {\n      chunker: 'fixed'\n    };\n  } else if (chunker.startsWith('size-')) {\n    const sizeStr = chunker.split('-')[1];\n    const size = parseInt(sizeStr);\n\n    if (isNaN(size)) {\n      throw new Error('Chunker parameter size must be an integer');\n    }\n\n    return {\n      chunker: 'fixed',\n      maxChunkSize: size\n    };\n  } else if (chunker.startsWith('rabin')) {\n    return {\n      chunker: 'rabin',\n      ...parseRabinString(chunker)\n    };\n  } else {\n    throw new Error(`Unrecognized chunker option: ${chunker}`);\n  }\n};\n\nconst parseRabinString = chunker => {\n  const options = {};\n  const parts = chunker.split('-');\n\n  switch (parts.length) {\n    case 1:\n      options.avgChunkSize = 262144;\n      break;\n\n    case 2:\n      options.avgChunkSize = parseChunkSize(parts[1], 'avg');\n      break;\n\n    case 4:\n      options.minChunkSize = parseChunkSize(parts[1], 'min');\n      options.avgChunkSize = parseChunkSize(parts[2], 'avg');\n      options.maxChunkSize = parseChunkSize(parts[3], 'max');\n      break;\n\n    default:\n      throw new Error('Incorrect chunker format (expected \"rabin\" \"rabin-[avg]\" or \"rabin-[min]-[avg]-[max]\"');\n  }\n\n  return options;\n};\n\nconst parseChunkSize = (str, name) => {\n  const size = parseInt(str);\n\n  if (isNaN(size)) {\n    throw new Error(`Chunker parameter ${name} must be an integer`);\n  }\n\n  return size;\n};\n\nexports.parseChunkSize = parseChunkSize;\nexports.parseChunkerString = parseChunkerString;\nexports.parseRabinString = parseRabinString;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-core/cjs/src/components/add-all/utils.js"],"names":["Object","defineProperty","exports","value","parseChunkerString","chunker","startsWith","sizeStr","split","size","parseInt","isNaN","Error","maxChunkSize","parseRabinString","options","parts","length","avgChunkSize","parseChunkSize","minChunkSize","str","name"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AAEA,MAAMC,kBAAkB,GAAGC,OAAO,IAAI;AACpC,MAAI,CAACA,OAAL,EAAc;AACZ,WAAO;AAAEA,MAAAA,OAAO,EAAE;AAAX,KAAP;AACD,GAFD,MAEO,IAAIA,OAAO,CAACC,UAAR,CAAmB,OAAnB,CAAJ,EAAiC;AACtC,UAAMC,OAAO,GAAGF,OAAO,CAACG,KAAR,CAAc,GAAd,EAAmB,CAAnB,CAAhB;AACA,UAAMC,IAAI,GAAGC,QAAQ,CAACH,OAAD,CAArB;;AACA,QAAII,KAAK,CAACF,IAAD,CAAT,EAAiB;AACf,YAAM,IAAIG,KAAJ,CAAU,2CAAV,CAAN;AACD;;AACD,WAAO;AACLP,MAAAA,OAAO,EAAE,OADJ;AAELQ,MAAAA,YAAY,EAAEJ;AAFT,KAAP;AAID,GAVM,MAUA,IAAIJ,OAAO,CAACC,UAAR,CAAmB,OAAnB,CAAJ,EAAiC;AACtC,WAAO;AACLD,MAAAA,OAAO,EAAE,OADJ;AAEL,SAAGS,gBAAgB,CAACT,OAAD;AAFd,KAAP;AAID,GALM,MAKA;AACL,UAAM,IAAIO,KAAJ,CAAW,gCAAgCP,OAAS,EAApD,CAAN;AACD;AACF,CArBD;;AAsBA,MAAMS,gBAAgB,GAAGT,OAAO,IAAI;AAClC,QAAMU,OAAO,GAAG,EAAhB;AACA,QAAMC,KAAK,GAAGX,OAAO,CAACG,KAAR,CAAc,GAAd,CAAd;;AACA,UAAQQ,KAAK,CAACC,MAAd;AACA,SAAK,CAAL;AACEF,MAAAA,OAAO,CAACG,YAAR,GAAuB,MAAvB;AACA;;AACF,SAAK,CAAL;AACEH,MAAAA,OAAO,CAACG,YAAR,GAAuBC,cAAc,CAACH,KAAK,CAAC,CAAD,CAAN,EAAW,KAAX,CAArC;AACA;;AACF,SAAK,CAAL;AACED,MAAAA,OAAO,CAACK,YAAR,GAAuBD,cAAc,CAACH,KAAK,CAAC,CAAD,CAAN,EAAW,KAAX,CAArC;AACAD,MAAAA,OAAO,CAACG,YAAR,GAAuBC,cAAc,CAACH,KAAK,CAAC,CAAD,CAAN,EAAW,KAAX,CAArC;AACAD,MAAAA,OAAO,CAACF,YAAR,GAAuBM,cAAc,CAACH,KAAK,CAAC,CAAD,CAAN,EAAW,KAAX,CAArC;AACA;;AACF;AACE,YAAM,IAAIJ,KAAJ,CAAU,uFAAV,CAAN;AAbF;;AAeA,SAAOG,OAAP;AACD,CAnBD;;AAoBA,MAAMI,cAAc,GAAG,CAACE,GAAD,EAAMC,IAAN,KAAe;AACpC,QAAMb,IAAI,GAAGC,QAAQ,CAACW,GAAD,CAArB;;AACA,MAAIV,KAAK,CAACF,IAAD,CAAT,EAAiB;AACf,UAAM,IAAIG,KAAJ,CAAW,qBAAqBU,IAAM,qBAAtC,CAAN;AACD;;AACD,SAAOb,IAAP;AACD,CAND;;AAQAP,OAAO,CAACiB,cAAR,GAAyBA,cAAzB;AACAjB,OAAO,CAACE,kBAAR,GAA6BA,kBAA7B;AACAF,OAAO,CAACY,gBAAR,GAA2BA,gBAA3B","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst parseChunkerString = chunker => {\n  if (!chunker) {\n    return { chunker: 'fixed' };\n  } else if (chunker.startsWith('size-')) {\n    const sizeStr = chunker.split('-')[1];\n    const size = parseInt(sizeStr);\n    if (isNaN(size)) {\n      throw new Error('Chunker parameter size must be an integer');\n    }\n    return {\n      chunker: 'fixed',\n      maxChunkSize: size\n    };\n  } else if (chunker.startsWith('rabin')) {\n    return {\n      chunker: 'rabin',\n      ...parseRabinString(chunker)\n    };\n  } else {\n    throw new Error(`Unrecognized chunker option: ${ chunker }`);\n  }\n};\nconst parseRabinString = chunker => {\n  const options = {};\n  const parts = chunker.split('-');\n  switch (parts.length) {\n  case 1:\n    options.avgChunkSize = 262144;\n    break;\n  case 2:\n    options.avgChunkSize = parseChunkSize(parts[1], 'avg');\n    break;\n  case 4:\n    options.minChunkSize = parseChunkSize(parts[1], 'min');\n    options.avgChunkSize = parseChunkSize(parts[2], 'avg');\n    options.maxChunkSize = parseChunkSize(parts[3], 'max');\n    break;\n  default:\n    throw new Error('Incorrect chunker format (expected \"rabin\" \"rabin-[avg]\" or \"rabin-[min]-[avg]-[max]\"');\n  }\n  return options;\n};\nconst parseChunkSize = (str, name) => {\n  const size = parseInt(str);\n  if (isNaN(size)) {\n    throw new Error(`Chunker parameter ${ name } must be an integer`);\n  }\n  return size;\n};\n\nexports.parseChunkSize = parseChunkSize;\nexports.parseChunkerString = parseChunkerString;\nexports.parseRabinString = parseRabinString;\n"]},"metadata":{},"sourceType":"script"}