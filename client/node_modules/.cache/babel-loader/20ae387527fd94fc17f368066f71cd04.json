{"ast":null,"code":"'use strict';\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst crypto = require('libp2p-crypto');\n\nconst libp2pRecord = require('libp2p-record');\n\nconst {\n  MemoryDatastore\n} = require('datastore-core/memory');\n\nconst {\n  RoutingTable\n} = require('./routing-table');\n\nconst {\n  RoutingTableRefresh\n} = require('./routing-table/refresh');\n\nconst utils = require('./utils');\n\nconst {\n  K,\n  QUERY_SELF_INTERVAL,\n  RECORD_KEY_PREFIX\n} = require('./constants');\n\nconst {\n  Network\n} = require('./network');\n\nconst {\n  ContentFetching\n} = require('./content-fetching');\n\nconst {\n  ContentRouting\n} = require('./content-routing');\n\nconst {\n  PeerRouting\n} = require('./peer-routing');\n\nconst {\n  Providers\n} = require('./providers');\n\nconst {\n  QueryManager\n} = require('./query/manager');\n\nconst {\n  RPC\n} = require('./rpc');\n\nconst {\n  TopologyListener\n} = require('./topology-listener');\n\nconst {\n  QuerySelf\n} = require('./query-self');\n\nconst {\n  removePrivateAddresses,\n  removePublicAddresses\n} = require('./utils');\n\nconst {\n  KeyTransformDatastore\n} = require('datastore-core');\n\nconst {\n  Key\n} = require('interface-datastore/key');\n/**\n * @typedef {import('libp2p')} Libp2p\n * @typedef {import('libp2p/src/peer-store')} PeerStore\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('libp2p/src/dialer')} Dialer\n * @typedef {import('libp2p/src/registrar')} Registrar\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('./types').DHT} DHT\n * @typedef {import('./types').PeerData} PeerData\n * @typedef {import('./types').QueryEvent} QueryEvent\n * @typedef {import('./types').SendingQueryEvent} SendingQueryEvent\n * @typedef {import('./types').PeerResponseEvent} PeerResponseEvent\n * @typedef {import('./types').FinalPeerEvent} FinalPeerEvent\n * @typedef {import('./types').QueryErrorEvent} QueryErrorEvent\n * @typedef {import('./types').ProviderEvent} ProviderEvent\n * @typedef {import('./types').ValueEvent} ValueEvent\n * @typedef {import('./types').AddingPeerEvent} AddingPeerEvent\n * @typedef {import('./types').DialingPeerEvent} DialingPeerEvent\n *\n * @typedef {object} KadDHTOps\n * @property {Libp2p} libp2p - the libp2p instance\n * @property {string} [protocol = '/ipfs/kad/1.0.0'] - libp2p registrar handle protocol\n * @property {number} kBucketSize - k-bucket size (default 20)\n * @property {boolean} clientMode - If true, the DHT will not respond to queries. This should be true if your node will not be dialable. (default: false)\n * @property {import('libp2p-interfaces/src/types').DhtValidators} validators - validators object with namespace as keys and function(key, record, callback)\n * @property {object} selectors - selectors object with namespace as keys and function(key, records)\n * @property {number} querySelfInterval - how often to search the network for peers close to ourselves\n * @property {boolean} lan\n * @property {PeerData[]} bootstrapPeers\n */\n\n\nclass PrefixTransform {\n  /**\n   *\n   * @param {string} prefix - : ;\n   */\n  constructor(prefix) {\n    this._prefix = prefix;\n\n    if (this._prefix.startsWith('/')) {\n      this._prefix = this._prefix.substring(1);\n    }\n  }\n  /**\n   * @param {Key} key\n   */\n\n\n  convert(key) {\n    return new Key(`/${this._prefix}${key}`);\n  }\n  /**\n   * @param {Key} key\n   */\n\n\n  invert(key) {\n    const namespaces = key.namespaces();\n\n    if (namespaces[0] === this._prefix) {\n      namespaces.shift();\n    }\n\n    return Key.withNamespaces(namespaces);\n  }\n\n}\n/**\n * A DHT implementation modelled after Kademlia with S/Kademlia modifications.\n * Original implementation in go: https://github.com/libp2p/go-libp2p-kad-dht.\n */\n\n\nclass KadDHT extends EventEmitter {\n  /**\n   * Create a new KadDHT.\n   *\n   * @param {KadDHTOps} opts\n   */\n  constructor(_ref) {\n    let {\n      libp2p,\n      kBucketSize = K,\n      clientMode = true,\n      validators = {},\n      selectors = {},\n      querySelfInterval = QUERY_SELF_INTERVAL,\n      lan = true,\n      protocol = '/ipfs/lan/kad/1.0.0',\n      bootstrapPeers = []\n    } = _ref;\n    super();\n    this._running = false;\n    this._log = utils.logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}`);\n    /**\n     * Local reference to the libp2p instance\n     *\n     * @type {Libp2p}\n     */\n\n    this._libp2p = libp2p;\n    /**\n     * Registrar protocol\n     *\n     * @type {string}\n     */\n\n    this._protocol = protocol;\n    /**\n     * k-bucket size\n     *\n     * @type {number}\n     */\n\n    this._kBucketSize = kBucketSize;\n    /**\n     * Whether we are in client or server mode\n     */\n\n    this._clientMode = clientMode;\n    /**\n     * Will be added to the routing table on startup\n     */\n\n    this._bootstrapPeers = bootstrapPeers;\n    /**\n     * The routing table.\n     *\n     * @type {RoutingTable}\n     */\n\n    this._routingTable = new RoutingTable({\n      peerId: libp2p.peerId,\n      dialer: libp2p,\n      kBucketSize,\n      metrics: libp2p.metrics,\n      lan\n    });\n    const datastore = libp2p.datastore || new MemoryDatastore();\n    const records = new KeyTransformDatastore(datastore, new PrefixTransform(RECORD_KEY_PREFIX));\n    /**\n     * Provider management\n     *\n     * @type {Providers}\n     */\n\n    this._providers = new Providers({\n      providers: datastore\n    });\n    /**\n     * @type {boolean}\n     */\n\n    this._lan = lan;\n    this._validators = {\n      pk: libp2pRecord.validator.validators.pk,\n      ...validators\n    };\n    this._selectors = {\n      pk: libp2pRecord.selection.selectors.pk,\n      ...selectors\n    };\n    this._network = new Network({\n      dialer: libp2p,\n      protocol: this._protocol,\n      lan\n    });\n    /**\n     * Keeps track of running queries\n     *\n     * @type {QueryManager}\n     */\n\n    this._queryManager = new QueryManager({\n      peerId: libp2p.peerId,\n      // Number of disjoint query paths to use - This is set to `kBucketSize/2` per the S/Kademlia paper\n      disjointPaths: Math.ceil(kBucketSize / 2),\n      metrics: libp2p.metrics,\n      lan\n    }); // DHT components\n\n    this._peerRouting = new PeerRouting({\n      peerId: libp2p.peerId,\n      routingTable: this._routingTable,\n      peerStore: libp2p.peerStore,\n      network: this._network,\n      validators: this._validators,\n      queryManager: this._queryManager,\n      lan\n    });\n    this._contentFetching = new ContentFetching({\n      peerId: libp2p.peerId,\n      records,\n      validators: this._validators,\n      selectors: this._selectors,\n      peerRouting: this._peerRouting,\n      queryManager: this._queryManager,\n      routingTable: this._routingTable,\n      network: this._network,\n      lan\n    });\n    this._contentRouting = new ContentRouting({\n      peerId: libp2p.peerId,\n      network: this._network,\n      peerRouting: this._peerRouting,\n      queryManager: this._queryManager,\n      routingTable: this._routingTable,\n      providers: this._providers,\n      peerStore: libp2p.peerStore,\n      lan\n    });\n    this._routingTableRefresh = new RoutingTableRefresh({\n      peerRouting: this._peerRouting,\n      routingTable: this._routingTable,\n      lan\n    });\n    this._rpc = new RPC({\n      routingTable: this._routingTable,\n      peerId: libp2p.peerId,\n      providers: this._providers,\n      peerStore: libp2p.peerStore,\n      addressable: libp2p,\n      peerRouting: this._peerRouting,\n      records,\n      validators: this._validators,\n      lan\n    });\n    this._topologyListener = new TopologyListener({\n      registrar: libp2p.registrar,\n      protocol: this._protocol,\n      lan\n    });\n    this._querySelf = new QuerySelf({\n      peerId: libp2p.peerId,\n      peerRouting: this._peerRouting,\n      interval: querySelfInterval,\n      lan\n    }); // handle peers being discovered during processing of DHT messages\n\n    this._network.on('peer', peerData => {\n      this.onPeerConnect(peerData).catch(err => {\n        this._log.error(`could not add ${peerData.id} to routing table`, err);\n      });\n      this.emit('peer', peerData);\n    }); // handle peers being discovered via other peer discovery mechanisms\n\n\n    this._topologyListener.on('peer', async peerId => {\n      const multiaddrs = await this._libp2p.peerStore.addressBook.get(peerId);\n      const peerData = {\n        id: peerId,\n        multiaddrs: multiaddrs.map(addr => addr.multiaddr)\n      };\n      this.onPeerConnect(peerData).catch(err => {\n        this._log.error(`could not add ${peerData.id} to routing table`, err);\n      });\n    });\n  }\n  /**\n   * @param {PeerData} peerData\n   */\n\n\n  async onPeerConnect(peerData) {\n    this._log('peer %p connected', peerData.id);\n\n    if (this._lan) {\n      peerData = removePublicAddresses(peerData);\n    } else {\n      peerData = removePrivateAddresses(peerData);\n    }\n\n    if (!peerData.multiaddrs.length) {\n      this._log('ignoring %p as they do not have any %s addresses in %s', peerData.id, this._lan ? 'private' : 'public', peerData.multiaddrs.map(addr => addr.toString()));\n\n      return;\n    }\n\n    try {\n      await this._routingTable.add(peerData.id);\n    } catch (\n    /** @type {any} */\n    err) {\n      this._log.error('could not add %p to routing table', peerData.id, err);\n    }\n  }\n  /**\n   * Is this DHT running.\n   */\n\n\n  isStarted() {\n    return this._running;\n  }\n  /**\n   * Is this DHT in server mode\n   */\n\n\n  isServer() {\n    return !this._clientMode;\n  }\n  /**\n   * Whether we are in client or server mode\n   */\n\n\n  async enableServerMode() {\n    this._log('enabling server mode');\n\n    this._clientMode = false;\n    await this._libp2p.handle(this._protocol, this._rpc.onIncomingStream.bind(this._rpc));\n  }\n  /**\n   * Whether we are in client or server mode\n   */\n\n\n  async enableClientMode() {\n    this._log('enabling client mode');\n\n    this._clientMode = true;\n    await this._libp2p.unhandle(this._protocol);\n  }\n  /**\n   * Start listening to incoming connections.\n   */\n\n\n  async start() {\n    this._running = true; // Only respond to queries when not in client mode\n\n    if (this._clientMode) {\n      await this.enableClientMode();\n    } else {\n      await this.enableServerMode();\n    }\n\n    await Promise.all([this._providers.start(), this._queryManager.start(), this._network.start(), this._routingTable.start(), this._topologyListener.start(), this._querySelf.start()]);\n    await Promise.all(this._bootstrapPeers.map(peerData => this._routingTable.add(peerData.id)));\n    await this._routingTableRefresh.start();\n    await this.refreshRoutingTable();\n  }\n  /**\n   * Stop accepting incoming connections and sending outgoing\n   * messages.\n   */\n\n\n  async stop() {\n    this._running = false;\n    await Promise.all([this._providers.stop(), this._queryManager.stop(), this._network.stop(), this._routingTable.stop(), this._routingTableRefresh.stop(), this._topologyListener.stop(), this._querySelf.stop()]);\n  }\n  /**\n   * Store the given key/value pair in the DHT\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} value\n   * @param {object} [options] - put options\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.minPeers] - minimum number of peers required to successfully put (default: closestPeers.length)\n   */\n\n\n  async *put(key, value) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // eslint-disable-line require-await\n    yield* this._contentFetching.put(key, value, options);\n  }\n  /**\n   * Get the value that corresponds to the passed key\n   *\n   * @param {Uint8Array} key\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.queryFuncTimeout]\n   */\n\n\n  async *get(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // eslint-disable-line require-await\n    yield* this._contentFetching.get(key, options);\n  } // ----------- Content Routing\n\n  /**\n   * Announce to the network that we can provide given key's value\n   *\n   * @param {CID} key\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  async *provide(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // eslint-disable-line require-await\n    yield* this._contentRouting.provide(key, this._libp2p.multiaddrs, options);\n  }\n  /**\n   * Search the dht for up to `K` providers of the given CID.\n   *\n   * @param {CID} key\n   * @param {object} [options] - findProviders options\n   * @param {number} [options.maxNumProviders=5] - maximum number of providers to find\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.queryFuncTimeout]\n   */\n\n\n  async *findProviders(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      maxNumProviders: 5\n    };\n    yield* this._contentRouting.findProviders(key, options);\n  } // ----------- Peer Routing -----------\n\n  /**\n   * Search for a peer with the given ID\n   *\n   * @param {PeerId} id\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.queryFuncTimeout]\n   */\n\n\n  async *findPeer(id) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // eslint-disable-line require-await\n    yield* this._peerRouting.findPeer(id, options);\n  }\n  /**\n   * Kademlia 'node lookup' operation.\n   *\n   * @param {Uint8Array} key\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.queryFuncTimeout]\n   */\n\n\n  async *getClosestPeers(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    yield* this._peerRouting.getClosestPeers(key, options);\n  }\n  /**\n   * Get the public key for the given peer id\n   *\n   * @param {PeerId} peer\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  async getPublicKey(peer) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    this._log('getPublicKey %p', peer); // try the node directly\n\n\n    for await (const event of this._peerRouting.getPublicKeyFromNode(peer, options)) {\n      if (event.name === 'VALUE') {\n        return crypto.keys.unmarshalPublicKey(event.value);\n      }\n    } // search the dht\n\n\n    const pkKey = utils.keyForPublicKey(peer);\n\n    for await (const event of this.get(pkKey, options)) {\n      if (event.name === 'VALUE') {\n        return crypto.keys.unmarshalPublicKey(event.value);\n      }\n    }\n  }\n\n  async refreshRoutingTable() {\n    await this._routingTableRefresh.refreshTable(true);\n  }\n\n}\n\nmodule.exports = {\n  KadDHT\n};","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p-kad-dht/src/kad-dht.js"],"names":["EventEmitter","require","crypto","libp2pRecord","MemoryDatastore","RoutingTable","RoutingTableRefresh","utils","K","QUERY_SELF_INTERVAL","RECORD_KEY_PREFIX","Network","ContentFetching","ContentRouting","PeerRouting","Providers","QueryManager","RPC","TopologyListener","QuerySelf","removePrivateAddresses","removePublicAddresses","KeyTransformDatastore","Key","PrefixTransform","constructor","prefix","_prefix","startsWith","substring","convert","key","invert","namespaces","shift","withNamespaces","KadDHT","libp2p","kBucketSize","clientMode","validators","selectors","querySelfInterval","lan","protocol","bootstrapPeers","_running","_log","logger","_libp2p","_protocol","_kBucketSize","_clientMode","_bootstrapPeers","_routingTable","peerId","dialer","metrics","datastore","records","_providers","providers","_lan","_validators","pk","validator","_selectors","selection","_network","_queryManager","disjointPaths","Math","ceil","_peerRouting","routingTable","peerStore","network","queryManager","_contentFetching","peerRouting","_contentRouting","_routingTableRefresh","_rpc","addressable","_topologyListener","registrar","_querySelf","interval","on","peerData","onPeerConnect","catch","err","error","id","emit","multiaddrs","addressBook","get","map","addr","multiaddr","length","toString","add","isStarted","isServer","enableServerMode","handle","onIncomingStream","bind","enableClientMode","unhandle","start","Promise","all","refreshRoutingTable","stop","put","value","options","provide","findProviders","maxNumProviders","findPeer","getClosestPeers","getPublicKey","peer","event","getPublicKeyFromNode","name","keys","unmarshalPublicKey","pkKey","keyForPublicKey","refreshTable","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { EventEmitter } = require('events')\nconst crypto = require('libp2p-crypto')\nconst libp2pRecord = require('libp2p-record')\nconst { MemoryDatastore } = require('datastore-core/memory')\nconst { RoutingTable } = require('./routing-table')\nconst { RoutingTableRefresh } = require('./routing-table/refresh')\nconst utils = require('./utils')\nconst {\n  K,\n  QUERY_SELF_INTERVAL,\n  RECORD_KEY_PREFIX\n} = require('./constants')\nconst { Network } = require('./network')\nconst { ContentFetching } = require('./content-fetching')\nconst { ContentRouting } = require('./content-routing')\nconst { PeerRouting } = require('./peer-routing')\nconst { Providers } = require('./providers')\nconst { QueryManager } = require('./query/manager')\nconst { RPC } = require('./rpc')\nconst { TopologyListener } = require('./topology-listener')\nconst { QuerySelf } = require('./query-self')\nconst {\n  removePrivateAddresses,\n  removePublicAddresses\n} = require('./utils')\nconst { KeyTransformDatastore } = require('datastore-core')\nconst { Key } = require('interface-datastore/key')\n\n/**\n * @typedef {import('libp2p')} Libp2p\n * @typedef {import('libp2p/src/peer-store')} PeerStore\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('libp2p/src/dialer')} Dialer\n * @typedef {import('libp2p/src/registrar')} Registrar\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('./types').DHT} DHT\n * @typedef {import('./types').PeerData} PeerData\n * @typedef {import('./types').QueryEvent} QueryEvent\n * @typedef {import('./types').SendingQueryEvent} SendingQueryEvent\n * @typedef {import('./types').PeerResponseEvent} PeerResponseEvent\n * @typedef {import('./types').FinalPeerEvent} FinalPeerEvent\n * @typedef {import('./types').QueryErrorEvent} QueryErrorEvent\n * @typedef {import('./types').ProviderEvent} ProviderEvent\n * @typedef {import('./types').ValueEvent} ValueEvent\n * @typedef {import('./types').AddingPeerEvent} AddingPeerEvent\n * @typedef {import('./types').DialingPeerEvent} DialingPeerEvent\n *\n * @typedef {object} KadDHTOps\n * @property {Libp2p} libp2p - the libp2p instance\n * @property {string} [protocol = '/ipfs/kad/1.0.0'] - libp2p registrar handle protocol\n * @property {number} kBucketSize - k-bucket size (default 20)\n * @property {boolean} clientMode - If true, the DHT will not respond to queries. This should be true if your node will not be dialable. (default: false)\n * @property {import('libp2p-interfaces/src/types').DhtValidators} validators - validators object with namespace as keys and function(key, record, callback)\n * @property {object} selectors - selectors object with namespace as keys and function(key, records)\n * @property {number} querySelfInterval - how often to search the network for peers close to ourselves\n * @property {boolean} lan\n * @property {PeerData[]} bootstrapPeers\n */\n\nclass PrefixTransform {\n  /**\n   *\n   * @param {string} prefix - : ;\n   */\n  constructor (prefix) {\n    this._prefix = prefix\n\n    if (this._prefix.startsWith('/')) {\n      this._prefix = this._prefix.substring(1)\n    }\n  }\n\n  /**\n   * @param {Key} key\n   */\n  convert (key) {\n    return new Key(`/${this._prefix}${key}`)\n  }\n\n  /**\n   * @param {Key} key\n   */\n  invert (key) {\n    const namespaces = key.namespaces()\n\n    if (namespaces[0] === this._prefix) {\n      namespaces.shift()\n    }\n\n    return Key.withNamespaces(namespaces)\n  }\n}\n\n/**\n * A DHT implementation modelled after Kademlia with S/Kademlia modifications.\n * Original implementation in go: https://github.com/libp2p/go-libp2p-kad-dht.\n */\nclass KadDHT extends EventEmitter {\n  /**\n   * Create a new KadDHT.\n   *\n   * @param {KadDHTOps} opts\n   */\n  constructor ({\n    libp2p,\n    kBucketSize = K,\n    clientMode = true,\n    validators = {},\n    selectors = {},\n    querySelfInterval = QUERY_SELF_INTERVAL,\n    lan = true,\n    protocol = '/ipfs/lan/kad/1.0.0',\n    bootstrapPeers = []\n  }) {\n    super()\n\n    this._running = false\n    this._log = utils.logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}`)\n\n    /**\n     * Local reference to the libp2p instance\n     *\n     * @type {Libp2p}\n     */\n    this._libp2p = libp2p\n\n    /**\n     * Registrar protocol\n     *\n     * @type {string}\n     */\n    this._protocol = protocol\n\n    /**\n     * k-bucket size\n     *\n     * @type {number}\n     */\n    this._kBucketSize = kBucketSize\n\n    /**\n     * Whether we are in client or server mode\n     */\n    this._clientMode = clientMode\n\n    /**\n     * Will be added to the routing table on startup\n     */\n    this._bootstrapPeers = bootstrapPeers\n\n    /**\n     * The routing table.\n     *\n     * @type {RoutingTable}\n     */\n    this._routingTable = new RoutingTable({\n      peerId: libp2p.peerId,\n      dialer: libp2p,\n      kBucketSize,\n      metrics: libp2p.metrics,\n      lan\n    })\n\n    const datastore = libp2p.datastore || new MemoryDatastore()\n    const records = new KeyTransformDatastore(datastore, new PrefixTransform(RECORD_KEY_PREFIX))\n\n    /**\n     * Provider management\n     *\n     * @type {Providers}\n     */\n    this._providers = new Providers({\n      providers: datastore\n    })\n\n    /**\n     * @type {boolean}\n     */\n    this._lan = lan\n\n    this._validators = {\n      pk: libp2pRecord.validator.validators.pk,\n      ...validators\n    }\n\n    this._selectors = {\n      pk: libp2pRecord.selection.selectors.pk,\n      ...selectors\n    }\n\n    this._network = new Network({\n      dialer: libp2p,\n      protocol: this._protocol,\n      lan\n    })\n    /**\n     * Keeps track of running queries\n     *\n     * @type {QueryManager}\n     */\n    this._queryManager = new QueryManager({\n      peerId: libp2p.peerId,\n      // Number of disjoint query paths to use - This is set to `kBucketSize/2` per the S/Kademlia paper\n      disjointPaths: Math.ceil(kBucketSize / 2),\n      metrics: libp2p.metrics,\n      lan\n    })\n\n    // DHT components\n    this._peerRouting = new PeerRouting({\n      peerId: libp2p.peerId,\n      routingTable: this._routingTable,\n      peerStore: libp2p.peerStore,\n      network: this._network,\n      validators: this._validators,\n      queryManager: this._queryManager,\n      lan\n    })\n    this._contentFetching = new ContentFetching({\n      peerId: libp2p.peerId,\n      records,\n      validators: this._validators,\n      selectors: this._selectors,\n      peerRouting: this._peerRouting,\n      queryManager: this._queryManager,\n      routingTable: this._routingTable,\n      network: this._network,\n      lan\n    })\n    this._contentRouting = new ContentRouting({\n      peerId: libp2p.peerId,\n      network: this._network,\n      peerRouting: this._peerRouting,\n      queryManager: this._queryManager,\n      routingTable: this._routingTable,\n      providers: this._providers,\n      peerStore: libp2p.peerStore,\n      lan\n    })\n    this._routingTableRefresh = new RoutingTableRefresh({\n      peerRouting: this._peerRouting,\n      routingTable: this._routingTable,\n      lan\n    })\n    this._rpc = new RPC({\n      routingTable: this._routingTable,\n      peerId: libp2p.peerId,\n      providers: this._providers,\n      peerStore: libp2p.peerStore,\n      addressable: libp2p,\n      peerRouting: this._peerRouting,\n      records,\n      validators: this._validators,\n      lan\n    })\n    this._topologyListener = new TopologyListener({\n      registrar: libp2p.registrar,\n      protocol: this._protocol,\n      lan\n    })\n    this._querySelf = new QuerySelf({\n      peerId: libp2p.peerId,\n      peerRouting: this._peerRouting,\n      interval: querySelfInterval,\n      lan\n    })\n\n    // handle peers being discovered during processing of DHT messages\n    this._network.on('peer', (peerData) => {\n      this.onPeerConnect(peerData).catch(err => {\n        this._log.error(`could not add ${peerData.id} to routing table`, err)\n      })\n\n      this.emit('peer', peerData)\n    })\n\n    // handle peers being discovered via other peer discovery mechanisms\n    this._topologyListener.on('peer', async (peerId) => {\n      const multiaddrs = await this._libp2p.peerStore.addressBook.get(peerId)\n\n      const peerData = {\n        id: peerId,\n        multiaddrs: multiaddrs.map(addr => addr.multiaddr)\n      }\n\n      this.onPeerConnect(peerData).catch(err => {\n        this._log.error(`could not add ${peerData.id} to routing table`, err)\n      })\n    })\n  }\n\n  /**\n   * @param {PeerData} peerData\n   */\n  async onPeerConnect (peerData) {\n    this._log('peer %p connected', peerData.id)\n\n    if (this._lan) {\n      peerData = removePublicAddresses(peerData)\n    } else {\n      peerData = removePrivateAddresses(peerData)\n    }\n\n    if (!peerData.multiaddrs.length) {\n      this._log('ignoring %p as they do not have any %s addresses in %s', peerData.id, this._lan ? 'private' : 'public', peerData.multiaddrs.map(addr => addr.toString()))\n      return\n    }\n\n    try {\n      await this._routingTable.add(peerData.id)\n    } catch (/** @type {any} */ err) {\n      this._log.error('could not add %p to routing table', peerData.id, err)\n    }\n  }\n\n  /**\n   * Is this DHT running.\n   */\n  isStarted () {\n    return this._running\n  }\n\n  /**\n   * Is this DHT in server mode\n   */\n  isServer () {\n    return !this._clientMode\n  }\n\n  /**\n   * Whether we are in client or server mode\n   */\n  async enableServerMode () {\n    this._log('enabling server mode')\n    this._clientMode = false\n    await this._libp2p.handle(this._protocol, this._rpc.onIncomingStream.bind(this._rpc))\n  }\n\n  /**\n   * Whether we are in client or server mode\n   */\n  async enableClientMode () {\n    this._log('enabling client mode')\n    this._clientMode = true\n    await this._libp2p.unhandle(this._protocol)\n  }\n\n  /**\n   * Start listening to incoming connections.\n   */\n  async start () {\n    this._running = true\n\n    // Only respond to queries when not in client mode\n    if (this._clientMode) {\n      await this.enableClientMode()\n    } else {\n      await this.enableServerMode()\n    }\n\n    await Promise.all([\n      this._providers.start(),\n      this._queryManager.start(),\n      this._network.start(),\n      this._routingTable.start(),\n      this._topologyListener.start(),\n      this._querySelf.start()\n    ])\n\n    await Promise.all(\n      this._bootstrapPeers.map(peerData => this._routingTable.add(peerData.id))\n    )\n\n    await this._routingTableRefresh.start()\n    await this.refreshRoutingTable()\n  }\n\n  /**\n   * Stop accepting incoming connections and sending outgoing\n   * messages.\n   */\n  async stop () {\n    this._running = false\n\n    await Promise.all([\n      this._providers.stop(),\n      this._queryManager.stop(),\n      this._network.stop(),\n      this._routingTable.stop(),\n      this._routingTableRefresh.stop(),\n      this._topologyListener.stop(),\n      this._querySelf.stop()\n    ])\n  }\n\n  /**\n   * Store the given key/value pair in the DHT\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} value\n   * @param {object} [options] - put options\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.minPeers] - minimum number of peers required to successfully put (default: closestPeers.length)\n   */\n  async * put (key, value, options = {}) { // eslint-disable-line require-await\n    yield * this._contentFetching.put(key, value, options)\n  }\n\n  /**\n   * Get the value that corresponds to the passed key\n   *\n   * @param {Uint8Array} key\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.queryFuncTimeout]\n   */\n  async * get (key, options = {}) { // eslint-disable-line require-await\n    yield * this._contentFetching.get(key, options)\n  }\n\n  // ----------- Content Routing\n\n  /**\n   * Announce to the network that we can provide given key's value\n   *\n   * @param {CID} key\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async * provide (key, options = {}) { // eslint-disable-line require-await\n    yield * this._contentRouting.provide(key, this._libp2p.multiaddrs, options)\n  }\n\n  /**\n   * Search the dht for up to `K` providers of the given CID.\n   *\n   * @param {CID} key\n   * @param {object} [options] - findProviders options\n   * @param {number} [options.maxNumProviders=5] - maximum number of providers to find\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.queryFuncTimeout]\n   */\n  async * findProviders (key, options = { maxNumProviders: 5 }) {\n    yield * this._contentRouting.findProviders(key, options)\n  }\n\n  // ----------- Peer Routing -----------\n\n  /**\n   * Search for a peer with the given ID\n   *\n   * @param {PeerId} id\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.queryFuncTimeout]\n   */\n  async * findPeer (id, options = {}) { // eslint-disable-line require-await\n    yield * this._peerRouting.findPeer(id, options)\n  }\n\n  /**\n   * Kademlia 'node lookup' operation.\n   *\n   * @param {Uint8Array} key\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.queryFuncTimeout]\n   */\n  async * getClosestPeers (key, options = {}) {\n    yield * this._peerRouting.getClosestPeers(key, options)\n  }\n\n  /**\n   * Get the public key for the given peer id\n   *\n   * @param {PeerId} peer\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async getPublicKey (peer, options = {}) {\n    this._log('getPublicKey %p', peer)\n\n    // try the node directly\n    for await (const event of this._peerRouting.getPublicKeyFromNode(peer, options)) {\n      if (event.name === 'VALUE') {\n        return crypto.keys.unmarshalPublicKey(event.value)\n      }\n    }\n\n    // search the dht\n    const pkKey = utils.keyForPublicKey(peer)\n\n    for await (const event of this.get(pkKey, options)) {\n      if (event.name === 'VALUE') {\n        return crypto.keys.unmarshalPublicKey(event.value)\n      }\n    }\n  }\n\n  async refreshRoutingTable () {\n    await this._routingTableRefresh.refreshTable(true)\n  }\n}\n\nmodule.exports = {\n  KadDHT\n}\n"]},"metadata":{},"sourceType":"script"}