{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar base = require('./base.js');\n\nvar errors = require('./errors.js');\n\nvar debug = require('debug');\n\nvar pushable = require('it-pushable');\n\nvar drain = require('it-drain');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\n\nvar pushable__default = /*#__PURE__*/_interopDefaultLegacy(pushable);\n\nvar drain__default = /*#__PURE__*/_interopDefaultLegacy(drain);\n\nconst log = debug__default[\"default\"]('datastore:core:tiered');\n\nclass TieredDatastore extends base.BaseDatastore {\n  constructor(stores) {\n    super();\n    this.stores = stores.slice();\n  }\n\n  async open() {\n    try {\n      await Promise.all(this.stores.map(store => store.open()));\n    } catch (err) {\n      throw errors.dbOpenFailedError();\n    }\n  }\n\n  async put(key, value) {\n    try {\n      await Promise.all(this.stores.map(store => store.put(key, value)));\n    } catch (err) {\n      throw errors.dbWriteFailedError();\n    }\n  }\n\n  async get(key, options) {\n    for (const store of this.stores) {\n      try {\n        const res = await store.get(key, options);\n        if (res) return res;\n      } catch (err) {\n        log(err);\n      }\n    }\n\n    throw errors.notFoundError();\n  }\n\n  async has(key, options) {\n    for (const s of this.stores) {\n      if (await s.has(key, options)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  async delete(key, options) {\n    try {\n      await Promise.all(this.stores.map(store => store.delete(key, options)));\n    } catch (err) {\n      throw errors.dbDeleteFailedError();\n    }\n  }\n\n  async *putMany(source) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let error;\n    const pushables = this.stores.map(store => {\n      const source = pushable__default[\"default\"]();\n      drain__default[\"default\"](store.putMany(source, options)).catch(err => {\n        error = err;\n      });\n      return source;\n    });\n\n    try {\n      for await (const pair of source) {\n        if (error) {\n          throw error;\n        }\n\n        pushables.forEach(p => p.push(pair));\n        yield pair;\n      }\n    } finally {\n      pushables.forEach(p => p.end());\n    }\n  }\n\n  async *deleteMany(source) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let error;\n    const pushables = this.stores.map(store => {\n      const source = pushable__default[\"default\"]();\n      drain__default[\"default\"](store.deleteMany(source, options)).catch(err => {\n        error = err;\n      });\n      return source;\n    });\n\n    try {\n      for await (const key of source) {\n        if (error) {\n          throw error;\n        }\n\n        pushables.forEach(p => p.push(key));\n        yield key;\n      }\n    } finally {\n      pushables.forEach(p => p.end());\n    }\n  }\n\n  async close() {\n    await Promise.all(this.stores.map(store => store.close()));\n  }\n\n  batch() {\n    const batches = this.stores.map(store => store.batch());\n    return {\n      put: (key, value) => {\n        batches.forEach(b => b.put(key, value));\n      },\n      delete: key => {\n        batches.forEach(b => b.delete(key));\n      },\n      commit: async options => {\n        for (const batch of batches) {\n          await batch.commit(options);\n        }\n      }\n    };\n  }\n\n  query(q, options) {\n    return this.stores[this.stores.length - 1].query(q, options);\n  }\n\n  queryKeys(q, options) {\n    return this.stores[this.stores.length - 1].queryKeys(q, options);\n  }\n\n}\n\nexports.TieredDatastore = TieredDatastore;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/datastore-core/cjs/src/tiered.js"],"names":["Object","defineProperty","exports","value","base","require","errors","debug","pushable","drain","_interopDefaultLegacy","e","debug__default","pushable__default","drain__default","log","TieredDatastore","BaseDatastore","constructor","stores","slice","open","Promise","all","map","store","err","dbOpenFailedError","put","key","dbWriteFailedError","get","options","res","notFoundError","has","s","delete","dbDeleteFailedError","putMany","source","error","pushables","catch","pair","forEach","p","push","end","deleteMany","close","batch","batches","b","commit","query","q","length","queryKeys"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar base = require('./base.js');\nvar errors = require('./errors.js');\nvar debug = require('debug');\nvar pushable = require('it-pushable');\nvar drain = require('it-drain');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\nvar pushable__default = /*#__PURE__*/_interopDefaultLegacy(pushable);\nvar drain__default = /*#__PURE__*/_interopDefaultLegacy(drain);\n\nconst log = debug__default[\"default\"]('datastore:core:tiered');\nclass TieredDatastore extends base.BaseDatastore {\n  constructor(stores) {\n    super();\n    this.stores = stores.slice();\n  }\n  async open() {\n    try {\n      await Promise.all(this.stores.map(store => store.open()));\n    } catch (err) {\n      throw errors.dbOpenFailedError();\n    }\n  }\n  async put(key, value) {\n    try {\n      await Promise.all(this.stores.map(store => store.put(key, value)));\n    } catch (err) {\n      throw errors.dbWriteFailedError();\n    }\n  }\n  async get(key, options) {\n    for (const store of this.stores) {\n      try {\n        const res = await store.get(key, options);\n        if (res)\n          return res;\n      } catch (err) {\n        log(err);\n      }\n    }\n    throw errors.notFoundError();\n  }\n  async has(key, options) {\n    for (const s of this.stores) {\n      if (await s.has(key, options)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  async delete(key, options) {\n    try {\n      await Promise.all(this.stores.map(store => store.delete(key, options)));\n    } catch (err) {\n      throw errors.dbDeleteFailedError();\n    }\n  }\n  async *putMany(source, options = {}) {\n    let error;\n    const pushables = this.stores.map(store => {\n      const source = pushable__default[\"default\"]();\n      drain__default[\"default\"](store.putMany(source, options)).catch(err => {\n        error = err;\n      });\n      return source;\n    });\n    try {\n      for await (const pair of source) {\n        if (error) {\n          throw error;\n        }\n        pushables.forEach(p => p.push(pair));\n        yield pair;\n      }\n    } finally {\n      pushables.forEach(p => p.end());\n    }\n  }\n  async *deleteMany(source, options = {}) {\n    let error;\n    const pushables = this.stores.map(store => {\n      const source = pushable__default[\"default\"]();\n      drain__default[\"default\"](store.deleteMany(source, options)).catch(err => {\n        error = err;\n      });\n      return source;\n    });\n    try {\n      for await (const key of source) {\n        if (error) {\n          throw error;\n        }\n        pushables.forEach(p => p.push(key));\n        yield key;\n      }\n    } finally {\n      pushables.forEach(p => p.end());\n    }\n  }\n  async close() {\n    await Promise.all(this.stores.map(store => store.close()));\n  }\n  batch() {\n    const batches = this.stores.map(store => store.batch());\n    return {\n      put: (key, value) => {\n        batches.forEach(b => b.put(key, value));\n      },\n      delete: key => {\n        batches.forEach(b => b.delete(key));\n      },\n      commit: async options => {\n        for (const batch of batches) {\n          await batch.commit(options);\n        }\n      }\n    };\n  }\n  query(q, options) {\n    return this.stores[this.stores.length - 1].query(q, options);\n  }\n  queryKeys(q, options) {\n    return this.stores[this.stores.length - 1].queryKeys(q, options);\n  }\n}\n\nexports.TieredDatastore = TieredDatastore;\n"]},"metadata":{},"sourceType":"script"}