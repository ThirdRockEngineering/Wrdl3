{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SimpleTimeCache = void 0;\n/**\n * This is similar to https://github.com/daviddias/time-cache/blob/master/src/index.js\n * for our own need, we don't use lodash throttle to improve performance.\n * This gives 4x - 5x performance gain compared to npm TimeCache\n */\n\nclass SimpleTimeCache {\n  constructor(options) {\n    this.lastPruneTime = 0;\n    this.entries = new Map();\n    this.validityMs = options.validityMs; // allow negative validityMs so that this does not cache anything, spec test compliance.spec.js\n    // sends duplicate messages and expect peer to receive all. Application likely uses positive validityMs\n  }\n\n  put(key, value) {\n    this.entries.set(key, {\n      value,\n      validUntilMs: Date.now() + this.validityMs\n    });\n    this.prune();\n  }\n\n  prune() {\n    const now = Date.now();\n\n    if (now - this.lastPruneTime < 200) {\n      return;\n    }\n\n    this.lastPruneTime = now;\n\n    for (const [k, v] of this.entries.entries()) {\n      if (v.validUntilMs < now) {\n        this.entries.delete(k);\n      } else {\n        // sort by insertion order\n        break;\n      }\n    }\n  }\n\n  has(key) {\n    return this.entries.has(key);\n  }\n\n  get(key) {\n    const value = this.entries.get(key);\n    return value && value.validUntilMs >= Date.now() ? value.value : undefined;\n  }\n\n  clear() {\n    this.entries = new Map();\n    this.lastPruneTime = 0;\n  }\n\n}\n\nexports.SimpleTimeCache = SimpleTimeCache;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p-gossipsub/src/utils/time-cache.js"],"names":["Object","defineProperty","exports","value","SimpleTimeCache","constructor","options","lastPruneTime","entries","Map","validityMs","put","key","set","validUntilMs","Date","now","prune","k","v","delete","has","get","undefined","clear"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,eAAR,GAA0B,KAAK,CAA/B;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMA,eAAN,CAAsB;AAClBC,EAAAA,WAAW,CAACC,OAAD,EAAU;AACjB,SAAKC,aAAL,GAAqB,CAArB;AACA,SAAKC,OAAL,GAAe,IAAIC,GAAJ,EAAf;AACA,SAAKC,UAAL,GAAkBJ,OAAO,CAACI,UAA1B,CAHiB,CAIjB;AACA;AACH;;AACDC,EAAAA,GAAG,CAACC,GAAD,EAAMT,KAAN,EAAa;AACZ,SAAKK,OAAL,CAAaK,GAAb,CAAiBD,GAAjB,EAAsB;AAAET,MAAAA,KAAF;AAASW,MAAAA,YAAY,EAAEC,IAAI,CAACC,GAAL,KAAa,KAAKN;AAAzC,KAAtB;AACA,SAAKO,KAAL;AACH;;AACDA,EAAAA,KAAK,GAAG;AACJ,UAAMD,GAAG,GAAGD,IAAI,CAACC,GAAL,EAAZ;;AACA,QAAIA,GAAG,GAAG,KAAKT,aAAX,GAA2B,GAA/B,EAAoC;AAChC;AACH;;AACD,SAAKA,aAAL,GAAqBS,GAArB;;AACA,SAAK,MAAM,CAACE,CAAD,EAAIC,CAAJ,CAAX,IAAqB,KAAKX,OAAL,CAAaA,OAAb,EAArB,EAA6C;AACzC,UAAIW,CAAC,CAACL,YAAF,GAAiBE,GAArB,EAA0B;AACtB,aAAKR,OAAL,CAAaY,MAAb,CAAoBF,CAApB;AACH,OAFD,MAGK;AACD;AACA;AACH;AACJ;AACJ;;AACDG,EAAAA,GAAG,CAACT,GAAD,EAAM;AACL,WAAO,KAAKJ,OAAL,CAAaa,GAAb,CAAiBT,GAAjB,CAAP;AACH;;AACDU,EAAAA,GAAG,CAACV,GAAD,EAAM;AACL,UAAMT,KAAK,GAAG,KAAKK,OAAL,CAAac,GAAb,CAAiBV,GAAjB,CAAd;AACA,WAAQT,KAAK,IAAIA,KAAK,CAACW,YAAN,IAAsBC,IAAI,CAACC,GAAL,EAAhC,GAA8Cb,KAAK,CAACA,KAApD,GAA4DoB,SAAnE;AACH;;AACDC,EAAAA,KAAK,GAAG;AACJ,SAAKhB,OAAL,GAAe,IAAIC,GAAJ,EAAf;AACA,SAAKF,aAAL,GAAqB,CAArB;AACH;;AAtCiB;;AAwCtBL,OAAO,CAACE,eAAR,GAA0BA,eAA1B","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SimpleTimeCache = void 0;\n/**\n * This is similar to https://github.com/daviddias/time-cache/blob/master/src/index.js\n * for our own need, we don't use lodash throttle to improve performance.\n * This gives 4x - 5x performance gain compared to npm TimeCache\n */\nclass SimpleTimeCache {\n    constructor(options) {\n        this.lastPruneTime = 0;\n        this.entries = new Map();\n        this.validityMs = options.validityMs;\n        // allow negative validityMs so that this does not cache anything, spec test compliance.spec.js\n        // sends duplicate messages and expect peer to receive all. Application likely uses positive validityMs\n    }\n    put(key, value) {\n        this.entries.set(key, { value, validUntilMs: Date.now() + this.validityMs });\n        this.prune();\n    }\n    prune() {\n        const now = Date.now();\n        if (now - this.lastPruneTime < 200) {\n            return;\n        }\n        this.lastPruneTime = now;\n        for (const [k, v] of this.entries.entries()) {\n            if (v.validUntilMs < now) {\n                this.entries.delete(k);\n            }\n            else {\n                // sort by insertion order\n                break;\n            }\n        }\n    }\n    has(key) {\n        return this.entries.has(key);\n    }\n    get(key) {\n        const value = this.entries.get(key);\n        return (value && value.validUntilMs >= Date.now()) ? value.value : undefined;\n    }\n    clear() {\n        this.entries = new Map();\n        this.lastPruneTime = 0;\n    }\n}\nexports.SimpleTimeCache = SimpleTimeCache;\n"]},"metadata":{},"sourceType":"script"}