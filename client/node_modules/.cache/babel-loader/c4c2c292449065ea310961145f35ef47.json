{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar dagPB = require('@ipld/dag-pb');\n\nvar cid = require('multiformats/cid');\n\nvar debug = require('debug');\n\nvar ipfsUnixfs = require('ipfs-unixfs');\n\nvar dirSharded = require('./dir-sharded.js');\n\nvar hamtUtils = require('./hamt-utils.js');\n\nvar errCode = require('err-code');\n\nvar last = require('it-last');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar dagPB__namespace = /*#__PURE__*/_interopNamespace(dagPB);\n\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\n\nvar last__default = /*#__PURE__*/_interopDefaultLegacy(last);\n\nconst log = debug__default[\"default\"]('ipfs:mfs:core:utils:add-link');\n\nasync function addLink(context, options) {\n  let parent = options.parent;\n\n  if (options.parentCid) {\n    const parentCid = cid.CID.asCID(options.parentCid);\n\n    if (parentCid === null) {\n      throw errCode__default[\"default\"](new Error('Invalid CID passed to addLink'), 'EINVALIDPARENTCID');\n    }\n\n    if (parentCid.code !== dagPB__namespace.code) {\n      throw errCode__default[\"default\"](new Error('Unsupported codec. Only DAG-PB is supported'), 'EINVALIDPARENTCID');\n    }\n\n    log(`Loading parent node ${parentCid}`);\n    const block = await context.repo.blocks.get(parentCid);\n    parent = dagPB__namespace.decode(block);\n  }\n\n  if (!parent) {\n    throw errCode__default[\"default\"](new Error('No parent node or CID passed to addLink'), 'EINVALIDPARENT');\n  }\n\n  if (!options.cid) {\n    throw errCode__default[\"default\"](new Error('No child cid passed to addLink'), 'EINVALIDCHILDCID');\n  }\n\n  if (!options.name) {\n    throw errCode__default[\"default\"](new Error('No child name passed to addLink'), 'EINVALIDCHILDNAME');\n  }\n\n  if (!options.size && options.size !== 0) {\n    throw errCode__default[\"default\"](new Error('No child size passed to addLink'), 'EINVALIDCHILDSIZE');\n  }\n\n  if (!parent.Data) {\n    throw errCode__default[\"default\"](new Error('Parent node with no data passed to addLink'), 'ERR_INVALID_PARENT');\n  }\n\n  const meta = ipfsUnixfs.UnixFS.unmarshal(parent.Data);\n\n  if (meta.type === 'hamt-sharded-directory') {\n    log('Adding link to sharded directory');\n    return addToShardedDirectory(context, { ...options,\n      parent\n    });\n  }\n\n  if (parent.Links.length >= options.shardSplitThreshold) {\n    log('Converting directory to sharded directory');\n    return convertToShardedDirectory(context, { ...options,\n      parent,\n      mtime: meta.mtime,\n      mode: meta.mode\n    });\n  }\n\n  log(`Adding ${options.name} (${options.cid}) to regular directory`);\n  return addToDirectory(context, { ...options,\n    parent\n  });\n}\n\nconst convertToShardedDirectory = async (context, options) => {\n  const result = await hamtUtils.createShard(context, options.parent.Links.map(link => ({\n    name: link.Name || '',\n    size: link.Tsize || 0,\n    cid: link.Hash\n  })).concat({\n    name: options.name,\n    size: options.size,\n    cid: options.cid\n  }), options);\n  log(`Converted directory to sharded directory ${result.cid}`);\n  return result;\n};\n\nconst addToDirectory = async (context, options) => {\n  const parentLinks = options.parent.Links.filter(link => {\n    return link.Name !== options.name;\n  });\n  parentLinks.push({\n    Name: options.name,\n    Tsize: options.size,\n    Hash: options.cid\n  });\n\n  if (!options.parent.Data) {\n    throw errCode__default[\"default\"](new Error('Parent node with no data passed to addToDirectory'), 'ERR_INVALID_PARENT');\n  }\n\n  const node = ipfsUnixfs.UnixFS.unmarshal(options.parent.Data);\n  let data;\n\n  if (node.mtime) {\n    const ms = Date.now();\n    const secs = Math.floor(ms / 1000);\n    node.mtime = {\n      secs: secs,\n      nsecs: (ms - secs * 1000) * 1000\n    };\n    data = node.marshal();\n  } else {\n    data = options.parent.Data;\n  }\n\n  options.parent = dagPB__namespace.prepare({\n    Data: data,\n    Links: parentLinks\n  });\n  const hasher = await context.hashers.getHasher(options.hashAlg);\n  const buf = dagPB__namespace.encode(options.parent);\n  const hash = await hasher.digest(buf);\n  const cid$1 = cid.CID.create(options.cidVersion, dagPB__namespace.code, hash);\n\n  if (options.flush) {\n    await context.repo.blocks.put(cid$1, buf);\n  }\n\n  return {\n    node: options.parent,\n    cid: cid$1,\n    size: buf.length\n  };\n};\n\nconst addToShardedDirectory = async (context, options) => {\n  const {\n    shard,\n    path\n  } = await addFileToShardedDirectory(context, options);\n  const result = await last__default[\"default\"](shard.flush(context.repo.blocks));\n\n  if (!result) {\n    throw new Error('No result from flushing shard');\n  }\n\n  const block = await context.repo.blocks.get(result.cid);\n  const node = dagPB__namespace.decode(block);\n  const parentLinks = options.parent.Links.filter(link => {\n    return (link.Name || '').substring(0, 2) !== path[0].prefix;\n  });\n  const newLink = node.Links.find(link => (link.Name || '').substring(0, 2) === path[0].prefix);\n\n  if (!newLink) {\n    throw new Error(`No link found with prefix ${path[0].prefix}`);\n  }\n\n  parentLinks.push(newLink);\n  return hamtUtils.updateHamtDirectory(context, parentLinks, path[0].bucket, options);\n};\n\nconst addFileToShardedDirectory = async (context, options) => {\n  const file = {\n    name: options.name,\n    cid: options.cid,\n    size: options.size\n  };\n\n  if (!options.parent.Data) {\n    throw errCode__default[\"default\"](new Error('Parent node with no data passed to addFileToShardedDirectory'), 'ERR_INVALID_PARENT');\n  }\n\n  const rootBucket = await hamtUtils.recreateInitialHamtLevel(options.parent.Links);\n  const node = ipfsUnixfs.UnixFS.unmarshal(options.parent.Data);\n  const shard = new dirSharded.DirSharded({\n    root: true,\n    dir: true,\n    parent: undefined,\n    parentKey: undefined,\n    path: '',\n    dirty: true,\n    flat: false,\n    mode: node.mode\n  }, options);\n  shard._bucket = rootBucket;\n\n  if (node.mtime) {\n    shard.mtime = {\n      secs: Math.round(Date.now() / 1000)\n    };\n  }\n\n  const position = await rootBucket._findNewBucketAndPos(file.name);\n  const path = toBucketPath(position);\n  path[0].node = options.parent;\n  let index = 0;\n\n  while (index < path.length) {\n    const segment = path[index];\n    index++;\n    const node = segment.node;\n\n    if (!node) {\n      throw new Error('Segment had no node');\n    }\n\n    const link = node.Links.find(link => (link.Name || '').substring(0, 2) === segment.prefix);\n\n    if (!link) {\n      log(`Link ${segment.prefix}${file.name} will be added`);\n      index = path.length;\n      break;\n    }\n\n    if (link.Name === `${segment.prefix}${file.name}`) {\n      log(`Link ${segment.prefix}${file.name} will be replaced`);\n      index = path.length;\n      break;\n    }\n\n    if ((link.Name || '').length > 2) {\n      log(`Link ${link.Name} ${link.Hash} will be replaced with a subshard`);\n      index = path.length;\n      break;\n    }\n\n    log(`Found subshard ${segment.prefix}`);\n    const block = await context.repo.blocks.get(link.Hash);\n    const subShard = dagPB__namespace.decode(block);\n\n    if (!path[index]) {\n      log(`Loaded new subshard ${segment.prefix}`);\n      await hamtUtils.recreateHamtLevel(context, subShard.Links, rootBucket, segment.bucket, parseInt(segment.prefix, 16));\n      const position = await rootBucket._findNewBucketAndPos(file.name);\n      path.push({\n        bucket: position.bucket,\n        prefix: hamtUtils.toPrefix(position.pos),\n        node: subShard\n      });\n      break;\n    }\n\n    const nextSegment = path[index];\n    await hamtUtils.addLinksToHamtBucket(context, subShard.Links, nextSegment.bucket, rootBucket);\n    nextSegment.node = subShard;\n  }\n\n  await shard._bucket.put(file.name, {\n    size: file.size,\n    cid: file.cid\n  });\n  return {\n    shard,\n    path\n  };\n};\n\nconst toBucketPath = position => {\n  const path = [{\n    bucket: position.bucket,\n    prefix: hamtUtils.toPrefix(position.pos)\n  }];\n  let bucket = position.bucket._parent;\n  let positionInBucket = position.bucket._posAtParent;\n\n  while (bucket) {\n    path.push({\n      bucket,\n      prefix: hamtUtils.toPrefix(positionInBucket)\n    });\n    positionInBucket = bucket._posAtParent;\n    bucket = bucket._parent;\n  }\n\n  path.reverse();\n  return path;\n};\n\nexports.addLink = addLink;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-core/cjs/src/components/files/utils/add-link.js"],"names":["Object","defineProperty","exports","value","dagPB","require","cid","debug","ipfsUnixfs","dirSharded","hamtUtils","errCode","last","_interopDefaultLegacy","e","_interopNamespace","__esModule","n","create","keys","forEach","k","d","getOwnPropertyDescriptor","get","enumerable","freeze","dagPB__namespace","debug__default","errCode__default","last__default","log","addLink","context","options","parent","parentCid","CID","asCID","Error","code","block","repo","blocks","decode","name","size","Data","meta","UnixFS","unmarshal","type","addToShardedDirectory","Links","length","shardSplitThreshold","convertToShardedDirectory","mtime","mode","addToDirectory","result","createShard","map","link","Name","Tsize","Hash","concat","parentLinks","filter","push","node","data","ms","Date","now","secs","Math","floor","nsecs","marshal","prepare","hasher","hashers","getHasher","hashAlg","buf","encode","hash","digest","cid$1","cidVersion","flush","put","shard","path","addFileToShardedDirectory","substring","prefix","newLink","find","updateHamtDirectory","bucket","file","rootBucket","recreateInitialHamtLevel","DirSharded","root","dir","undefined","parentKey","dirty","flat","_bucket","round","position","_findNewBucketAndPos","toBucketPath","index","segment","subShard","recreateHamtLevel","parseInt","toPrefix","pos","nextSegment","addLinksToHamtBucket","_parent","positionInBucket","_posAtParent","reverse"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar dagPB = require('@ipld/dag-pb');\nvar cid = require('multiformats/cid');\nvar debug = require('debug');\nvar ipfsUnixfs = require('ipfs-unixfs');\nvar dirSharded = require('./dir-sharded.js');\nvar hamtUtils = require('./hamt-utils.js');\nvar errCode = require('err-code');\nvar last = require('it-last');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar dagPB__namespace = /*#__PURE__*/_interopNamespace(dagPB);\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\nvar last__default = /*#__PURE__*/_interopDefaultLegacy(last);\n\nconst log = debug__default[\"default\"]('ipfs:mfs:core:utils:add-link');\nasync function addLink(context, options) {\n  let parent = options.parent;\n  if (options.parentCid) {\n    const parentCid = cid.CID.asCID(options.parentCid);\n    if (parentCid === null) {\n      throw errCode__default[\"default\"](new Error('Invalid CID passed to addLink'), 'EINVALIDPARENTCID');\n    }\n    if (parentCid.code !== dagPB__namespace.code) {\n      throw errCode__default[\"default\"](new Error('Unsupported codec. Only DAG-PB is supported'), 'EINVALIDPARENTCID');\n    }\n    log(`Loading parent node ${ parentCid }`);\n    const block = await context.repo.blocks.get(parentCid);\n    parent = dagPB__namespace.decode(block);\n  }\n  if (!parent) {\n    throw errCode__default[\"default\"](new Error('No parent node or CID passed to addLink'), 'EINVALIDPARENT');\n  }\n  if (!options.cid) {\n    throw errCode__default[\"default\"](new Error('No child cid passed to addLink'), 'EINVALIDCHILDCID');\n  }\n  if (!options.name) {\n    throw errCode__default[\"default\"](new Error('No child name passed to addLink'), 'EINVALIDCHILDNAME');\n  }\n  if (!options.size && options.size !== 0) {\n    throw errCode__default[\"default\"](new Error('No child size passed to addLink'), 'EINVALIDCHILDSIZE');\n  }\n  if (!parent.Data) {\n    throw errCode__default[\"default\"](new Error('Parent node with no data passed to addLink'), 'ERR_INVALID_PARENT');\n  }\n  const meta = ipfsUnixfs.UnixFS.unmarshal(parent.Data);\n  if (meta.type === 'hamt-sharded-directory') {\n    log('Adding link to sharded directory');\n    return addToShardedDirectory(context, {\n      ...options,\n      parent\n    });\n  }\n  if (parent.Links.length >= options.shardSplitThreshold) {\n    log('Converting directory to sharded directory');\n    return convertToShardedDirectory(context, {\n      ...options,\n      parent,\n      mtime: meta.mtime,\n      mode: meta.mode\n    });\n  }\n  log(`Adding ${ options.name } (${ options.cid }) to regular directory`);\n  return addToDirectory(context, {\n    ...options,\n    parent\n  });\n}\nconst convertToShardedDirectory = async (context, options) => {\n  const result = await hamtUtils.createShard(context, options.parent.Links.map(link => ({\n    name: link.Name || '',\n    size: link.Tsize || 0,\n    cid: link.Hash\n  })).concat({\n    name: options.name,\n    size: options.size,\n    cid: options.cid\n  }), options);\n  log(`Converted directory to sharded directory ${ result.cid }`);\n  return result;\n};\nconst addToDirectory = async (context, options) => {\n  const parentLinks = options.parent.Links.filter(link => {\n    return link.Name !== options.name;\n  });\n  parentLinks.push({\n    Name: options.name,\n    Tsize: options.size,\n    Hash: options.cid\n  });\n  if (!options.parent.Data) {\n    throw errCode__default[\"default\"](new Error('Parent node with no data passed to addToDirectory'), 'ERR_INVALID_PARENT');\n  }\n  const node = ipfsUnixfs.UnixFS.unmarshal(options.parent.Data);\n  let data;\n  if (node.mtime) {\n    const ms = Date.now();\n    const secs = Math.floor(ms / 1000);\n    node.mtime = {\n      secs: secs,\n      nsecs: (ms - secs * 1000) * 1000\n    };\n    data = node.marshal();\n  } else {\n    data = options.parent.Data;\n  }\n  options.parent = dagPB__namespace.prepare({\n    Data: data,\n    Links: parentLinks\n  });\n  const hasher = await context.hashers.getHasher(options.hashAlg);\n  const buf = dagPB__namespace.encode(options.parent);\n  const hash = await hasher.digest(buf);\n  const cid$1 = cid.CID.create(options.cidVersion, dagPB__namespace.code, hash);\n  if (options.flush) {\n    await context.repo.blocks.put(cid$1, buf);\n  }\n  return {\n    node: options.parent,\n    cid: cid$1,\n    size: buf.length\n  };\n};\nconst addToShardedDirectory = async (context, options) => {\n  const {shard, path} = await addFileToShardedDirectory(context, options);\n  const result = await last__default[\"default\"](shard.flush(context.repo.blocks));\n  if (!result) {\n    throw new Error('No result from flushing shard');\n  }\n  const block = await context.repo.blocks.get(result.cid);\n  const node = dagPB__namespace.decode(block);\n  const parentLinks = options.parent.Links.filter(link => {\n    return (link.Name || '').substring(0, 2) !== path[0].prefix;\n  });\n  const newLink = node.Links.find(link => (link.Name || '').substring(0, 2) === path[0].prefix);\n  if (!newLink) {\n    throw new Error(`No link found with prefix ${ path[0].prefix }`);\n  }\n  parentLinks.push(newLink);\n  return hamtUtils.updateHamtDirectory(context, parentLinks, path[0].bucket, options);\n};\nconst addFileToShardedDirectory = async (context, options) => {\n  const file = {\n    name: options.name,\n    cid: options.cid,\n    size: options.size\n  };\n  if (!options.parent.Data) {\n    throw errCode__default[\"default\"](new Error('Parent node with no data passed to addFileToShardedDirectory'), 'ERR_INVALID_PARENT');\n  }\n  const rootBucket = await hamtUtils.recreateInitialHamtLevel(options.parent.Links);\n  const node = ipfsUnixfs.UnixFS.unmarshal(options.parent.Data);\n  const shard = new dirSharded.DirSharded({\n    root: true,\n    dir: true,\n    parent: undefined,\n    parentKey: undefined,\n    path: '',\n    dirty: true,\n    flat: false,\n    mode: node.mode\n  }, options);\n  shard._bucket = rootBucket;\n  if (node.mtime) {\n    shard.mtime = { secs: Math.round(Date.now() / 1000) };\n  }\n  const position = await rootBucket._findNewBucketAndPos(file.name);\n  const path = toBucketPath(position);\n  path[0].node = options.parent;\n  let index = 0;\n  while (index < path.length) {\n    const segment = path[index];\n    index++;\n    const node = segment.node;\n    if (!node) {\n      throw new Error('Segment had no node');\n    }\n    const link = node.Links.find(link => (link.Name || '').substring(0, 2) === segment.prefix);\n    if (!link) {\n      log(`Link ${ segment.prefix }${ file.name } will be added`);\n      index = path.length;\n      break;\n    }\n    if (link.Name === `${ segment.prefix }${ file.name }`) {\n      log(`Link ${ segment.prefix }${ file.name } will be replaced`);\n      index = path.length;\n      break;\n    }\n    if ((link.Name || '').length > 2) {\n      log(`Link ${ link.Name } ${ link.Hash } will be replaced with a subshard`);\n      index = path.length;\n      break;\n    }\n    log(`Found subshard ${ segment.prefix }`);\n    const block = await context.repo.blocks.get(link.Hash);\n    const subShard = dagPB__namespace.decode(block);\n    if (!path[index]) {\n      log(`Loaded new subshard ${ segment.prefix }`);\n      await hamtUtils.recreateHamtLevel(context, subShard.Links, rootBucket, segment.bucket, parseInt(segment.prefix, 16));\n      const position = await rootBucket._findNewBucketAndPos(file.name);\n      path.push({\n        bucket: position.bucket,\n        prefix: hamtUtils.toPrefix(position.pos),\n        node: subShard\n      });\n      break;\n    }\n    const nextSegment = path[index];\n    await hamtUtils.addLinksToHamtBucket(context, subShard.Links, nextSegment.bucket, rootBucket);\n    nextSegment.node = subShard;\n  }\n  await shard._bucket.put(file.name, {\n    size: file.size,\n    cid: file.cid\n  });\n  return {\n    shard,\n    path\n  };\n};\nconst toBucketPath = position => {\n  const path = [{\n      bucket: position.bucket,\n      prefix: hamtUtils.toPrefix(position.pos)\n    }];\n  let bucket = position.bucket._parent;\n  let positionInBucket = position.bucket._posAtParent;\n  while (bucket) {\n    path.push({\n      bucket,\n      prefix: hamtUtils.toPrefix(positionInBucket)\n    });\n    positionInBucket = bucket._posAtParent;\n    bucket = bucket._parent;\n  }\n  path.reverse();\n  return path;\n};\n\nexports.addLink = addLink;\n"]},"metadata":{},"sourceType":"script"}