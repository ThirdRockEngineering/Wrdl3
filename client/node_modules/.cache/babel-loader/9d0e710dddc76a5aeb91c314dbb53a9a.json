{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar key = require('interface-datastore/key');\n\nvar shardReadme = require('./shard-readme.js');\n\nconst PREFIX = '/repo/flatfs/shard/';\nconst SHARDING_FN = 'SHARDING';\nconst README_FN = '_README';\n\nclass ShardBase {\n  constructor(param) {\n    this.param = param;\n    this.name = 'base';\n    this._padding = '';\n  }\n\n  fun(s) {\n    return 'implement me';\n  }\n\n  toString() {\n    return `${PREFIX}v1/${this.name}/${this.param}`;\n  }\n\n}\n\nclass Prefix extends ShardBase {\n  constructor(prefixLen) {\n    super(prefixLen);\n    this._padding = ''.padStart(prefixLen, '_');\n    this.name = 'prefix';\n  }\n\n  fun(noslash) {\n    return (noslash + this._padding).slice(0, this.param);\n  }\n\n}\n\nclass Suffix extends ShardBase {\n  constructor(suffixLen) {\n    super(suffixLen);\n    this._padding = ''.padStart(suffixLen, '_');\n    this.name = 'suffix';\n  }\n\n  fun(noslash) {\n    const s = this._padding + noslash;\n    return s.slice(s.length - this.param);\n  }\n\n}\n\nclass NextToLast extends ShardBase {\n  constructor(suffixLen) {\n    super(suffixLen);\n    this._padding = ''.padStart(suffixLen + 1, '_');\n    this.name = 'next-to-last';\n  }\n\n  fun(noslash) {\n    const s = this._padding + noslash;\n    const offset = s.length - this.param - 1;\n    return s.slice(offset, offset + this.param);\n  }\n\n}\n\nfunction parseShardFun(str) {\n  str = str.trim();\n\n  if (str.length === 0) {\n    throw new Error('empty shard string');\n  }\n\n  if (!str.startsWith(PREFIX)) {\n    throw new Error(`invalid or no path prefix: ${str}`);\n  }\n\n  const parts = str.slice(PREFIX.length).split('/');\n  const version = parts[0];\n\n  if (version !== 'v1') {\n    throw new Error(`expect 'v1' version, got '${version}'`);\n  }\n\n  const name = parts[1];\n\n  if (!parts[2]) {\n    throw new Error('missing param');\n  }\n\n  const param = parseInt(parts[2], 10);\n\n  switch (name) {\n    case 'prefix':\n      return new Prefix(param);\n\n    case 'suffix':\n      return new Suffix(param);\n\n    case 'next-to-last':\n      return new NextToLast(param);\n\n    default:\n      throw new Error(`unkown sharding function: ${name}`);\n  }\n}\n\nconst readShardFun = async (path, store) => {\n  const key$1 = new key.Key(path).child(new key.Key(SHARDING_FN));\n  const get = typeof store.getRaw === 'function' ? store.getRaw.bind(store) : store.get.bind(store);\n  const res = await get(key$1);\n  return parseShardFun(new TextDecoder().decode(res || '').trim());\n};\n\nexports.readme = shardReadme;\nexports.NextToLast = NextToLast;\nexports.PREFIX = PREFIX;\nexports.Prefix = Prefix;\nexports.README_FN = README_FN;\nexports.SHARDING_FN = SHARDING_FN;\nexports.ShardBase = ShardBase;\nexports.Suffix = Suffix;\nexports.parseShardFun = parseShardFun;\nexports.readShardFun = readShardFun;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/datastore-core/cjs/src/shard.js"],"names":["Object","defineProperty","exports","value","key","require","shardReadme","PREFIX","SHARDING_FN","README_FN","ShardBase","constructor","param","name","_padding","fun","s","toString","Prefix","prefixLen","padStart","noslash","slice","Suffix","suffixLen","length","NextToLast","offset","parseShardFun","str","trim","Error","startsWith","parts","split","version","parseInt","readShardFun","path","store","key$1","Key","child","get","getRaw","bind","res","TextDecoder","decode","readme"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar key = require('interface-datastore/key');\nvar shardReadme = require('./shard-readme.js');\n\nconst PREFIX = '/repo/flatfs/shard/';\nconst SHARDING_FN = 'SHARDING';\nconst README_FN = '_README';\nclass ShardBase {\n  constructor(param) {\n    this.param = param;\n    this.name = 'base';\n    this._padding = '';\n  }\n  fun(s) {\n    return 'implement me';\n  }\n  toString() {\n    return `${ PREFIX }v1/${ this.name }/${ this.param }`;\n  }\n}\nclass Prefix extends ShardBase {\n  constructor(prefixLen) {\n    super(prefixLen);\n    this._padding = ''.padStart(prefixLen, '_');\n    this.name = 'prefix';\n  }\n  fun(noslash) {\n    return (noslash + this._padding).slice(0, this.param);\n  }\n}\nclass Suffix extends ShardBase {\n  constructor(suffixLen) {\n    super(suffixLen);\n    this._padding = ''.padStart(suffixLen, '_');\n    this.name = 'suffix';\n  }\n  fun(noslash) {\n    const s = this._padding + noslash;\n    return s.slice(s.length - this.param);\n  }\n}\nclass NextToLast extends ShardBase {\n  constructor(suffixLen) {\n    super(suffixLen);\n    this._padding = ''.padStart(suffixLen + 1, '_');\n    this.name = 'next-to-last';\n  }\n  fun(noslash) {\n    const s = this._padding + noslash;\n    const offset = s.length - this.param - 1;\n    return s.slice(offset, offset + this.param);\n  }\n}\nfunction parseShardFun(str) {\n  str = str.trim();\n  if (str.length === 0) {\n    throw new Error('empty shard string');\n  }\n  if (!str.startsWith(PREFIX)) {\n    throw new Error(`invalid or no path prefix: ${ str }`);\n  }\n  const parts = str.slice(PREFIX.length).split('/');\n  const version = parts[0];\n  if (version !== 'v1') {\n    throw new Error(`expect 'v1' version, got '${ version }'`);\n  }\n  const name = parts[1];\n  if (!parts[2]) {\n    throw new Error('missing param');\n  }\n  const param = parseInt(parts[2], 10);\n  switch (name) {\n  case 'prefix':\n    return new Prefix(param);\n  case 'suffix':\n    return new Suffix(param);\n  case 'next-to-last':\n    return new NextToLast(param);\n  default:\n    throw new Error(`unkown sharding function: ${ name }`);\n  }\n}\nconst readShardFun = async (path, store) => {\n  const key$1 = new key.Key(path).child(new key.Key(SHARDING_FN));\n  const get = typeof store.getRaw === 'function' ? store.getRaw.bind(store) : store.get.bind(store);\n  const res = await get(key$1);\n  return parseShardFun(new TextDecoder().decode(res || '').trim());\n};\n\nexports.readme = shardReadme;\nexports.NextToLast = NextToLast;\nexports.PREFIX = PREFIX;\nexports.Prefix = Prefix;\nexports.README_FN = README_FN;\nexports.SHARDING_FN = SHARDING_FN;\nexports.ShardBase = ShardBase;\nexports.Suffix = Suffix;\nexports.parseShardFun = parseShardFun;\nexports.readShardFun = readShardFun;\n"]},"metadata":{},"sourceType":"script"}