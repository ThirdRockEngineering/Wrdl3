{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar index$3 = require('./want-manager/index.js');\n\nvar network = require('./network.js');\n\nvar index$2 = require('./decision-engine/index.js');\n\nvar notifications = require('./notifications.js');\n\nvar index = require('./utils/index.js');\n\nvar index$1 = require('./stats/index.js');\n\nvar anySignal = require('any-signal');\n\nvar base = require('blockstore-core/base');\n\nvar cid = require('multiformats/cid');\n\nconst defaultOptions = {\n  statsEnabled: false,\n  statsComputeThrottleTimeout: 1000,\n  statsComputeThrottleMaxQueueSize: 1000\n};\nconst statsKeys = ['blocksReceived', 'dataReceived', 'dupBlksReceived', 'dupDataReceived', 'blocksSent', 'dataSent', 'providesBufferLength', 'wantListLength', 'peerCount'];\n\nclass Bitswap extends base.BaseBlockstore {\n  constructor(libp2p, blockstore) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    this._libp2p = libp2p;\n    this._log = index.logger(this.peerId);\n    this._options = Object.assign({}, defaultOptions, options);\n    this._stats = new index$1.Stats(libp2p, statsKeys, {\n      enabled: this._options.statsEnabled,\n      computeThrottleTimeout: this._options.statsComputeThrottleTimeout,\n      computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize\n    });\n    this.network = new network.Network(libp2p, this, this._stats, {\n      hashLoader: options.hashLoader\n    });\n    this.blockstore = blockstore;\n    this.engine = new index$2.DecisionEngine(this.peerId, blockstore, this.network, this._stats, libp2p);\n    this.wm = new index$3.WantManager(this.peerId, this.network, this._stats, libp2p);\n    this.notifications = new notifications.Notifications(this.peerId);\n    this.started = false;\n  }\n\n  isStarted() {\n    return this.started;\n  }\n\n  get peerId() {\n    return this._libp2p.peerId;\n  }\n\n  async _receiveMessage(peerId, incoming) {\n    try {\n      await this.engine.messageReceived(peerId, incoming);\n    } catch (err) {\n      this._log('failed to receive message', incoming);\n    }\n\n    if (incoming.blocks.size === 0) {\n      return;\n    }\n\n    const received = [];\n\n    for (const [cidStr, data] of incoming.blocks.entries()) {\n      const cid$1 = cid.CID.parse(cidStr);\n      received.push({\n        wasWanted: this.wm.wantlist.contains(cid$1),\n        cid: cid$1,\n        data\n      });\n    }\n\n    this.wm.cancelWants(received.filter(_ref => {\n      let {\n        wasWanted\n      } = _ref;\n      return wasWanted;\n    }).map(_ref2 => {\n      let {\n        cid\n      } = _ref2;\n      return cid;\n    }));\n    await Promise.all(received.map(_ref3 => {\n      let {\n        cid,\n        wasWanted,\n        data\n      } = _ref3;\n      return this._handleReceivedBlock(peerId, cid, data, wasWanted);\n    }));\n  }\n\n  async _handleReceivedBlock(peerId, cid, data, wasWanted) {\n    this._log('received block');\n\n    const has = await this.blockstore.has(cid);\n\n    this._updateReceiveCounters(peerId.toB58String(), cid, data, has);\n\n    if (!wasWanted) {\n      return;\n    }\n\n    await this.put(cid, data);\n  }\n\n  _updateReceiveCounters(peerIdStr, cid, data, exists) {\n    this._stats.push(peerIdStr, 'blocksReceived', 1);\n\n    this._stats.push(peerIdStr, 'dataReceived', data.length);\n\n    if (exists) {\n      this._stats.push(peerIdStr, 'dupBlksReceived', 1);\n\n      this._stats.push(peerIdStr, 'dupDataReceived', data.length);\n    }\n  }\n\n  _receiveError(err) {\n    this._log.error('ReceiveError: %s', err.message);\n  }\n\n  _onPeerConnected(peerId) {\n    this.wm.connected(peerId);\n  }\n\n  _onPeerDisconnected(peerId) {\n    this.wm.disconnected(peerId);\n    this.engine.peerDisconnected(peerId);\n\n    this._stats.disconnected(peerId);\n  }\n\n  enableStats() {\n    this._stats.enable();\n  }\n\n  disableStats() {\n    this._stats.disable();\n  }\n\n  wantlistForPeer(peerId, _options) {\n    return this.engine.wantlistForPeer(peerId);\n  }\n\n  ledgerForPeer(peerId) {\n    return this.engine.ledgerForPeer(peerId);\n  }\n\n  async get(cid) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    const fetchFromNetwork = (cid, options) => {\n      this.wm.wantBlocks([cid], options);\n      return this.notifications.wantBlock(cid, options);\n    };\n\n    let promptedNetwork = false;\n\n    const loadOrFetchFromNetwork = async (cid, options) => {\n      try {\n        const block = await this.blockstore.get(cid, options);\n        return block;\n      } catch (err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err;\n        }\n\n        if (!promptedNetwork) {\n          promptedNetwork = true;\n          this.network.findAndConnect(cid).catch(err => this._log.error(err));\n        }\n\n        return fetchFromNetwork(cid, options);\n      }\n    };\n\n    const controller = new AbortController();\n    const signal = options.signal ? anySignal.anySignal([options.signal, controller.signal]) : controller.signal;\n    const block = await Promise.race([this.notifications.wantBlock(cid, {\n      signal\n    }), loadOrFetchFromNetwork(cid, {\n      signal\n    })]);\n    controller.abort();\n    return block;\n  }\n\n  async *getMany(cids) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for await (const cid of cids) {\n      yield this.get(cid, options);\n    }\n  }\n\n  unwant(cids) {\n    const cidsArray = Array.isArray(cids) ? cids : [cids];\n    this.wm.unwantBlocks(cidsArray);\n    cidsArray.forEach(cid => this.notifications.unwantBlock(cid));\n  }\n\n  cancelWants(cids) {\n    this.wm.cancelWants(Array.isArray(cids) ? cids : [cids]);\n  }\n\n  async put(cid, block, _options) {\n    await this.blockstore.put(cid, block);\n\n    this._sendHaveBlockNotifications(cid, block);\n  }\n\n  async *putMany(source, options) {\n    for await (const {\n      key,\n      value\n    } of this.blockstore.putMany(source, options)) {\n      this._sendHaveBlockNotifications(key, value);\n\n      yield {\n        key,\n        value\n      };\n    }\n  }\n\n  _sendHaveBlockNotifications(cid, data) {\n    this.notifications.hasBlock(cid, data);\n    this.engine.receivedBlocks([{\n      cid,\n      data\n    }]);\n    this.network.provide(cid).catch(err => {\n      this._log.error('Failed to provide: %s', err.message);\n    });\n  }\n\n  getWantlist() {\n    return this.wm.wantlist.entries();\n  }\n\n  peers() {\n    return this.engine.peers();\n  }\n\n  stat() {\n    return this._stats;\n  }\n\n  async start() {\n    this.wm.start();\n    await this.network.start();\n    this.engine.start();\n    this.started = true;\n  }\n\n  async stop() {\n    this._stats.stop();\n\n    this.wm.stop();\n    await this.network.stop();\n    this.engine.stop();\n    this.started = false;\n  }\n\n  unwrap() {\n    return this.blockstore;\n  }\n\n}\n\nexports.Bitswap = Bitswap;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-bitswap/cjs/src/bitswap.js"],"names":["Object","defineProperty","exports","value","index$3","require","network","index$2","notifications","index","index$1","anySignal","base","cid","defaultOptions","statsEnabled","statsComputeThrottleTimeout","statsComputeThrottleMaxQueueSize","statsKeys","Bitswap","BaseBlockstore","constructor","libp2p","blockstore","options","_libp2p","_log","logger","peerId","_options","assign","_stats","Stats","enabled","computeThrottleTimeout","computeThrottleMaxQueueSize","Network","hashLoader","engine","DecisionEngine","wm","WantManager","Notifications","started","isStarted","_receiveMessage","incoming","messageReceived","err","blocks","size","received","cidStr","data","entries","cid$1","CID","parse","push","wasWanted","wantlist","contains","cancelWants","filter","map","Promise","all","_handleReceivedBlock","has","_updateReceiveCounters","toB58String","put","peerIdStr","exists","length","_receiveError","error","message","_onPeerConnected","connected","_onPeerDisconnected","disconnected","peerDisconnected","enableStats","enable","disableStats","disable","wantlistForPeer","ledgerForPeer","get","fetchFromNetwork","wantBlocks","wantBlock","promptedNetwork","loadOrFetchFromNetwork","block","code","findAndConnect","catch","controller","AbortController","signal","race","abort","getMany","cids","unwant","cidsArray","Array","isArray","unwantBlocks","forEach","unwantBlock","_sendHaveBlockNotifications","putMany","source","key","hasBlock","receivedBlocks","provide","getWantlist","peers","stat","start","stop","unwrap"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar index$3 = require('./want-manager/index.js');\nvar network = require('./network.js');\nvar index$2 = require('./decision-engine/index.js');\nvar notifications = require('./notifications.js');\nvar index = require('./utils/index.js');\nvar index$1 = require('./stats/index.js');\nvar anySignal = require('any-signal');\nvar base = require('blockstore-core/base');\nvar cid = require('multiformats/cid');\n\nconst defaultOptions = {\n  statsEnabled: false,\n  statsComputeThrottleTimeout: 1000,\n  statsComputeThrottleMaxQueueSize: 1000\n};\nconst statsKeys = [\n  'blocksReceived',\n  'dataReceived',\n  'dupBlksReceived',\n  'dupDataReceived',\n  'blocksSent',\n  'dataSent',\n  'providesBufferLength',\n  'wantListLength',\n  'peerCount'\n];\nclass Bitswap extends base.BaseBlockstore {\n  constructor(libp2p, blockstore, options = {}) {\n    super();\n    this._libp2p = libp2p;\n    this._log = index.logger(this.peerId);\n    this._options = Object.assign({}, defaultOptions, options);\n    this._stats = new index$1.Stats(libp2p, statsKeys, {\n      enabled: this._options.statsEnabled,\n      computeThrottleTimeout: this._options.statsComputeThrottleTimeout,\n      computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize\n    });\n    this.network = new network.Network(libp2p, this, this._stats, { hashLoader: options.hashLoader });\n    this.blockstore = blockstore;\n    this.engine = new index$2.DecisionEngine(this.peerId, blockstore, this.network, this._stats, libp2p);\n    this.wm = new index$3.WantManager(this.peerId, this.network, this._stats, libp2p);\n    this.notifications = new notifications.Notifications(this.peerId);\n    this.started = false;\n  }\n  isStarted() {\n    return this.started;\n  }\n  get peerId() {\n    return this._libp2p.peerId;\n  }\n  async _receiveMessage(peerId, incoming) {\n    try {\n      await this.engine.messageReceived(peerId, incoming);\n    } catch (err) {\n      this._log('failed to receive message', incoming);\n    }\n    if (incoming.blocks.size === 0) {\n      return;\n    }\n    const received = [];\n    for (const [cidStr, data] of incoming.blocks.entries()) {\n      const cid$1 = cid.CID.parse(cidStr);\n      received.push({\n        wasWanted: this.wm.wantlist.contains(cid$1),\n        cid: cid$1,\n        data\n      });\n    }\n    this.wm.cancelWants(received.filter(({wasWanted}) => wasWanted).map(({cid}) => cid));\n    await Promise.all(received.map(({cid, wasWanted, data}) => this._handleReceivedBlock(peerId, cid, data, wasWanted)));\n  }\n  async _handleReceivedBlock(peerId, cid, data, wasWanted) {\n    this._log('received block');\n    const has = await this.blockstore.has(cid);\n    this._updateReceiveCounters(peerId.toB58String(), cid, data, has);\n    if (!wasWanted) {\n      return;\n    }\n    await this.put(cid, data);\n  }\n  _updateReceiveCounters(peerIdStr, cid, data, exists) {\n    this._stats.push(peerIdStr, 'blocksReceived', 1);\n    this._stats.push(peerIdStr, 'dataReceived', data.length);\n    if (exists) {\n      this._stats.push(peerIdStr, 'dupBlksReceived', 1);\n      this._stats.push(peerIdStr, 'dupDataReceived', data.length);\n    }\n  }\n  _receiveError(err) {\n    this._log.error('ReceiveError: %s', err.message);\n  }\n  _onPeerConnected(peerId) {\n    this.wm.connected(peerId);\n  }\n  _onPeerDisconnected(peerId) {\n    this.wm.disconnected(peerId);\n    this.engine.peerDisconnected(peerId);\n    this._stats.disconnected(peerId);\n  }\n  enableStats() {\n    this._stats.enable();\n  }\n  disableStats() {\n    this._stats.disable();\n  }\n  wantlistForPeer(peerId, _options) {\n    return this.engine.wantlistForPeer(peerId);\n  }\n  ledgerForPeer(peerId) {\n    return this.engine.ledgerForPeer(peerId);\n  }\n  async get(cid, options = {}) {\n    const fetchFromNetwork = (cid, options) => {\n      this.wm.wantBlocks([cid], options);\n      return this.notifications.wantBlock(cid, options);\n    };\n    let promptedNetwork = false;\n    const loadOrFetchFromNetwork = async (cid, options) => {\n      try {\n        const block = await this.blockstore.get(cid, options);\n        return block;\n      } catch (err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err;\n        }\n        if (!promptedNetwork) {\n          promptedNetwork = true;\n          this.network.findAndConnect(cid).catch(err => this._log.error(err));\n        }\n        return fetchFromNetwork(cid, options);\n      }\n    };\n    const controller = new AbortController();\n    const signal = options.signal ? anySignal.anySignal([\n      options.signal,\n      controller.signal\n    ]) : controller.signal;\n    const block = await Promise.race([\n      this.notifications.wantBlock(cid, { signal }),\n      loadOrFetchFromNetwork(cid, { signal })\n    ]);\n    controller.abort();\n    return block;\n  }\n  async *getMany(cids, options = {}) {\n    for await (const cid of cids) {\n      yield this.get(cid, options);\n    }\n  }\n  unwant(cids) {\n    const cidsArray = Array.isArray(cids) ? cids : [cids];\n    this.wm.unwantBlocks(cidsArray);\n    cidsArray.forEach(cid => this.notifications.unwantBlock(cid));\n  }\n  cancelWants(cids) {\n    this.wm.cancelWants(Array.isArray(cids) ? cids : [cids]);\n  }\n  async put(cid, block, _options) {\n    await this.blockstore.put(cid, block);\n    this._sendHaveBlockNotifications(cid, block);\n  }\n  async *putMany(source, options) {\n    for await (const {key, value} of this.blockstore.putMany(source, options)) {\n      this._sendHaveBlockNotifications(key, value);\n      yield {\n        key,\n        value\n      };\n    }\n  }\n  _sendHaveBlockNotifications(cid, data) {\n    this.notifications.hasBlock(cid, data);\n    this.engine.receivedBlocks([{\n        cid,\n        data\n      }]);\n    this.network.provide(cid).catch(err => {\n      this._log.error('Failed to provide: %s', err.message);\n    });\n  }\n  getWantlist() {\n    return this.wm.wantlist.entries();\n  }\n  peers() {\n    return this.engine.peers();\n  }\n  stat() {\n    return this._stats;\n  }\n  async start() {\n    this.wm.start();\n    await this.network.start();\n    this.engine.start();\n    this.started = true;\n  }\n  async stop() {\n    this._stats.stop();\n    this.wm.stop();\n    await this.network.stop();\n    this.engine.stop();\n    this.started = false;\n  }\n  unwrap() {\n    return this.blockstore;\n  }\n}\n\nexports.Bitswap = Bitswap;\n"]},"metadata":{},"sourceType":"script"}