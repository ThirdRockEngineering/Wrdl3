{"ast":null,"code":"'use strict';\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst errcode = require('err-code');\n\nconst utils = require('../../utils');\n\nconst log = utils.logger('libp2p:kad-dht:rpc:handlers:add-provider');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../../message').Message} Message\n * @typedef {import('../types').DHTMessageHandler} DHTMessageHandler\n */\n\n/**\n * @implements {DHTMessageHandler}\n */\n\nclass AddProviderHandler {\n  /**\n   * @param {object} params\n   * @param {PeerId} params.peerId\n   * @param {import('../../providers').Providers} params.providers\n   * @param {import('libp2p/src/peer-store/types').PeerStore} params.peerStore\n   */\n  constructor(_ref) {\n    let {\n      peerId,\n      providers,\n      peerStore\n    } = _ref;\n    this._peerId = peerId;\n    this._providers = providers;\n    this._peerStore = peerStore;\n  }\n  /**\n   * @param {PeerId} peerId\n   * @param {Message} msg\n   */\n\n\n  async handle(peerId, msg) {\n    log('start');\n\n    if (!msg.key || msg.key.length === 0) {\n      throw errcode(new Error('Missing key'), 'ERR_MISSING_KEY');\n    }\n    /** @type {CID} */\n\n\n    let cid;\n\n    try {\n      // this is actually just the multihash, not the whole CID\n      cid = CID.decode(msg.key);\n    } catch (\n    /** @type {any} */\n    err) {\n      const errMsg = `Invalid CID: ${err.message}`;\n      throw errcode(new Error(errMsg), 'ERR_INVALID_CID');\n    }\n\n    if (!msg.providerPeers || !msg.providerPeers.length) {\n      log.error('no providers found in message');\n    }\n\n    await Promise.all(msg.providerPeers.map(async pi => {\n      // Ignore providers not from the originator\n      if (!pi.id.equals(peerId)) {\n        log('invalid provider peer %p from %p', pi.id, peerId);\n        return;\n      }\n\n      if (pi.multiaddrs.length < 1) {\n        log('no valid addresses for provider %p. Ignore', peerId);\n        return;\n      }\n\n      log('received provider %p for %s (addrs %s)', peerId, cid, pi.multiaddrs.map(m => m.toString()));\n\n      if (!this._peerId.equals(pi.id)) {\n        // Add known address to peer store\n        await this._peerStore.addressBook.add(pi.id, pi.multiaddrs);\n        await this._providers.addProvider(cid, pi.id);\n      }\n    })); // typescript requires a return value\n\n    return undefined;\n  }\n\n}\n\nmodule.exports.AddProviderHandler = AddProviderHandler;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p-kad-dht/src/rpc/handlers/add-provider.js"],"names":["CID","require","errcode","utils","log","logger","AddProviderHandler","constructor","peerId","providers","peerStore","_peerId","_providers","_peerStore","handle","msg","key","length","Error","cid","decode","err","errMsg","message","providerPeers","error","Promise","all","map","pi","id","equals","multiaddrs","m","toString","addressBook","add","addProvider","undefined","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { CID } = require('multiformats/cid')\nconst errcode = require('err-code')\nconst utils = require('../../utils')\nconst log = utils.logger('libp2p:kad-dht:rpc:handlers:add-provider')\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../../message').Message} Message\n * @typedef {import('../types').DHTMessageHandler} DHTMessageHandler\n */\n\n/**\n * @implements {DHTMessageHandler}\n */\nclass AddProviderHandler {\n  /**\n   * @param {object} params\n   * @param {PeerId} params.peerId\n   * @param {import('../../providers').Providers} params.providers\n   * @param {import('libp2p/src/peer-store/types').PeerStore} params.peerStore\n   */\n  constructor ({ peerId, providers, peerStore }) {\n    this._peerId = peerId\n    this._providers = providers\n    this._peerStore = peerStore\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {Message} msg\n   */\n  async handle (peerId, msg) {\n    log('start')\n\n    if (!msg.key || msg.key.length === 0) {\n      throw errcode(new Error('Missing key'), 'ERR_MISSING_KEY')\n    }\n\n    /** @type {CID} */\n    let cid\n    try {\n      // this is actually just the multihash, not the whole CID\n      cid = CID.decode(msg.key)\n    } catch (/** @type {any} */ err) {\n      const errMsg = `Invalid CID: ${err.message}`\n      throw errcode(new Error(errMsg), 'ERR_INVALID_CID')\n    }\n\n    if (!msg.providerPeers || !msg.providerPeers.length) {\n      log.error('no providers found in message')\n    }\n\n    await Promise.all(\n      msg.providerPeers.map(async (pi) => {\n        // Ignore providers not from the originator\n        if (!pi.id.equals(peerId)) {\n          log('invalid provider peer %p from %p', pi.id, peerId)\n          return\n        }\n\n        if (pi.multiaddrs.length < 1) {\n          log('no valid addresses for provider %p. Ignore', peerId)\n          return\n        }\n\n        log('received provider %p for %s (addrs %s)', peerId, cid, pi.multiaddrs.map((m) => m.toString()))\n\n        if (!this._peerId.equals(pi.id)) {\n          // Add known address to peer store\n          await this._peerStore.addressBook.add(pi.id, pi.multiaddrs)\n          await this._providers.addProvider(cid, pi.id)\n        }\n      })\n    )\n\n    // typescript requires a return value\n    return undefined\n  }\n}\n\nmodule.exports.AddProviderHandler = AddProviderHandler\n"]},"metadata":{},"sourceType":"script"}