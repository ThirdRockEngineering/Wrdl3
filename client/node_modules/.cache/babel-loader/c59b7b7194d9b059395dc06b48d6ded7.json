{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar cid = require('multiformats/cid');\n\nvar errCode = require('err-code');\n\nvar debug = require('debug');\n\nvar first = require('it-first');\n\nvar block = require('multiformats/block');\n\nvar cborg = require('cborg');\n\nvar dagPb = require('@ipld/dag-pb');\n\nvar blockstore = require('./utils/blockstore.js');\n\nvar walkDag = require('./utils/walk-dag.js');\n\nvar pinTypes = require('./pin-types.js');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\n\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\n\nvar first__default = /*#__PURE__*/_interopDefaultLegacy(first);\n\nvar cborg__namespace = /*#__PURE__*/_interopNamespace(cborg);\n\nvar dagPb__namespace = /*#__PURE__*/_interopNamespace(dagPb);\n\nfunction invalidPinTypeErr(type) {\n  const errMsg = `Invalid type '${type}', must be one of {direct, indirect, recursive, all}`;\n  return errCode__default[\"default\"](new Error(errMsg), 'ERR_INVALID_PIN_TYPE');\n}\n\nclass PinManager {\n  constructor(_ref) {\n    let {\n      pinstore,\n      blockstore,\n      loadCodec\n    } = _ref;\n    this.pinstore = pinstore;\n    this.blockstore = blockstore;\n    this.loadCodec = loadCodec;\n    this.log = debug__default[\"default\"]('ipfs:repo:pin');\n    this.directPins = new Set();\n    this.recursivePins = new Set();\n  }\n\n  async pinDirectly(cid) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    await this.blockstore.get(cid, options);\n    const pin = {\n      depth: 0\n    };\n\n    if (cid.version !== 0) {\n      pin.version = cid.version;\n    }\n\n    if (cid.code !== dagPb__namespace.code) {\n      pin.codec = cid.code;\n    }\n\n    if (options.metadata) {\n      pin.metadata = options.metadata;\n    }\n\n    return this.pinstore.put(blockstore.cidToKey(cid), cborg__namespace.encode(pin));\n  }\n\n  unpin(cid, options) {\n    return this.pinstore.delete(blockstore.cidToKey(cid), options);\n  }\n\n  async pinRecursively(cid) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    await this.fetchCompleteDag(cid, options);\n    const pin = {\n      depth: Infinity\n    };\n\n    if (cid.version !== 0) {\n      pin.version = cid.version;\n    }\n\n    if (cid.code !== dagPb__namespace.code) {\n      pin.codec = cid.code;\n    }\n\n    if (options.metadata) {\n      pin.metadata = options.metadata;\n    }\n\n    await this.pinstore.put(blockstore.cidToKey(cid), cborg__namespace.encode(pin));\n  }\n\n  async *directKeys(options) {\n    for await (const entry of this.pinstore.query({\n      filters: [entry => {\n        const pin = cborg__namespace.decode(entry.value);\n        return pin.depth === 0;\n      }]\n    })) {\n      const pin = cborg__namespace.decode(entry.value);\n      const version = pin.version || 0;\n      const codec = pin.codec != null ? pin.codec : dagPb__namespace.code;\n      const multihash = blockstore.keyToMultihash(entry.key);\n      yield {\n        cid: cid.CID.create(version, codec, multihash),\n        metadata: pin.metadata\n      };\n    }\n  }\n\n  async *recursiveKeys(options) {\n    for await (const entry of this.pinstore.query({\n      filters: [entry => {\n        const pin = cborg__namespace.decode(entry.value);\n        return pin.depth === Infinity;\n      }]\n    })) {\n      const pin = cborg__namespace.decode(entry.value);\n      const version = pin.version || 0;\n      const codec = pin.codec != null ? pin.codec : dagPb__namespace.code;\n      const multihash = blockstore.keyToMultihash(entry.key);\n      yield {\n        cid: cid.CID.create(version, codec, multihash),\n        metadata: pin.metadata\n      };\n    }\n  }\n\n  async *indirectKeys(options) {\n    for await (const {\n      cid\n    } of this.recursiveKeys()) {\n      for await (const childCid of walkDag.walkDag(cid, this.blockstore, this.loadCodec, options)) {\n        const types = [pinTypes.PinTypes.recursive];\n        const result = await this.isPinnedWithType(childCid, types);\n\n        if (result.pinned) {\n          continue;\n        }\n\n        yield childCid;\n      }\n    }\n  }\n\n  async isPinnedWithType(cid, types, options) {\n    if (!Array.isArray(types)) {\n      types = [types];\n    }\n\n    const all = types.includes(pinTypes.PinTypes.all);\n    const direct = types.includes(pinTypes.PinTypes.direct);\n    const recursive = types.includes(pinTypes.PinTypes.recursive);\n    const indirect = types.includes(pinTypes.PinTypes.indirect);\n\n    if (recursive || direct || all) {\n      const result = await first__default[\"default\"](this.pinstore.query({\n        prefix: blockstore.cidToKey(cid).toString(),\n        filters: [entry => {\n          if (all) {\n            return true;\n          }\n\n          const pin = cborg__namespace.decode(entry.value);\n          return types.includes(pin.depth === 0 ? pinTypes.PinTypes.direct : pinTypes.PinTypes.recursive);\n        }],\n        limit: 1\n      }));\n\n      if (result) {\n        const pin = cborg__namespace.decode(result.value);\n        return {\n          cid,\n          pinned: true,\n          reason: pin.depth === 0 ? pinTypes.PinTypes.direct : pinTypes.PinTypes.recursive,\n          metadata: pin.metadata\n        };\n      }\n    }\n\n    const self = this;\n\n    async function* findChild(key, source) {\n      for await (const {\n        cid: parentCid\n      } of source) {\n        for await (const childCid of walkDag.walkDag(parentCid, self.blockstore, self.loadCodec)) {\n          if (childCid.equals(key)) {\n            yield parentCid;\n            return;\n          }\n        }\n      }\n    }\n\n    if (all || indirect) {\n      const parentCid = await first__default[\"default\"](findChild(cid, this.recursiveKeys()));\n\n      if (parentCid) {\n        return {\n          cid,\n          pinned: true,\n          reason: pinTypes.PinTypes.indirect,\n          parent: parentCid\n        };\n      }\n    }\n\n    return {\n      cid,\n      pinned: false\n    };\n  }\n\n  async fetchCompleteDag(cid, options) {\n    const seen = new Set();\n\n    const walkDag = async (cid, options) => {\n      if (seen.has(cid.toString())) {\n        return;\n      }\n\n      seen.add(cid.toString());\n      const bytes = await this.blockstore.get(cid, options);\n      const codec = await this.loadCodec(cid.code);\n      const block$1 = block.createUnsafe({\n        bytes,\n        cid,\n        codec\n      });\n      await Promise.all([...block$1.links()].map(_ref2 => {\n        let [, childCid] = _ref2;\n        return walkDag(childCid, options);\n      }));\n    };\n\n    await walkDag(cid, options);\n  }\n\n  static checkPinType(type) {\n    if (typeof type !== 'string' || !Object.keys(pinTypes.PinTypes).includes(type)) {\n      throw invalidPinTypeErr(type);\n    }\n\n    return true;\n  }\n\n}\n\nexports.PinManager = PinManager;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-repo/cjs/src/pin-manager.js"],"names":["Object","defineProperty","exports","value","cid","require","errCode","debug","first","block","cborg","dagPb","blockstore","walkDag","pinTypes","_interopDefaultLegacy","e","_interopNamespace","__esModule","n","create","keys","forEach","k","d","getOwnPropertyDescriptor","get","enumerable","freeze","errCode__default","debug__default","first__default","cborg__namespace","dagPb__namespace","invalidPinTypeErr","type","errMsg","Error","PinManager","constructor","pinstore","loadCodec","log","directPins","Set","recursivePins","pinDirectly","options","pin","depth","version","code","codec","metadata","put","cidToKey","encode","unpin","delete","pinRecursively","fetchCompleteDag","Infinity","directKeys","entry","query","filters","decode","multihash","keyToMultihash","key","CID","recursiveKeys","indirectKeys","childCid","types","PinTypes","recursive","result","isPinnedWithType","pinned","Array","isArray","all","includes","direct","indirect","prefix","toString","limit","reason","self","findChild","source","parentCid","equals","parent","seen","has","add","bytes","block$1","createUnsafe","Promise","links","map","checkPinType"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar cid = require('multiformats/cid');\nvar errCode = require('err-code');\nvar debug = require('debug');\nvar first = require('it-first');\nvar block = require('multiformats/block');\nvar cborg = require('cborg');\nvar dagPb = require('@ipld/dag-pb');\nvar blockstore = require('./utils/blockstore.js');\nvar walkDag = require('./utils/walk-dag.js');\nvar pinTypes = require('./pin-types.js');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\nvar first__default = /*#__PURE__*/_interopDefaultLegacy(first);\nvar cborg__namespace = /*#__PURE__*/_interopNamespace(cborg);\nvar dagPb__namespace = /*#__PURE__*/_interopNamespace(dagPb);\n\nfunction invalidPinTypeErr(type) {\n  const errMsg = `Invalid type '${ type }', must be one of {direct, indirect, recursive, all}`;\n  return errCode__default[\"default\"](new Error(errMsg), 'ERR_INVALID_PIN_TYPE');\n}\nclass PinManager {\n  constructor({pinstore, blockstore, loadCodec}) {\n    this.pinstore = pinstore;\n    this.blockstore = blockstore;\n    this.loadCodec = loadCodec;\n    this.log = debug__default[\"default\"]('ipfs:repo:pin');\n    this.directPins = new Set();\n    this.recursivePins = new Set();\n  }\n  async pinDirectly(cid, options = {}) {\n    await this.blockstore.get(cid, options);\n    const pin = { depth: 0 };\n    if (cid.version !== 0) {\n      pin.version = cid.version;\n    }\n    if (cid.code !== dagPb__namespace.code) {\n      pin.codec = cid.code;\n    }\n    if (options.metadata) {\n      pin.metadata = options.metadata;\n    }\n    return this.pinstore.put(blockstore.cidToKey(cid), cborg__namespace.encode(pin));\n  }\n  unpin(cid, options) {\n    return this.pinstore.delete(blockstore.cidToKey(cid), options);\n  }\n  async pinRecursively(cid, options = {}) {\n    await this.fetchCompleteDag(cid, options);\n    const pin = { depth: Infinity };\n    if (cid.version !== 0) {\n      pin.version = cid.version;\n    }\n    if (cid.code !== dagPb__namespace.code) {\n      pin.codec = cid.code;\n    }\n    if (options.metadata) {\n      pin.metadata = options.metadata;\n    }\n    await this.pinstore.put(blockstore.cidToKey(cid), cborg__namespace.encode(pin));\n  }\n  async *directKeys(options) {\n    for await (const entry of this.pinstore.query({\n        filters: [entry => {\n            const pin = cborg__namespace.decode(entry.value);\n            return pin.depth === 0;\n          }]\n      })) {\n      const pin = cborg__namespace.decode(entry.value);\n      const version = pin.version || 0;\n      const codec = pin.codec != null ? pin.codec : dagPb__namespace.code;\n      const multihash = blockstore.keyToMultihash(entry.key);\n      yield {\n        cid: cid.CID.create(version, codec, multihash),\n        metadata: pin.metadata\n      };\n    }\n  }\n  async *recursiveKeys(options) {\n    for await (const entry of this.pinstore.query({\n        filters: [entry => {\n            const pin = cborg__namespace.decode(entry.value);\n            return pin.depth === Infinity;\n          }]\n      })) {\n      const pin = cborg__namespace.decode(entry.value);\n      const version = pin.version || 0;\n      const codec = pin.codec != null ? pin.codec : dagPb__namespace.code;\n      const multihash = blockstore.keyToMultihash(entry.key);\n      yield {\n        cid: cid.CID.create(version, codec, multihash),\n        metadata: pin.metadata\n      };\n    }\n  }\n  async *indirectKeys(options) {\n    for await (const {cid} of this.recursiveKeys()) {\n      for await (const childCid of walkDag.walkDag(cid, this.blockstore, this.loadCodec, options)) {\n        const types = [pinTypes.PinTypes.recursive];\n        const result = await this.isPinnedWithType(childCid, types);\n        if (result.pinned) {\n          continue;\n        }\n        yield childCid;\n      }\n    }\n  }\n  async isPinnedWithType(cid, types, options) {\n    if (!Array.isArray(types)) {\n      types = [types];\n    }\n    const all = types.includes(pinTypes.PinTypes.all);\n    const direct = types.includes(pinTypes.PinTypes.direct);\n    const recursive = types.includes(pinTypes.PinTypes.recursive);\n    const indirect = types.includes(pinTypes.PinTypes.indirect);\n    if (recursive || direct || all) {\n      const result = await first__default[\"default\"](this.pinstore.query({\n        prefix: blockstore.cidToKey(cid).toString(),\n        filters: [entry => {\n            if (all) {\n              return true;\n            }\n            const pin = cborg__namespace.decode(entry.value);\n            return types.includes(pin.depth === 0 ? pinTypes.PinTypes.direct : pinTypes.PinTypes.recursive);\n          }],\n        limit: 1\n      }));\n      if (result) {\n        const pin = cborg__namespace.decode(result.value);\n        return {\n          cid,\n          pinned: true,\n          reason: pin.depth === 0 ? pinTypes.PinTypes.direct : pinTypes.PinTypes.recursive,\n          metadata: pin.metadata\n        };\n      }\n    }\n    const self = this;\n    async function* findChild(key, source) {\n      for await (const {cid: parentCid} of source) {\n        for await (const childCid of walkDag.walkDag(parentCid, self.blockstore, self.loadCodec)) {\n          if (childCid.equals(key)) {\n            yield parentCid;\n            return;\n          }\n        }\n      }\n    }\n    if (all || indirect) {\n      const parentCid = await first__default[\"default\"](findChild(cid, this.recursiveKeys()));\n      if (parentCid) {\n        return {\n          cid,\n          pinned: true,\n          reason: pinTypes.PinTypes.indirect,\n          parent: parentCid\n        };\n      }\n    }\n    return {\n      cid,\n      pinned: false\n    };\n  }\n  async fetchCompleteDag(cid, options) {\n    const seen = new Set();\n    const walkDag = async (cid, options) => {\n      if (seen.has(cid.toString())) {\n        return;\n      }\n      seen.add(cid.toString());\n      const bytes = await this.blockstore.get(cid, options);\n      const codec = await this.loadCodec(cid.code);\n      const block$1 = block.createUnsafe({\n        bytes,\n        cid,\n        codec\n      });\n      await Promise.all([...block$1.links()].map(([, childCid]) => walkDag(childCid, options)));\n    };\n    await walkDag(cid, options);\n  }\n  static checkPinType(type) {\n    if (typeof type !== 'string' || !Object.keys(pinTypes.PinTypes).includes(type)) {\n      throw invalidPinTypeErr(type);\n    }\n    return true;\n  }\n}\n\nexports.PinManager = PinManager;\n"]},"metadata":{},"sourceType":"script"}