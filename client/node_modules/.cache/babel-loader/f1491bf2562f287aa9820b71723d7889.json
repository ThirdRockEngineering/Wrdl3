{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar mkdir = require('./mkdir.js');\n\nvar stat = require('./stat.js');\n\nvar debug = require('debug');\n\nvar errCode = require('err-code');\n\nvar updateTree = require('./utils/update-tree.js');\n\nvar updateMfsRoot = require('./utils/update-mfs-root.js');\n\nvar addLink = require('./utils/add-link.js');\n\nvar toMfsPath = require('./utils/to-mfs-path.js');\n\nvar mergeOpts = require('merge-options');\n\nvar toTrail = require('./utils/to-trail.js');\n\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\n\nvar mergeOpts__default = /*#__PURE__*/_interopDefaultLegacy(mergeOpts);\n\nconst mergeOptions = mergeOpts__default[\"default\"].bind({\n  ignoreUndefined: true\n});\nconst log = debug__default[\"default\"]('ipfs:mfs:cp');\nconst defaultOptions = {\n  parents: false,\n  flush: true,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000\n};\n\nfunction createCp(context) {\n  async function mfsCp(from, to) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const options = mergeOptions(defaultOptions, opts);\n\n    if (!Array.isArray(from)) {\n      from = [from];\n    }\n\n    const sources = await Promise.all(from.map(path => toMfsPath.toMfsPath(context, path, options)));\n    let destination = await toMfsPath.toMfsPath(context, to, options);\n\n    if (!sources.length || !destination) {\n      throw errCode__default[\"default\"](new Error('Please supply at least one source'), 'ERR_INVALID_PARAMS');\n    }\n\n    const missing = sources.find(source => !source.exists);\n\n    if (missing) {\n      throw errCode__default[\"default\"](new Error(`${missing.path} does not exist`), 'ERR_INVALID_PARAMS');\n    }\n\n    const destinationIsDirectory = isDirectory(destination);\n\n    if (destination.exists) {\n      log('Destination exists');\n\n      if (sources.length === 1 && !destinationIsDirectory) {\n        throw errCode__default[\"default\"](new Error('directory already has entry by that name'), 'ERR_ALREADY_EXISTS');\n      }\n    } else {\n      log('Destination does not exist');\n\n      if (sources.length > 1) {\n        if (!options.parents) {\n          throw errCode__default[\"default\"](new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS');\n        }\n\n        await mkdir.createMkdir(context)(destination.path, options);\n        destination = await toMfsPath.toMfsPath(context, destination.path, options);\n      } else if (destination.parts.length > 1) {\n        const parentFolder = `/${destination.parts.slice(0, -1).join('/')}`;\n\n        try {\n          await stat.createStat(context)(parentFolder, options);\n        } catch (err) {\n          if (err.code !== 'ERR_NOT_FOUND') {\n            throw err;\n          }\n\n          if (!options.parents) {\n            throw errCode__default[\"default\"](new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS');\n          }\n\n          await mkdir.createMkdir(context)(parentFolder, options);\n          destination = await toMfsPath.toMfsPath(context, destination.path, options);\n        }\n      }\n    }\n\n    const destinationPath = isDirectory(destination) ? destination.mfsPath : destination.mfsDirectory;\n    const trail = await toTrail.toTrail(context, destinationPath);\n\n    if (sources.length === 1) {\n      const source = sources.pop();\n\n      if (!source) {\n        throw errCode__default[\"default\"](new Error('could not find source'), 'ERR_INVALID_PARAMS');\n      }\n\n      const destinationName = destinationIsDirectory ? source.name : destination.name;\n      log(`Only one source, copying to destination ${destinationIsDirectory ? 'directory' : 'file'} ${destinationName}`);\n      return copyToFile(context, source, destinationName, trail, options);\n    }\n\n    log('Multiple sources, wrapping in a directory');\n    return copyToDirectory(context, sources, destination, trail, options);\n  }\n\n  return withTimeoutOption.withTimeoutOption(mfsCp);\n}\n\nconst isDirectory = destination => {\n  return destination.unixfs && destination.unixfs.type && destination.unixfs.type.includes('directory');\n};\n\nconst copyToFile = async (context, source, destination, destinationTrail, options) => {\n  let parent = destinationTrail.pop();\n\n  if (!parent) {\n    throw errCode__default[\"default\"](new Error('destination had no parent'), 'ERR_INVALID_PARAMS');\n  }\n\n  parent = await addSourceToParent(context, source, destination, parent, options);\n  destinationTrail.push(parent);\n  const newRootCid = await updateTree.updateTree(context, destinationTrail, options);\n  await updateMfsRoot.updateMfsRoot(context, newRootCid, options);\n};\n\nconst copyToDirectory = async (context, sources, destination, destinationTrail, options) => {\n  for (let i = 0; i < sources.length; i++) {\n    const source = sources[i];\n    destination = await addSourceToParent(context, source, source.name, destination, options);\n  }\n\n  destinationTrail[destinationTrail.length - 1] = destination;\n  const newRootCid = await updateTree.updateTree(context, destinationTrail, options);\n  await updateMfsRoot.updateMfsRoot(context, newRootCid, options);\n};\n\nconst addSourceToParent = async (context, source, childName, parent, options) => {\n  const sourceBlock = await context.repo.blocks.get(source.cid);\n  const {\n    node,\n    cid,\n    size\n  } = await addLink.addLink(context, {\n    parentCid: parent.cid,\n    size: sourceBlock.length,\n    cid: source.cid,\n    name: childName,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush,\n    shardSplitThreshold: options.shardSplitThreshold\n  });\n  parent.node = node;\n  parent.cid = cid;\n  parent.size = size;\n  return parent;\n};\n\nexports.createCp = createCp;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-core/cjs/src/components/files/cp.js"],"names":["Object","defineProperty","exports","value","mkdir","require","stat","debug","errCode","updateTree","updateMfsRoot","addLink","toMfsPath","mergeOpts","toTrail","withTimeoutOption","_interopDefaultLegacy","e","debug__default","errCode__default","mergeOpts__default","mergeOptions","bind","ignoreUndefined","log","defaultOptions","parents","flush","hashAlg","cidVersion","shardSplitThreshold","createCp","context","mfsCp","from","to","opts","options","Array","isArray","sources","Promise","all","map","path","destination","length","Error","missing","find","source","exists","destinationIsDirectory","isDirectory","createMkdir","parts","parentFolder","slice","join","createStat","err","code","destinationPath","mfsPath","mfsDirectory","trail","pop","destinationName","name","copyToFile","copyToDirectory","unixfs","type","includes","destinationTrail","parent","addSourceToParent","push","newRootCid","i","childName","sourceBlock","repo","blocks","get","cid","node","size","parentCid"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar mkdir = require('./mkdir.js');\nvar stat = require('./stat.js');\nvar debug = require('debug');\nvar errCode = require('err-code');\nvar updateTree = require('./utils/update-tree.js');\nvar updateMfsRoot = require('./utils/update-mfs-root.js');\nvar addLink = require('./utils/add-link.js');\nvar toMfsPath = require('./utils/to-mfs-path.js');\nvar mergeOpts = require('merge-options');\nvar toTrail = require('./utils/to-trail.js');\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\nvar mergeOpts__default = /*#__PURE__*/_interopDefaultLegacy(mergeOpts);\n\nconst mergeOptions = mergeOpts__default[\"default\"].bind({ ignoreUndefined: true });\nconst log = debug__default[\"default\"]('ipfs:mfs:cp');\nconst defaultOptions = {\n  parents: false,\n  flush: true,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000\n};\nfunction createCp(context) {\n  async function mfsCp(from, to, opts = {}) {\n    const options = mergeOptions(defaultOptions, opts);\n    if (!Array.isArray(from)) {\n      from = [from];\n    }\n    const sources = await Promise.all(from.map(path => toMfsPath.toMfsPath(context, path, options)));\n    let destination = await toMfsPath.toMfsPath(context, to, options);\n    if (!sources.length || !destination) {\n      throw errCode__default[\"default\"](new Error('Please supply at least one source'), 'ERR_INVALID_PARAMS');\n    }\n    const missing = sources.find(source => !source.exists);\n    if (missing) {\n      throw errCode__default[\"default\"](new Error(`${ missing.path } does not exist`), 'ERR_INVALID_PARAMS');\n    }\n    const destinationIsDirectory = isDirectory(destination);\n    if (destination.exists) {\n      log('Destination exists');\n      if (sources.length === 1 && !destinationIsDirectory) {\n        throw errCode__default[\"default\"](new Error('directory already has entry by that name'), 'ERR_ALREADY_EXISTS');\n      }\n    } else {\n      log('Destination does not exist');\n      if (sources.length > 1) {\n        if (!options.parents) {\n          throw errCode__default[\"default\"](new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS');\n        }\n        await mkdir.createMkdir(context)(destination.path, options);\n        destination = await toMfsPath.toMfsPath(context, destination.path, options);\n      } else if (destination.parts.length > 1) {\n        const parentFolder = `/${ destination.parts.slice(0, -1).join('/') }`;\n        try {\n          await stat.createStat(context)(parentFolder, options);\n        } catch (err) {\n          if (err.code !== 'ERR_NOT_FOUND') {\n            throw err;\n          }\n          if (!options.parents) {\n            throw errCode__default[\"default\"](new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS');\n          }\n          await mkdir.createMkdir(context)(parentFolder, options);\n          destination = await toMfsPath.toMfsPath(context, destination.path, options);\n        }\n      }\n    }\n    const destinationPath = isDirectory(destination) ? destination.mfsPath : destination.mfsDirectory;\n    const trail = await toTrail.toTrail(context, destinationPath);\n    if (sources.length === 1) {\n      const source = sources.pop();\n      if (!source) {\n        throw errCode__default[\"default\"](new Error('could not find source'), 'ERR_INVALID_PARAMS');\n      }\n      const destinationName = destinationIsDirectory ? source.name : destination.name;\n      log(`Only one source, copying to destination ${ destinationIsDirectory ? 'directory' : 'file' } ${ destinationName }`);\n      return copyToFile(context, source, destinationName, trail, options);\n    }\n    log('Multiple sources, wrapping in a directory');\n    return copyToDirectory(context, sources, destination, trail, options);\n  }\n  return withTimeoutOption.withTimeoutOption(mfsCp);\n}\nconst isDirectory = destination => {\n  return destination.unixfs && destination.unixfs.type && destination.unixfs.type.includes('directory');\n};\nconst copyToFile = async (context, source, destination, destinationTrail, options) => {\n  let parent = destinationTrail.pop();\n  if (!parent) {\n    throw errCode__default[\"default\"](new Error('destination had no parent'), 'ERR_INVALID_PARAMS');\n  }\n  parent = await addSourceToParent(context, source, destination, parent, options);\n  destinationTrail.push(parent);\n  const newRootCid = await updateTree.updateTree(context, destinationTrail, options);\n  await updateMfsRoot.updateMfsRoot(context, newRootCid, options);\n};\nconst copyToDirectory = async (context, sources, destination, destinationTrail, options) => {\n  for (let i = 0; i < sources.length; i++) {\n    const source = sources[i];\n    destination = await addSourceToParent(context, source, source.name, destination, options);\n  }\n  destinationTrail[destinationTrail.length - 1] = destination;\n  const newRootCid = await updateTree.updateTree(context, destinationTrail, options);\n  await updateMfsRoot.updateMfsRoot(context, newRootCid, options);\n};\nconst addSourceToParent = async (context, source, childName, parent, options) => {\n  const sourceBlock = await context.repo.blocks.get(source.cid);\n  const {node, cid, size} = await addLink.addLink(context, {\n    parentCid: parent.cid,\n    size: sourceBlock.length,\n    cid: source.cid,\n    name: childName,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush,\n    shardSplitThreshold: options.shardSplitThreshold\n  });\n  parent.node = node;\n  parent.cid = cid;\n  parent.size = size;\n  return parent;\n};\n\nexports.createCp = createCp;\n"]},"metadata":{},"sourceType":"script"}