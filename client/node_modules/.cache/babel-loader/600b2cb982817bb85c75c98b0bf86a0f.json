{"ast":null,"code":"'use strict';\n\nconst cache = require('hashlru'); // @ts-ignore\n\n\nconst varint = require('varint');\n\nconst PeerId = require('peer-id');\n\nconst {\n  Key\n} = require('interface-datastore/key');\n\nconst {\n  default: Queue\n} = require('p-queue');\n\nconst {\n  PROVIDERS_CLEANUP_INTERVAL,\n  PROVIDERS_VALIDITY,\n  PROVIDERS_LRU_CACHE_SIZE,\n  PROVIDER_KEY_PREFIX\n} = require('./constants');\n\nconst utils = require('./utils');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst log = utils.logger('libp2p:kad-dht:providers');\n/**\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('interface-datastore').Datastore} Datastore\n */\n\n/**\n * This class manages known providers.\n * A provider is a peer that we know to have the content for a given CID.\n *\n * Every `cleanupInterval` providers are checked if they\n * are still valid, i.e. younger than the `provideValidity`.\n * If they are not, they are deleted.\n *\n * To ensure the list survives restarts of the daemon,\n * providers are stored in the datastore, but to ensure\n * access is fast there is an LRU cache in front of that.\n */\n\nclass Providers {\n  /**\n   * @param {object} options\n   * @param {Datastore} options.providers\n   * @param {number} [options.cacheSize=256]\n   * @param {number} [options.cleanupInterval] - How often invalid records are cleaned. (in seconds)\n   * @param {number} [options.provideValidity] - How long is a provider valid for. (in seconds)\n   */\n  constructor(_ref) {\n    let {\n      providers,\n      cacheSize,\n      cleanupInterval,\n      provideValidity\n    } = _ref;\n    this.datastore = providers;\n    this.cleanupInterval = cleanupInterval || PROVIDERS_CLEANUP_INTERVAL;\n    this.provideValidity = provideValidity || PROVIDERS_VALIDITY; // @ts-expect-error hashlru types are wrong\n\n    this.cache = cache(cacheSize || PROVIDERS_LRU_CACHE_SIZE);\n    this.syncQueue = new Queue({\n      concurrency: 1\n    });\n  }\n  /**\n   * Start the provider cleanup service\n   */\n\n\n  start() {\n    if (this._started) {\n      return;\n    }\n\n    this._started = true;\n    this._cleaner = setInterval(() => this._cleanup(), this.cleanupInterval);\n  }\n  /**\n   * Release any resources.\n   */\n\n\n  stop() {\n    this._started = false;\n\n    if (this._cleaner) {\n      clearInterval(this._cleaner);\n      this._cleaner = null;\n    }\n  }\n  /**\n   * Check all providers if they are still valid, and if not delete them.\n   *\n   * @returns {Promise<void>}\n   * @private\n   */\n\n\n  _cleanup() {\n    return this.syncQueue.add(async () => {\n      const start = Date.now();\n      let count = 0;\n      let deleteCount = 0;\n      const deleted = new Map();\n      const batch = this.datastore.batch(); // Get all provider entries from the datastore\n\n      const query = this.datastore.query({\n        prefix: PROVIDER_KEY_PREFIX\n      });\n\n      for await (const entry of query) {\n        try {\n          // Add a delete to the batch for each expired entry\n          const {\n            cid,\n            peerId\n          } = parseProviderKey(entry.key);\n          const time = readTime(entry.value);\n          const now = Date.now();\n          const delta = now - time;\n          const expired = delta > this.provideValidity;\n          log('comparing: %d - %d = %d > %d %s', now, time, delta, this.provideValidity, expired ? '(expired)' : '');\n\n          if (expired) {\n            deleteCount++;\n            batch.delete(entry.key);\n            const peers = deleted.get(cid) || new Set();\n            peers.add(peerId);\n            deleted.set(cid, peers);\n          }\n\n          count++;\n        } catch (\n        /** @type {any} */\n        err) {\n          log.error(err.message);\n        }\n      } // Commit the deletes to the datastore\n\n\n      if (deleted.size) {\n        log('deleting %d / %d entries', deleteCount, count);\n        await batch.commit();\n      } else {\n        log('nothing to delete');\n      } // Clear expired entries from the cache\n\n\n      for (const [cid, peers] of deleted) {\n        const key = makeProviderKey(cid);\n        const provs = this.cache.get(key);\n\n        if (provs) {\n          for (const peerId of peers) {\n            provs.delete(peerId);\n          }\n\n          if (provs.size === 0) {\n            this.cache.remove(key);\n          } else {\n            this.cache.set(key, provs);\n          }\n        }\n      }\n\n      log('Cleanup successful (%dms)', Date.now() - start);\n    });\n  }\n  /**\n   * Get the currently known provider peer ids for a given CID.\n   *\n   * @param {CID} cid\n   * @returns {Promise<Map<string, Date>>}\n   *\n   * @private\n   */\n\n\n  async _getProvidersMap(cid) {\n    const cacheKey = makeProviderKey(cid);\n    let provs = this.cache.get(cacheKey);\n\n    if (!provs) {\n      provs = await loadProviders(this.datastore, cid);\n      this.cache.set(cacheKey, provs);\n    }\n\n    return provs;\n  }\n  /**\n   * Add a new provider for the given CID.\n   *\n   * @param {CID} cid\n   * @param {PeerId} provider\n   * @returns {Promise<void>}\n   */\n\n\n  async addProvider(cid, provider) {\n    // eslint-disable-line require-await\n    return this.syncQueue.add(async () => {\n      log('%p provides %s', provider, cid);\n      const provs = await this._getProvidersMap(cid);\n      log('loaded %s provs', provs.size);\n      const now = new Date();\n      provs.set(provider.toString(), now);\n      const dsKey = makeProviderKey(cid);\n      this.cache.set(dsKey, provs);\n      return writeProviderEntry(this.datastore, cid, provider, now);\n    });\n  }\n  /**\n   * Get a list of providers for the given CID.\n   *\n   * @param {CID} cid\n   * @returns {Promise<Array<PeerId>>}\n   */\n\n\n  async getProviders(cid) {\n    // eslint-disable-line require-await\n    return this.syncQueue.add(async () => {\n      log('get providers for %s', cid);\n      const provs = await this._getProvidersMap(cid);\n      return [...provs.keys()].map(peerIdStr => {\n        return PeerId.parse(peerIdStr);\n      });\n    });\n  }\n\n}\n/**\n * Encode the given key its matching datastore key.\n *\n * @param {CID|string} cid - cid or base32 encoded string\n * @returns {string}\n *\n * @private\n */\n\n\nfunction makeProviderKey(cid) {\n  cid = typeof cid === 'string' ? cid : uint8ArrayToString(cid.multihash.bytes, 'base32');\n  return `${PROVIDER_KEY_PREFIX}/${cid}`;\n}\n/**\n * Write a provider into the given store.\n *\n * @param {Datastore} store\n * @param {CID} cid\n * @param {PeerId} peer\n * @param {Date} time\n */\n\n\nasync function writeProviderEntry(store, cid, peer, time) {\n  // eslint-disable-line require-await\n  const dsKey = [makeProviderKey(cid), '/', peer.toString()].join('');\n  const key = new Key(dsKey);\n  const buffer = Uint8Array.from(varint.encode(time.getTime()));\n  return store.put(key, buffer);\n}\n/**\n * Parse the CID and provider peer id from the key\n *\n * @param {import('interface-datastore/key').Key} key\n */\n\n\nfunction parseProviderKey(key) {\n  const parts = key.toString().split('/');\n\n  if (parts.length !== 5) {\n    throw new Error('incorrectly formatted provider entry key in datastore: ' + key);\n  }\n\n  return {\n    cid: parts[3],\n    peerId: parts[4]\n  };\n}\n/**\n * Load providers for the given CID from the store.\n *\n * @param {Datastore} store\n * @param {CID} cid\n * @returns {Promise<Map<PeerId, Date>>}\n *\n * @private\n */\n\n\nasync function loadProviders(store, cid) {\n  const providers = new Map();\n  const query = store.query({\n    prefix: makeProviderKey(cid)\n  });\n\n  for await (const entry of query) {\n    const {\n      peerId\n    } = parseProviderKey(entry.key);\n    providers.set(peerId, readTime(entry.value));\n  }\n\n  return providers;\n}\n/**\n * @param {Uint8Array} buf\n */\n\n\nfunction readTime(buf) {\n  return varint.decode(buf);\n}\n\nmodule.exports.Providers = Providers;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p-kad-dht/src/providers.js"],"names":["cache","require","varint","PeerId","Key","default","Queue","PROVIDERS_CLEANUP_INTERVAL","PROVIDERS_VALIDITY","PROVIDERS_LRU_CACHE_SIZE","PROVIDER_KEY_PREFIX","utils","toString","uint8ArrayToString","log","logger","Providers","constructor","providers","cacheSize","cleanupInterval","provideValidity","datastore","syncQueue","concurrency","start","_started","_cleaner","setInterval","_cleanup","stop","clearInterval","add","Date","now","count","deleteCount","deleted","Map","batch","query","prefix","entry","cid","peerId","parseProviderKey","key","time","readTime","value","delta","expired","delete","peers","get","Set","set","err","error","message","size","commit","makeProviderKey","provs","remove","_getProvidersMap","cacheKey","loadProviders","addProvider","provider","dsKey","writeProviderEntry","getProviders","keys","map","peerIdStr","parse","multihash","bytes","store","peer","join","buffer","Uint8Array","from","encode","getTime","put","parts","split","length","Error","buf","decode","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,SAAD,CAArB,C,CACA;;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,SAAD,CAAtB;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAUH,OAAO,CAAC,yBAAD,CAAvB;;AACA,MAAM;AAAEI,EAAAA,OAAO,EAAEC;AAAX,IAAqBL,OAAO,CAAC,SAAD,CAAlC;;AACA,MAAM;AACJM,EAAAA,0BADI;AAEJC,EAAAA,kBAFI;AAGJC,EAAAA,wBAHI;AAIJC,EAAAA;AAJI,IAKFT,OAAO,CAAC,aAAD,CALX;;AAMA,MAAMU,KAAK,GAAGV,OAAO,CAAC,SAAD,CAArB;;AACA,MAAM;AAAEW,EAAAA,QAAQ,EAAEC;AAAZ,IAAmCZ,OAAO,CAAC,uBAAD,CAAhD;;AAEA,MAAMa,GAAG,GAAGH,KAAK,CAACI,MAAN,CAAa,0BAAb,CAAZ;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,SAAN,CAAgB;AACd;AACF;AACA;AACA;AACA;AACA;AACA;AACEC,EAAAA,WAAW,OAA8D;AAAA,QAA5D;AAAEC,MAAAA,SAAF;AAAaC,MAAAA,SAAb;AAAwBC,MAAAA,eAAxB;AAAyCC,MAAAA;AAAzC,KAA4D;AACvE,SAAKC,SAAL,GAAiBJ,SAAjB;AACA,SAAKE,eAAL,GAAuBA,eAAe,IAAIb,0BAA1C;AACA,SAAKc,eAAL,GAAuBA,eAAe,IAAIb,kBAA1C,CAHuE,CAIvE;;AACA,SAAKR,KAAL,GAAaA,KAAK,CAACmB,SAAS,IAAIV,wBAAd,CAAlB;AACA,SAAKc,SAAL,GAAiB,IAAIjB,KAAJ,CAAU;AAAEkB,MAAAA,WAAW,EAAE;AAAf,KAAV,CAAjB;AACD;AAED;AACF;AACA;;;AACEC,EAAAA,KAAK,GAAI;AACP,QAAI,KAAKC,QAAT,EAAmB;AACjB;AACD;;AAED,SAAKA,QAAL,GAAgB,IAAhB;AAEA,SAAKC,QAAL,GAAgBC,WAAW,CACzB,MAAM,KAAKC,QAAL,EADmB,EAEzB,KAAKT,eAFoB,CAA3B;AAID;AAED;AACF;AACA;;;AACEU,EAAAA,IAAI,GAAI;AACN,SAAKJ,QAAL,GAAgB,KAAhB;;AAEA,QAAI,KAAKC,QAAT,EAAmB;AACjBI,MAAAA,aAAa,CAAC,KAAKJ,QAAN,CAAb;AACA,WAAKA,QAAL,GAAgB,IAAhB;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEE,EAAAA,QAAQ,GAAI;AACV,WAAO,KAAKN,SAAL,CAAeS,GAAf,CAAmB,YAAY;AACpC,YAAMP,KAAK,GAAGQ,IAAI,CAACC,GAAL,EAAd;AAEA,UAAIC,KAAK,GAAG,CAAZ;AACA,UAAIC,WAAW,GAAG,CAAlB;AACA,YAAMC,OAAO,GAAG,IAAIC,GAAJ,EAAhB;AACA,YAAMC,KAAK,GAAG,KAAKjB,SAAL,CAAeiB,KAAf,EAAd,CANoC,CAQpC;;AACA,YAAMC,KAAK,GAAG,KAAKlB,SAAL,CAAekB,KAAf,CAAqB;AAAEC,QAAAA,MAAM,EAAE/B;AAAV,OAArB,CAAd;;AAEA,iBAAW,MAAMgC,KAAjB,IAA0BF,KAA1B,EAAiC;AAC/B,YAAI;AACF;AACA,gBAAM;AAAEG,YAAAA,GAAF;AAAOC,YAAAA;AAAP,cAAkBC,gBAAgB,CAACH,KAAK,CAACI,GAAP,CAAxC;AACA,gBAAMC,IAAI,GAAGC,QAAQ,CAACN,KAAK,CAACO,KAAP,CAArB;AACA,gBAAMf,GAAG,GAAGD,IAAI,CAACC,GAAL,EAAZ;AACA,gBAAMgB,KAAK,GAAGhB,GAAG,GAAGa,IAApB;AACA,gBAAMI,OAAO,GAAGD,KAAK,GAAG,KAAK7B,eAA7B;AAEAP,UAAAA,GAAG,CAAC,iCAAD,EAAoCoB,GAApC,EAAyCa,IAAzC,EAA+CG,KAA/C,EAAsD,KAAK7B,eAA3D,EAA4E8B,OAAO,GAAG,WAAH,GAAiB,EAApG,CAAH;;AAEA,cAAIA,OAAJ,EAAa;AACXf,YAAAA,WAAW;AACXG,YAAAA,KAAK,CAACa,MAAN,CAAaV,KAAK,CAACI,GAAnB;AACA,kBAAMO,KAAK,GAAGhB,OAAO,CAACiB,GAAR,CAAYX,GAAZ,KAAoB,IAAIY,GAAJ,EAAlC;AACAF,YAAAA,KAAK,CAACrB,GAAN,CAAUY,MAAV;AACAP,YAAAA,OAAO,CAACmB,GAAR,CAAYb,GAAZ,EAAiBU,KAAjB;AACD;;AACDlB,UAAAA,KAAK;AACN,SAlBD,CAkBE;AAAO;AAAmBsB,QAAAA,GAA1B,EAA+B;AAC/B3C,UAAAA,GAAG,CAAC4C,KAAJ,CAAUD,GAAG,CAACE,OAAd;AACD;AACF,OAjCmC,CAmCpC;;;AACA,UAAItB,OAAO,CAACuB,IAAZ,EAAkB;AAChB9C,QAAAA,GAAG,CAAC,0BAAD,EAA6BsB,WAA7B,EAA0CD,KAA1C,CAAH;AACA,cAAMI,KAAK,CAACsB,MAAN,EAAN;AACD,OAHD,MAGO;AACL/C,QAAAA,GAAG,CAAC,mBAAD,CAAH;AACD,OAzCmC,CA2CpC;;;AACA,WAAK,MAAM,CAAC6B,GAAD,EAAMU,KAAN,CAAX,IAA2BhB,OAA3B,EAAoC;AAClC,cAAMS,GAAG,GAAGgB,eAAe,CAACnB,GAAD,CAA3B;AACA,cAAMoB,KAAK,GAAG,KAAK/D,KAAL,CAAWsD,GAAX,CAAeR,GAAf,CAAd;;AAEA,YAAIiB,KAAJ,EAAW;AACT,eAAK,MAAMnB,MAAX,IAAqBS,KAArB,EAA4B;AAC1BU,YAAAA,KAAK,CAACX,MAAN,CAAaR,MAAb;AACD;;AAED,cAAImB,KAAK,CAACH,IAAN,KAAe,CAAnB,EAAsB;AACpB,iBAAK5D,KAAL,CAAWgE,MAAX,CAAkBlB,GAAlB;AACD,WAFD,MAEO;AACL,iBAAK9C,KAAL,CAAWwD,GAAX,CAAeV,GAAf,EAAoBiB,KAApB;AACD;AACF;AACF;;AAEDjD,MAAAA,GAAG,CAAC,2BAAD,EAA8BmB,IAAI,CAACC,GAAL,KAAaT,KAA3C,CAAH;AACD,KA9DM,CAAP;AA+DD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACwB,QAAhBwC,gBAAgB,CAAEtB,GAAF,EAAO;AAC3B,UAAMuB,QAAQ,GAAGJ,eAAe,CAACnB,GAAD,CAAhC;AACA,QAAIoB,KAAK,GAAG,KAAK/D,KAAL,CAAWsD,GAAX,CAAeY,QAAf,CAAZ;;AAEA,QAAI,CAACH,KAAL,EAAY;AACVA,MAAAA,KAAK,GAAG,MAAMI,aAAa,CAAC,KAAK7C,SAAN,EAAiBqB,GAAjB,CAA3B;AACA,WAAK3C,KAAL,CAAWwD,GAAX,CAAeU,QAAf,EAAyBH,KAAzB;AACD;;AAED,WAAOA,KAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACmB,QAAXK,WAAW,CAAEzB,GAAF,EAAO0B,QAAP,EAAiB;AAAE;AAClC,WAAO,KAAK9C,SAAL,CAAeS,GAAf,CAAmB,YAAY;AACpClB,MAAAA,GAAG,CAAC,gBAAD,EAAmBuD,QAAnB,EAA6B1B,GAA7B,CAAH;AACA,YAAMoB,KAAK,GAAG,MAAM,KAAKE,gBAAL,CAAsBtB,GAAtB,CAApB;AAEA7B,MAAAA,GAAG,CAAC,iBAAD,EAAoBiD,KAAK,CAACH,IAA1B,CAAH;AACA,YAAM1B,GAAG,GAAG,IAAID,IAAJ,EAAZ;AACA8B,MAAAA,KAAK,CAACP,GAAN,CAAUa,QAAQ,CAACzD,QAAT,EAAV,EAA+BsB,GAA/B;AAEA,YAAMoC,KAAK,GAAGR,eAAe,CAACnB,GAAD,CAA7B;AACA,WAAK3C,KAAL,CAAWwD,GAAX,CAAec,KAAf,EAAsBP,KAAtB;AAEA,aAAOQ,kBAAkB,CAAC,KAAKjD,SAAN,EAAiBqB,GAAjB,EAAsB0B,QAAtB,EAAgCnC,GAAhC,CAAzB;AACD,KAZM,CAAP;AAaD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACoB,QAAZsC,YAAY,CAAE7B,GAAF,EAAO;AAAE;AACzB,WAAO,KAAKpB,SAAL,CAAeS,GAAf,CAAmB,YAAY;AACpClB,MAAAA,GAAG,CAAC,sBAAD,EAAyB6B,GAAzB,CAAH;AACA,YAAMoB,KAAK,GAAG,MAAM,KAAKE,gBAAL,CAAsBtB,GAAtB,CAApB;AAEA,aAAO,CAAC,GAAGoB,KAAK,CAACU,IAAN,EAAJ,EAAkBC,GAAlB,CAAsBC,SAAS,IAAI;AACxC,eAAOxE,MAAM,CAACyE,KAAP,CAAaD,SAAb,CAAP;AACD,OAFM,CAAP;AAGD,KAPM,CAAP;AAQD;;AA/Ka;AAkLhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASb,eAAT,CAA0BnB,GAA1B,EAA+B;AAC7BA,EAAAA,GAAG,GAAG,OAAOA,GAAP,KAAe,QAAf,GAA0BA,GAA1B,GAAgC9B,kBAAkB,CAAC8B,GAAG,CAACkC,SAAJ,CAAcC,KAAf,EAAsB,QAAtB,CAAxD;AAEA,SAAQ,GAAEpE,mBAAoB,IAAGiC,GAAI,EAArC;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,eAAe4B,kBAAf,CAAmCQ,KAAnC,EAA0CpC,GAA1C,EAA+CqC,IAA/C,EAAqDjC,IAArD,EAA2D;AAAE;AAC3D,QAAMuB,KAAK,GAAG,CACZR,eAAe,CAACnB,GAAD,CADH,EAEZ,GAFY,EAGZqC,IAAI,CAACpE,QAAL,EAHY,EAIZqE,IAJY,CAIP,EAJO,CAAd;AAMA,QAAMnC,GAAG,GAAG,IAAI1C,GAAJ,CAAQkE,KAAR,CAAZ;AACA,QAAMY,MAAM,GAAGC,UAAU,CAACC,IAAX,CAAgBlF,MAAM,CAACmF,MAAP,CAActC,IAAI,CAACuC,OAAL,EAAd,CAAhB,CAAf;AAEA,SAAOP,KAAK,CAACQ,GAAN,CAAUzC,GAAV,EAAeoC,MAAf,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASrC,gBAAT,CAA2BC,GAA3B,EAAgC;AAC9B,QAAM0C,KAAK,GAAG1C,GAAG,CAAClC,QAAJ,GAAe6E,KAAf,CAAqB,GAArB,CAAd;;AAEA,MAAID,KAAK,CAACE,MAAN,KAAiB,CAArB,EAAwB;AACtB,UAAM,IAAIC,KAAJ,CAAU,4DAA4D7C,GAAtE,CAAN;AACD;;AAED,SAAO;AACLH,IAAAA,GAAG,EAAE6C,KAAK,CAAC,CAAD,CADL;AAEL5C,IAAAA,MAAM,EAAE4C,KAAK,CAAC,CAAD;AAFR,GAAP;AAID;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,eAAerB,aAAf,CAA8BY,KAA9B,EAAqCpC,GAArC,EAA0C;AACxC,QAAMzB,SAAS,GAAG,IAAIoB,GAAJ,EAAlB;AACA,QAAME,KAAK,GAAGuC,KAAK,CAACvC,KAAN,CAAY;AAAEC,IAAAA,MAAM,EAAEqB,eAAe,CAACnB,GAAD;AAAzB,GAAZ,CAAd;;AAEA,aAAW,MAAMD,KAAjB,IAA0BF,KAA1B,EAAiC;AAC/B,UAAM;AAAEI,MAAAA;AAAF,QAAaC,gBAAgB,CAACH,KAAK,CAACI,GAAP,CAAnC;AACA5B,IAAAA,SAAS,CAACsC,GAAV,CAAcZ,MAAd,EAAsBI,QAAQ,CAACN,KAAK,CAACO,KAAP,CAA9B;AACD;;AAED,SAAO/B,SAAP;AACD;AAED;AACA;AACA;;;AACA,SAAS8B,QAAT,CAAmB4C,GAAnB,EAAwB;AACtB,SAAO1F,MAAM,CAAC2F,MAAP,CAAcD,GAAd,CAAP;AACD;;AAEDE,MAAM,CAACC,OAAP,CAAe/E,SAAf,GAA2BA,SAA3B","sourcesContent":["'use strict'\n\nconst cache = require('hashlru')\n// @ts-ignore\nconst varint = require('varint')\nconst PeerId = require('peer-id')\nconst { Key } = require('interface-datastore/key')\nconst { default: Queue } = require('p-queue')\nconst {\n  PROVIDERS_CLEANUP_INTERVAL,\n  PROVIDERS_VALIDITY,\n  PROVIDERS_LRU_CACHE_SIZE,\n  PROVIDER_KEY_PREFIX\n} = require('./constants')\nconst utils = require('./utils')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\n\nconst log = utils.logger('libp2p:kad-dht:providers')\n\n/**\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('interface-datastore').Datastore} Datastore\n */\n\n/**\n * This class manages known providers.\n * A provider is a peer that we know to have the content for a given CID.\n *\n * Every `cleanupInterval` providers are checked if they\n * are still valid, i.e. younger than the `provideValidity`.\n * If they are not, they are deleted.\n *\n * To ensure the list survives restarts of the daemon,\n * providers are stored in the datastore, but to ensure\n * access is fast there is an LRU cache in front of that.\n */\nclass Providers {\n  /**\n   * @param {object} options\n   * @param {Datastore} options.providers\n   * @param {number} [options.cacheSize=256]\n   * @param {number} [options.cleanupInterval] - How often invalid records are cleaned. (in seconds)\n   * @param {number} [options.provideValidity] - How long is a provider valid for. (in seconds)\n   */\n  constructor ({ providers, cacheSize, cleanupInterval, provideValidity }) {\n    this.datastore = providers\n    this.cleanupInterval = cleanupInterval || PROVIDERS_CLEANUP_INTERVAL\n    this.provideValidity = provideValidity || PROVIDERS_VALIDITY\n    // @ts-expect-error hashlru types are wrong\n    this.cache = cache(cacheSize || PROVIDERS_LRU_CACHE_SIZE)\n    this.syncQueue = new Queue({ concurrency: 1 })\n  }\n\n  /**\n   * Start the provider cleanup service\n   */\n  start () {\n    if (this._started) {\n      return\n    }\n\n    this._started = true\n\n    this._cleaner = setInterval(\n      () => this._cleanup(),\n      this.cleanupInterval\n    )\n  }\n\n  /**\n   * Release any resources.\n   */\n  stop () {\n    this._started = false\n\n    if (this._cleaner) {\n      clearInterval(this._cleaner)\n      this._cleaner = null\n    }\n  }\n\n  /**\n   * Check all providers if they are still valid, and if not delete them.\n   *\n   * @returns {Promise<void>}\n   * @private\n   */\n  _cleanup () {\n    return this.syncQueue.add(async () => {\n      const start = Date.now()\n\n      let count = 0\n      let deleteCount = 0\n      const deleted = new Map()\n      const batch = this.datastore.batch()\n\n      // Get all provider entries from the datastore\n      const query = this.datastore.query({ prefix: PROVIDER_KEY_PREFIX })\n\n      for await (const entry of query) {\n        try {\n          // Add a delete to the batch for each expired entry\n          const { cid, peerId } = parseProviderKey(entry.key)\n          const time = readTime(entry.value)\n          const now = Date.now()\n          const delta = now - time\n          const expired = delta > this.provideValidity\n\n          log('comparing: %d - %d = %d > %d %s', now, time, delta, this.provideValidity, expired ? '(expired)' : '')\n\n          if (expired) {\n            deleteCount++\n            batch.delete(entry.key)\n            const peers = deleted.get(cid) || new Set()\n            peers.add(peerId)\n            deleted.set(cid, peers)\n          }\n          count++\n        } catch (/** @type {any} */ err) {\n          log.error(err.message)\n        }\n      }\n\n      // Commit the deletes to the datastore\n      if (deleted.size) {\n        log('deleting %d / %d entries', deleteCount, count)\n        await batch.commit()\n      } else {\n        log('nothing to delete')\n      }\n\n      // Clear expired entries from the cache\n      for (const [cid, peers] of deleted) {\n        const key = makeProviderKey(cid)\n        const provs = this.cache.get(key)\n\n        if (provs) {\n          for (const peerId of peers) {\n            provs.delete(peerId)\n          }\n\n          if (provs.size === 0) {\n            this.cache.remove(key)\n          } else {\n            this.cache.set(key, provs)\n          }\n        }\n      }\n\n      log('Cleanup successful (%dms)', Date.now() - start)\n    })\n  }\n\n  /**\n   * Get the currently known provider peer ids for a given CID.\n   *\n   * @param {CID} cid\n   * @returns {Promise<Map<string, Date>>}\n   *\n   * @private\n   */\n  async _getProvidersMap (cid) {\n    const cacheKey = makeProviderKey(cid)\n    let provs = this.cache.get(cacheKey)\n\n    if (!provs) {\n      provs = await loadProviders(this.datastore, cid)\n      this.cache.set(cacheKey, provs)\n    }\n\n    return provs\n  }\n\n  /**\n   * Add a new provider for the given CID.\n   *\n   * @param {CID} cid\n   * @param {PeerId} provider\n   * @returns {Promise<void>}\n   */\n  async addProvider (cid, provider) { // eslint-disable-line require-await\n    return this.syncQueue.add(async () => {\n      log('%p provides %s', provider, cid)\n      const provs = await this._getProvidersMap(cid)\n\n      log('loaded %s provs', provs.size)\n      const now = new Date()\n      provs.set(provider.toString(), now)\n\n      const dsKey = makeProviderKey(cid)\n      this.cache.set(dsKey, provs)\n\n      return writeProviderEntry(this.datastore, cid, provider, now)\n    })\n  }\n\n  /**\n   * Get a list of providers for the given CID.\n   *\n   * @param {CID} cid\n   * @returns {Promise<Array<PeerId>>}\n   */\n  async getProviders (cid) { // eslint-disable-line require-await\n    return this.syncQueue.add(async () => {\n      log('get providers for %s', cid)\n      const provs = await this._getProvidersMap(cid)\n\n      return [...provs.keys()].map(peerIdStr => {\n        return PeerId.parse(peerIdStr)\n      })\n    })\n  }\n}\n\n/**\n * Encode the given key its matching datastore key.\n *\n * @param {CID|string} cid - cid or base32 encoded string\n * @returns {string}\n *\n * @private\n */\nfunction makeProviderKey (cid) {\n  cid = typeof cid === 'string' ? cid : uint8ArrayToString(cid.multihash.bytes, 'base32')\n\n  return `${PROVIDER_KEY_PREFIX}/${cid}`\n}\n\n/**\n * Write a provider into the given store.\n *\n * @param {Datastore} store\n * @param {CID} cid\n * @param {PeerId} peer\n * @param {Date} time\n */\nasync function writeProviderEntry (store, cid, peer, time) { // eslint-disable-line require-await\n  const dsKey = [\n    makeProviderKey(cid),\n    '/',\n    peer.toString()\n  ].join('')\n\n  const key = new Key(dsKey)\n  const buffer = Uint8Array.from(varint.encode(time.getTime()))\n\n  return store.put(key, buffer)\n}\n\n/**\n * Parse the CID and provider peer id from the key\n *\n * @param {import('interface-datastore/key').Key} key\n */\nfunction parseProviderKey (key) {\n  const parts = key.toString().split('/')\n\n  if (parts.length !== 5) {\n    throw new Error('incorrectly formatted provider entry key in datastore: ' + key)\n  }\n\n  return {\n    cid: parts[3],\n    peerId: parts[4]\n  }\n}\n\n/**\n * Load providers for the given CID from the store.\n *\n * @param {Datastore} store\n * @param {CID} cid\n * @returns {Promise<Map<PeerId, Date>>}\n *\n * @private\n */\nasync function loadProviders (store, cid) {\n  const providers = new Map()\n  const query = store.query({ prefix: makeProviderKey(cid) })\n\n  for await (const entry of query) {\n    const { peerId } = parseProviderKey(entry.key)\n    providers.set(peerId, readTime(entry.value))\n  }\n\n  return providers\n}\n\n/**\n * @param {Uint8Array} buf\n */\nfunction readTime (buf) {\n  return varint.decode(buf)\n}\n\nmodule.exports.Providers = Providers\n"]},"metadata":{},"sourceType":"script"}