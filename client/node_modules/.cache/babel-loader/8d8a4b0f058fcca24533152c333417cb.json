{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar cid = require('multiformats/cid');\n\nvar debug = require('debug');\n\nvar errors = require('datastore-core/errors');\n\nvar parallelBatch = require('it-parallel-batch');\n\nvar itPipe = require('it-pipe');\n\nvar merge = require('it-merge');\n\nvar map = require('it-map');\n\nvar filter = require('it-filter');\n\nvar key = require('interface-datastore/key');\n\nvar base32 = require('multiformats/bases/base32');\n\nvar walkDag = require('./utils/walk-dag.js');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\n\nvar parallelBatch__default = /*#__PURE__*/_interopDefaultLegacy(parallelBatch);\n\nvar merge__default = /*#__PURE__*/_interopDefaultLegacy(merge);\n\nvar map__default = /*#__PURE__*/_interopDefaultLegacy(map);\n\nvar filter__default = /*#__PURE__*/_interopDefaultLegacy(filter);\n\nconst log = debug__default[\"default\"]('ipfs:repo:gc');\nconst ERR_NOT_FOUND = errors.notFoundError().code;\nconst BLOCK_RM_CONCURRENCY = 256;\nconst MFS_ROOT_KEY = new key.Key('/local/filesroot');\n\nfunction gc(_ref) {\n  let {\n    gcLock,\n    pins,\n    blockstore,\n    root,\n    loadCodec\n  } = _ref;\n\n  async function* gc() {\n    const start = Date.now();\n    log('Creating set of marked blocks');\n    const release = await gcLock.writeLock();\n\n    try {\n      const markedSet = await createMarkedSet({\n        pins,\n        blockstore,\n        root,\n        loadCodec\n      });\n      const blockKeys = blockstore.queryKeys({});\n      yield* deleteUnmarkedBlocks({\n        blockstore\n      }, markedSet, blockKeys);\n      log(`Complete (${Date.now() - start}ms)`);\n    } finally {\n      release();\n    }\n  }\n\n  return gc;\n}\n\nasync function createMarkedSet(_ref2) {\n  let {\n    pins,\n    blockstore,\n    loadCodec,\n    root\n  } = _ref2;\n\n  const mfsSource = async function* () {\n    let mh;\n\n    try {\n      mh = await root.get(MFS_ROOT_KEY);\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        log('No blocks in MFS');\n        return;\n      }\n\n      throw err;\n    }\n\n    const rootCid = cid.CID.decode(mh);\n    yield rootCid;\n    yield* walkDag.walkDag(rootCid, blockstore, loadCodec);\n  }();\n\n  const pinsSource = merge__default[\"default\"](map__default[\"default\"](pins.recursiveKeys(), _ref3 => {\n    let {\n      cid\n    } = _ref3;\n    return cid;\n  }), pins.indirectKeys(), map__default[\"default\"](pins.directKeys(), _ref4 => {\n    let {\n      cid\n    } = _ref4;\n    return cid;\n  }), mfsSource);\n  const output = new Set();\n\n  for await (const cid of merge__default[\"default\"](pinsSource, mfsSource)) {\n    output.add(base32.base32.encode(cid.multihash.bytes));\n  }\n\n  return output;\n}\n\nasync function* deleteUnmarkedBlocks(_ref5, markedSet, blockKeys) {\n  let {\n    blockstore\n  } = _ref5;\n  let blocksCount = 0;\n  let removedBlocksCount = 0;\n\n  const removeBlock = async cid => {\n    return async function remove() {\n      blocksCount++;\n\n      try {\n        const b32 = base32.base32.encode(cid.multihash.bytes);\n\n        if (markedSet.has(b32)) {\n          return null;\n        }\n\n        try {\n          await blockstore.delete(cid);\n          removedBlocksCount++;\n        } catch (err) {\n          return {\n            err: new Error(`Could not delete block with CID ${cid}: ${err.message}`)\n          };\n        }\n\n        return {\n          cid\n        };\n      } catch (err) {\n        const msg = `Could delete block with CID ${cid}`;\n        log(msg, err);\n        return {\n          err: new Error(msg + `: ${err.message}`)\n        };\n      }\n    };\n  };\n\n  yield* itPipe.pipe(parallelBatch__default[\"default\"](map__default[\"default\"](blockKeys, removeBlock), BLOCK_RM_CONCURRENCY), source => filter__default[\"default\"](source, Boolean));\n  log(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blocksCount} blocks. ` + `Deleted ${removedBlocksCount} blocks.`);\n}\n\nexports.gc = gc;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-repo/cjs/src/gc.js"],"names":["Object","defineProperty","exports","value","cid","require","debug","errors","parallelBatch","itPipe","merge","map","filter","key","base32","walkDag","_interopDefaultLegacy","e","debug__default","parallelBatch__default","merge__default","map__default","filter__default","log","ERR_NOT_FOUND","notFoundError","code","BLOCK_RM_CONCURRENCY","MFS_ROOT_KEY","Key","gc","gcLock","pins","blockstore","root","loadCodec","start","Date","now","release","writeLock","markedSet","createMarkedSet","blockKeys","queryKeys","deleteUnmarkedBlocks","mfsSource","mh","get","err","rootCid","CID","decode","pinsSource","recursiveKeys","indirectKeys","directKeys","output","Set","add","encode","multihash","bytes","blocksCount","removedBlocksCount","removeBlock","remove","b32","has","delete","Error","message","msg","pipe","source","Boolean","size"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar cid = require('multiformats/cid');\nvar debug = require('debug');\nvar errors = require('datastore-core/errors');\nvar parallelBatch = require('it-parallel-batch');\nvar itPipe = require('it-pipe');\nvar merge = require('it-merge');\nvar map = require('it-map');\nvar filter = require('it-filter');\nvar key = require('interface-datastore/key');\nvar base32 = require('multiformats/bases/base32');\nvar walkDag = require('./utils/walk-dag.js');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\nvar parallelBatch__default = /*#__PURE__*/_interopDefaultLegacy(parallelBatch);\nvar merge__default = /*#__PURE__*/_interopDefaultLegacy(merge);\nvar map__default = /*#__PURE__*/_interopDefaultLegacy(map);\nvar filter__default = /*#__PURE__*/_interopDefaultLegacy(filter);\n\nconst log = debug__default[\"default\"]('ipfs:repo:gc');\nconst ERR_NOT_FOUND = errors.notFoundError().code;\nconst BLOCK_RM_CONCURRENCY = 256;\nconst MFS_ROOT_KEY = new key.Key('/local/filesroot');\nfunction gc({gcLock, pins, blockstore, root, loadCodec}) {\n  async function* gc() {\n    const start = Date.now();\n    log('Creating set of marked blocks');\n    const release = await gcLock.writeLock();\n    try {\n      const markedSet = await createMarkedSet({\n        pins,\n        blockstore,\n        root,\n        loadCodec\n      });\n      const blockKeys = blockstore.queryKeys({});\n      yield* deleteUnmarkedBlocks({ blockstore }, markedSet, blockKeys);\n      log(`Complete (${ Date.now() - start }ms)`);\n    } finally {\n      release();\n    }\n  }\n  return gc;\n}\nasync function createMarkedSet({pins, blockstore, loadCodec, root}) {\n  const mfsSource = async function* () {\n    let mh;\n    try {\n      mh = await root.get(MFS_ROOT_KEY);\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        log('No blocks in MFS');\n        return;\n      }\n      throw err;\n    }\n    const rootCid = cid.CID.decode(mh);\n    yield rootCid;\n    yield* walkDag.walkDag(rootCid, blockstore, loadCodec);\n  }();\n  const pinsSource = merge__default[\"default\"](map__default[\"default\"](pins.recursiveKeys(), ({cid}) => cid), pins.indirectKeys(), map__default[\"default\"](pins.directKeys(), ({cid}) => cid), mfsSource);\n  const output = new Set();\n  for await (const cid of merge__default[\"default\"](pinsSource, mfsSource)) {\n    output.add(base32.base32.encode(cid.multihash.bytes));\n  }\n  return output;\n}\nasync function* deleteUnmarkedBlocks({blockstore}, markedSet, blockKeys) {\n  let blocksCount = 0;\n  let removedBlocksCount = 0;\n  const removeBlock = async cid => {\n    return async function remove() {\n      blocksCount++;\n      try {\n        const b32 = base32.base32.encode(cid.multihash.bytes);\n        if (markedSet.has(b32)) {\n          return null;\n        }\n        try {\n          await blockstore.delete(cid);\n          removedBlocksCount++;\n        } catch (err) {\n          return { err: new Error(`Could not delete block with CID ${ cid }: ${ err.message }`) };\n        }\n        return { cid };\n      } catch (err) {\n        const msg = `Could delete block with CID ${ cid }`;\n        log(msg, err);\n        return { err: new Error(msg + `: ${ err.message }`) };\n      }\n    };\n  };\n  yield* itPipe.pipe(parallelBatch__default[\"default\"](map__default[\"default\"](blockKeys, removeBlock), BLOCK_RM_CONCURRENCY), source => filter__default[\"default\"](source, Boolean));\n  log(`Marked set has ${ markedSet.size } unique blocks. Blockstore has ${ blocksCount } blocks. ` + `Deleted ${ removedBlocksCount } blocks.`);\n}\n\nexports.gc = gc;\n"]},"metadata":{},"sourceType":"script"}