{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar index = require('../migrations/index.js');\n\nvar version = require('./repo/version.js');\n\nvar errors$1 = require('./errors.js');\n\nvar utils = require('./utils.js');\n\nvar debug = require('debug');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\n\nconst log = debug__default[\"default\"]('ipfs:repo:migrator');\n\nfunction getLatestMigrationVersion(migrations) {\n  migrations = migrations || index;\n\n  if (!Array.isArray(migrations) || migrations.length === 0) {\n    return 0;\n  }\n\n  return migrations[migrations.length - 1].version;\n}\n\nasync function migrate(path, backends, repoOptions, toVersion, _ref) {\n  let {\n    ignoreLock = false,\n    onProgress,\n    isDryRun = false,\n    migrations\n  } = _ref;\n  migrations = migrations || index;\n\n  if (!path) {\n    throw new errors.RequiredParameterError('Path argument is required!');\n  }\n\n  if (!repoOptions) {\n    throw new errors.RequiredParameterError('repoOptions argument is required!');\n  }\n\n  if (!toVersion) {\n    throw new errors.RequiredParameterError('toVersion argument is required!');\n  }\n\n  if (!Number.isInteger(toVersion) || toVersion <= 0) {\n    throw new errors.InvalidValueError('Version has to be positive integer!');\n  }\n\n  backends = utils.wrapBackends(backends);\n  const currentVersion = await version.getVersion(backends);\n\n  if (currentVersion === toVersion) {\n    log('Nothing to migrate.');\n    return;\n  }\n\n  if (currentVersion > toVersion) {\n    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is higher then toVersion (${toVersion}), you probably wanted to revert it?`);\n  }\n\n  verifyAvailableMigrations(migrations, currentVersion, toVersion);\n  let lock;\n\n  if (!isDryRun && !ignoreLock) {\n    lock = await repoOptions.repoLock.lock(path);\n  }\n\n  try {\n    for (const migration of migrations) {\n      if (toVersion !== undefined && migration.version > toVersion) {\n        break;\n      }\n\n      if (migration.version <= currentVersion) {\n        continue;\n      }\n\n      log(`Migrating version ${migration.version}`);\n\n      try {\n        if (!isDryRun) {\n          let progressCallback = () => {};\n\n          if (onProgress) {\n            progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message);\n          }\n\n          await migration.migrate(backends, progressCallback);\n        }\n      } catch (e) {\n        const lastSuccessfullyMigratedVersion = migration.version - 1;\n        log(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${lastSuccessfullyMigratedVersion}`);\n        await version.setVersion(lastSuccessfullyMigratedVersion, backends);\n        throw new Error(`During migration to version ${migration.version} exception was raised: ${e.stack || e.message || e}`);\n      }\n\n      log(`Migrating to version ${migration.version} finished`);\n    }\n\n    if (!isDryRun) {\n      await version.setVersion(toVersion || getLatestMigrationVersion(migrations), backends);\n    }\n\n    log('Repo successfully migrated', toVersion !== undefined ? `to version ${toVersion}!` : 'to latest version!');\n  } finally {\n    if (!isDryRun && !ignoreLock && lock) {\n      await lock.close();\n    }\n  }\n}\n\nasync function revert(path, backends, repoOptions, toVersion, _ref2) {\n  let {\n    ignoreLock = false,\n    onProgress,\n    isDryRun = false,\n    migrations\n  } = _ref2;\n  migrations = migrations || index;\n\n  if (!path) {\n    throw new errors.RequiredParameterError('Path argument is required!');\n  }\n\n  if (!repoOptions) {\n    throw new errors.RequiredParameterError('repoOptions argument is required!');\n  }\n\n  if (!toVersion) {\n    throw new errors.RequiredParameterError('When reverting migrations, you have to specify to which version to revert!');\n  }\n\n  if (!Number.isInteger(toVersion) || toVersion <= 0) {\n    throw new errors.InvalidValueError('Version has to be positive integer!');\n  }\n\n  backends = utils.wrapBackends(backends);\n  const currentVersion = await version.getVersion(backends);\n\n  if (currentVersion === toVersion) {\n    log('Nothing to revert.');\n    return;\n  }\n\n  if (currentVersion < toVersion) {\n    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is lower then toVersion (${toVersion}), you probably wanted to migrate it?`);\n  }\n\n  verifyAvailableMigrations(migrations, toVersion, currentVersion, true);\n  let lock;\n\n  if (!isDryRun && !ignoreLock) {\n    lock = await repoOptions.repoLock.lock(path);\n  }\n\n  log(`Reverting from version ${currentVersion} to ${toVersion}`);\n\n  try {\n    const reversedMigrationArray = migrations.slice().reverse();\n\n    for (const migration of reversedMigrationArray) {\n      if (migration.version <= toVersion) {\n        break;\n      }\n\n      if (migration.version > currentVersion) {\n        continue;\n      }\n\n      log(`Reverting migration version ${migration.version}`);\n\n      try {\n        if (!isDryRun) {\n          let progressCallback = () => {};\n\n          if (onProgress) {\n            progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message);\n          }\n\n          await migration.revert(backends, progressCallback);\n        }\n      } catch (e) {\n        const lastSuccessfullyRevertedVersion = migration.version;\n        log(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${lastSuccessfullyRevertedVersion}`);\n        await version.setVersion(lastSuccessfullyRevertedVersion, backends);\n        e.message = `During reversion to version ${migration.version} exception was raised: ${e.message}`;\n        throw e;\n      }\n\n      log(`Reverting to version ${migration.version} finished`);\n    }\n\n    if (!isDryRun) {\n      await version.setVersion(toVersion, backends);\n    }\n\n    log(`All migrations successfully reverted to version ${toVersion}!`);\n  } finally {\n    if (!isDryRun && !ignoreLock && lock) {\n      await lock.close();\n    }\n  }\n}\n\nfunction verifyAvailableMigrations(migrations, fromVersion, toVersion) {\n  let checkReversibility = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let migrationCounter = 0;\n\n  for (const migration of migrations) {\n    if (migration.version > toVersion) {\n      break;\n    }\n\n    if (migration.version > fromVersion) {\n      if (checkReversibility && !migration.revert) {\n        throw new errors.NonReversibleMigrationError(`It is not possible to revert to version ${fromVersion} because migration version ${migration.version} is not reversible. Cancelling reversion.`);\n      }\n\n      migrationCounter++;\n    }\n  }\n\n  if (migrationCounter !== toVersion - fromVersion) {\n    throw new errors.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${fromVersion} to ${toVersion}`);\n  }\n}\n\nconst getCurrentRepoVersion = version.getVersion;\nconst errors = errors$1;\nconst migrations = index;\nexports.errors = errors;\nexports.getCurrentRepoVersion = getCurrentRepoVersion;\nexports.getLatestMigrationVersion = getLatestMigrationVersion;\nexports.migrate = migrate;\nexports.migrations = migrations;\nexports.revert = revert;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-repo-migrations/cjs/src/index.js"],"names":["Object","defineProperty","exports","value","index","require","version","errors$1","utils","debug","_interopDefaultLegacy","e","debug__default","log","getLatestMigrationVersion","migrations","Array","isArray","length","migrate","path","backends","repoOptions","toVersion","ignoreLock","onProgress","isDryRun","errors","RequiredParameterError","Number","isInteger","InvalidValueError","wrapBackends","currentVersion","getVersion","verifyAvailableMigrations","lock","repoLock","migration","undefined","progressCallback","percent","message","toFixed","lastSuccessfullyMigratedVersion","setVersion","Error","stack","close","revert","reversedMigrationArray","slice","reverse","lastSuccessfullyRevertedVersion","fromVersion","checkReversibility","migrationCounter","NonReversibleMigrationError","getCurrentRepoVersion"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar index = require('../migrations/index.js');\nvar version = require('./repo/version.js');\nvar errors$1 = require('./errors.js');\nvar utils = require('./utils.js');\nvar debug = require('debug');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\n\nconst log = debug__default[\"default\"]('ipfs:repo:migrator');\nfunction getLatestMigrationVersion(migrations) {\n  migrations = migrations || index;\n  if (!Array.isArray(migrations) || migrations.length === 0) {\n    return 0;\n  }\n  return migrations[migrations.length - 1].version;\n}\nasync function migrate(path, backends, repoOptions, toVersion, {ignoreLock = false, onProgress, isDryRun = false, migrations}) {\n  migrations = migrations || index;\n  if (!path) {\n    throw new errors.RequiredParameterError('Path argument is required!');\n  }\n  if (!repoOptions) {\n    throw new errors.RequiredParameterError('repoOptions argument is required!');\n  }\n  if (!toVersion) {\n    throw new errors.RequiredParameterError('toVersion argument is required!');\n  }\n  if (!Number.isInteger(toVersion) || toVersion <= 0) {\n    throw new errors.InvalidValueError('Version has to be positive integer!');\n  }\n  backends = utils.wrapBackends(backends);\n  const currentVersion = await version.getVersion(backends);\n  if (currentVersion === toVersion) {\n    log('Nothing to migrate.');\n    return;\n  }\n  if (currentVersion > toVersion) {\n    throw new errors.InvalidValueError(`Current repo's version (${ currentVersion }) is higher then toVersion (${ toVersion }), you probably wanted to revert it?`);\n  }\n  verifyAvailableMigrations(migrations, currentVersion, toVersion);\n  let lock;\n  if (!isDryRun && !ignoreLock) {\n    lock = await repoOptions.repoLock.lock(path);\n  }\n  try {\n    for (const migration of migrations) {\n      if (toVersion !== undefined && migration.version > toVersion) {\n        break;\n      }\n      if (migration.version <= currentVersion) {\n        continue;\n      }\n      log(`Migrating version ${ migration.version }`);\n      try {\n        if (!isDryRun) {\n          let progressCallback = () => {\n          };\n          if (onProgress) {\n            progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message);\n          }\n          await migration.migrate(backends, progressCallback);\n        }\n      } catch (e) {\n        const lastSuccessfullyMigratedVersion = migration.version - 1;\n        log(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${ lastSuccessfullyMigratedVersion }`);\n        await version.setVersion(lastSuccessfullyMigratedVersion, backends);\n        throw new Error(`During migration to version ${ migration.version } exception was raised: ${ e.stack || e.message || e }`);\n      }\n      log(`Migrating to version ${ migration.version } finished`);\n    }\n    if (!isDryRun) {\n      await version.setVersion(toVersion || getLatestMigrationVersion(migrations), backends);\n    }\n    log('Repo successfully migrated', toVersion !== undefined ? `to version ${ toVersion }!` : 'to latest version!');\n  } finally {\n    if (!isDryRun && !ignoreLock && lock) {\n      await lock.close();\n    }\n  }\n}\nasync function revert(path, backends, repoOptions, toVersion, {ignoreLock = false, onProgress, isDryRun = false, migrations}) {\n  migrations = migrations || index;\n  if (!path) {\n    throw new errors.RequiredParameterError('Path argument is required!');\n  }\n  if (!repoOptions) {\n    throw new errors.RequiredParameterError('repoOptions argument is required!');\n  }\n  if (!toVersion) {\n    throw new errors.RequiredParameterError('When reverting migrations, you have to specify to which version to revert!');\n  }\n  if (!Number.isInteger(toVersion) || toVersion <= 0) {\n    throw new errors.InvalidValueError('Version has to be positive integer!');\n  }\n  backends = utils.wrapBackends(backends);\n  const currentVersion = await version.getVersion(backends);\n  if (currentVersion === toVersion) {\n    log('Nothing to revert.');\n    return;\n  }\n  if (currentVersion < toVersion) {\n    throw new errors.InvalidValueError(`Current repo's version (${ currentVersion }) is lower then toVersion (${ toVersion }), you probably wanted to migrate it?`);\n  }\n  verifyAvailableMigrations(migrations, toVersion, currentVersion, true);\n  let lock;\n  if (!isDryRun && !ignoreLock) {\n    lock = await repoOptions.repoLock.lock(path);\n  }\n  log(`Reverting from version ${ currentVersion } to ${ toVersion }`);\n  try {\n    const reversedMigrationArray = migrations.slice().reverse();\n    for (const migration of reversedMigrationArray) {\n      if (migration.version <= toVersion) {\n        break;\n      }\n      if (migration.version > currentVersion) {\n        continue;\n      }\n      log(`Reverting migration version ${ migration.version }`);\n      try {\n        if (!isDryRun) {\n          let progressCallback = () => {\n          };\n          if (onProgress) {\n            progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message);\n          }\n          await migration.revert(backends, progressCallback);\n        }\n      } catch (e) {\n        const lastSuccessfullyRevertedVersion = migration.version;\n        log(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${ lastSuccessfullyRevertedVersion }`);\n        await version.setVersion(lastSuccessfullyRevertedVersion, backends);\n        e.message = `During reversion to version ${ migration.version } exception was raised: ${ e.message }`;\n        throw e;\n      }\n      log(`Reverting to version ${ migration.version } finished`);\n    }\n    if (!isDryRun) {\n      await version.setVersion(toVersion, backends);\n    }\n    log(`All migrations successfully reverted to version ${ toVersion }!`);\n  } finally {\n    if (!isDryRun && !ignoreLock && lock) {\n      await lock.close();\n    }\n  }\n}\nfunction verifyAvailableMigrations(migrations, fromVersion, toVersion, checkReversibility = false) {\n  let migrationCounter = 0;\n  for (const migration of migrations) {\n    if (migration.version > toVersion) {\n      break;\n    }\n    if (migration.version > fromVersion) {\n      if (checkReversibility && !migration.revert) {\n        throw new errors.NonReversibleMigrationError(`It is not possible to revert to version ${ fromVersion } because migration version ${ migration.version } is not reversible. Cancelling reversion.`);\n      }\n      migrationCounter++;\n    }\n  }\n  if (migrationCounter !== toVersion - fromVersion) {\n    throw new errors.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${ fromVersion } to ${ toVersion }`);\n  }\n}\nconst getCurrentRepoVersion = version.getVersion;\nconst errors = errors$1;\nconst migrations = index;\n\nexports.errors = errors;\nexports.getCurrentRepoVersion = getCurrentRepoVersion;\nexports.getLatestMigrationVersion = getLatestMigrationVersion;\nexports.migrate = migrate;\nexports.migrations = migrations;\nexports.revert = revert;\n"]},"metadata":{},"sourceType":"script"}