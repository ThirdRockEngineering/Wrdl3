{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar dagPB = require('@ipld/dag-pb');\n\nvar cid = require('multiformats/cid');\n\nvar debug = require('debug');\n\nvar ipfsUnixfs = require('ipfs-unixfs');\n\nvar hamtUtils = require('./hamt-utils.js');\n\nvar errCode = require('err-code');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar dagPB__namespace = /*#__PURE__*/_interopNamespace(dagPB);\n\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\n\nconst log = debug__default[\"default\"]('ipfs:mfs:core:utils:remove-link');\n\nasync function removeLink(context, options) {\n  let parent = options.parent;\n\n  if (options.parentCid) {\n    const parentCid = cid.CID.asCID(options.parentCid);\n\n    if (parentCid === null) {\n      throw errCode__default[\"default\"](new Error('Invalid CID passed to removeLink'), 'EINVALIDPARENTCID');\n    }\n\n    log(`Loading parent node ${parentCid}`);\n    const block = await context.repo.blocks.get(parentCid);\n    parent = dagPB__namespace.decode(block);\n  }\n\n  if (!parent) {\n    throw errCode__default[\"default\"](new Error('No parent node or CID passed to removeLink'), 'EINVALIDPARENT');\n  }\n\n  if (!options.name) {\n    throw errCode__default[\"default\"](new Error('No child name passed to removeLink'), 'EINVALIDCHILDNAME');\n  }\n\n  if (!parent.Data) {\n    throw errCode__default[\"default\"](new Error('Parent node had no data'), 'ERR_INVALID_NODE');\n  }\n\n  const meta = ipfsUnixfs.UnixFS.unmarshal(parent.Data);\n\n  if (meta.type === 'hamt-sharded-directory') {\n    log(`Removing ${options.name} from sharded directory`);\n    return removeFromShardedDirectory(context, { ...options,\n      parent\n    });\n  }\n\n  log(`Removing link ${options.name} regular directory`);\n  return removeFromDirectory(context, { ...options,\n    parent\n  });\n}\n\nconst removeFromDirectory = async (context, options) => {\n  options.parent.Links = options.parent.Links.filter(link => {\n    return link.Name !== options.name;\n  });\n  const parentBlock = await dagPB__namespace.encode(options.parent);\n  const hasher = await context.hashers.getHasher(options.hashAlg);\n  const hash = await hasher.digest(parentBlock);\n  const parentCid = cid.CID.create(options.cidVersion, dagPB__namespace.code, hash);\n  await context.repo.blocks.put(parentCid, parentBlock);\n  log(`Updated regular directory ${parentCid}`);\n  return {\n    node: options.parent,\n    cid: parentCid\n  };\n};\n\nconst removeFromShardedDirectory = async (context, options) => {\n  const {\n    rootBucket,\n    path\n  } = await hamtUtils.generatePath(context, options.name, options.parent);\n  await rootBucket.del(options.name);\n  const {\n    node\n  } = await updateShard(context, path, options.name, options);\n  return hamtUtils.updateHamtDirectory(context, node.Links, rootBucket, options);\n};\n\nconst updateShard = async (context, positions, name, options) => {\n  const last = positions.pop();\n\n  if (!last) {\n    throw errCode__default[\"default\"](new Error('Could not find parent'), 'EINVALIDPARENT');\n  }\n\n  const {\n    bucket,\n    prefix,\n    node\n  } = last;\n\n  if (!node) {\n    throw errCode__default[\"default\"](new Error('Could not find parent'), 'EINVALIDPARENT');\n  }\n\n  const link = node.Links.find(link => (link.Name || '').substring(0, 2) === prefix);\n\n  if (!link) {\n    throw errCode__default[\"default\"](new Error(`No link found with prefix ${prefix} for file ${name}`), 'ERR_NOT_FOUND');\n  }\n\n  if (link.Name === `${prefix}${name}`) {\n    log(`Removing existing link ${link.Name}`);\n    const links = node.Links.filter(nodeLink => {\n      return nodeLink.Name !== link.Name;\n    });\n    await bucket.del(name);\n    return hamtUtils.updateHamtDirectory(context, links, bucket, options);\n  }\n\n  log(`Descending into sub-shard ${link.Name} for ${prefix}${name}`);\n  const result = await updateShard(context, positions, name, options);\n  let cid = result.cid;\n  let size = result.size;\n  let newName = prefix;\n\n  if (result.node.Links.length === 1) {\n    log(`Removing subshard for ${prefix}`);\n    const link = result.node.Links[0];\n    newName = `${prefix}${(link.Name || '').substring(2)}`;\n    cid = link.Hash;\n    size = link.Tsize || 0;\n  }\n\n  log(`Updating shard ${prefix} with name ${newName}`);\n  return updateShardParent(context, bucket, node, prefix, newName, size, cid, options);\n};\n\nconst updateShardParent = (context, bucket, parent, oldName, newName, size, cid, options) => {\n  const parentLinks = parent.Links.filter(link => {\n    return link.Name !== oldName;\n  });\n  parentLinks.push({\n    Name: newName,\n    Tsize: size,\n    Hash: cid\n  });\n  return hamtUtils.updateHamtDirectory(context, parentLinks, bucket, options);\n};\n\nexports.removeLink = removeLink;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-core/cjs/src/components/files/utils/remove-link.js"],"names":["Object","defineProperty","exports","value","dagPB","require","cid","debug","ipfsUnixfs","hamtUtils","errCode","_interopDefaultLegacy","e","_interopNamespace","__esModule","n","create","keys","forEach","k","d","getOwnPropertyDescriptor","get","enumerable","freeze","dagPB__namespace","debug__default","errCode__default","log","removeLink","context","options","parent","parentCid","CID","asCID","Error","block","repo","blocks","decode","name","Data","meta","UnixFS","unmarshal","type","removeFromShardedDirectory","removeFromDirectory","Links","filter","link","Name","parentBlock","encode","hasher","hashers","getHasher","hashAlg","hash","digest","cidVersion","code","put","node","rootBucket","path","generatePath","del","updateShard","updateHamtDirectory","positions","last","pop","bucket","prefix","find","substring","links","nodeLink","result","size","newName","length","Hash","Tsize","updateShardParent","oldName","parentLinks","push"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AAEA,IAAIC,KAAK,GAAGC,OAAO,CAAC,cAAD,CAAnB;;AACA,IAAIC,GAAG,GAAGD,OAAO,CAAC,kBAAD,CAAjB;;AACA,IAAIE,KAAK,GAAGF,OAAO,CAAC,OAAD,CAAnB;;AACA,IAAIG,UAAU,GAAGH,OAAO,CAAC,aAAD,CAAxB;;AACA,IAAII,SAAS,GAAGJ,OAAO,CAAC,iBAAD,CAAvB;;AACA,IAAIK,OAAO,GAAGL,OAAO,CAAC,UAAD,CAArB;;AAEA,SAASM,qBAAT,CAAgCC,CAAhC,EAAmC;AAAE,SAAOA,CAAC,IAAI,OAAOA,CAAP,KAAa,QAAlB,IAA8B,aAAaA,CAA3C,GAA+CA,CAA/C,GAAmD;AAAE,eAAWA;AAAb,GAA1D;AAA6E;;AAElH,SAASC,iBAAT,CAA2BD,CAA3B,EAA8B;AAC5B,MAAIA,CAAC,IAAIA,CAAC,CAACE,UAAX,EAAuB,OAAOF,CAAP;AACvB,MAAIG,CAAC,GAAGf,MAAM,CAACgB,MAAP,CAAc,IAAd,CAAR;;AACA,MAAIJ,CAAJ,EAAO;AACLZ,IAAAA,MAAM,CAACiB,IAAP,CAAYL,CAAZ,EAAeM,OAAf,CAAuB,UAAUC,CAAV,EAAa;AAClC,UAAIA,CAAC,KAAK,SAAV,EAAqB;AACnB,YAAIC,CAAC,GAAGpB,MAAM,CAACqB,wBAAP,CAAgCT,CAAhC,EAAmCO,CAAnC,CAAR;AACAnB,QAAAA,MAAM,CAACC,cAAP,CAAsBc,CAAtB,EAAyBI,CAAzB,EAA4BC,CAAC,CAACE,GAAF,GAAQF,CAAR,GAAY;AACtCG,UAAAA,UAAU,EAAE,IAD0B;AAEtCD,UAAAA,GAAG,EAAE,YAAY;AAAE,mBAAOV,CAAC,CAACO,CAAD,CAAR;AAAc;AAFK,SAAxC;AAID;AACF,KARD;AASD;;AACDJ,EAAAA,CAAC,CAAC,SAAD,CAAD,GAAeH,CAAf;AACA,SAAOZ,MAAM,CAACwB,MAAP,CAAcT,CAAd,CAAP;AACD;;AAED,IAAIU,gBAAgB,GAAG,aAAaZ,iBAAiB,CAACT,KAAD,CAArD;;AACA,IAAIsB,cAAc,GAAG,aAAaf,qBAAqB,CAACJ,KAAD,CAAvD;;AACA,IAAIoB,gBAAgB,GAAG,aAAahB,qBAAqB,CAACD,OAAD,CAAzD;;AAEA,MAAMkB,GAAG,GAAGF,cAAc,CAAC,SAAD,CAAd,CAA0B,iCAA1B,CAAZ;;AACA,eAAeG,UAAf,CAA0BC,OAA1B,EAAmCC,OAAnC,EAA4C;AAC1C,MAAIC,MAAM,GAAGD,OAAO,CAACC,MAArB;;AACA,MAAID,OAAO,CAACE,SAAZ,EAAuB;AACrB,UAAMA,SAAS,GAAG3B,GAAG,CAAC4B,GAAJ,CAAQC,KAAR,CAAcJ,OAAO,CAACE,SAAtB,CAAlB;;AACA,QAAIA,SAAS,KAAK,IAAlB,EAAwB;AACtB,YAAMN,gBAAgB,CAAC,SAAD,CAAhB,CAA4B,IAAIS,KAAJ,CAAU,kCAAV,CAA5B,EAA2E,mBAA3E,CAAN;AACD;;AACDR,IAAAA,GAAG,CAAE,uBAAuBK,SAAW,EAApC,CAAH;AACA,UAAMI,KAAK,GAAG,MAAMP,OAAO,CAACQ,IAAR,CAAaC,MAAb,CAAoBjB,GAApB,CAAwBW,SAAxB,CAApB;AACAD,IAAAA,MAAM,GAAGP,gBAAgB,CAACe,MAAjB,CAAwBH,KAAxB,CAAT;AACD;;AACD,MAAI,CAACL,MAAL,EAAa;AACX,UAAML,gBAAgB,CAAC,SAAD,CAAhB,CAA4B,IAAIS,KAAJ,CAAU,4CAAV,CAA5B,EAAqF,gBAArF,CAAN;AACD;;AACD,MAAI,CAACL,OAAO,CAACU,IAAb,EAAmB;AACjB,UAAMd,gBAAgB,CAAC,SAAD,CAAhB,CAA4B,IAAIS,KAAJ,CAAU,oCAAV,CAA5B,EAA6E,mBAA7E,CAAN;AACD;;AACD,MAAI,CAACJ,MAAM,CAACU,IAAZ,EAAkB;AAChB,UAAMf,gBAAgB,CAAC,SAAD,CAAhB,CAA4B,IAAIS,KAAJ,CAAU,yBAAV,CAA5B,EAAkE,kBAAlE,CAAN;AACD;;AACD,QAAMO,IAAI,GAAGnC,UAAU,CAACoC,MAAX,CAAkBC,SAAlB,CAA4Bb,MAAM,CAACU,IAAnC,CAAb;;AACA,MAAIC,IAAI,CAACG,IAAL,KAAc,wBAAlB,EAA4C;AAC1ClB,IAAAA,GAAG,CAAE,YAAYG,OAAO,CAACU,IAAM,yBAA5B,CAAH;AACA,WAAOM,0BAA0B,CAACjB,OAAD,EAAU,EACzC,GAAGC,OADsC;AAEzCC,MAAAA;AAFyC,KAAV,CAAjC;AAID;;AACDJ,EAAAA,GAAG,CAAE,iBAAiBG,OAAO,CAACU,IAAM,oBAAjC,CAAH;AACA,SAAOO,mBAAmB,CAAClB,OAAD,EAAU,EAClC,GAAGC,OAD+B;AAElCC,IAAAA;AAFkC,GAAV,CAA1B;AAID;;AACD,MAAMgB,mBAAmB,GAAG,OAAOlB,OAAP,EAAgBC,OAAhB,KAA4B;AACtDA,EAAAA,OAAO,CAACC,MAAR,CAAeiB,KAAf,GAAuBlB,OAAO,CAACC,MAAR,CAAeiB,KAAf,CAAqBC,MAArB,CAA4BC,IAAI,IAAI;AACzD,WAAOA,IAAI,CAACC,IAAL,KAAcrB,OAAO,CAACU,IAA7B;AACD,GAFsB,CAAvB;AAGA,QAAMY,WAAW,GAAG,MAAM5B,gBAAgB,CAAC6B,MAAjB,CAAwBvB,OAAO,CAACC,MAAhC,CAA1B;AACA,QAAMuB,MAAM,GAAG,MAAMzB,OAAO,CAAC0B,OAAR,CAAgBC,SAAhB,CAA0B1B,OAAO,CAAC2B,OAAlC,CAArB;AACA,QAAMC,IAAI,GAAG,MAAMJ,MAAM,CAACK,MAAP,CAAcP,WAAd,CAAnB;AACA,QAAMpB,SAAS,GAAG3B,GAAG,CAAC4B,GAAJ,CAAQlB,MAAR,CAAee,OAAO,CAAC8B,UAAvB,EAAmCpC,gBAAgB,CAACqC,IAApD,EAA0DH,IAA1D,CAAlB;AACA,QAAM7B,OAAO,CAACQ,IAAR,CAAaC,MAAb,CAAoBwB,GAApB,CAAwB9B,SAAxB,EAAmCoB,WAAnC,CAAN;AACAzB,EAAAA,GAAG,CAAE,6BAA6BK,SAAW,EAA1C,CAAH;AACA,SAAO;AACL+B,IAAAA,IAAI,EAAEjC,OAAO,CAACC,MADT;AAEL1B,IAAAA,GAAG,EAAE2B;AAFA,GAAP;AAID,CAdD;;AAeA,MAAMc,0BAA0B,GAAG,OAAOjB,OAAP,EAAgBC,OAAhB,KAA4B;AAC7D,QAAM;AAACkC,IAAAA,UAAD;AAAaC,IAAAA;AAAb,MAAqB,MAAMzD,SAAS,CAAC0D,YAAV,CAAuBrC,OAAvB,EAAgCC,OAAO,CAACU,IAAxC,EAA8CV,OAAO,CAACC,MAAtD,CAAjC;AACA,QAAMiC,UAAU,CAACG,GAAX,CAAerC,OAAO,CAACU,IAAvB,CAAN;AACA,QAAM;AAACuB,IAAAA;AAAD,MAAS,MAAMK,WAAW,CAACvC,OAAD,EAAUoC,IAAV,EAAgBnC,OAAO,CAACU,IAAxB,EAA8BV,OAA9B,CAAhC;AACA,SAAOtB,SAAS,CAAC6D,mBAAV,CAA8BxC,OAA9B,EAAuCkC,IAAI,CAACf,KAA5C,EAAmDgB,UAAnD,EAA+DlC,OAA/D,CAAP;AACD,CALD;;AAMA,MAAMsC,WAAW,GAAG,OAAOvC,OAAP,EAAgByC,SAAhB,EAA2B9B,IAA3B,EAAiCV,OAAjC,KAA6C;AAC/D,QAAMyC,IAAI,GAAGD,SAAS,CAACE,GAAV,EAAb;;AACA,MAAI,CAACD,IAAL,EAAW;AACT,UAAM7C,gBAAgB,CAAC,SAAD,CAAhB,CAA4B,IAAIS,KAAJ,CAAU,uBAAV,CAA5B,EAAgE,gBAAhE,CAAN;AACD;;AACD,QAAM;AAACsC,IAAAA,MAAD;AAASC,IAAAA,MAAT;AAAiBX,IAAAA;AAAjB,MAAyBQ,IAA/B;;AACA,MAAI,CAACR,IAAL,EAAW;AACT,UAAMrC,gBAAgB,CAAC,SAAD,CAAhB,CAA4B,IAAIS,KAAJ,CAAU,uBAAV,CAA5B,EAAgE,gBAAhE,CAAN;AACD;;AACD,QAAMe,IAAI,GAAGa,IAAI,CAACf,KAAL,CAAW2B,IAAX,CAAgBzB,IAAI,IAAI,CAACA,IAAI,CAACC,IAAL,IAAa,EAAd,EAAkByB,SAAlB,CAA4B,CAA5B,EAA+B,CAA/B,MAAsCF,MAA9D,CAAb;;AACA,MAAI,CAACxB,IAAL,EAAW;AACT,UAAMxB,gBAAgB,CAAC,SAAD,CAAhB,CAA4B,IAAIS,KAAJ,CAAW,6BAA6BuC,MAAQ,aAAalC,IAAM,EAAnE,CAA5B,EAAmG,eAAnG,CAAN;AACD;;AACD,MAAIU,IAAI,CAACC,IAAL,KAAe,GAAGuB,MAAQ,GAAGlC,IAAM,EAAvC,EAA0C;AACxCb,IAAAA,GAAG,CAAE,0BAA0BuB,IAAI,CAACC,IAAM,EAAvC,CAAH;AACA,UAAM0B,KAAK,GAAGd,IAAI,CAACf,KAAL,CAAWC,MAAX,CAAkB6B,QAAQ,IAAI;AAC1C,aAAOA,QAAQ,CAAC3B,IAAT,KAAkBD,IAAI,CAACC,IAA9B;AACD,KAFa,CAAd;AAGA,UAAMsB,MAAM,CAACN,GAAP,CAAW3B,IAAX,CAAN;AACA,WAAOhC,SAAS,CAAC6D,mBAAV,CAA8BxC,OAA9B,EAAuCgD,KAAvC,EAA8CJ,MAA9C,EAAsD3C,OAAtD,CAAP;AACD;;AACDH,EAAAA,GAAG,CAAE,6BAA6BuB,IAAI,CAACC,IAAM,QAAQuB,MAAQ,GAAGlC,IAAM,EAAnE,CAAH;AACA,QAAMuC,MAAM,GAAG,MAAMX,WAAW,CAACvC,OAAD,EAAUyC,SAAV,EAAqB9B,IAArB,EAA2BV,OAA3B,CAAhC;AACA,MAAIzB,GAAG,GAAG0E,MAAM,CAAC1E,GAAjB;AACA,MAAI2E,IAAI,GAAGD,MAAM,CAACC,IAAlB;AACA,MAAIC,OAAO,GAAGP,MAAd;;AACA,MAAIK,MAAM,CAAChB,IAAP,CAAYf,KAAZ,CAAkBkC,MAAlB,KAA6B,CAAjC,EAAoC;AAClCvD,IAAAA,GAAG,CAAE,yBAAyB+C,MAAQ,EAAnC,CAAH;AACA,UAAMxB,IAAI,GAAG6B,MAAM,CAAChB,IAAP,CAAYf,KAAZ,CAAkB,CAAlB,CAAb;AACAiC,IAAAA,OAAO,GAAI,GAAGP,MAAQ,GAAG,CAACxB,IAAI,CAACC,IAAL,IAAa,EAAd,EAAkByB,SAAlB,CAA4B,CAA5B,CAAgC,EAAzD;AACAvE,IAAAA,GAAG,GAAG6C,IAAI,CAACiC,IAAX;AACAH,IAAAA,IAAI,GAAG9B,IAAI,CAACkC,KAAL,IAAc,CAArB;AACD;;AACDzD,EAAAA,GAAG,CAAE,kBAAkB+C,MAAQ,cAAcO,OAAS,EAAnD,CAAH;AACA,SAAOI,iBAAiB,CAACxD,OAAD,EAAU4C,MAAV,EAAkBV,IAAlB,EAAwBW,MAAxB,EAAgCO,OAAhC,EAAyCD,IAAzC,EAA+C3E,GAA/C,EAAoDyB,OAApD,CAAxB;AACD,CAnCD;;AAoCA,MAAMuD,iBAAiB,GAAG,CAACxD,OAAD,EAAU4C,MAAV,EAAkB1C,MAAlB,EAA0BuD,OAA1B,EAAmCL,OAAnC,EAA4CD,IAA5C,EAAkD3E,GAAlD,EAAuDyB,OAAvD,KAAmE;AAC3F,QAAMyD,WAAW,GAAGxD,MAAM,CAACiB,KAAP,CAAaC,MAAb,CAAoBC,IAAI,IAAI;AAC9C,WAAOA,IAAI,CAACC,IAAL,KAAcmC,OAArB;AACD,GAFmB,CAApB;AAGAC,EAAAA,WAAW,CAACC,IAAZ,CAAiB;AACfrC,IAAAA,IAAI,EAAE8B,OADS;AAEfG,IAAAA,KAAK,EAAEJ,IAFQ;AAGfG,IAAAA,IAAI,EAAE9E;AAHS,GAAjB;AAKA,SAAOG,SAAS,CAAC6D,mBAAV,CAA8BxC,OAA9B,EAAuC0D,WAAvC,EAAoDd,MAApD,EAA4D3C,OAA5D,CAAP;AACD,CAVD;;AAYA7B,OAAO,CAAC2B,UAAR,GAAqBA,UAArB","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar dagPB = require('@ipld/dag-pb');\nvar cid = require('multiformats/cid');\nvar debug = require('debug');\nvar ipfsUnixfs = require('ipfs-unixfs');\nvar hamtUtils = require('./hamt-utils.js');\nvar errCode = require('err-code');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar dagPB__namespace = /*#__PURE__*/_interopNamespace(dagPB);\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\n\nconst log = debug__default[\"default\"]('ipfs:mfs:core:utils:remove-link');\nasync function removeLink(context, options) {\n  let parent = options.parent;\n  if (options.parentCid) {\n    const parentCid = cid.CID.asCID(options.parentCid);\n    if (parentCid === null) {\n      throw errCode__default[\"default\"](new Error('Invalid CID passed to removeLink'), 'EINVALIDPARENTCID');\n    }\n    log(`Loading parent node ${ parentCid }`);\n    const block = await context.repo.blocks.get(parentCid);\n    parent = dagPB__namespace.decode(block);\n  }\n  if (!parent) {\n    throw errCode__default[\"default\"](new Error('No parent node or CID passed to removeLink'), 'EINVALIDPARENT');\n  }\n  if (!options.name) {\n    throw errCode__default[\"default\"](new Error('No child name passed to removeLink'), 'EINVALIDCHILDNAME');\n  }\n  if (!parent.Data) {\n    throw errCode__default[\"default\"](new Error('Parent node had no data'), 'ERR_INVALID_NODE');\n  }\n  const meta = ipfsUnixfs.UnixFS.unmarshal(parent.Data);\n  if (meta.type === 'hamt-sharded-directory') {\n    log(`Removing ${ options.name } from sharded directory`);\n    return removeFromShardedDirectory(context, {\n      ...options,\n      parent\n    });\n  }\n  log(`Removing link ${ options.name } regular directory`);\n  return removeFromDirectory(context, {\n    ...options,\n    parent\n  });\n}\nconst removeFromDirectory = async (context, options) => {\n  options.parent.Links = options.parent.Links.filter(link => {\n    return link.Name !== options.name;\n  });\n  const parentBlock = await dagPB__namespace.encode(options.parent);\n  const hasher = await context.hashers.getHasher(options.hashAlg);\n  const hash = await hasher.digest(parentBlock);\n  const parentCid = cid.CID.create(options.cidVersion, dagPB__namespace.code, hash);\n  await context.repo.blocks.put(parentCid, parentBlock);\n  log(`Updated regular directory ${ parentCid }`);\n  return {\n    node: options.parent,\n    cid: parentCid\n  };\n};\nconst removeFromShardedDirectory = async (context, options) => {\n  const {rootBucket, path} = await hamtUtils.generatePath(context, options.name, options.parent);\n  await rootBucket.del(options.name);\n  const {node} = await updateShard(context, path, options.name, options);\n  return hamtUtils.updateHamtDirectory(context, node.Links, rootBucket, options);\n};\nconst updateShard = async (context, positions, name, options) => {\n  const last = positions.pop();\n  if (!last) {\n    throw errCode__default[\"default\"](new Error('Could not find parent'), 'EINVALIDPARENT');\n  }\n  const {bucket, prefix, node} = last;\n  if (!node) {\n    throw errCode__default[\"default\"](new Error('Could not find parent'), 'EINVALIDPARENT');\n  }\n  const link = node.Links.find(link => (link.Name || '').substring(0, 2) === prefix);\n  if (!link) {\n    throw errCode__default[\"default\"](new Error(`No link found with prefix ${ prefix } for file ${ name }`), 'ERR_NOT_FOUND');\n  }\n  if (link.Name === `${ prefix }${ name }`) {\n    log(`Removing existing link ${ link.Name }`);\n    const links = node.Links.filter(nodeLink => {\n      return nodeLink.Name !== link.Name;\n    });\n    await bucket.del(name);\n    return hamtUtils.updateHamtDirectory(context, links, bucket, options);\n  }\n  log(`Descending into sub-shard ${ link.Name } for ${ prefix }${ name }`);\n  const result = await updateShard(context, positions, name, options);\n  let cid = result.cid;\n  let size = result.size;\n  let newName = prefix;\n  if (result.node.Links.length === 1) {\n    log(`Removing subshard for ${ prefix }`);\n    const link = result.node.Links[0];\n    newName = `${ prefix }${ (link.Name || '').substring(2) }`;\n    cid = link.Hash;\n    size = link.Tsize || 0;\n  }\n  log(`Updating shard ${ prefix } with name ${ newName }`);\n  return updateShardParent(context, bucket, node, prefix, newName, size, cid, options);\n};\nconst updateShardParent = (context, bucket, parent, oldName, newName, size, cid, options) => {\n  const parentLinks = parent.Links.filter(link => {\n    return link.Name !== oldName;\n  });\n  parentLinks.push({\n    Name: newName,\n    Tsize: size,\n    Hash: cid\n  });\n  return hamtUtils.updateHamtDirectory(context, parentLinks, bucket, options);\n};\n\nexports.removeLink = removeLink;\n"]},"metadata":{},"sourceType":"script"}