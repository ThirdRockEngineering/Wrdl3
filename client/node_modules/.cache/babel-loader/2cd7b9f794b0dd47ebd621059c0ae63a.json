{"ast":null,"code":"const getIterator = require('get-iterator');\n\nconst AbortError = require('./AbortError'); // Wrap an iterator to make it abortable, allow cleanup when aborted via onAbort\n\n\nconst toAbortableSource = (source, signal, options) => toMultiAbortableSource(source, Array.isArray(signal) ? signal : [{\n  signal,\n  options\n}]);\n\nconst toMultiAbortableSource = (source, signals) => {\n  source = getIterator(source);\n  signals = signals.map(_ref => {\n    let {\n      signal,\n      options\n    } = _ref;\n    return {\n      signal,\n      options: options || {}\n    };\n  });\n\n  async function* abortable() {\n    let nextAbortHandler;\n\n    const abortHandler = () => {\n      if (nextAbortHandler) nextAbortHandler();\n    };\n\n    for (const {\n      signal\n    } of signals) {\n      signal.addEventListener('abort', abortHandler);\n    }\n\n    while (true) {\n      let result;\n\n      try {\n        for (const {\n          signal,\n          options\n        } of signals) {\n          if (signal.aborted) {\n            const {\n              abortMessage,\n              abortCode\n            } = options;\n            throw new AbortError(abortMessage, abortCode);\n          }\n        }\n\n        const abort = new Promise((resolve, reject) => {\n          nextAbortHandler = () => {\n            const {\n              options\n            } = signals.find(_ref2 => {\n              let {\n                signal\n              } = _ref2;\n              return signal.aborted;\n            });\n            const {\n              abortMessage,\n              abortCode\n            } = options;\n            reject(new AbortError(abortMessage, abortCode));\n          };\n        }); // Race the iterator and the abort signals\n\n        result = await Promise.race([abort, source.next()]);\n        nextAbortHandler = null;\n      } catch (err) {\n        for (const {\n          signal\n        } of signals) {\n          signal.removeEventListener('abort', abortHandler);\n        } // Might not have been aborted by a known signal\n\n\n        const aborter = signals.find(_ref3 => {\n          let {\n            signal\n          } = _ref3;\n          return signal.aborted;\n        });\n        const isKnownAborter = err.type === 'aborted' && aborter;\n\n        if (isKnownAborter && aborter.options.onAbort) {\n          // Do any custom abort handling for the iterator\n          await aborter.options.onAbort(source);\n        } // End the iterator if it is a generator\n\n\n        if (typeof source.return === 'function') {\n          try {\n            const p = source.return();\n\n            if (p instanceof Promise) {\n              // eslint-disable-line max-depth\n              p.catch(err => {\n                if (aborter.options.onReturnError != null) {\n                  aborter.options.onReturnError(err);\n                }\n              });\n            }\n          } catch (err) {\n            if (aborter.options.onReturnError != null) {\n              // eslint-disable-line max-depth\n              aborter.options.onReturnError(err);\n            }\n          }\n        }\n\n        if (isKnownAborter && aborter.options.returnOnAbort) {\n          return;\n        }\n\n        throw err;\n      }\n\n      if (result.done) break;\n      yield result.value;\n    }\n\n    for (const {\n      signal\n    } of signals) {\n      signal.removeEventListener('abort', abortHandler);\n    }\n  }\n\n  return abortable();\n};\n\nconst toAbortableSink = (sink, signal, options) => toMultiAbortableSink(sink, Array.isArray(signal) ? signal : [{\n  signal,\n  options\n}]);\n\nconst toMultiAbortableSink = (sink, signals) => source => sink(toMultiAbortableSource(source, signals));\n\nconst toAbortableDuplex = (duplex, signal, options) => toMultiAbortableDuplex(duplex, Array.isArray(signal) ? signal : [{\n  signal,\n  options\n}]);\n\nconst toMultiAbortableDuplex = (duplex, signals) => ({\n  sink: toMultiAbortableSink(duplex.sink, signals),\n  source: toMultiAbortableSource(duplex.source, signals)\n});\n\nmodule.exports = toAbortableSource;\nmodule.exports.AbortError = AbortError;\nmodule.exports.source = toAbortableSource;\nmodule.exports.sink = toAbortableSink;\nmodule.exports.transform = toAbortableSink;\nmodule.exports.duplex = toAbortableDuplex;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/abortable-iterator/index.js"],"names":["getIterator","require","AbortError","toAbortableSource","source","signal","options","toMultiAbortableSource","Array","isArray","signals","map","abortable","nextAbortHandler","abortHandler","addEventListener","result","aborted","abortMessage","abortCode","abort","Promise","resolve","reject","find","race","next","err","removeEventListener","aborter","isKnownAborter","type","onAbort","return","p","catch","onReturnError","returnOnAbort","done","value","toAbortableSink","sink","toMultiAbortableSink","toAbortableDuplex","duplex","toMultiAbortableDuplex","module","exports","transform"],"mappings":"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","sourcesContent":["const getIterator = require('get-iterator')\nconst AbortError = require('./AbortError')\n\n// Wrap an iterator to make it abortable, allow cleanup when aborted via onAbort\nconst toAbortableSource = (source, signal, options) => (\n  toMultiAbortableSource(source, Array.isArray(signal) ? signal : [{ signal, options }])\n)\n\nconst toMultiAbortableSource = (source, signals) => {\n  source = getIterator(source)\n  signals = signals.map(({ signal, options }) => ({ signal, options: options || {} }))\n\n  async function * abortable () {\n    let nextAbortHandler\n    const abortHandler = () => {\n      if (nextAbortHandler) nextAbortHandler()\n    }\n\n    for (const { signal } of signals) {\n      signal.addEventListener('abort', abortHandler)\n    }\n\n    while (true) {\n      let result\n      try {\n        for (const { signal, options } of signals) {\n          if (signal.aborted) {\n            const { abortMessage, abortCode } = options\n            throw new AbortError(abortMessage, abortCode)\n          }\n        }\n\n        const abort = new Promise((resolve, reject) => {\n          nextAbortHandler = () => {\n            const { options } = signals.find(({ signal }) => signal.aborted)\n            const { abortMessage, abortCode } = options\n            reject(new AbortError(abortMessage, abortCode))\n          }\n        })\n\n        // Race the iterator and the abort signals\n        result = await Promise.race([abort, source.next()])\n        nextAbortHandler = null\n      } catch (err) {\n        for (const { signal } of signals) {\n          signal.removeEventListener('abort', abortHandler)\n        }\n\n        // Might not have been aborted by a known signal\n        const aborter = signals.find(({ signal }) => signal.aborted)\n        const isKnownAborter = err.type === 'aborted' && aborter\n\n        if (isKnownAborter && aborter.options.onAbort) {\n          // Do any custom abort handling for the iterator\n          await aborter.options.onAbort(source)\n        }\n\n        // End the iterator if it is a generator\n        if (typeof source.return === 'function') {\n          try {\n            const p = source.return()\n\n            if (p instanceof Promise) { // eslint-disable-line max-depth\n              p.catch(err => {\n                if (aborter.options.onReturnError != null) {\n                  aborter.options.onReturnError(err)\n                }\n              })\n            }\n          } catch (err) {\n            if (aborter.options.onReturnError != null) { // eslint-disable-line max-depth\n              aborter.options.onReturnError(err)\n            }\n          }\n        }\n\n        if (isKnownAborter && aborter.options.returnOnAbort) {\n          return\n        }\n\n        throw err\n      }\n\n      if (result.done) break\n      yield result.value\n    }\n\n    for (const { signal } of signals) {\n      signal.removeEventListener('abort', abortHandler)\n    }\n  }\n\n  return abortable()\n}\n\nconst toAbortableSink = (sink, signal, options) => (\n  toMultiAbortableSink(sink, Array.isArray(signal) ? signal : [{ signal, options }])\n)\n\nconst toMultiAbortableSink = (sink, signals) => source => (\n  sink(toMultiAbortableSource(source, signals))\n)\n\nconst toAbortableDuplex = (duplex, signal, options) => (\n  toMultiAbortableDuplex(duplex, Array.isArray(signal) ? signal : [{ signal, options }])\n)\n\nconst toMultiAbortableDuplex = (duplex, signals) => ({\n  sink: toMultiAbortableSink(duplex.sink, signals),\n  source: toMultiAbortableSource(duplex.source, signals)\n})\n\nmodule.exports = toAbortableSource\nmodule.exports.AbortError = AbortError\nmodule.exports.source = toAbortableSource\nmodule.exports.sink = toAbortableSink\nmodule.exports.transform = toAbortableSink\nmodule.exports.duplex = toAbortableDuplex\n"]},"metadata":{},"sourceType":"script"}