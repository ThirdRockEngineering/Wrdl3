{"ast":null,"code":"'use strict';\n\nconst errCode = require('err-code');\n\nconst {\n  messages,\n  codes\n} = require('../errors');\n\nconst {\n  storeAddresses,\n  uniquePeers,\n  requirePeers,\n  maybeLimitSource\n} = require('./utils');\n\nconst drain = require('it-drain');\n\nconst merge = require('it-merge');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst {\n  DHTContentRouting\n} = require('../dht/dht-content-routing');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('libp2p-interfaces/src/content-routing/types').ContentRouting} ContentRoutingModule\n */\n\n/**\n * @typedef {Object} GetData\n * @property {PeerId} from\n * @property {Uint8Array} val\n */\n\n\nclass ContentRouting {\n  /**\n   * @class\n   * @param {import('..')} libp2p\n   */\n  constructor(libp2p) {\n    this.libp2p = libp2p;\n    /** @type {ContentRoutingModule[]} */\n\n    this.routers = libp2p._modules.contentRouting || [];\n    this.dht = libp2p._dht; // If we have the dht, add it to the available content routers\n\n    if (this.dht && libp2p._config.dht.enabled) {\n      this.routers.push(new DHTContentRouting(this.dht));\n    }\n  }\n  /**\n   * Iterates over all content routers in parallel to find providers of the given key.\n   *\n   * @param {CID} key - The CID key of the content to find\n   * @param {object} [options]\n   * @param {number} [options.timeout] - How long the query should run\n   * @param {number} [options.maxNumProviders] - maximum number of providers to find\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n\n\n  async *findProviders(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!this.routers.length) {\n      throw errCode(new Error('No content this.routers available'), codes.ERR_NO_ROUTERS_AVAILABLE);\n    }\n\n    yield* pipe(merge(...this.routers.map(router => router.findProviders(key, options))), source => storeAddresses(source, this.libp2p.peerStore), source => uniquePeers(source), source => maybeLimitSource(source, options.maxNumProviders), source => requirePeers(source));\n  }\n  /**\n   * Iterates over all content routers in parallel to notify it is\n   * a provider of the given key.\n   *\n   * @param {CID} key - The CID key of the content to find\n   * @returns {Promise<void>}\n   */\n\n\n  async provide(key) {\n    if (!this.routers.length) {\n      throw errCode(new Error('No content routers available'), codes.ERR_NO_ROUTERS_AVAILABLE);\n    }\n\n    await Promise.all(this.routers.map(router => router.provide(key)));\n  }\n  /**\n   * Store the given key/value pair in the DHT.\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} value\n   * @param {Object} [options] - put options\n   * @param {number} [options.minPeers] - minimum number of peers required to successfully put\n   * @returns {Promise<void>}\n   */\n\n\n  async put(key, value, options) {\n    if (!this.libp2p.isStarted() || !this.dht.isStarted) {\n      throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);\n    }\n\n    await drain(this.dht.put(key, value, options));\n  }\n  /**\n   * Get the value to the given key.\n   * Times out after 1 minute by default.\n   *\n   * @param {Uint8Array} key\n   * @param {Object} [options] - get options\n   * @param {number} [options.timeout] - optional timeout (default: 60000)\n   * @returns {Promise<GetData>}\n   */\n\n\n  async get(key, options) {\n    if (!this.libp2p.isStarted() || !this.dht.isStarted) {\n      throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);\n    }\n\n    for await (const event of this.dht.get(key, options)) {\n      if (event.name === 'VALUE') {\n        return {\n          from: event.peerId,\n          val: event.value\n        };\n      }\n    }\n\n    throw errCode(new Error(messages.NOT_FOUND), codes.ERR_NOT_FOUND);\n  }\n  /**\n   * Get the `n` values to the given key without sorting.\n   *\n   * @param {Uint8Array} key\n   * @param {number} nVals\n   * @param {Object} [options] - get options\n   * @param {number} [options.timeout] - optional timeout (default: 60000)\n   */\n\n\n  async *getMany(key, nVals, options) {\n    // eslint-disable-line require-await\n    if (!this.libp2p.isStarted() || !this.dht.isStarted) {\n      throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);\n    }\n\n    if (!nVals) {\n      return;\n    }\n\n    let gotValues = 0;\n\n    for await (const event of this.dht.get(key, options)) {\n      if (event.name === 'VALUE') {\n        yield {\n          from: event.peerId,\n          val: event.value\n        };\n        gotValues++;\n\n        if (gotValues === nVals) {\n          break;\n        }\n      }\n    }\n\n    if (gotValues === 0) {\n      throw errCode(new Error(messages.NOT_FOUND), codes.ERR_NOT_FOUND);\n    }\n  }\n\n}\n\nmodule.exports = ContentRouting;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p/src/content-routing/index.js"],"names":["errCode","require","messages","codes","storeAddresses","uniquePeers","requirePeers","maybeLimitSource","drain","merge","pipe","DHTContentRouting","ContentRouting","constructor","libp2p","routers","_modules","contentRouting","dht","_dht","_config","enabled","push","findProviders","key","options","length","Error","ERR_NO_ROUTERS_AVAILABLE","map","router","source","peerStore","maxNumProviders","provide","Promise","all","put","value","isStarted","NOT_STARTED_YET","DHT_NOT_STARTED","get","event","name","from","peerId","val","NOT_FOUND","ERR_NOT_FOUND","getMany","nVals","gotValues","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst { messages, codes } = require('../errors')\nconst {\n  storeAddresses,\n  uniquePeers,\n  requirePeers,\n  maybeLimitSource\n} = require('./utils')\nconst drain = require('it-drain')\nconst merge = require('it-merge')\nconst { pipe } = require('it-pipe')\nconst { DHTContentRouting } = require('../dht/dht-content-routing')\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('libp2p-interfaces/src/content-routing/types').ContentRouting} ContentRoutingModule\n */\n\n/**\n * @typedef {Object} GetData\n * @property {PeerId} from\n * @property {Uint8Array} val\n */\n\nclass ContentRouting {\n  /**\n   * @class\n   * @param {import('..')} libp2p\n   */\n  constructor (libp2p) {\n    this.libp2p = libp2p\n    /** @type {ContentRoutingModule[]} */\n    this.routers = libp2p._modules.contentRouting || []\n    this.dht = libp2p._dht\n\n    // If we have the dht, add it to the available content routers\n    if (this.dht && libp2p._config.dht.enabled) {\n      this.routers.push(new DHTContentRouting(this.dht))\n    }\n  }\n\n  /**\n   * Iterates over all content routers in parallel to find providers of the given key.\n   *\n   * @param {CID} key - The CID key of the content to find\n   * @param {object} [options]\n   * @param {number} [options.timeout] - How long the query should run\n   * @param {number} [options.maxNumProviders] - maximum number of providers to find\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n  async * findProviders (key, options = {}) {\n    if (!this.routers.length) {\n      throw errCode(new Error('No content this.routers available'), codes.ERR_NO_ROUTERS_AVAILABLE)\n    }\n\n    yield * pipe(\n      merge(\n        ...this.routers.map(router => router.findProviders(key, options))\n      ),\n      (source) => storeAddresses(source, this.libp2p.peerStore),\n      (source) => uniquePeers(source),\n      (source) => maybeLimitSource(source, options.maxNumProviders),\n      (source) => requirePeers(source)\n    )\n  }\n\n  /**\n   * Iterates over all content routers in parallel to notify it is\n   * a provider of the given key.\n   *\n   * @param {CID} key - The CID key of the content to find\n   * @returns {Promise<void>}\n   */\n  async provide (key) {\n    if (!this.routers.length) {\n      throw errCode(new Error('No content routers available'), codes.ERR_NO_ROUTERS_AVAILABLE)\n    }\n\n    await Promise.all(this.routers.map((router) => router.provide(key)))\n  }\n\n  /**\n   * Store the given key/value pair in the DHT.\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} value\n   * @param {Object} [options] - put options\n   * @param {number} [options.minPeers] - minimum number of peers required to successfully put\n   * @returns {Promise<void>}\n   */\n  async put (key, value, options) {\n    if (!this.libp2p.isStarted() || !this.dht.isStarted) {\n      throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED)\n    }\n\n    await drain(this.dht.put(key, value, options))\n  }\n\n  /**\n   * Get the value to the given key.\n   * Times out after 1 minute by default.\n   *\n   * @param {Uint8Array} key\n   * @param {Object} [options] - get options\n   * @param {number} [options.timeout] - optional timeout (default: 60000)\n   * @returns {Promise<GetData>}\n   */\n  async get (key, options) {\n    if (!this.libp2p.isStarted() || !this.dht.isStarted) {\n      throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED)\n    }\n\n    for await (const event of this.dht.get(key, options)) {\n      if (event.name === 'VALUE') {\n        return { from: event.peerId, val: event.value }\n      }\n    }\n\n    throw errCode(new Error(messages.NOT_FOUND), codes.ERR_NOT_FOUND)\n  }\n\n  /**\n   * Get the `n` values to the given key without sorting.\n   *\n   * @param {Uint8Array} key\n   * @param {number} nVals\n   * @param {Object} [options] - get options\n   * @param {number} [options.timeout] - optional timeout (default: 60000)\n   */\n  async * getMany (key, nVals, options) { // eslint-disable-line require-await\n    if (!this.libp2p.isStarted() || !this.dht.isStarted) {\n      throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED)\n    }\n\n    if (!nVals) {\n      return\n    }\n\n    let gotValues = 0\n\n    for await (const event of this.dht.get(key, options)) {\n      if (event.name === 'VALUE') {\n        yield { from: event.peerId, val: event.value }\n\n        gotValues++\n\n        if (gotValues === nVals) {\n          break\n        }\n      }\n    }\n\n    if (gotValues === 0) {\n      throw errCode(new Error(messages.NOT_FOUND), codes.ERR_NOT_FOUND)\n    }\n  }\n}\n\nmodule.exports = ContentRouting\n"]},"metadata":{},"sourceType":"script"}