{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar isIpfs = require('is-ipfs');\n\nvar cid = require('multiformats/cid');\n\nvar PeerId = require('peer-id');\n\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\n\nvar utils = require('../utils.js');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar isIpfs__default = /*#__PURE__*/_interopDefaultLegacy(isIpfs);\n\nvar PeerId__default = /*#__PURE__*/_interopDefaultLegacy(PeerId);\n\nfunction createResolve(_ref) {\n  let {\n    repo,\n    codecs,\n    bases,\n    name\n  } = _ref;\n\n  async function resolve(path) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!isIpfs__default[\"default\"].path(path)) {\n      throw new Error('invalid argument ' + path);\n    }\n\n    if (isIpfs__default[\"default\"].ipnsPath(path)) {\n      for await (const resolvedPath of name.resolve(path, opts)) {\n        path = resolvedPath;\n      }\n    }\n\n    const [, schema, hash, ...rest] = path.split('/');\n    const base = opts.cidBase ? await bases.getBase(opts.cidBase) : undefined;\n    const bytes = parseBytes(hash);\n\n    if (rest.length === 0) {\n      const str = base ? base.encoder.encode(bytes) : hash;\n      return `/${schema}/${str}`;\n    }\n\n    const cid$1 = cid.CID.decode(bytes);\n    path = rest.join('/');\n    const results = utils.resolve(cid$1, path, codecs, repo, opts);\n    let value = cid$1;\n    let remainderPath = path;\n\n    for await (const result of results) {\n      if (cid.CID.asCID(result.value)) {\n        value = result.value;\n        remainderPath = result.remainderPath;\n      }\n    }\n\n    return `/ipfs/${value.toString(base && base.encoder)}${remainderPath ? '/' + remainderPath : ''}`;\n  }\n\n  return withTimeoutOption.withTimeoutOption(resolve);\n}\n\nfunction parseBytes(str) {\n  try {\n    return PeerId__default[\"default\"].parse(str).toBytes();\n  } catch {\n    return cid.CID.parse(str).bytes;\n  }\n}\n\nexports.createResolve = createResolve;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-core/cjs/src/components/resolve.js"],"names":["Object","defineProperty","exports","value","isIpfs","require","cid","PeerId","withTimeoutOption","utils","_interopDefaultLegacy","e","isIpfs__default","PeerId__default","createResolve","repo","codecs","bases","name","resolve","path","opts","Error","ipnsPath","resolvedPath","schema","hash","rest","split","base","cidBase","getBase","undefined","bytes","parseBytes","length","str","encoder","encode","cid$1","CID","decode","join","results","remainderPath","result","asCID","toString","parse","toBytes"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar isIpfs = require('is-ipfs');\nvar cid = require('multiformats/cid');\nvar PeerId = require('peer-id');\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\nvar utils = require('../utils.js');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar isIpfs__default = /*#__PURE__*/_interopDefaultLegacy(isIpfs);\nvar PeerId__default = /*#__PURE__*/_interopDefaultLegacy(PeerId);\n\nfunction createResolve({repo, codecs, bases, name}) {\n  async function resolve(path, opts = {}) {\n    if (!isIpfs__default[\"default\"].path(path)) {\n      throw new Error('invalid argument ' + path);\n    }\n    if (isIpfs__default[\"default\"].ipnsPath(path)) {\n      for await (const resolvedPath of name.resolve(path, opts)) {\n        path = resolvedPath;\n      }\n    }\n    const [, schema, hash, ...rest] = path.split('/');\n    const base = opts.cidBase ? await bases.getBase(opts.cidBase) : undefined;\n    const bytes = parseBytes(hash);\n    if (rest.length === 0) {\n      const str = base ? base.encoder.encode(bytes) : hash;\n      return `/${ schema }/${ str }`;\n    }\n    const cid$1 = cid.CID.decode(bytes);\n    path = rest.join('/');\n    const results = utils.resolve(cid$1, path, codecs, repo, opts);\n    let value = cid$1;\n    let remainderPath = path;\n    for await (const result of results) {\n      if (cid.CID.asCID(result.value)) {\n        value = result.value;\n        remainderPath = result.remainderPath;\n      }\n    }\n    return `/ipfs/${ value.toString(base && base.encoder) }${ remainderPath ? '/' + remainderPath : '' }`;\n  }\n  return withTimeoutOption.withTimeoutOption(resolve);\n}\nfunction parseBytes(str) {\n  try {\n    return PeerId__default[\"default\"].parse(str).toBytes();\n  } catch {\n    return cid.CID.parse(str).bytes;\n  }\n}\n\nexports.createResolve = createResolve;\n"]},"metadata":{},"sourceType":"script"}