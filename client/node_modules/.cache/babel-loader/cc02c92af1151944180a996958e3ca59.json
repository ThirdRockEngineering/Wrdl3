{"ast":null,"code":"'use strict';\n\nconst supports = require('level-supports');\n\nconst isBuffer = require('is-buffer');\n\nconst catering = require('catering');\n\nconst AbstractIterator = require('./abstract-iterator');\n\nconst AbstractChainedBatch = require('./abstract-chained-batch');\n\nconst getCallback = require('./lib/common').getCallback;\n\nconst getOptions = require('./lib/common').getOptions;\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst rangeOptions = ['lt', 'lte', 'gt', 'gte'];\n\nfunction AbstractLevelDOWN(manifest) {\n  this.status = 'new'; // TODO (next major): make this mandatory\n\n  this.supports = supports(manifest, {\n    status: true\n  });\n}\n\nAbstractLevelDOWN.prototype.open = function (options, callback) {\n  const oldStatus = this.status;\n  if (typeof options === 'function') callback = options;\n\n  if (typeof callback !== 'function') {\n    throw new Error('open() requires a callback argument');\n  }\n\n  if (typeof options !== 'object' || options === null) options = {};\n  options.createIfMissing = options.createIfMissing !== false;\n  options.errorIfExists = !!options.errorIfExists;\n  this.status = 'opening';\n\n  this._open(options, err => {\n    if (err) {\n      this.status = oldStatus;\n      return callback(err);\n    }\n\n    this.status = 'open';\n    callback();\n  });\n};\n\nAbstractLevelDOWN.prototype._open = function (options, callback) {\n  this._nextTick(callback);\n};\n\nAbstractLevelDOWN.prototype.close = function (callback) {\n  const oldStatus = this.status;\n\n  if (typeof callback !== 'function') {\n    throw new Error('close() requires a callback argument');\n  }\n\n  this.status = 'closing';\n\n  this._close(err => {\n    if (err) {\n      this.status = oldStatus;\n      return callback(err);\n    }\n\n    this.status = 'closed';\n    callback();\n  });\n};\n\nAbstractLevelDOWN.prototype._close = function (callback) {\n  this._nextTick(callback);\n};\n\nAbstractLevelDOWN.prototype.get = function (key, options, callback) {\n  if (typeof options === 'function') callback = options;\n\n  if (typeof callback !== 'function') {\n    throw new Error('get() requires a callback argument');\n  }\n\n  const err = this._checkKey(key);\n\n  if (err) return this._nextTick(callback, err);\n  key = this._serializeKey(key);\n  if (typeof options !== 'object' || options === null) options = {};\n  options.asBuffer = options.asBuffer !== false;\n\n  this._get(key, options, callback);\n};\n\nAbstractLevelDOWN.prototype._get = function (key, options, callback) {\n  this._nextTick(function () {\n    callback(new Error('NotFound'));\n  });\n};\n\nAbstractLevelDOWN.prototype.getMany = function (keys, options, callback) {\n  callback = getCallback(options, callback);\n  callback = catering.fromCallback(callback);\n  options = getOptions(options);\n\n  if (maybeError(this, callback)) {\n    return callback.promise;\n  }\n\n  if (!Array.isArray(keys)) {\n    this._nextTick(callback, new Error('getMany() requires an array argument'));\n\n    return callback.promise;\n  }\n\n  if (keys.length === 0) {\n    this._nextTick(callback, null, []);\n\n    return callback.promise;\n  }\n\n  if (typeof options.asBuffer !== 'boolean') {\n    options = { ...options,\n      asBuffer: true\n    };\n  }\n\n  const serialized = new Array(keys.length);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n\n    const err = this._checkKey(key);\n\n    if (err) {\n      this._nextTick(callback, err);\n\n      return callback.promise;\n    }\n\n    serialized[i] = this._serializeKey(key);\n  }\n\n  this._getMany(serialized, options, callback);\n\n  return callback.promise;\n};\n\nAbstractLevelDOWN.prototype._getMany = function (keys, options, callback) {\n  this._nextTick(callback, null, new Array(keys.length).fill(undefined));\n};\n\nAbstractLevelDOWN.prototype.put = function (key, value, options, callback) {\n  if (typeof options === 'function') callback = options;\n\n  if (typeof callback !== 'function') {\n    throw new Error('put() requires a callback argument');\n  }\n\n  const err = this._checkKey(key) || this._checkValue(value);\n\n  if (err) return this._nextTick(callback, err);\n  key = this._serializeKey(key);\n  value = this._serializeValue(value);\n  if (typeof options !== 'object' || options === null) options = {};\n\n  this._put(key, value, options, callback);\n};\n\nAbstractLevelDOWN.prototype._put = function (key, value, options, callback) {\n  this._nextTick(callback);\n};\n\nAbstractLevelDOWN.prototype.del = function (key, options, callback) {\n  if (typeof options === 'function') callback = options;\n\n  if (typeof callback !== 'function') {\n    throw new Error('del() requires a callback argument');\n  }\n\n  const err = this._checkKey(key);\n\n  if (err) return this._nextTick(callback, err);\n  key = this._serializeKey(key);\n  if (typeof options !== 'object' || options === null) options = {};\n\n  this._del(key, options, callback);\n};\n\nAbstractLevelDOWN.prototype._del = function (key, options, callback) {\n  this._nextTick(callback);\n};\n\nAbstractLevelDOWN.prototype.batch = function (array, options, callback) {\n  if (!arguments.length) return this._chainedBatch();\n  if (typeof options === 'function') callback = options;\n  if (typeof array === 'function') callback = array;\n\n  if (typeof callback !== 'function') {\n    throw new Error('batch(array) requires a callback argument');\n  }\n\n  if (!Array.isArray(array)) {\n    return this._nextTick(callback, new Error('batch(array) requires an array argument'));\n  }\n\n  if (array.length === 0) {\n    return this._nextTick(callback);\n  }\n\n  if (typeof options !== 'object' || options === null) options = {};\n  const serialized = new Array(array.length);\n\n  for (let i = 0; i < array.length; i++) {\n    if (typeof array[i] !== 'object' || array[i] === null) {\n      return this._nextTick(callback, new Error('batch(array) element must be an object and not `null`'));\n    }\n\n    const e = Object.assign({}, array[i]);\n\n    if (e.type !== 'put' && e.type !== 'del') {\n      return this._nextTick(callback, new Error(\"`type` must be 'put' or 'del'\"));\n    }\n\n    const err = this._checkKey(e.key);\n\n    if (err) return this._nextTick(callback, err);\n    e.key = this._serializeKey(e.key);\n\n    if (e.type === 'put') {\n      const valueErr = this._checkValue(e.value);\n\n      if (valueErr) return this._nextTick(callback, valueErr);\n      e.value = this._serializeValue(e.value);\n    }\n\n    serialized[i] = e;\n  }\n\n  this._batch(serialized, options, callback);\n};\n\nAbstractLevelDOWN.prototype._batch = function (array, options, callback) {\n  this._nextTick(callback);\n};\n\nAbstractLevelDOWN.prototype.clear = function (options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n  } else if (typeof callback !== 'function') {\n    throw new Error('clear() requires a callback argument');\n  }\n\n  options = cleanRangeOptions(this, options);\n  options.reverse = !!options.reverse;\n  options.limit = 'limit' in options ? options.limit : -1;\n\n  this._clear(options, callback);\n};\n\nAbstractLevelDOWN.prototype._clear = function (options, callback) {\n  // Avoid setupIteratorOptions, would serialize range options a second time.\n  options.keys = true;\n  options.values = false;\n  options.keyAsBuffer = true;\n  options.valueAsBuffer = true;\n\n  const iterator = this._iterator(options);\n\n  const emptyOptions = {};\n\n  const next = err => {\n    if (err) {\n      return iterator.end(function () {\n        callback(err);\n      });\n    }\n\n    iterator.next((err, key) => {\n      if (err) return next(err);\n      if (key === undefined) return iterator.end(callback); // This could be optimized by using a batch, but the default _clear\n      // is not meant to be fast. Implementations have more room to optimize\n      // if they override _clear. Note: using _del bypasses key serialization.\n\n      this._del(key, emptyOptions, next);\n    });\n  };\n\n  next();\n};\n\nAbstractLevelDOWN.prototype._setupIteratorOptions = function (options) {\n  options = cleanRangeOptions(this, options);\n  options.reverse = !!options.reverse;\n  options.keys = options.keys !== false;\n  options.values = options.values !== false;\n  options.limit = 'limit' in options ? options.limit : -1;\n  options.keyAsBuffer = options.keyAsBuffer !== false;\n  options.valueAsBuffer = options.valueAsBuffer !== false;\n  return options;\n};\n\nfunction cleanRangeOptions(db, options) {\n  const result = {};\n\n  for (const k in options) {\n    if (!hasOwnProperty.call(options, k)) continue;\n\n    if (k === 'start' || k === 'end') {\n      throw new Error('Legacy range options (\"start\" and \"end\") have been removed');\n    }\n\n    let opt = options[k];\n\n    if (isRangeOption(k)) {\n      // Note that we don't reject nullish and empty options here. While\n      // those types are invalid as keys, they are valid as range options.\n      opt = db._serializeKey(opt);\n    }\n\n    result[k] = opt;\n  }\n\n  return result;\n}\n\nfunction isRangeOption(k) {\n  return rangeOptions.indexOf(k) !== -1;\n}\n\nAbstractLevelDOWN.prototype.iterator = function (options) {\n  if (typeof options !== 'object' || options === null) options = {};\n  options = this._setupIteratorOptions(options);\n  return this._iterator(options);\n};\n\nAbstractLevelDOWN.prototype._iterator = function (options) {\n  return new AbstractIterator(this);\n};\n\nAbstractLevelDOWN.prototype._chainedBatch = function () {\n  return new AbstractChainedBatch(this);\n};\n\nAbstractLevelDOWN.prototype._serializeKey = function (key) {\n  return key;\n};\n\nAbstractLevelDOWN.prototype._serializeValue = function (value) {\n  return value;\n};\n\nAbstractLevelDOWN.prototype._checkKey = function (key) {\n  if (key === null || key === undefined) {\n    return new Error('key cannot be `null` or `undefined`');\n  } else if (isBuffer(key) && key.length === 0) {\n    // TODO: replace with typed array check\n    return new Error('key cannot be an empty Buffer');\n  } else if (key === '') {\n    return new Error('key cannot be an empty String');\n  } else if (Array.isArray(key) && key.length === 0) {\n    return new Error('key cannot be an empty Array');\n  }\n};\n\nAbstractLevelDOWN.prototype._checkValue = function (value) {\n  if (value === null || value === undefined) {\n    return new Error('value cannot be `null` or `undefined`');\n  }\n}; // TODO: docs and tests\n\n\nAbstractLevelDOWN.prototype.isOperational = function () {\n  return this.status === 'open' || this._isOperational();\n}; // Implementation may accept operations in other states too\n\n\nAbstractLevelDOWN.prototype._isOperational = function () {\n  return false;\n}; // Expose browser-compatible nextTick for dependents\n// TODO: rename _nextTick to _queueMicrotask\n// TODO: after we drop node 10, also use queueMicrotask in node\n\n\nAbstractLevelDOWN.prototype._nextTick = require('./next-tick');\nmodule.exports = AbstractLevelDOWN;\n\nfunction maybeError(db, callback) {\n  if (!db.isOperational()) {\n    db._nextTick(callback, new Error('Database is not open'));\n\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/abstract-leveldown/abstract-leveldown.js"],"names":["supports","require","isBuffer","catering","AbstractIterator","AbstractChainedBatch","getCallback","getOptions","hasOwnProperty","Object","prototype","rangeOptions","AbstractLevelDOWN","manifest","status","open","options","callback","oldStatus","Error","createIfMissing","errorIfExists","_open","err","_nextTick","close","_close","get","key","_checkKey","_serializeKey","asBuffer","_get","getMany","keys","fromCallback","maybeError","promise","Array","isArray","length","serialized","i","_getMany","fill","undefined","put","value","_checkValue","_serializeValue","_put","del","_del","batch","array","arguments","_chainedBatch","e","assign","type","valueErr","_batch","clear","cleanRangeOptions","reverse","limit","_clear","values","keyAsBuffer","valueAsBuffer","iterator","_iterator","emptyOptions","next","end","_setupIteratorOptions","db","result","k","call","opt","isRangeOption","indexOf","isOperational","_isOperational","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst supports = require('level-supports')\nconst isBuffer = require('is-buffer')\nconst catering = require('catering')\nconst AbstractIterator = require('./abstract-iterator')\nconst AbstractChainedBatch = require('./abstract-chained-batch')\nconst getCallback = require('./lib/common').getCallback\nconst getOptions = require('./lib/common').getOptions\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\nconst rangeOptions = ['lt', 'lte', 'gt', 'gte']\n\nfunction AbstractLevelDOWN (manifest) {\n  this.status = 'new'\n\n  // TODO (next major): make this mandatory\n  this.supports = supports(manifest, {\n    status: true\n  })\n}\n\nAbstractLevelDOWN.prototype.open = function (options, callback) {\n  const oldStatus = this.status\n\n  if (typeof options === 'function') callback = options\n\n  if (typeof callback !== 'function') {\n    throw new Error('open() requires a callback argument')\n  }\n\n  if (typeof options !== 'object' || options === null) options = {}\n\n  options.createIfMissing = options.createIfMissing !== false\n  options.errorIfExists = !!options.errorIfExists\n\n  this.status = 'opening'\n  this._open(options, (err) => {\n    if (err) {\n      this.status = oldStatus\n      return callback(err)\n    }\n    this.status = 'open'\n    callback()\n  })\n}\n\nAbstractLevelDOWN.prototype._open = function (options, callback) {\n  this._nextTick(callback)\n}\n\nAbstractLevelDOWN.prototype.close = function (callback) {\n  const oldStatus = this.status\n\n  if (typeof callback !== 'function') {\n    throw new Error('close() requires a callback argument')\n  }\n\n  this.status = 'closing'\n  this._close((err) => {\n    if (err) {\n      this.status = oldStatus\n      return callback(err)\n    }\n    this.status = 'closed'\n    callback()\n  })\n}\n\nAbstractLevelDOWN.prototype._close = function (callback) {\n  this._nextTick(callback)\n}\n\nAbstractLevelDOWN.prototype.get = function (key, options, callback) {\n  if (typeof options === 'function') callback = options\n\n  if (typeof callback !== 'function') {\n    throw new Error('get() requires a callback argument')\n  }\n\n  const err = this._checkKey(key)\n  if (err) return this._nextTick(callback, err)\n\n  key = this._serializeKey(key)\n\n  if (typeof options !== 'object' || options === null) options = {}\n\n  options.asBuffer = options.asBuffer !== false\n\n  this._get(key, options, callback)\n}\n\nAbstractLevelDOWN.prototype._get = function (key, options, callback) {\n  this._nextTick(function () { callback(new Error('NotFound')) })\n}\n\nAbstractLevelDOWN.prototype.getMany = function (keys, options, callback) {\n  callback = getCallback(options, callback)\n  callback = catering.fromCallback(callback)\n  options = getOptions(options)\n\n  if (maybeError(this, callback)) {\n    return callback.promise\n  }\n\n  if (!Array.isArray(keys)) {\n    this._nextTick(callback, new Error('getMany() requires an array argument'))\n    return callback.promise\n  }\n\n  if (keys.length === 0) {\n    this._nextTick(callback, null, [])\n    return callback.promise\n  }\n\n  if (typeof options.asBuffer !== 'boolean') {\n    options = { ...options, asBuffer: true }\n  }\n\n  const serialized = new Array(keys.length)\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i]\n    const err = this._checkKey(key)\n\n    if (err) {\n      this._nextTick(callback, err)\n      return callback.promise\n    }\n\n    serialized[i] = this._serializeKey(key)\n  }\n\n  this._getMany(serialized, options, callback)\n  return callback.promise\n}\n\nAbstractLevelDOWN.prototype._getMany = function (keys, options, callback) {\n  this._nextTick(callback, null, new Array(keys.length).fill(undefined))\n}\n\nAbstractLevelDOWN.prototype.put = function (key, value, options, callback) {\n  if (typeof options === 'function') callback = options\n\n  if (typeof callback !== 'function') {\n    throw new Error('put() requires a callback argument')\n  }\n\n  const err = this._checkKey(key) || this._checkValue(value)\n  if (err) return this._nextTick(callback, err)\n\n  key = this._serializeKey(key)\n  value = this._serializeValue(value)\n\n  if (typeof options !== 'object' || options === null) options = {}\n\n  this._put(key, value, options, callback)\n}\n\nAbstractLevelDOWN.prototype._put = function (key, value, options, callback) {\n  this._nextTick(callback)\n}\n\nAbstractLevelDOWN.prototype.del = function (key, options, callback) {\n  if (typeof options === 'function') callback = options\n\n  if (typeof callback !== 'function') {\n    throw new Error('del() requires a callback argument')\n  }\n\n  const err = this._checkKey(key)\n  if (err) return this._nextTick(callback, err)\n\n  key = this._serializeKey(key)\n\n  if (typeof options !== 'object' || options === null) options = {}\n\n  this._del(key, options, callback)\n}\n\nAbstractLevelDOWN.prototype._del = function (key, options, callback) {\n  this._nextTick(callback)\n}\n\nAbstractLevelDOWN.prototype.batch = function (array, options, callback) {\n  if (!arguments.length) return this._chainedBatch()\n\n  if (typeof options === 'function') callback = options\n\n  if (typeof array === 'function') callback = array\n\n  if (typeof callback !== 'function') {\n    throw new Error('batch(array) requires a callback argument')\n  }\n\n  if (!Array.isArray(array)) {\n    return this._nextTick(callback, new Error('batch(array) requires an array argument'))\n  }\n\n  if (array.length === 0) {\n    return this._nextTick(callback)\n  }\n\n  if (typeof options !== 'object' || options === null) options = {}\n\n  const serialized = new Array(array.length)\n\n  for (let i = 0; i < array.length; i++) {\n    if (typeof array[i] !== 'object' || array[i] === null) {\n      return this._nextTick(callback, new Error('batch(array) element must be an object and not `null`'))\n    }\n\n    const e = Object.assign({}, array[i])\n\n    if (e.type !== 'put' && e.type !== 'del') {\n      return this._nextTick(callback, new Error(\"`type` must be 'put' or 'del'\"))\n    }\n\n    const err = this._checkKey(e.key)\n    if (err) return this._nextTick(callback, err)\n\n    e.key = this._serializeKey(e.key)\n\n    if (e.type === 'put') {\n      const valueErr = this._checkValue(e.value)\n      if (valueErr) return this._nextTick(callback, valueErr)\n\n      e.value = this._serializeValue(e.value)\n    }\n\n    serialized[i] = e\n  }\n\n  this._batch(serialized, options, callback)\n}\n\nAbstractLevelDOWN.prototype._batch = function (array, options, callback) {\n  this._nextTick(callback)\n}\n\nAbstractLevelDOWN.prototype.clear = function (options, callback) {\n  if (typeof options === 'function') {\n    callback = options\n  } else if (typeof callback !== 'function') {\n    throw new Error('clear() requires a callback argument')\n  }\n\n  options = cleanRangeOptions(this, options)\n  options.reverse = !!options.reverse\n  options.limit = 'limit' in options ? options.limit : -1\n\n  this._clear(options, callback)\n}\n\nAbstractLevelDOWN.prototype._clear = function (options, callback) {\n  // Avoid setupIteratorOptions, would serialize range options a second time.\n  options.keys = true\n  options.values = false\n  options.keyAsBuffer = true\n  options.valueAsBuffer = true\n\n  const iterator = this._iterator(options)\n  const emptyOptions = {}\n\n  const next = (err) => {\n    if (err) {\n      return iterator.end(function () {\n        callback(err)\n      })\n    }\n\n    iterator.next((err, key) => {\n      if (err) return next(err)\n      if (key === undefined) return iterator.end(callback)\n\n      // This could be optimized by using a batch, but the default _clear\n      // is not meant to be fast. Implementations have more room to optimize\n      // if they override _clear. Note: using _del bypasses key serialization.\n      this._del(key, emptyOptions, next)\n    })\n  }\n\n  next()\n}\n\nAbstractLevelDOWN.prototype._setupIteratorOptions = function (options) {\n  options = cleanRangeOptions(this, options)\n\n  options.reverse = !!options.reverse\n  options.keys = options.keys !== false\n  options.values = options.values !== false\n  options.limit = 'limit' in options ? options.limit : -1\n  options.keyAsBuffer = options.keyAsBuffer !== false\n  options.valueAsBuffer = options.valueAsBuffer !== false\n\n  return options\n}\n\nfunction cleanRangeOptions (db, options) {\n  const result = {}\n\n  for (const k in options) {\n    if (!hasOwnProperty.call(options, k)) continue\n\n    if (k === 'start' || k === 'end') {\n      throw new Error('Legacy range options (\"start\" and \"end\") have been removed')\n    }\n\n    let opt = options[k]\n\n    if (isRangeOption(k)) {\n      // Note that we don't reject nullish and empty options here. While\n      // those types are invalid as keys, they are valid as range options.\n      opt = db._serializeKey(opt)\n    }\n\n    result[k] = opt\n  }\n\n  return result\n}\n\nfunction isRangeOption (k) {\n  return rangeOptions.indexOf(k) !== -1\n}\n\nAbstractLevelDOWN.prototype.iterator = function (options) {\n  if (typeof options !== 'object' || options === null) options = {}\n  options = this._setupIteratorOptions(options)\n  return this._iterator(options)\n}\n\nAbstractLevelDOWN.prototype._iterator = function (options) {\n  return new AbstractIterator(this)\n}\n\nAbstractLevelDOWN.prototype._chainedBatch = function () {\n  return new AbstractChainedBatch(this)\n}\n\nAbstractLevelDOWN.prototype._serializeKey = function (key) {\n  return key\n}\n\nAbstractLevelDOWN.prototype._serializeValue = function (value) {\n  return value\n}\n\nAbstractLevelDOWN.prototype._checkKey = function (key) {\n  if (key === null || key === undefined) {\n    return new Error('key cannot be `null` or `undefined`')\n  } else if (isBuffer(key) && key.length === 0) { // TODO: replace with typed array check\n    return new Error('key cannot be an empty Buffer')\n  } else if (key === '') {\n    return new Error('key cannot be an empty String')\n  } else if (Array.isArray(key) && key.length === 0) {\n    return new Error('key cannot be an empty Array')\n  }\n}\n\nAbstractLevelDOWN.prototype._checkValue = function (value) {\n  if (value === null || value === undefined) {\n    return new Error('value cannot be `null` or `undefined`')\n  }\n}\n\n// TODO: docs and tests\nAbstractLevelDOWN.prototype.isOperational = function () {\n  return this.status === 'open' || this._isOperational()\n}\n\n// Implementation may accept operations in other states too\nAbstractLevelDOWN.prototype._isOperational = function () {\n  return false\n}\n\n// Expose browser-compatible nextTick for dependents\n// TODO: rename _nextTick to _queueMicrotask\n// TODO: after we drop node 10, also use queueMicrotask in node\nAbstractLevelDOWN.prototype._nextTick = require('./next-tick')\n\nmodule.exports = AbstractLevelDOWN\n\nfunction maybeError (db, callback) {\n  if (!db.isOperational()) {\n    db._nextTick(callback, new Error('Database is not open'))\n    return true\n  }\n\n  return false\n}\n"]},"metadata":{},"sourceType":"script"}