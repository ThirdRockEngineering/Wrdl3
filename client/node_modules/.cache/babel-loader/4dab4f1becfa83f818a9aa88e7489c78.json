{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar PeerId = require('peer-id');\n\nvar errCode = require('err-code');\n\nvar errors = require('../errors.js');\n\nvar get = require('dlv');\n\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\n\nvar map = require('it-map');\n\nvar cid = require('multiformats/cid');\n\nvar base58 = require('multiformats/bases/base58');\n\nvar base36 = require('multiformats/bases/base36');\n\nvar concat = require('uint8arrays/concat');\n\nvar fromString = require('uint8arrays/from-string');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar PeerId__default = /*#__PURE__*/_interopDefaultLegacy(PeerId);\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\n\nvar get__default = /*#__PURE__*/_interopDefaultLegacy(get);\n\nvar map__default = /*#__PURE__*/_interopDefaultLegacy(map);\n\nconst IPNS_PREFIX = '/ipns/';\n\nfunction toDHTKey(str) {\n  if (str.startsWith(IPNS_PREFIX)) {\n    str = str.substring(IPNS_PREFIX.length);\n  }\n\n  let buf;\n\n  if (str[0] === '1' || str[0] === 'Q') {\n    str = `z${str}`;\n  }\n\n  if (str[0] === 'z') {\n    buf = base58.base58btc.decode(str);\n  }\n\n  if (str[0] === 'k') {\n    buf = base36.base36.decode(str);\n  }\n\n  if (!buf) {\n    throw new Error('Could not parse string');\n  }\n\n  if (buf[0] !== 1 && buf[1] !== 114) {\n    buf = concat.concat([[1, 114], buf]);\n  }\n\n  if (buf.length !== 40) {\n    throw new Error('Incorrect length ' + buf.length);\n  }\n\n  return concat.concat([fromString.fromString(IPNS_PREFIX), buf.subarray(2)]);\n}\n\nfunction mapEvent(event) {\n  if (event.name === 'SENDING_QUERY') {\n    return {\n      type: event.type,\n      name: event.name,\n      to: event.to.toB58String()\n    };\n  }\n\n  if (event.name === 'PEER_RESPONSE') {\n    return {\n      type: event.type,\n      name: event.name,\n      messageType: event.messageType,\n      messageName: event.messageName,\n      closer: event.closer.map(_ref => {\n        let {\n          id,\n          multiaddrs\n        } = _ref;\n        return {\n          id: id.toB58String(),\n          multiaddrs\n        };\n      }),\n      providers: event.providers.map(_ref2 => {\n        let {\n          id,\n          multiaddrs\n        } = _ref2;\n        return {\n          id: id.toB58String(),\n          multiaddrs\n        };\n      }),\n      record: event.record,\n      from: event.from.toB58String()\n    };\n  }\n\n  if (event.name === 'FINAL_PEER') {\n    return {\n      type: event.type,\n      name: event.name,\n      from: event.from.toB58String(),\n      peer: {\n        id: event.peer.id.toB58String(),\n        multiaddrs: event.peer.multiaddrs\n      }\n    };\n  }\n\n  if (event.name === 'QUERY_ERROR') {\n    return {\n      type: event.type,\n      name: event.name,\n      error: event.error,\n      from: event.from.toB58String()\n    };\n  }\n\n  if (event.name === 'PROVIDER') {\n    return {\n      type: event.type,\n      name: event.name,\n      providers: event.providers.map(_ref3 => {\n        let {\n          id,\n          multiaddrs\n        } = _ref3;\n        return {\n          id: id.toB58String(),\n          multiaddrs\n        };\n      }),\n      from: event.from.toB58String()\n    };\n  }\n\n  if (event.name === 'VALUE') {\n    return {\n      type: event.type,\n      name: event.name,\n      value: event.value,\n      from: event.from.toB58String()\n    };\n  }\n\n  if (event.name === 'ADDING_PEER') {\n    return {\n      type: event.type,\n      name: event.name,\n      peer: event.peer.toB58String()\n    };\n  }\n\n  if (event.name === 'DIALING_PEER') {\n    return {\n      type: event.type,\n      name: event.name,\n      peer: event.peer.toB58String()\n    };\n  }\n\n  throw errCode__default[\"default\"](new Error('Unknown DHT event type'), 'ERR_UNKNOWN_DHT_EVENT');\n}\n\nfunction createDht(_ref4) {\n  let {\n    network,\n    repo,\n    peerId\n  } = _ref4;\n  const {\n    get,\n    put,\n    findProvs,\n    findPeer,\n    provide,\n    query\n  } = {\n    async *get(key) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const {\n        libp2p\n      } = await use(network, peerId, options);\n      const dhtKey = key instanceof Uint8Array ? key : toDHTKey(key);\n      yield* map__default[\"default\"](libp2p._dht.get(dhtKey, options), mapEvent);\n    },\n\n    async *put(key, value, options) {\n      const {\n        libp2p\n      } = await use(network, peerId, options);\n      const dhtKey = key instanceof Uint8Array ? key : toDHTKey(key);\n      yield* map__default[\"default\"](libp2p._dht.put(dhtKey, value), mapEvent);\n    },\n\n    async *findProvs(cid) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const {\n        libp2p\n      } = await use(network, peerId, options);\n      yield* map__default[\"default\"](libp2p._dht.findProviders(cid, {\n        signal: options.signal\n      }), mapEvent);\n    },\n\n    async *findPeer(peerIdToFind) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const {\n        libp2p\n      } = await use(network, peerId, options);\n      yield* map__default[\"default\"](libp2p._dht.findPeer(PeerId__default[\"default\"].parse(peerIdToFind), {\n        signal: options.signal\n      }), mapEvent);\n    },\n\n    async *provide(cid) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        recursive: false\n      };\n      const {\n        libp2p\n      } = await use(network, peerId, options);\n      const hasBlock = await repo.blocks.has(cid);\n\n      if (!hasBlock) {\n        throw errCode__default[\"default\"](new Error('block(s) not found locally, cannot provide'), 'ERR_BLOCK_NOT_FOUND');\n      }\n\n      if (options.recursive) {\n        throw errCode__default[\"default\"](new Error('not implemented yet'), 'ERR_NOT_IMPLEMENTED_YET');\n      }\n\n      yield* map__default[\"default\"](libp2p._dht.provide(cid), mapEvent);\n    },\n\n    async *query(peerIdToQuery) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const {\n        libp2p\n      } = await use(network, peerId, options);\n      let bytes;\n      const asCid = cid.CID.asCID(peerIdToQuery);\n\n      if (asCid != null) {\n        bytes = asCid.multihash.bytes;\n      } else {\n        bytes = PeerId__default[\"default\"].parse(peerIdToQuery.toString()).toBytes();\n      }\n\n      yield* map__default[\"default\"](libp2p._dht.getClosestPeers(bytes, options), mapEvent);\n    }\n\n  };\n  return {\n    get: withTimeoutOption.withTimeoutOption(get),\n    put: withTimeoutOption.withTimeoutOption(put),\n    findProvs: withTimeoutOption.withTimeoutOption(findProvs),\n    findPeer: withTimeoutOption.withTimeoutOption(findPeer),\n    provide: withTimeoutOption.withTimeoutOption(provide),\n    query: withTimeoutOption.withTimeoutOption(query)\n  };\n}\n\nconst use = async (network, peerId, options) => {\n  const net = await network.use(options);\n\n  if (get__default[\"default\"](net.libp2p, '_config.dht.enabled', false)) {\n    return net;\n  } else {\n    const fn = async function* () {\n      yield {\n        from: peerId,\n        name: 'QUERY_ERROR',\n        type: 3,\n        error: new errors.NotEnabledError('dht not enabled')\n      };\n    };\n\n    return {\n      libp2p: {\n        _dht: {\n          get: fn,\n          put: fn,\n          findProvs: fn,\n          findPeer: fn,\n          provide: fn,\n          query: fn\n        }\n      }\n    };\n  }\n};\n\nexports.createDht = createDht;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-core/cjs/src/components/dht.js"],"names":["Object","defineProperty","exports","value","PeerId","require","errCode","errors","get","withTimeoutOption","map","cid","base58","base36","concat","fromString","_interopDefaultLegacy","e","PeerId__default","errCode__default","get__default","map__default","IPNS_PREFIX","toDHTKey","str","startsWith","substring","length","buf","base58btc","decode","Error","subarray","mapEvent","event","name","type","to","toB58String","messageType","messageName","closer","id","multiaddrs","providers","record","from","peer","error","createDht","network","repo","peerId","put","findProvs","findPeer","provide","query","key","options","libp2p","use","dhtKey","Uint8Array","_dht","findProviders","signal","peerIdToFind","parse","recursive","hasBlock","blocks","has","peerIdToQuery","bytes","asCid","CID","asCID","multihash","toString","toBytes","getClosestPeers","net","fn","NotEnabledError"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar PeerId = require('peer-id');\nvar errCode = require('err-code');\nvar errors = require('../errors.js');\nvar get = require('dlv');\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\nvar map = require('it-map');\nvar cid = require('multiformats/cid');\nvar base58 = require('multiformats/bases/base58');\nvar base36 = require('multiformats/bases/base36');\nvar concat = require('uint8arrays/concat');\nvar fromString = require('uint8arrays/from-string');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar PeerId__default = /*#__PURE__*/_interopDefaultLegacy(PeerId);\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\nvar get__default = /*#__PURE__*/_interopDefaultLegacy(get);\nvar map__default = /*#__PURE__*/_interopDefaultLegacy(map);\n\nconst IPNS_PREFIX = '/ipns/';\nfunction toDHTKey(str) {\n  if (str.startsWith(IPNS_PREFIX)) {\n    str = str.substring(IPNS_PREFIX.length);\n  }\n  let buf;\n  if (str[0] === '1' || str[0] === 'Q') {\n    str = `z${ str }`;\n  }\n  if (str[0] === 'z') {\n    buf = base58.base58btc.decode(str);\n  }\n  if (str[0] === 'k') {\n    buf = base36.base36.decode(str);\n  }\n  if (!buf) {\n    throw new Error('Could not parse string');\n  }\n  if (buf[0] !== 1 && buf[1] !== 114) {\n    buf = concat.concat([\n      [\n        1,\n        114\n      ],\n      buf\n    ]);\n  }\n  if (buf.length !== 40) {\n    throw new Error('Incorrect length ' + buf.length);\n  }\n  return concat.concat([\n    fromString.fromString(IPNS_PREFIX),\n    buf.subarray(2)\n  ]);\n}\nfunction mapEvent(event) {\n  if (event.name === 'SENDING_QUERY') {\n    return {\n      type: event.type,\n      name: event.name,\n      to: event.to.toB58String()\n    };\n  }\n  if (event.name === 'PEER_RESPONSE') {\n    return {\n      type: event.type,\n      name: event.name,\n      messageType: event.messageType,\n      messageName: event.messageName,\n      closer: event.closer.map(({id, multiaddrs}) => ({\n        id: id.toB58String(),\n        multiaddrs\n      })),\n      providers: event.providers.map(({id, multiaddrs}) => ({\n        id: id.toB58String(),\n        multiaddrs\n      })),\n      record: event.record,\n      from: event.from.toB58String()\n    };\n  }\n  if (event.name === 'FINAL_PEER') {\n    return {\n      type: event.type,\n      name: event.name,\n      from: event.from.toB58String(),\n      peer: {\n        id: event.peer.id.toB58String(),\n        multiaddrs: event.peer.multiaddrs\n      }\n    };\n  }\n  if (event.name === 'QUERY_ERROR') {\n    return {\n      type: event.type,\n      name: event.name,\n      error: event.error,\n      from: event.from.toB58String()\n    };\n  }\n  if (event.name === 'PROVIDER') {\n    return {\n      type: event.type,\n      name: event.name,\n      providers: event.providers.map(({id, multiaddrs}) => ({\n        id: id.toB58String(),\n        multiaddrs\n      })),\n      from: event.from.toB58String()\n    };\n  }\n  if (event.name === 'VALUE') {\n    return {\n      type: event.type,\n      name: event.name,\n      value: event.value,\n      from: event.from.toB58String()\n    };\n  }\n  if (event.name === 'ADDING_PEER') {\n    return {\n      type: event.type,\n      name: event.name,\n      peer: event.peer.toB58String()\n    };\n  }\n  if (event.name === 'DIALING_PEER') {\n    return {\n      type: event.type,\n      name: event.name,\n      peer: event.peer.toB58String()\n    };\n  }\n  throw errCode__default[\"default\"](new Error('Unknown DHT event type'), 'ERR_UNKNOWN_DHT_EVENT');\n}\nfunction createDht({network, repo, peerId}) {\n  const {get, put, findProvs, findPeer, provide, query} = {\n    async *get(key, options = {}) {\n      const {libp2p} = await use(network, peerId, options);\n      const dhtKey = key instanceof Uint8Array ? key : toDHTKey(key);\n      yield* map__default[\"default\"](libp2p._dht.get(dhtKey, options), mapEvent);\n    },\n    async *put(key, value, options) {\n      const {libp2p} = await use(network, peerId, options);\n      const dhtKey = key instanceof Uint8Array ? key : toDHTKey(key);\n      yield* map__default[\"default\"](libp2p._dht.put(dhtKey, value), mapEvent);\n    },\n    async *findProvs(cid, options = {}) {\n      const {libp2p} = await use(network, peerId, options);\n      yield* map__default[\"default\"](libp2p._dht.findProviders(cid, { signal: options.signal }), mapEvent);\n    },\n    async *findPeer(peerIdToFind, options = {}) {\n      const {libp2p} = await use(network, peerId, options);\n      yield* map__default[\"default\"](libp2p._dht.findPeer(PeerId__default[\"default\"].parse(peerIdToFind), { signal: options.signal }), mapEvent);\n    },\n    async *provide(cid, options = { recursive: false }) {\n      const {libp2p} = await use(network, peerId, options);\n      const hasBlock = await repo.blocks.has(cid);\n      if (!hasBlock) {\n        throw errCode__default[\"default\"](new Error('block(s) not found locally, cannot provide'), 'ERR_BLOCK_NOT_FOUND');\n      }\n      if (options.recursive) {\n        throw errCode__default[\"default\"](new Error('not implemented yet'), 'ERR_NOT_IMPLEMENTED_YET');\n      }\n      yield* map__default[\"default\"](libp2p._dht.provide(cid), mapEvent);\n    },\n    async *query(peerIdToQuery, options = {}) {\n      const {libp2p} = await use(network, peerId, options);\n      let bytes;\n      const asCid = cid.CID.asCID(peerIdToQuery);\n      if (asCid != null) {\n        bytes = asCid.multihash.bytes;\n      } else {\n        bytes = PeerId__default[\"default\"].parse(peerIdToQuery.toString()).toBytes();\n      }\n      yield* map__default[\"default\"](libp2p._dht.getClosestPeers(bytes, options), mapEvent);\n    }\n  };\n  return {\n    get: withTimeoutOption.withTimeoutOption(get),\n    put: withTimeoutOption.withTimeoutOption(put),\n    findProvs: withTimeoutOption.withTimeoutOption(findProvs),\n    findPeer: withTimeoutOption.withTimeoutOption(findPeer),\n    provide: withTimeoutOption.withTimeoutOption(provide),\n    query: withTimeoutOption.withTimeoutOption(query)\n  };\n}\nconst use = async (network, peerId, options) => {\n  const net = await network.use(options);\n  if (get__default[\"default\"](net.libp2p, '_config.dht.enabled', false)) {\n    return net;\n  } else {\n    const fn = async function* () {\n      yield {\n        from: peerId,\n        name: 'QUERY_ERROR',\n        type: 3,\n        error: new errors.NotEnabledError('dht not enabled')\n      };\n    };\n    return {\n      libp2p: {\n        _dht: {\n          get: fn,\n          put: fn,\n          findProvs: fn,\n          findPeer: fn,\n          provide: fn,\n          query: fn\n        }\n      }\n    };\n  }\n};\n\nexports.createDht = createDht;\n"]},"metadata":{},"sourceType":"script"}