{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar lp = require('it-length-prefixed');\n\nvar itPipe = require('it-pipe');\n\nvar MulticodecTopology = require('libp2p-interfaces/src/topology/multicodec-topology.js');\n\nvar index$1 = require('./message/index.js');\n\nvar constants = require('./constants.js');\n\nvar index = require('./utils/index.js');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar lp__default = /*#__PURE__*/_interopDefaultLegacy(lp);\n\nvar MulticodecTopology__default = /*#__PURE__*/_interopDefaultLegacy(MulticodecTopology);\n\nconst BITSWAP100 = '/ipfs/bitswap/1.0.0';\nconst BITSWAP110 = '/ipfs/bitswap/1.1.0';\nconst BITSWAP120 = '/ipfs/bitswap/1.2.0';\n\nclass Network {\n  constructor(libp2p, bitswap, stats) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    this._log = index.logger(libp2p.peerId, 'network');\n    this._libp2p = libp2p;\n    this._bitswap = bitswap;\n    this._protocols = [BITSWAP100];\n\n    if (!options.b100Only) {\n      this._protocols.unshift(BITSWAP110);\n\n      this._protocols.unshift(BITSWAP120);\n    }\n\n    this._stats = stats;\n    this._running = false;\n    this._onPeerConnect = this._onPeerConnect.bind(this);\n    this._onPeerDisconnect = this._onPeerDisconnect.bind(this);\n    this._onConnection = this._onConnection.bind(this);\n    this._hashLoader = options.hashLoader;\n  }\n\n  async start() {\n    this._running = true;\n    await this._libp2p.handle(this._protocols, this._onConnection);\n    const topology = new MulticodecTopology__default[\"default\"]({\n      multicodecs: this._protocols,\n      handlers: {\n        onConnect: this._onPeerConnect,\n        onDisconnect: this._onPeerDisconnect\n      }\n    });\n    this._registrarId = await this._libp2p.registrar.register(topology);\n\n    for await (const peer of this._libp2p.peerStore.getPeers()) {\n      const conn = this._libp2p.connectionManager.get(peer.id);\n\n      conn && this._onPeerConnect(conn.remotePeer);\n    }\n  }\n\n  async stop() {\n    this._running = false;\n    await this._libp2p.unhandle(this._protocols);\n\n    if (this._registrarId != null) {\n      this._libp2p.registrar.unregister(this._registrarId);\n    }\n  }\n\n  async _onConnection(_ref) {\n    let {\n      protocol,\n      stream,\n      connection\n    } = _ref;\n\n    if (!this._running) {\n      return;\n    }\n\n    this._log('incoming new bitswap %s connection from %s', protocol, connection.remotePeer.toB58String());\n\n    try {\n      await itPipe.pipe(stream, lp__default[\"default\"].decode(), async source => {\n        for await (const data of source) {\n          try {\n            const message = await index$1.BitswapMessage.deserialize(data.slice(), this._hashLoader);\n            await this._bitswap._receiveMessage(connection.remotePeer, message);\n          } catch (err) {\n            this._bitswap._receiveError(err);\n\n            break;\n          }\n        }\n      });\n    } catch (err) {\n      this._log(err);\n    }\n  }\n\n  _onPeerConnect(peerId) {\n    this._bitswap._onPeerConnected(peerId);\n  }\n\n  _onPeerDisconnect(peerId) {\n    this._bitswap._onPeerDisconnected(peerId);\n  }\n\n  findProviders(cid, maxProviders) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this._libp2p.contentRouting.findProviders(cid, {\n      timeout: constants.providerRequestTimeout,\n      maxNumProviders: maxProviders\n    });\n  }\n\n  async findAndConnect(cid, options) {\n    const connectAttempts = [];\n\n    for await (const provider of this.findProviders(cid, constants.maxProvidersPerRequest, options)) {\n      this._log(`connecting to provider ${provider.id}`);\n\n      connectAttempts.push(this.connectTo(provider.id, options).catch(err => {\n        this._log.error(err);\n      }));\n    }\n\n    await Promise.all(connectAttempts);\n  }\n\n  async provide(cid, options) {\n    await this._libp2p.contentRouting.provide(cid, options);\n  }\n\n  async sendMessage(peer, msg) {\n    if (!this._running) throw new Error('network isn\\'t running');\n    const stringId = peer.toB58String();\n\n    this._log('sendMessage to %s', stringId, msg);\n\n    const connection = await this._libp2p.dial(peer);\n    const {\n      stream,\n      protocol\n    } = await connection.newStream([BITSWAP120, BITSWAP110, BITSWAP100]);\n    let serialized;\n\n    switch (protocol) {\n      case BITSWAP100:\n        serialized = msg.serializeToBitswap100();\n        break;\n\n      case BITSWAP110:\n      case BITSWAP120:\n        serialized = msg.serializeToBitswap110();\n        break;\n\n      default:\n        throw new Error('Unknown protocol: ' + protocol);\n    }\n\n    writeMessage(stream, serialized, this._log);\n\n    this._updateSentStats(peer, msg.blocks);\n  }\n\n  async connectTo(peer, options) {\n    if (!this._running) {\n      throw new Error('network isn\\'t running');\n    }\n\n    return this._libp2p.dial(peer, options);\n  }\n\n  _updateSentStats(peer, blocks) {\n    const peerId = peer.toB58String();\n\n    if (this._stats) {\n      for (const block of blocks.values()) {\n        this._stats.push(peerId, 'dataSent', block.length);\n      }\n\n      this._stats.push(peerId, 'blocksSent', blocks.size);\n    }\n  }\n\n}\n\nasync function writeMessage(stream, msg, log) {\n  try {\n    await itPipe.pipe([msg], lp__default[\"default\"].encode(), stream);\n  } catch (err) {\n    log(err);\n  }\n}\n\nexports.Network = Network;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-bitswap/cjs/src/network.js"],"names":["Object","defineProperty","exports","value","lp","require","itPipe","MulticodecTopology","index$1","constants","index","_interopDefaultLegacy","e","lp__default","MulticodecTopology__default","BITSWAP100","BITSWAP110","BITSWAP120","Network","constructor","libp2p","bitswap","stats","options","_log","logger","peerId","_libp2p","_bitswap","_protocols","b100Only","unshift","_stats","_running","_onPeerConnect","bind","_onPeerDisconnect","_onConnection","_hashLoader","hashLoader","start","handle","topology","multicodecs","handlers","onConnect","onDisconnect","_registrarId","registrar","register","peer","peerStore","getPeers","conn","connectionManager","get","id","remotePeer","stop","unhandle","unregister","protocol","stream","connection","toB58String","pipe","decode","source","data","message","BitswapMessage","deserialize","slice","_receiveMessage","err","_receiveError","_onPeerConnected","_onPeerDisconnected","findProviders","cid","maxProviders","contentRouting","timeout","providerRequestTimeout","maxNumProviders","findAndConnect","connectAttempts","provider","maxProvidersPerRequest","push","connectTo","catch","error","Promise","all","provide","sendMessage","msg","Error","stringId","dial","newStream","serialized","serializeToBitswap100","serializeToBitswap110","writeMessage","_updateSentStats","blocks","block","values","length","size","log","encode"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar lp = require('it-length-prefixed');\nvar itPipe = require('it-pipe');\nvar MulticodecTopology = require('libp2p-interfaces/src/topology/multicodec-topology.js');\nvar index$1 = require('./message/index.js');\nvar constants = require('./constants.js');\nvar index = require('./utils/index.js');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar lp__default = /*#__PURE__*/_interopDefaultLegacy(lp);\nvar MulticodecTopology__default = /*#__PURE__*/_interopDefaultLegacy(MulticodecTopology);\n\nconst BITSWAP100 = '/ipfs/bitswap/1.0.0';\nconst BITSWAP110 = '/ipfs/bitswap/1.1.0';\nconst BITSWAP120 = '/ipfs/bitswap/1.2.0';\nclass Network {\n  constructor(libp2p, bitswap, stats, options = {}) {\n    this._log = index.logger(libp2p.peerId, 'network');\n    this._libp2p = libp2p;\n    this._bitswap = bitswap;\n    this._protocols = [BITSWAP100];\n    if (!options.b100Only) {\n      this._protocols.unshift(BITSWAP110);\n      this._protocols.unshift(BITSWAP120);\n    }\n    this._stats = stats;\n    this._running = false;\n    this._onPeerConnect = this._onPeerConnect.bind(this);\n    this._onPeerDisconnect = this._onPeerDisconnect.bind(this);\n    this._onConnection = this._onConnection.bind(this);\n    this._hashLoader = options.hashLoader;\n  }\n  async start() {\n    this._running = true;\n    await this._libp2p.handle(this._protocols, this._onConnection);\n    const topology = new MulticodecTopology__default[\"default\"]({\n      multicodecs: this._protocols,\n      handlers: {\n        onConnect: this._onPeerConnect,\n        onDisconnect: this._onPeerDisconnect\n      }\n    });\n    this._registrarId = await this._libp2p.registrar.register(topology);\n    for await (const peer of this._libp2p.peerStore.getPeers()) {\n      const conn = this._libp2p.connectionManager.get(peer.id);\n      conn && this._onPeerConnect(conn.remotePeer);\n    }\n  }\n  async stop() {\n    this._running = false;\n    await this._libp2p.unhandle(this._protocols);\n    if (this._registrarId != null) {\n      this._libp2p.registrar.unregister(this._registrarId);\n    }\n  }\n  async _onConnection({protocol, stream, connection}) {\n    if (!this._running) {\n      return;\n    }\n    this._log('incoming new bitswap %s connection from %s', protocol, connection.remotePeer.toB58String());\n    try {\n      await itPipe.pipe(stream, lp__default[\"default\"].decode(), async source => {\n        for await (const data of source) {\n          try {\n            const message = await index$1.BitswapMessage.deserialize(data.slice(), this._hashLoader);\n            await this._bitswap._receiveMessage(connection.remotePeer, message);\n          } catch (err) {\n            this._bitswap._receiveError(err);\n            break;\n          }\n        }\n      });\n    } catch (err) {\n      this._log(err);\n    }\n  }\n  _onPeerConnect(peerId) {\n    this._bitswap._onPeerConnected(peerId);\n  }\n  _onPeerDisconnect(peerId) {\n    this._bitswap._onPeerDisconnected(peerId);\n  }\n  findProviders(cid, maxProviders, options = {}) {\n    return this._libp2p.contentRouting.findProviders(cid, {\n      timeout: constants.providerRequestTimeout,\n      maxNumProviders: maxProviders\n    });\n  }\n  async findAndConnect(cid, options) {\n    const connectAttempts = [];\n    for await (const provider of this.findProviders(cid, constants.maxProvidersPerRequest, options)) {\n      this._log(`connecting to provider ${ provider.id }`);\n      connectAttempts.push(this.connectTo(provider.id, options).catch(err => {\n        this._log.error(err);\n      }));\n    }\n    await Promise.all(connectAttempts);\n  }\n  async provide(cid, options) {\n    await this._libp2p.contentRouting.provide(cid, options);\n  }\n  async sendMessage(peer, msg) {\n    if (!this._running)\n      throw new Error('network isn\\'t running');\n    const stringId = peer.toB58String();\n    this._log('sendMessage to %s', stringId, msg);\n    const connection = await this._libp2p.dial(peer);\n    const {stream, protocol} = await connection.newStream([\n      BITSWAP120,\n      BITSWAP110,\n      BITSWAP100\n    ]);\n    let serialized;\n    switch (protocol) {\n    case BITSWAP100:\n      serialized = msg.serializeToBitswap100();\n      break;\n    case BITSWAP110:\n    case BITSWAP120:\n      serialized = msg.serializeToBitswap110();\n      break;\n    default:\n      throw new Error('Unknown protocol: ' + protocol);\n    }\n    writeMessage(stream, serialized, this._log);\n    this._updateSentStats(peer, msg.blocks);\n  }\n  async connectTo(peer, options) {\n    if (!this._running) {\n      throw new Error('network isn\\'t running');\n    }\n    return this._libp2p.dial(peer, options);\n  }\n  _updateSentStats(peer, blocks) {\n    const peerId = peer.toB58String();\n    if (this._stats) {\n      for (const block of blocks.values()) {\n        this._stats.push(peerId, 'dataSent', block.length);\n      }\n      this._stats.push(peerId, 'blocksSent', blocks.size);\n    }\n  }\n}\nasync function writeMessage(stream, msg, log) {\n  try {\n    await itPipe.pipe([msg], lp__default[\"default\"].encode(), stream);\n  } catch (err) {\n    log(err);\n  }\n}\n\nexports.Network = Network;\n"]},"metadata":{},"sourceType":"script"}