{"ast":null,"code":"'use strict'; // @ts-expect-error no types\n\nconst KBuck = require('k-bucket');\n\nconst utils = require('../utils');\n\nconst {\n  default: Queue\n} = require('p-queue');\n\nconst {\n  PROTOCOL_DHT\n} = require('../constants');\n\nconst {\n  TimeoutController\n} = require('timeout-abort-controller');\n/**\n * @typedef {import('./types').KBucketPeer} KBucketPeer\n * @typedef {import('./types').KBucket} KBucket\n * @typedef {import('./types').KBucketTree} KBucketTree\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../types').Metrics} Metrics\n */\n\n\nconst METRIC_ROUTING_TABLE_SIZE = 'routing-table-size';\n/**\n * A wrapper around `k-bucket`, to provide easy store and\n * retrieval for peers.\n */\n\nclass RoutingTable {\n  /**\n   * @param {object} params\n   * @param {import('peer-id')} params.peerId\n   * @param {import('../types').Dialer} params.dialer\n   * @param {boolean} params.lan\n   * @param {Metrics} [params.metrics]\n   * @param {number} [params.kBucketSize=20]\n   * @param {number} [params.pingTimeout=10000]\n   */\n  constructor(_ref) {\n    let {\n      peerId,\n      dialer,\n      kBucketSize,\n      pingTimeout,\n      lan,\n      metrics\n    } = _ref;\n    this._log = utils.logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}:routing-table`);\n    this._peerId = peerId;\n    this._dialer = dialer;\n    this._kBucketSize = kBucketSize || 20;\n    this._pingTimeout = pingTimeout || 10000;\n    this._lan = lan;\n    this._metrics = metrics;\n    /** @type {KBucketTree} */\n\n    this.kb; // eslint-disable-line no-unused-expressions\n\n    /** @type {Date[]} */\n\n    this.commonPrefixLengthRefreshedAt = [];\n    this._onPing = this._onPing.bind(this);\n    this._pingQueue = new Queue({\n      concurrency: 1\n    });\n    this._running = false;\n  }\n\n  async start() {\n    this._running = true;\n    this.kb = new KBuck({\n      localNodeId: await utils.convertPeerId(this._peerId),\n      numberOfNodesPerKBucket: this._kBucketSize,\n      numberOfNodesToPing: 1\n    });\n    this.kb.on('ping', this._onPing);\n  }\n\n  async stop() {\n    this._running = false;\n\n    this._pingQueue.clear();\n  }\n  /**\n   * Called on the `ping` event from `k-bucket` when a bucket is full\n   * and cannot split.\n   *\n   * `oldContacts.length` is defined by the `numberOfNodesToPing` param\n   * passed to the `k-bucket` constructor.\n   *\n   * `oldContacts` will not be empty and is the list of contacts that\n   * have not been contacted for the longest.\n   *\n   * @param {KBucketPeer[]} oldContacts\n   * @param {KBucketPeer} newContact\n   */\n\n\n  _onPing(oldContacts, newContact) {\n    // add to a queue so multiple ping requests do not overlap and we don't\n    // flood the network with ping requests if lots of newContact requests\n    // are received\n    this._pingQueue.add(async () => {\n      if (!this._running) {\n        return;\n      }\n\n      let responded = 0;\n\n      try {\n        await Promise.all(oldContacts.map(async oldContact => {\n          let timeoutController;\n\n          try {\n            timeoutController = new TimeoutController(this._pingTimeout);\n\n            this._log(`pinging old contact ${oldContact.peer}`);\n\n            const {\n              stream\n            } = await this._dialer.dialProtocol(oldContact.peer, PROTOCOL_DHT, {\n              signal: timeoutController.signal\n            });\n            await stream.close();\n            responded++;\n          } catch (\n          /** @type {any} */\n          err) {\n            if (this._running) {\n              // only evict peers if we are still running, otherwise we evict when dialing is\n              // cancelled due to shutdown in progress\n              this._log.error('could not ping peer %p', oldContact.peer, err);\n\n              this._log(`evicting old contact after ping failed ${oldContact.peer}`);\n\n              this.kb.remove(oldContact.id);\n            }\n          } finally {\n            if (timeoutController) {\n              timeoutController.clear();\n            }\n\n            this._metrics && this._metrics.updateComponentMetric({\n              component: `kad-dht-${this._lan ? 'lan' : 'wan'}`,\n              metric: METRIC_ROUTING_TABLE_SIZE,\n              value: this.size\n            });\n          }\n        }));\n\n        if (this._running && responded < oldContacts.length) {\n          this._log(`adding new contact ${newContact.peer}`);\n\n          this.kb.add(newContact);\n        }\n      } catch (\n      /** @type {any} */\n      err) {\n        this._log.error('could not process k-bucket ping event', err);\n      }\n    });\n  } // -- Public Interface\n\n  /**\n   * Amount of currently stored peers.\n   */\n\n\n  get size() {\n    return this.kb.count();\n  }\n  /**\n   * Find a specific peer by id.\n   *\n   * @param {PeerId} peer\n   */\n\n\n  async find(peer) {\n    const key = await utils.convertPeerId(peer);\n    const closest = this.closestPeer(key);\n\n    if (closest && peer.equals(closest)) {\n      return closest;\n    }\n  }\n  /**\n   * Retrieve the closest peers to the given key.\n   *\n   * @param {Uint8Array} key\n   */\n\n\n  closestPeer(key) {\n    const res = this.closestPeers(key, 1);\n\n    if (res.length > 0) {\n      return res[0];\n    }\n  }\n  /**\n   * Retrieve the `count`-closest peers to the given key.\n   *\n   * @param {Uint8Array} key\n   * @param {number} [count] - defaults to kBucketSize\n   */\n\n\n  closestPeers(key) {\n    let count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._kBucketSize;\n    const closest = this.kb.closest(key, count);\n    return closest.map(p => p.peer);\n  }\n  /**\n   * Add or update the routing table with the given peer.\n   *\n   * @param {PeerId} peer\n   */\n\n\n  async add(peer) {\n    const id = await utils.convertPeerId(peer);\n    this.kb.add({\n      id: id,\n      peer: peer\n    });\n\n    this._log('added %p with kad id %b', peer, id);\n\n    this._metrics && this._metrics.updateComponentMetric({\n      component: `kad-dht-${this._lan ? 'lan' : 'wan'}`,\n      metric: METRIC_ROUTING_TABLE_SIZE,\n      value: this.size\n    });\n  }\n  /**\n   * Remove a given peer from the table.\n   *\n   * @param {PeerId} peer\n   */\n\n\n  async remove(peer) {\n    const id = await utils.convertPeerId(peer);\n    this.kb.remove(id);\n    this._metrics && this._metrics.updateComponentMetric({\n      component: `kad-dht-${this._lan ? 'lan' : 'wan'}`,\n      metric: METRIC_ROUTING_TABLE_SIZE,\n      value: this.size\n    });\n  }\n\n}\n\nmodule.exports.RoutingTable = RoutingTable;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p-kad-dht/src/routing-table/index.js"],"names":["KBuck","require","utils","default","Queue","PROTOCOL_DHT","TimeoutController","METRIC_ROUTING_TABLE_SIZE","RoutingTable","constructor","peerId","dialer","kBucketSize","pingTimeout","lan","metrics","_log","logger","_peerId","_dialer","_kBucketSize","_pingTimeout","_lan","_metrics","kb","commonPrefixLengthRefreshedAt","_onPing","bind","_pingQueue","concurrency","_running","start","localNodeId","convertPeerId","numberOfNodesPerKBucket","numberOfNodesToPing","on","stop","clear","oldContacts","newContact","add","responded","Promise","all","map","oldContact","timeoutController","peer","stream","dialProtocol","signal","close","err","error","remove","id","updateComponentMetric","component","metric","value","size","length","count","find","key","closest","closestPeer","equals","res","closestPeers","p","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\n// @ts-expect-error no types\nconst KBuck = require('k-bucket')\nconst utils = require('../utils')\nconst { default: Queue } = require('p-queue')\nconst { PROTOCOL_DHT } = require('../constants')\nconst { TimeoutController } = require('timeout-abort-controller')\n\n/**\n * @typedef {import('./types').KBucketPeer} KBucketPeer\n * @typedef {import('./types').KBucket} KBucket\n * @typedef {import('./types').KBucketTree} KBucketTree\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../types').Metrics} Metrics\n */\n\nconst METRIC_ROUTING_TABLE_SIZE = 'routing-table-size'\n\n/**\n * A wrapper around `k-bucket`, to provide easy store and\n * retrieval for peers.\n */\nclass RoutingTable {\n  /**\n   * @param {object} params\n   * @param {import('peer-id')} params.peerId\n   * @param {import('../types').Dialer} params.dialer\n   * @param {boolean} params.lan\n   * @param {Metrics} [params.metrics]\n   * @param {number} [params.kBucketSize=20]\n   * @param {number} [params.pingTimeout=10000]\n   */\n  constructor ({ peerId, dialer, kBucketSize, pingTimeout, lan, metrics }) {\n    this._log = utils.logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}:routing-table`)\n    this._peerId = peerId\n    this._dialer = dialer\n    this._kBucketSize = kBucketSize || 20\n    this._pingTimeout = pingTimeout || 10000\n    this._lan = lan\n    this._metrics = metrics\n\n    /** @type {KBucketTree} */\n    this.kb // eslint-disable-line no-unused-expressions\n\n    /** @type {Date[]} */\n    this.commonPrefixLengthRefreshedAt = []\n\n    this._onPing = this._onPing.bind(this)\n    this._pingQueue = new Queue({ concurrency: 1 })\n    this._running = false\n  }\n\n  async start () {\n    this._running = true\n\n    this.kb = new KBuck({\n      localNodeId: await utils.convertPeerId(this._peerId),\n      numberOfNodesPerKBucket: this._kBucketSize,\n      numberOfNodesToPing: 1\n    })\n    this.kb.on('ping', this._onPing)\n  }\n\n  async stop () {\n    this._running = false\n    this._pingQueue.clear()\n  }\n\n  /**\n   * Called on the `ping` event from `k-bucket` when a bucket is full\n   * and cannot split.\n   *\n   * `oldContacts.length` is defined by the `numberOfNodesToPing` param\n   * passed to the `k-bucket` constructor.\n   *\n   * `oldContacts` will not be empty and is the list of contacts that\n   * have not been contacted for the longest.\n   *\n   * @param {KBucketPeer[]} oldContacts\n   * @param {KBucketPeer} newContact\n   */\n  _onPing (oldContacts, newContact) {\n    // add to a queue so multiple ping requests do not overlap and we don't\n    // flood the network with ping requests if lots of newContact requests\n    // are received\n    this._pingQueue.add(async () => {\n      if (!this._running) {\n        return\n      }\n\n      let responded = 0\n\n      try {\n        await Promise.all(\n          oldContacts.map(async oldContact => {\n            let timeoutController\n\n            try {\n              timeoutController = new TimeoutController(this._pingTimeout)\n\n              this._log(`pinging old contact ${oldContact.peer}`)\n              const { stream } = await this._dialer.dialProtocol(oldContact.peer, PROTOCOL_DHT, {\n                signal: timeoutController.signal\n              })\n              await stream.close()\n              responded++\n            } catch (/** @type {any} */ err) {\n              if (this._running) {\n                // only evict peers if we are still running, otherwise we evict when dialing is\n                // cancelled due to shutdown in progress\n                this._log.error('could not ping peer %p', oldContact.peer, err)\n                this._log(`evicting old contact after ping failed ${oldContact.peer}`)\n                this.kb.remove(oldContact.id)\n              }\n            } finally {\n              if (timeoutController) {\n                timeoutController.clear()\n              }\n\n              this._metrics && this._metrics.updateComponentMetric({ component: `kad-dht-${this._lan ? 'lan' : 'wan'}`, metric: METRIC_ROUTING_TABLE_SIZE, value: this.size })\n            }\n          })\n        )\n\n        if (this._running && responded < oldContacts.length) {\n          this._log(`adding new contact ${newContact.peer}`)\n          this.kb.add(newContact)\n        }\n      } catch (/** @type {any} */ err) {\n        this._log.error('could not process k-bucket ping event', err)\n      }\n    })\n  }\n\n  // -- Public Interface\n\n  /**\n   * Amount of currently stored peers.\n   */\n  get size () {\n    return this.kb.count()\n  }\n\n  /**\n   * Find a specific peer by id.\n   *\n   * @param {PeerId} peer\n   */\n  async find (peer) {\n    const key = await utils.convertPeerId(peer)\n    const closest = this.closestPeer(key)\n\n    if (closest && peer.equals(closest)) {\n      return closest\n    }\n  }\n\n  /**\n   * Retrieve the closest peers to the given key.\n   *\n   * @param {Uint8Array} key\n   */\n  closestPeer (key) {\n    const res = this.closestPeers(key, 1)\n\n    if (res.length > 0) {\n      return res[0]\n    }\n  }\n\n  /**\n   * Retrieve the `count`-closest peers to the given key.\n   *\n   * @param {Uint8Array} key\n   * @param {number} [count] - defaults to kBucketSize\n   */\n  closestPeers (key, count = this._kBucketSize) {\n    const closest = this.kb.closest(key, count)\n\n    return closest.map(p => p.peer)\n  }\n\n  /**\n   * Add or update the routing table with the given peer.\n   *\n   * @param {PeerId} peer\n   */\n  async add (peer) {\n    const id = await utils.convertPeerId(peer)\n\n    this.kb.add({ id: id, peer: peer })\n\n    this._log('added %p with kad id %b', peer, id)\n\n    this._metrics && this._metrics.updateComponentMetric({ component: `kad-dht-${this._lan ? 'lan' : 'wan'}`, metric: METRIC_ROUTING_TABLE_SIZE, value: this.size })\n  }\n\n  /**\n   * Remove a given peer from the table.\n   *\n   * @param {PeerId} peer\n   */\n  async remove (peer) {\n    const id = await utils.convertPeerId(peer)\n\n    this.kb.remove(id)\n\n    this._metrics && this._metrics.updateComponentMetric({ component: `kad-dht-${this._lan ? 'lan' : 'wan'}`, metric: METRIC_ROUTING_TABLE_SIZE, value: this.size })\n  }\n}\n\nmodule.exports.RoutingTable = RoutingTable\n"]},"metadata":{},"sourceType":"script"}