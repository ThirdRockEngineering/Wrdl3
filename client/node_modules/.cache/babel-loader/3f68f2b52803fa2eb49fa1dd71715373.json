{"ast":null,"code":"'use strict';\n\nconst {\n  TimeoutController\n} = require('timeout-abort-controller');\n\nconst {\n  anySignal\n} = require('any-signal');\n\nconst {\n  ALPHA,\n  K,\n  DEFAULT_QUERY_TIMEOUT\n} = require('../constants');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst {\n  logger\n} = require('../utils');\n\nconst {\n  queryPath\n} = require('./query-path');\n\nconst merge = require('it-merge');\n\nconst {\n  EventEmitter,\n  // @ts-expect-error only available in node 15+\n  setMaxListeners\n} = require('events');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../types').Metrics} Metrics\n */\n\n\nconst METRIC_RUNNING_QUERIES = 'running-queries';\n/**\n * Keeps track of all running queries\n */\n\nclass QueryManager {\n  /**\n   * Creates a new QueryManager\n   *\n   * @param {object} params\n   * @param {PeerId} params.peerId\n   * @param {boolean} params.lan\n   * @param {Metrics} [params.metrics]\n   * @param {number} [params.disjointPaths]\n   * @param {number} [params.alpha]\n   */\n  constructor(_ref) {\n    let {\n      peerId,\n      lan,\n      metrics,\n      disjointPaths = K,\n      alpha = ALPHA\n    } = _ref;\n    this._peerId = peerId;\n    this._disjointPaths = disjointPaths || K;\n    this._controllers = new Set();\n    this._running = false;\n    this._alpha = alpha || ALPHA;\n    this._lan = lan;\n    this._metrics = metrics;\n    this._queries = 0;\n  }\n  /**\n   * Starts the query manager\n   */\n\n\n  start() {\n    this._running = true;\n  }\n  /**\n   * Stops all queries\n   */\n\n\n  stop() {\n    this._running = false;\n\n    for (const controller of this._controllers) {\n      controller.abort();\n    }\n\n    this._controllers.clear();\n  }\n  /**\n   * @template T\n   *\n   * @param {Uint8Array} key\n   * @param {PeerId[]} peers\n   * @param {import('./types').QueryFunc} queryFunc\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.queryFuncTimeout]\n   *\n   * @returns {AsyncIterable<import('../types').QueryEvent>}\n   */\n\n\n  async *run(key, peers, queryFunc) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    if (!this._running) {\n      throw new Error('QueryManager not started');\n    }\n\n    let timeoutController;\n\n    if (!options.signal) {\n      // don't let queries run forever\n      timeoutController = new TimeoutController(DEFAULT_QUERY_TIMEOUT);\n      options.signal = timeoutController.signal;\n    } // allow us to stop queries on shut down\n\n\n    const abortController = new AbortController();\n\n    this._controllers.add(abortController);\n\n    const signals = [abortController.signal];\n    options.signal && signals.push(options.signal);\n    const signal = anySignal(signals); // this signal will get listened to for every invocation of queryFunc\n    // so make sure we don't make a lot of noise in the logs\n\n    try {\n      setMaxListeners && setMaxListeners(0, signal);\n    } catch {} // fails on node < 15.4\n\n\n    const log = logger(`libp2p:kad-dht:${this._lan ? 'lan' : 'wan'}:query:` + uint8ArrayToString(key, 'base58btc')); // query a subset of peers up to `kBucketSize / 2` in length\n\n    const peersToQuery = peers.slice(0, Math.min(this._disjointPaths, peers.length));\n    const startTime = Date.now();\n    const cleanUp = new EventEmitter();\n\n    try {\n      log('query:start');\n      this._queries++;\n      this._metrics && this._metrics.updateComponentMetric({\n        component: `kad-dht-${this._lan ? 'lan' : 'wan'}`,\n        metric: METRIC_RUNNING_QUERIES,\n        value: this._queries\n      });\n\n      if (peers.length === 0) {\n        log.error('Running query with no peers');\n        return;\n      } // Create query paths from the starting peers\n\n\n      const paths = peersToQuery.map((peer, index) => {\n        return queryPath({\n          key,\n          startingPeer: peer,\n          ourPeerId: this._peerId,\n          signal,\n          query: queryFunc,\n          pathIndex: index,\n          numPaths: peersToQuery.length,\n          alpha: this._alpha,\n          cleanUp,\n          queryFuncTimeout: options.queryFuncTimeout,\n          log\n        });\n      }); // Execute the query along each disjoint path and yield their results as they become available\n\n      for await (const event of merge(...paths)) {\n        yield event;\n\n        if (event.name === 'QUERY_ERROR' && event.error) {\n          log('error', event.error);\n        }\n      }\n    } catch (\n    /** @type {any} */\n    err) {\n      if (!this._running && err.code === 'ERR_QUERY_ABORTED') {// ignore query aborted errors that were thrown during query manager shutdown\n      } else {\n        throw err;\n      }\n    } finally {\n      this._controllers.delete(abortController);\n\n      if (timeoutController) {\n        timeoutController.clear();\n      }\n\n      this._queries--;\n      this._metrics && this._metrics.updateComponentMetric({\n        component: `kad-dht-${this._lan ? 'lan' : 'wan'}`,\n        metric: METRIC_RUNNING_QUERIES,\n        value: this._queries\n      });\n      cleanUp.emit('cleanup');\n      log(`query:done in ${Date.now() - (startTime || 0)}ms`);\n    }\n  }\n\n}\n\nmodule.exports.QueryManager = QueryManager;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p-kad-dht/src/query/manager.js"],"names":["TimeoutController","require","anySignal","ALPHA","K","DEFAULT_QUERY_TIMEOUT","toString","uint8ArrayToString","logger","queryPath","merge","EventEmitter","setMaxListeners","METRIC_RUNNING_QUERIES","QueryManager","constructor","peerId","lan","metrics","disjointPaths","alpha","_peerId","_disjointPaths","_controllers","Set","_running","_alpha","_lan","_metrics","_queries","start","stop","controller","abort","clear","run","key","peers","queryFunc","options","Error","timeoutController","signal","abortController","AbortController","add","signals","push","log","peersToQuery","slice","Math","min","length","startTime","Date","now","cleanUp","updateComponentMetric","component","metric","value","error","paths","map","peer","index","startingPeer","ourPeerId","query","pathIndex","numPaths","queryFuncTimeout","event","name","err","code","delete","emit","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { TimeoutController } = require('timeout-abort-controller')\nconst { anySignal } = require('any-signal')\nconst {\n  ALPHA, K, DEFAULT_QUERY_TIMEOUT\n} = require('../constants')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst { logger } = require('../utils')\nconst { queryPath } = require('./query-path')\nconst merge = require('it-merge')\nconst {\n  EventEmitter,\n  // @ts-expect-error only available in node 15+\n  setMaxListeners\n} = require('events')\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../types').Metrics} Metrics\n */\n\nconst METRIC_RUNNING_QUERIES = 'running-queries'\n\n/**\n * Keeps track of all running queries\n */\nclass QueryManager {\n  /**\n   * Creates a new QueryManager\n   *\n   * @param {object} params\n   * @param {PeerId} params.peerId\n   * @param {boolean} params.lan\n   * @param {Metrics} [params.metrics]\n   * @param {number} [params.disjointPaths]\n   * @param {number} [params.alpha]\n   */\n  constructor ({ peerId, lan, metrics, disjointPaths = K, alpha = ALPHA }) {\n    this._peerId = peerId\n    this._disjointPaths = disjointPaths || K\n    this._controllers = new Set()\n    this._running = false\n    this._alpha = alpha || ALPHA\n    this._lan = lan\n    this._metrics = metrics\n    this._queries = 0\n  }\n\n  /**\n   * Starts the query manager\n   */\n  start () {\n    this._running = true\n  }\n\n  /**\n   * Stops all queries\n   */\n  stop () {\n    this._running = false\n\n    for (const controller of this._controllers) {\n      controller.abort()\n    }\n\n    this._controllers.clear()\n  }\n\n  /**\n   * @template T\n   *\n   * @param {Uint8Array} key\n   * @param {PeerId[]} peers\n   * @param {import('./types').QueryFunc} queryFunc\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.queryFuncTimeout]\n   *\n   * @returns {AsyncIterable<import('../types').QueryEvent>}\n   */\n  async * run (key, peers, queryFunc, options = {}) {\n    if (!this._running) {\n      throw new Error('QueryManager not started')\n    }\n\n    let timeoutController\n\n    if (!options.signal) {\n      // don't let queries run forever\n      timeoutController = new TimeoutController(DEFAULT_QUERY_TIMEOUT)\n      options.signal = timeoutController.signal\n    }\n\n    // allow us to stop queries on shut down\n    const abortController = new AbortController()\n    this._controllers.add(abortController)\n    const signals = [abortController.signal]\n    options.signal && signals.push(options.signal)\n    const signal = anySignal(signals)\n\n    // this signal will get listened to for every invocation of queryFunc\n    // so make sure we don't make a lot of noise in the logs\n    try {\n      setMaxListeners && setMaxListeners(0, signal)\n    } catch {} // fails on node < 15.4\n\n    const log = logger(`libp2p:kad-dht:${this._lan ? 'lan' : 'wan'}:query:` + uint8ArrayToString(key, 'base58btc'))\n\n    // query a subset of peers up to `kBucketSize / 2` in length\n    const peersToQuery = peers.slice(0, Math.min(this._disjointPaths, peers.length))\n    const startTime = Date.now()\n    const cleanUp = new EventEmitter()\n\n    try {\n      log('query:start')\n      this._queries++\n      this._metrics && this._metrics.updateComponentMetric({ component: `kad-dht-${this._lan ? 'lan' : 'wan'}`, metric: METRIC_RUNNING_QUERIES, value: this._queries })\n\n      if (peers.length === 0) {\n        log.error('Running query with no peers')\n        return\n      }\n\n      // Create query paths from the starting peers\n      const paths = peersToQuery.map((peer, index) => {\n        return queryPath({\n          key,\n          startingPeer: peer,\n          ourPeerId: this._peerId,\n          signal,\n          query: queryFunc,\n          pathIndex: index,\n          numPaths: peersToQuery.length,\n          alpha: this._alpha,\n          cleanUp,\n          queryFuncTimeout: options.queryFuncTimeout,\n          log\n        })\n      })\n\n      // Execute the query along each disjoint path and yield their results as they become available\n      for await (const event of merge(...paths)) {\n        yield event\n\n        if (event.name === 'QUERY_ERROR' && event.error) {\n          log('error', event.error)\n        }\n      }\n    } catch (/** @type {any} */ err) {\n      if (!this._running && err.code === 'ERR_QUERY_ABORTED') {\n        // ignore query aborted errors that were thrown during query manager shutdown\n      } else {\n        throw err\n      }\n    } finally {\n      this._controllers.delete(abortController)\n\n      if (timeoutController) {\n        timeoutController.clear()\n      }\n\n      this._queries--\n      this._metrics && this._metrics.updateComponentMetric({ component: `kad-dht-${this._lan ? 'lan' : 'wan'}`, metric: METRIC_RUNNING_QUERIES, value: this._queries })\n\n      cleanUp.emit('cleanup')\n      log(`query:done in ${Date.now() - (startTime || 0)}ms`)\n    }\n  }\n}\n\nmodule.exports.QueryManager = QueryManager\n"]},"metadata":{},"sourceType":"script"}