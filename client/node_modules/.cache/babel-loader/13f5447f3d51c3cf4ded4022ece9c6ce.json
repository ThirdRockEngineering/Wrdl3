{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar dagPB = require('@ipld/dag-pb');\n\nvar Errors = require('datastore-core/errors');\n\nvar toCidAndPath = require('ipfs-core-utils/to-cid-and-path');\n\nvar cid = require('multiformats/cid');\n\nvar timeoutAbortController = require('timeout-abort-controller');\n\nvar anySignal = require('any-signal');\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar dagPB__namespace = /*#__PURE__*/_interopNamespace(dagPB);\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\nconst Format = {\n  default: '<dst>',\n  edges: '<src> -> <dst>'\n};\n\nfunction createRefs(_ref) {\n  let {\n    repo,\n    codecs,\n    resolve,\n    preload\n  } = _ref;\n\n  async function* refs(ipfsPath) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (options.maxDepth === 0) {\n      return;\n    }\n\n    if (options.edges && options.format && options.format !== Format.default) {\n      throw new Error('Cannot set edges to true and also specify format');\n    }\n\n    options.format = options.edges ? Format.edges : options.format;\n\n    if (typeof options.maxDepth !== 'number') {\n      options.maxDepth = options.recursive ? Infinity : 1;\n    }\n\n    if (options.timeout) {\n      const controller = new timeoutAbortController.TimeoutController(options.timeout);\n      const signals = [controller.signal];\n\n      if (options.signal) {\n        signals.push(options.signal);\n      }\n\n      options.signal = anySignal.anySignal(signals);\n    }\n\n    const rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath];\n    const paths = rawPaths.map(p => getFullPath(preload, p, options));\n\n    for (const path of paths) {\n      try {\n        yield* refsStream(resolve, repo, codecs, path, options);\n      } catch (err) {\n        yield {\n          ref: '',\n          err: err.message\n        };\n      }\n    }\n  }\n\n  return refs;\n}\n\nfunction getFullPath(preload, ipfsPath, options) {\n  const {\n    cid,\n    path\n  } = toCidAndPath.toCidAndPath(ipfsPath);\n\n  if (options.preload !== false) {\n    preload(cid);\n  }\n\n  return `/ipfs/${cid}${path || ''}`;\n}\n\nasync function* refsStream(resolve, repo, codecs, path, options) {\n  const resPath = await resolve(path, options);\n  const {\n    cid\n  } = toCidAndPath.toCidAndPath(resPath);\n  const maxDepth = options.maxDepth != null ? options.maxDepth : Infinity;\n  const unique = options.unique || false;\n\n  for await (const obj of objectStream(repo, codecs, cid, maxDepth, unique, options)) {\n    if (!obj.parent) {\n      continue;\n    }\n\n    if (obj.isDuplicate) {\n      continue;\n    }\n\n    yield {\n      ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)\n    };\n  }\n}\n\nfunction formatLink(srcCid, dstCid) {\n  let linkName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  let format = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Format.default;\n  let out = format.replace(/<src>/g, srcCid.toString());\n  out = out.replace(/<dst>/g, dstCid.toString());\n  out = out.replace(/<linkname>/g, linkName);\n  return out;\n}\n\nasync function* objectStream(repo, codecs, rootCid, maxDepth, uniqueOnly, options) {\n  const seen = new Set();\n\n  async function* traverseLevel(parent, depth) {\n    const nextLevelDepth = depth + 1;\n\n    if (nextLevelDepth > maxDepth) {\n      return;\n    }\n\n    try {\n      for await (const link of getLinks(repo, codecs, parent.cid, options)) {\n        yield {\n          parent: parent,\n          node: link,\n          isDuplicate: uniqueOnly && seen.has(link.cid.toString())\n        };\n\n        if (uniqueOnly) {\n          seen.add(link.cid.toString());\n        }\n\n        yield* traverseLevel(link, nextLevelDepth);\n      }\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        err.message = `Could not find object with CID: ${parent.cid}`;\n      }\n\n      throw err;\n    }\n  }\n\n  yield* traverseLevel({\n    cid: rootCid\n  }, 0);\n}\n\nasync function* getLinks(repo, codecs, cid, options) {\n  const block = await repo.blocks.get(cid, options);\n  const codec = await codecs.getCodec(cid.code);\n  const value = codec.decode(block);\n  const isDagPb = cid.code === dagPB__namespace.code;\n  const base = [];\n\n  for (const [name, cid] of links(value, base)) {\n    if (isDagPb) {\n      const match = name.match(/^Links\\/(\\d+)\\/Hash$/);\n\n      if (match) {\n        const index = Number(match[1]);\n\n        if (index < value.Links.length) {\n          yield {\n            name: value.Links[index].Name,\n            cid\n          };\n          continue;\n        }\n      }\n    }\n\n    yield {\n      name,\n      cid\n    };\n  }\n}\n\nconst links = function* (source, base) {\n  if (source == null) {\n    return;\n  }\n\n  if (source instanceof Uint8Array) {\n    return;\n  }\n\n  for (const [key, value] of Object.entries(source)) {\n    const path = [...base, key];\n\n    if (value != null && typeof value === 'object') {\n      if (Array.isArray(value)) {\n        for (const [index, element] of value.entries()) {\n          const elementPath = [...path, index];\n          const cid$1 = cid.CID.asCID(element);\n\n          if (cid$1) {\n            yield [elementPath.join('/'), cid$1];\n          } else if (typeof element === 'object') {\n            yield* links(element, elementPath);\n          }\n        }\n      } else {\n        const cid$1 = cid.CID.asCID(value);\n\n        if (cid$1) {\n          yield [path.join('/'), cid$1];\n        } else {\n          yield* links(value, path);\n        }\n      }\n    }\n  }\n\n  return [];\n};\n\nexports.Format = Format;\nexports.createRefs = createRefs;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-core/cjs/src/components/refs/index.js"],"names":["Object","defineProperty","exports","value","dagPB","require","Errors","toCidAndPath","cid","timeoutAbortController","anySignal","_interopNamespace","e","__esModule","n","create","keys","forEach","k","d","getOwnPropertyDescriptor","get","enumerable","freeze","dagPB__namespace","ERR_NOT_FOUND","notFoundError","code","Format","default","edges","createRefs","repo","codecs","resolve","preload","refs","ipfsPath","options","maxDepth","format","Error","recursive","Infinity","timeout","controller","TimeoutController","signals","signal","push","rawPaths","Array","isArray","paths","map","p","getFullPath","path","refsStream","err","ref","message","resPath","unique","obj","objectStream","parent","isDuplicate","formatLink","node","name","srcCid","dstCid","linkName","out","replace","toString","rootCid","uniqueOnly","seen","Set","traverseLevel","depth","nextLevelDepth","link","getLinks","has","add","block","blocks","codec","getCodec","decode","isDagPb","base","links","match","index","Number","Links","length","Name","source","Uint8Array","key","entries","element","elementPath","cid$1","CID","asCID","join"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar dagPB = require('@ipld/dag-pb');\nvar Errors = require('datastore-core/errors');\nvar toCidAndPath = require('ipfs-core-utils/to-cid-and-path');\nvar cid = require('multiformats/cid');\nvar timeoutAbortController = require('timeout-abort-controller');\nvar anySignal = require('any-signal');\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar dagPB__namespace = /*#__PURE__*/_interopNamespace(dagPB);\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\nconst Format = {\n  default: '<dst>',\n  edges: '<src> -> <dst>'\n};\nfunction createRefs({repo, codecs, resolve, preload}) {\n  async function* refs(ipfsPath, options = {}) {\n    if (options.maxDepth === 0) {\n      return;\n    }\n    if (options.edges && options.format && options.format !== Format.default) {\n      throw new Error('Cannot set edges to true and also specify format');\n    }\n    options.format = options.edges ? Format.edges : options.format;\n    if (typeof options.maxDepth !== 'number') {\n      options.maxDepth = options.recursive ? Infinity : 1;\n    }\n    if (options.timeout) {\n      const controller = new timeoutAbortController.TimeoutController(options.timeout);\n      const signals = [controller.signal];\n      if (options.signal) {\n        signals.push(options.signal);\n      }\n      options.signal = anySignal.anySignal(signals);\n    }\n    const rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath];\n    const paths = rawPaths.map(p => getFullPath(preload, p, options));\n    for (const path of paths) {\n      try {\n        yield* refsStream(resolve, repo, codecs, path, options);\n      } catch (err) {\n        yield {\n          ref: '',\n          err: err.message\n        };\n      }\n    }\n  }\n  return refs;\n}\nfunction getFullPath(preload, ipfsPath, options) {\n  const {cid, path} = toCidAndPath.toCidAndPath(ipfsPath);\n  if (options.preload !== false) {\n    preload(cid);\n  }\n  return `/ipfs/${ cid }${ path || '' }`;\n}\nasync function* refsStream(resolve, repo, codecs, path, options) {\n  const resPath = await resolve(path, options);\n  const {cid} = toCidAndPath.toCidAndPath(resPath);\n  const maxDepth = options.maxDepth != null ? options.maxDepth : Infinity;\n  const unique = options.unique || false;\n  for await (const obj of objectStream(repo, codecs, cid, maxDepth, unique, options)) {\n    if (!obj.parent) {\n      continue;\n    }\n    if (obj.isDuplicate) {\n      continue;\n    }\n    yield { ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format) };\n  }\n}\nfunction formatLink(srcCid, dstCid, linkName = '', format = Format.default) {\n  let out = format.replace(/<src>/g, srcCid.toString());\n  out = out.replace(/<dst>/g, dstCid.toString());\n  out = out.replace(/<linkname>/g, linkName);\n  return out;\n}\nasync function* objectStream(repo, codecs, rootCid, maxDepth, uniqueOnly, options) {\n  const seen = new Set();\n  async function* traverseLevel(parent, depth) {\n    const nextLevelDepth = depth + 1;\n    if (nextLevelDepth > maxDepth) {\n      return;\n    }\n    try {\n      for await (const link of getLinks(repo, codecs, parent.cid, options)) {\n        yield {\n          parent: parent,\n          node: link,\n          isDuplicate: uniqueOnly && seen.has(link.cid.toString())\n        };\n        if (uniqueOnly) {\n          seen.add(link.cid.toString());\n        }\n        yield* traverseLevel(link, nextLevelDepth);\n      }\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        err.message = `Could not find object with CID: ${ parent.cid }`;\n      }\n      throw err;\n    }\n  }\n  yield* traverseLevel({ cid: rootCid }, 0);\n}\nasync function* getLinks(repo, codecs, cid, options) {\n  const block = await repo.blocks.get(cid, options);\n  const codec = await codecs.getCodec(cid.code);\n  const value = codec.decode(block);\n  const isDagPb = cid.code === dagPB__namespace.code;\n  const base = [];\n  for (const [name, cid] of links(value, base)) {\n    if (isDagPb) {\n      const match = name.match(/^Links\\/(\\d+)\\/Hash$/);\n      if (match) {\n        const index = Number(match[1]);\n        if (index < value.Links.length) {\n          yield {\n            name: value.Links[index].Name,\n            cid\n          };\n          continue;\n        }\n      }\n    }\n    yield {\n      name,\n      cid\n    };\n  }\n}\nconst links = function* (source, base) {\n  if (source == null) {\n    return;\n  }\n  if (source instanceof Uint8Array) {\n    return;\n  }\n  for (const [key, value] of Object.entries(source)) {\n    const path = [\n      ...base,\n      key\n    ];\n    if (value != null && typeof value === 'object') {\n      if (Array.isArray(value)) {\n        for (const [index, element] of value.entries()) {\n          const elementPath = [\n            ...path,\n            index\n          ];\n          const cid$1 = cid.CID.asCID(element);\n          if (cid$1) {\n            yield [\n              elementPath.join('/'),\n              cid$1\n            ];\n          } else if (typeof element === 'object') {\n            yield* links(element, elementPath);\n          }\n        }\n      } else {\n        const cid$1 = cid.CID.asCID(value);\n        if (cid$1) {\n          yield [\n            path.join('/'),\n            cid$1\n          ];\n        } else {\n          yield* links(value, path);\n        }\n      }\n    }\n  }\n  return [];\n};\n\nexports.Format = Format;\nexports.createRefs = createRefs;\n"]},"metadata":{},"sourceType":"script"}