{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst errcode = require('err-code');\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst PeerId = require('peer-id');\n\nconst {\n  codes\n} = require('../errors');\n\nconst PeerRecord = require('../record/peer-record');\n\nconst Envelope = require('../record/envelope');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst all = require('it-all');\n\nconst filter = require('it-filter');\n\nconst map = require('it-map');\n\nconst each = require('it-foreach');\n/**\n * @typedef {import('./types').PeerStore} PeerStore\n * @typedef {import('./types').Address} Address\n * @typedef {import('./types').AddressBook} AddressBook\n */\n\n\nconst log = Object.assign(debug('libp2p:peer-store:address-book'), {\n  error: debug('libp2p:peer-store:address-book:err')\n});\nconst EVENT_NAME = 'change:multiaddrs';\n/**\n * @implements {AddressBook}\n */\n\nclass PeerStoreAddressBook {\n  /**\n   * @param {PeerStore[\"emit\"]} emit\n   * @param {import('./types').Store} store\n   * @param {(peerId: PeerId, multiaddr: Multiaddr) => Promise<boolean>} addressFilter\n   */\n  constructor(emit, store, addressFilter) {\n    this._emit = emit;\n    this._store = store;\n    this._addressFilter = addressFilter;\n  }\n  /**\n   * ConsumePeerRecord adds addresses from a signed peer record contained in a record envelope.\n   * This will return a boolean that indicates if the record was successfully processed and added\n   * into the AddressBook.\n   *\n   * @param {Envelope} envelope\n   */\n\n\n  async consumePeerRecord(envelope) {\n    log('consumePeerRecord await write lock');\n    const release = await this._store.lock.writeLock();\n    log('consumePeerRecord got write lock');\n    let peerId;\n    let updatedPeer;\n\n    try {\n      let peerRecord;\n\n      try {\n        peerRecord = PeerRecord.createFromProtobuf(envelope.payload);\n      } catch (\n      /** @type {any} */\n      err) {\n        log.error('invalid peer record received');\n        return false;\n      }\n\n      peerId = peerRecord.peerId;\n      const multiaddrs = peerRecord.multiaddrs; // Verify peerId\n\n      if (!peerId.equals(envelope.peerId)) {\n        log('signing key does not match PeerId in the PeerRecord');\n        return false;\n      } // ensure the record has multiaddrs\n\n\n      if (!multiaddrs || !multiaddrs.length) {\n        return false;\n      }\n\n      if (await this._store.has(peerId)) {\n        const peer = await this._store.load(peerId);\n\n        if (peer.peerRecordEnvelope) {\n          const storedEnvelope = await Envelope.createFromProtobuf(peer.peerRecordEnvelope);\n          const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload); // ensure seq is greater than, or equal to, the last received\n\n          if (storedRecord.seqNumber >= peerRecord.seqNumber) {\n            return false;\n          }\n        }\n      } // Replace unsigned addresses by the new ones from the record\n      // TODO: Once we have ttls for the addresses, we should merge these in\n\n\n      updatedPeer = await this._store.patchOrCreate(peerId, {\n        addresses: await filterMultiaddrs(peerId, multiaddrs, this._addressFilter, true),\n        peerRecordEnvelope: envelope.marshal()\n      });\n      log(`stored provided peer record for ${peerRecord.peerId.toB58String()}`);\n    } finally {\n      log('consumePeerRecord release write lock');\n      release();\n    }\n\n    this._emit(EVENT_NAME, {\n      peerId,\n      multiaddrs: updatedPeer.addresses.map(_ref => {\n        let {\n          multiaddr\n        } = _ref;\n        return multiaddr;\n      })\n    });\n\n    return true;\n  }\n  /**\n   * @param {PeerId} peerId\n   */\n\n\n  async getRawEnvelope(peerId) {\n    log('getRawEnvelope await read lock');\n    const release = await this._store.lock.readLock();\n    log('getRawEnvelope got read lock');\n\n    try {\n      const peer = await this._store.load(peerId);\n      return peer.peerRecordEnvelope;\n    } catch (\n    /** @type {any} */\n    err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err;\n      }\n    } finally {\n      log('getRawEnvelope release read lock');\n      release();\n    }\n  }\n  /**\n   * Get an Envelope containing a PeerRecord for the given peer.\n   * Returns undefined if no record exists.\n   *\n   * @param {PeerId} peerId\n   */\n\n\n  async getPeerRecord(peerId) {\n    const raw = await this.getRawEnvelope(peerId);\n\n    if (!raw) {\n      return undefined;\n    }\n\n    return Envelope.createFromProtobuf(raw);\n  }\n  /**\n   * @param {PeerId} peerId\n   */\n\n\n  async get(peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log('get wait for read lock');\n    const release = await this._store.lock.readLock();\n    log('get got read lock');\n\n    try {\n      const peer = await this._store.load(peerId);\n      return peer.addresses;\n    } catch (\n    /** @type {any} */\n    err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err;\n      }\n    } finally {\n      log('get release read lock');\n      release();\n    }\n\n    return [];\n  }\n  /**\n   * @param {PeerId} peerId\n   * @param {Multiaddr[]} multiaddrs\n   */\n\n\n  async set(peerId, multiaddrs) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    if (!Array.isArray(multiaddrs)) {\n      log.error('multiaddrs must be an array of Multiaddrs');\n      throw errcode(new Error('multiaddrs must be an array of Multiaddrs'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log('set await write lock');\n    const release = await this._store.lock.writeLock();\n    log('set got write lock');\n    let hasPeer = false;\n    let updatedPeer;\n\n    try {\n      const addresses = await filterMultiaddrs(peerId, multiaddrs, this._addressFilter); // No valid addresses found\n\n      if (!addresses.length) {\n        return;\n      }\n\n      try {\n        const peer = await this._store.load(peerId);\n        hasPeer = true;\n\n        if (new Set([...addresses.map(_ref2 => {\n          let {\n            multiaddr\n          } = _ref2;\n          return multiaddr.toString();\n        }), ...peer.addresses.map(_ref3 => {\n          let {\n            multiaddr\n          } = _ref3;\n          return multiaddr.toString();\n        })]).size === peer.addresses.length && addresses.length === peer.addresses.length) {\n          // not changing anything, no need to update\n          return;\n        }\n      } catch (\n      /** @type {any} */\n      err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err;\n        }\n      }\n\n      updatedPeer = await this._store.patchOrCreate(peerId, {\n        addresses\n      });\n      log(`set multiaddrs for ${peerId.toB58String()}`);\n    } finally {\n      log('set release write lock');\n      release();\n    }\n\n    this._emit(EVENT_NAME, {\n      peerId,\n      multiaddrs: updatedPeer.addresses.map(addr => addr.multiaddr)\n    }); // Notify the existence of a new peer\n\n\n    if (!hasPeer) {\n      this._emit('peer', peerId);\n    }\n  }\n  /**\n   * @param {PeerId} peerId\n   * @param {Multiaddr[]} multiaddrs\n   */\n\n\n  async add(peerId, multiaddrs) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    if (!Array.isArray(multiaddrs)) {\n      log.error('multiaddrs must be an array of Multiaddrs');\n      throw errcode(new Error('multiaddrs must be an array of Multiaddrs'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log('add await write lock');\n    const release = await this._store.lock.writeLock();\n    log('add got write lock');\n    let hasPeer;\n    let updatedPeer;\n\n    try {\n      const addresses = await filterMultiaddrs(peerId, multiaddrs, this._addressFilter); // No valid addresses found\n\n      if (!addresses.length) {\n        return;\n      }\n\n      try {\n        const peer = await this._store.load(peerId);\n        hasPeer = true;\n\n        if (new Set([...addresses.map(_ref4 => {\n          let {\n            multiaddr\n          } = _ref4;\n          return multiaddr.toString();\n        }), ...peer.addresses.map(_ref5 => {\n          let {\n            multiaddr\n          } = _ref5;\n          return multiaddr.toString();\n        })]).size === peer.addresses.length) {\n          return;\n        }\n      } catch (\n      /** @type {any} */\n      err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err;\n        }\n      }\n\n      updatedPeer = await this._store.mergeOrCreate(peerId, {\n        addresses\n      });\n      log(`added multiaddrs for ${peerId.toB58String()}`);\n    } finally {\n      log('set release write lock');\n      release();\n    }\n\n    this._emit(EVENT_NAME, {\n      peerId,\n      multiaddrs: updatedPeer.addresses.map(addr => addr.multiaddr)\n    }); // Notify the existence of a new peer\n\n\n    if (!hasPeer) {\n      this._emit('peer', peerId);\n    }\n  }\n  /**\n   * @param {PeerId} peerId\n   */\n\n\n  async delete(peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log('delete await write lock');\n    const release = await this._store.lock.writeLock();\n    log('delete got write lock');\n    let has;\n\n    try {\n      has = await this._store.has(peerId);\n      await this._store.patchOrCreate(peerId, {\n        addresses: []\n      });\n    } finally {\n      log('delete release write lock');\n      release();\n    }\n\n    if (has) {\n      this._emit(EVENT_NAME, {\n        peerId,\n        multiaddrs: []\n      });\n    }\n  }\n  /**\n   * @param {PeerId} peerId\n   * @param {(addresses: Address[]) => Address[]} [addressSorter]\n   */\n\n\n  async getMultiaddrsForPeer(peerId) {\n    let addressSorter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ms => ms;\n    const addresses = await this.get(peerId);\n    return addressSorter(addresses).map(address => {\n      const multiaddr = address.multiaddr;\n      const idString = multiaddr.getPeerId();\n      if (idString && idString === peerId.toB58String()) return multiaddr;\n      return multiaddr.encapsulate(`/p2p/${peerId.toB58String()}`);\n    });\n  }\n\n}\n/**\n * @param {PeerId} peerId\n * @param {Multiaddr[]} multiaddrs\n * @param {(peerId: PeerId, multiaddr: Multiaddr) => Promise<boolean>} addressFilter\n * @param {boolean} isCertified\n */\n\n\nfunction filterMultiaddrs(peerId, multiaddrs, addressFilter) {\n  let isCertified = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  return pipe(multiaddrs, source => each(source, multiaddr => {\n    if (!Multiaddr.isMultiaddr(multiaddr)) {\n      log.error('multiaddr must be an instance of Multiaddr');\n      throw errcode(new Error('multiaddr must be an instance of Multiaddr'), codes.ERR_INVALID_PARAMETERS);\n    }\n  }), source => filter(source, multiaddr => addressFilter(peerId, multiaddr)), source => map(source, multiaddr => {\n    return {\n      multiaddr: new Multiaddr(multiaddr.toString()),\n      isCertified\n    };\n  }), source => all(source));\n}\n\nmodule.exports = PeerStoreAddressBook;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p/src/peer-store/address-book.js"],"names":["debug","require","errcode","Multiaddr","PeerId","codes","PeerRecord","Envelope","pipe","all","filter","map","each","log","Object","assign","error","EVENT_NAME","PeerStoreAddressBook","constructor","emit","store","addressFilter","_emit","_store","_addressFilter","consumePeerRecord","envelope","release","lock","writeLock","peerId","updatedPeer","peerRecord","createFromProtobuf","payload","err","multiaddrs","equals","length","has","peer","load","peerRecordEnvelope","storedEnvelope","storedRecord","seqNumber","patchOrCreate","addresses","filterMultiaddrs","marshal","toB58String","multiaddr","getRawEnvelope","readLock","code","ERR_NOT_FOUND","getPeerRecord","raw","undefined","get","isPeerId","Error","ERR_INVALID_PARAMETERS","set","Array","isArray","hasPeer","Set","toString","size","addr","add","mergeOrCreate","delete","getMultiaddrsForPeer","addressSorter","ms","address","idString","getPeerId","encapsulate","isCertified","source","isMultiaddr","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst errcode = require('err-code')\nconst { Multiaddr } = require('multiaddr')\nconst PeerId = require('peer-id')\nconst { codes } = require('../errors')\nconst PeerRecord = require('../record/peer-record')\nconst Envelope = require('../record/envelope')\nconst { pipe } = require('it-pipe')\nconst all = require('it-all')\nconst filter = require('it-filter')\nconst map = require('it-map')\nconst each = require('it-foreach')\n\n/**\n * @typedef {import('./types').PeerStore} PeerStore\n * @typedef {import('./types').Address} Address\n * @typedef {import('./types').AddressBook} AddressBook\n */\n\nconst log = Object.assign(debug('libp2p:peer-store:address-book'), {\n  error: debug('libp2p:peer-store:address-book:err')\n})\n\nconst EVENT_NAME = 'change:multiaddrs'\n\n/**\n * @implements {AddressBook}\n */\nclass PeerStoreAddressBook {\n  /**\n   * @param {PeerStore[\"emit\"]} emit\n   * @param {import('./types').Store} store\n   * @param {(peerId: PeerId, multiaddr: Multiaddr) => Promise<boolean>} addressFilter\n   */\n  constructor (emit, store, addressFilter) {\n    this._emit = emit\n    this._store = store\n    this._addressFilter = addressFilter\n  }\n\n  /**\n   * ConsumePeerRecord adds addresses from a signed peer record contained in a record envelope.\n   * This will return a boolean that indicates if the record was successfully processed and added\n   * into the AddressBook.\n   *\n   * @param {Envelope} envelope\n   */\n  async consumePeerRecord (envelope) {\n    log('consumePeerRecord await write lock')\n    const release = await this._store.lock.writeLock()\n    log('consumePeerRecord got write lock')\n\n    let peerId\n    let updatedPeer\n\n    try {\n      let peerRecord\n      try {\n        peerRecord = PeerRecord.createFromProtobuf(envelope.payload)\n      } catch (/** @type {any} */ err) {\n        log.error('invalid peer record received')\n        return false\n      }\n\n      peerId = peerRecord.peerId\n      const multiaddrs = peerRecord.multiaddrs\n\n      // Verify peerId\n      if (!peerId.equals(envelope.peerId)) {\n        log('signing key does not match PeerId in the PeerRecord')\n        return false\n      }\n\n      // ensure the record has multiaddrs\n      if (!multiaddrs || !multiaddrs.length) {\n        return false\n      }\n\n      if (await this._store.has(peerId)) {\n        const peer = await this._store.load(peerId)\n\n        if (peer.peerRecordEnvelope) {\n          const storedEnvelope = await Envelope.createFromProtobuf(peer.peerRecordEnvelope)\n          const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload)\n\n          // ensure seq is greater than, or equal to, the last received\n          if (storedRecord.seqNumber >= peerRecord.seqNumber) {\n            return false\n          }\n        }\n      }\n\n      // Replace unsigned addresses by the new ones from the record\n      // TODO: Once we have ttls for the addresses, we should merge these in\n      updatedPeer = await this._store.patchOrCreate(peerId, {\n        addresses: await filterMultiaddrs(peerId, multiaddrs, this._addressFilter, true),\n        peerRecordEnvelope: envelope.marshal()\n      })\n\n      log(`stored provided peer record for ${peerRecord.peerId.toB58String()}`)\n    } finally {\n      log('consumePeerRecord release write lock')\n      release()\n    }\n\n    this._emit(EVENT_NAME, { peerId, multiaddrs: updatedPeer.addresses.map(({ multiaddr }) => multiaddr) })\n\n    return true\n  }\n\n  /**\n   * @param {PeerId} peerId\n   */\n  async getRawEnvelope (peerId) {\n    log('getRawEnvelope await read lock')\n    const release = await this._store.lock.readLock()\n    log('getRawEnvelope got read lock')\n\n    try {\n      const peer = await this._store.load(peerId)\n\n      return peer.peerRecordEnvelope\n    } catch (/** @type {any} */ err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err\n      }\n    } finally {\n      log('getRawEnvelope release read lock')\n      release()\n    }\n  }\n\n  /**\n   * Get an Envelope containing a PeerRecord for the given peer.\n   * Returns undefined if no record exists.\n   *\n   * @param {PeerId} peerId\n   */\n  async getPeerRecord (peerId) {\n    const raw = await this.getRawEnvelope(peerId)\n\n    if (!raw) {\n      return undefined\n    }\n\n    return Envelope.createFromProtobuf(raw)\n  }\n\n  /**\n   * @param {PeerId} peerId\n   */\n  async get (peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log('get wait for read lock')\n    const release = await this._store.lock.readLock()\n    log('get got read lock')\n\n    try {\n      const peer = await this._store.load(peerId)\n\n      return peer.addresses\n    } catch (/** @type {any} */ err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err\n      }\n    } finally {\n      log('get release read lock')\n      release()\n    }\n\n    return []\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {Multiaddr[]} multiaddrs\n   */\n  async set (peerId, multiaddrs) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    if (!Array.isArray(multiaddrs)) {\n      log.error('multiaddrs must be an array of Multiaddrs')\n      throw errcode(new Error('multiaddrs must be an array of Multiaddrs'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log('set await write lock')\n    const release = await this._store.lock.writeLock()\n    log('set got write lock')\n\n    let hasPeer = false\n    let updatedPeer\n\n    try {\n      const addresses = await filterMultiaddrs(peerId, multiaddrs, this._addressFilter)\n\n      // No valid addresses found\n      if (!addresses.length) {\n        return\n      }\n\n      try {\n        const peer = await this._store.load(peerId)\n        hasPeer = true\n\n        if (new Set([\n          ...addresses.map(({ multiaddr }) => multiaddr.toString()),\n          ...peer.addresses.map(({ multiaddr }) => multiaddr.toString())\n        ]).size === peer.addresses.length && addresses.length === peer.addresses.length) {\n          // not changing anything, no need to update\n          return\n        }\n      } catch (/** @type {any} */ err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err\n        }\n      }\n\n      updatedPeer = await this._store.patchOrCreate(peerId, { addresses })\n\n      log(`set multiaddrs for ${peerId.toB58String()}`)\n    } finally {\n      log('set release write lock')\n      release()\n    }\n\n    this._emit(EVENT_NAME, { peerId, multiaddrs: updatedPeer.addresses.map(addr => addr.multiaddr) })\n\n    // Notify the existence of a new peer\n    if (!hasPeer) {\n      this._emit('peer', peerId)\n    }\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {Multiaddr[]} multiaddrs\n   */\n  async add (peerId, multiaddrs) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    if (!Array.isArray(multiaddrs)) {\n      log.error('multiaddrs must be an array of Multiaddrs')\n      throw errcode(new Error('multiaddrs must be an array of Multiaddrs'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log('add await write lock')\n    const release = await this._store.lock.writeLock()\n    log('add got write lock')\n\n    let hasPeer\n    let updatedPeer\n\n    try {\n      const addresses = await filterMultiaddrs(peerId, multiaddrs, this._addressFilter)\n\n      // No valid addresses found\n      if (!addresses.length) {\n        return\n      }\n\n      try {\n        const peer = await this._store.load(peerId)\n        hasPeer = true\n\n        if (new Set([\n          ...addresses.map(({ multiaddr }) => multiaddr.toString()),\n          ...peer.addresses.map(({ multiaddr }) => multiaddr.toString())\n        ]).size === peer.addresses.length) {\n          return\n        }\n      } catch (/** @type {any} */ err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err\n        }\n      }\n\n      updatedPeer = await this._store.mergeOrCreate(peerId, { addresses })\n\n      log(`added multiaddrs for ${peerId.toB58String()}`)\n    } finally {\n      log('set release write lock')\n      release()\n    }\n\n    this._emit(EVENT_NAME, { peerId, multiaddrs: updatedPeer.addresses.map(addr => addr.multiaddr) })\n\n    // Notify the existence of a new peer\n    if (!hasPeer) {\n      this._emit('peer', peerId)\n    }\n  }\n\n  /**\n   * @param {PeerId} peerId\n   */\n  async delete (peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log('delete await write lock')\n    const release = await this._store.lock.writeLock()\n    log('delete got write lock')\n\n    let has\n\n    try {\n      has = await this._store.has(peerId)\n\n      await this._store.patchOrCreate(peerId, {\n        addresses: []\n      })\n    } finally {\n      log('delete release write lock')\n      release()\n    }\n\n    if (has) {\n      this._emit(EVENT_NAME, { peerId, multiaddrs: [] })\n    }\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {(addresses: Address[]) => Address[]} [addressSorter]\n   */\n  async getMultiaddrsForPeer (peerId, addressSorter = (ms) => ms) {\n    const addresses = await this.get(peerId)\n\n    return addressSorter(\n      addresses\n    ).map((address) => {\n      const multiaddr = address.multiaddr\n\n      const idString = multiaddr.getPeerId()\n      if (idString && idString === peerId.toB58String()) return multiaddr\n\n      return multiaddr.encapsulate(`/p2p/${peerId.toB58String()}`)\n    })\n  }\n}\n\n/**\n * @param {PeerId} peerId\n * @param {Multiaddr[]} multiaddrs\n * @param {(peerId: PeerId, multiaddr: Multiaddr) => Promise<boolean>} addressFilter\n * @param {boolean} isCertified\n */\nfunction filterMultiaddrs (peerId, multiaddrs, addressFilter, isCertified = false) {\n  return pipe(\n    multiaddrs,\n    (source) => each(source, (multiaddr) => {\n      if (!Multiaddr.isMultiaddr(multiaddr)) {\n        log.error('multiaddr must be an instance of Multiaddr')\n        throw errcode(new Error('multiaddr must be an instance of Multiaddr'), codes.ERR_INVALID_PARAMETERS)\n      }\n    }),\n    (source) => filter(source, (multiaddr) => addressFilter(peerId, multiaddr)),\n    (source) => map(source, (multiaddr) => {\n      return {\n        multiaddr: new Multiaddr(multiaddr.toString()),\n        isCertified\n      }\n    }),\n    (source) => all(source)\n  )\n}\n\nmodule.exports = PeerStoreAddressBook\n"]},"metadata":{},"sourceType":"script"}