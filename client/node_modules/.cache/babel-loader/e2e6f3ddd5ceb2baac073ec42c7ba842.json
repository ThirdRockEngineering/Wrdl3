{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst mergeOptions = require('merge-options');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst {\n  tap\n} = require('streaming-iterables');\n\nconst oldPeerLRU = require('./old-peers');\n\nconst {\n  METRICS: defaultOptions\n} = require('../constants');\n\nconst Stats = require('./stats');\n\nconst initialCounters = ['dataReceived', 'dataSent'];\nconst directionToEvent = {\n  in: 'dataReceived',\n  out: 'dataSent'\n};\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('libp2p-interfaces/src/transport/types').MultiaddrConnection} MultiaddrConnection\n */\n\n/**\n * @typedef MetricsOptions\n * @property {number} [computeThrottleMaxQueueSize = defaultOptions.computeThrottleMaxQueueSize]\n * @property {number} [computeThrottleTimeout = defaultOptions.computeThrottleTimeout]\n * @property {number[]} [movingAverageIntervals = defaultOptions.movingAverageIntervals]\n * @property {number} [maxOldPeersRetention = defaultOptions.maxOldPeersRetention]\n */\n\nclass Metrics {\n  /**\n   * @class\n   * @param {MetricsOptions} options\n   */\n  constructor(options) {\n    this._options = mergeOptions(defaultOptions, options);\n    this._globalStats = new Stats(initialCounters, this._options);\n    this._peerStats = new Map();\n    this._protocolStats = new Map();\n    this._oldPeers = oldPeerLRU(this._options.maxOldPeersRetention);\n    this._running = false;\n    this._onMessage = this._onMessage.bind(this);\n    this._systems = new Map();\n  }\n  /**\n   * Must be called for stats to saved. Any data pushed for tracking\n   * will be ignored.\n   */\n\n\n  start() {\n    this._running = true;\n  }\n  /**\n   * Stops all averages timers and prevents new data from being tracked.\n   * Once `stop` is called, `start` must be called to resume stats tracking.\n   */\n\n\n  stop() {\n    this._running = false;\n\n    this._globalStats.stop();\n\n    for (const stats of this._peerStats.values()) {\n      stats.stop();\n    }\n\n    for (const stats of this._protocolStats.values()) {\n      stats.stop();\n    }\n  }\n  /**\n   * Gets the global `Stats` object\n   *\n   * @returns {Stats}\n   */\n\n\n  get global() {\n    return this._globalStats;\n  }\n  /**\n   * Returns a list of `PeerId` strings currently being tracked\n   *\n   * @returns {string[]}\n   */\n\n\n  get peers() {\n    return Array.from(this._peerStats.keys());\n  }\n  /**\n   * @returns {Map<string, Map<string, Map<string, any>>>}\n   */\n\n\n  getComponentMetrics() {\n    return this._systems;\n  }\n\n  updateComponentMetric(_ref) {\n    let {\n      system = 'libp2p',\n      component,\n      metric,\n      value\n    } = _ref;\n\n    if (!this._systems.has(system)) {\n      this._systems.set(system, new Map());\n    }\n\n    const systemMetrics = this._systems.get(system);\n\n    if (!systemMetrics.has(component)) {\n      systemMetrics.set(component, new Map());\n    }\n\n    const componentMetrics = systemMetrics.get(component);\n    componentMetrics.set(metric, value);\n  }\n  /**\n   * Returns the `Stats` object for the given `PeerId` whether it\n   * is a live peer, or in the disconnected peer LRU cache.\n   *\n   * @param {PeerId} peerId\n   * @returns {Stats}\n   */\n\n\n  forPeer(peerId) {\n    const idString = peerId.toB58String();\n    return this._peerStats.get(idString) || this._oldPeers.get(idString);\n  }\n  /**\n   * Returns a list of all protocol strings currently being tracked.\n   *\n   * @returns {string[]}\n   */\n\n\n  get protocols() {\n    return Array.from(this._protocolStats.keys());\n  }\n  /**\n   * Returns the `Stats` object for the given `protocol`.\n   *\n   * @param {string} protocol\n   * @returns {Stats}\n   */\n\n\n  forProtocol(protocol) {\n    return this._protocolStats.get(protocol);\n  }\n  /**\n   * Should be called when all connections to a given peer\n   * have closed. The `Stats` collection for the peer will\n   * be stopped and moved to an LRU for temporary retention.\n   *\n   * @param {PeerId} peerId\n   */\n\n\n  onPeerDisconnected(peerId) {\n    const idString = peerId.toB58String();\n\n    const peerStats = this._peerStats.get(idString);\n\n    if (peerStats) {\n      peerStats.stop();\n\n      this._peerStats.delete(idString);\n\n      this._oldPeers.set(idString, peerStats);\n    }\n  }\n  /**\n   * Takes the metadata for a message and tracks it in the\n   * appropriate categories. If the protocol is present, protocol\n   * stats will also be tracked.\n   *\n   * @private\n   * @param {object} params\n   * @param {PeerId} params.remotePeer - Remote peer\n   * @param {string} [params.protocol] - Protocol string the stream is running\n   * @param {string} params.direction - One of ['in','out']\n   * @param {number} params.dataLength - Size of the message\n   * @returns {void}\n   */\n\n\n  _onMessage(_ref2) {\n    let {\n      remotePeer,\n      protocol,\n      direction,\n      dataLength\n    } = _ref2;\n    if (!this._running) return;\n    const key = directionToEvent[direction];\n    let peerStats = this.forPeer(remotePeer);\n\n    if (!peerStats) {\n      peerStats = new Stats(initialCounters, this._options);\n\n      this._peerStats.set(remotePeer.toB58String(), peerStats);\n    } // Peer and global stats\n\n\n    peerStats.push(key, dataLength);\n\n    this._globalStats.push(key, dataLength); // Protocol specific stats\n\n\n    if (protocol) {\n      let protocolStats = this.forProtocol(protocol);\n\n      if (!protocolStats) {\n        protocolStats = new Stats(initialCounters, this._options);\n\n        this._protocolStats.set(protocol, protocolStats);\n      }\n\n      protocolStats.push(key, dataLength);\n    }\n  }\n  /**\n   * Replaces the `PeerId` string with the given `peerId`.\n   * If stats are already being tracked for the given `peerId`, the\n   * placeholder stats will be merged with the existing stats.\n   *\n   * @param {PeerId} placeholder - A peerId string\n   * @param {PeerId} peerId\n   * @returns {void}\n   */\n\n\n  updatePlaceholder(placeholder, peerId) {\n    if (!this._running) return;\n    const placeholderStats = this.forPeer(placeholder);\n    const peerIdString = peerId.toB58String();\n    const existingStats = this.forPeer(peerId);\n    let mergedStats = placeholderStats; // If we already have stats, merge the two\n\n    if (existingStats) {\n      // If existing, merge\n      mergedStats = Metrics.mergeStats(existingStats, mergedStats); // Attempt to delete from the old peers list just in case it was tracked there\n\n      this._oldPeers.delete(peerIdString);\n    }\n\n    this._peerStats.delete(placeholder.toB58String());\n\n    this._peerStats.set(peerIdString, mergedStats);\n\n    mergedStats.start();\n  }\n  /**\n   * Tracks data running through a given Duplex Iterable `stream`. If\n   * the `peerId` is not provided, a placeholder string will be created and\n   * returned. This allows lazy tracking of a peer when the peer is not yet known.\n   * When the `PeerId` is known, `Metrics.updatePlaceholder` should be called\n   * with the placeholder string returned from here, and the known `PeerId`.\n   *\n   * @param {Object} options\n   * @param {MultiaddrConnection} options.stream - A duplex iterable stream\n   * @param {PeerId} [options.remotePeer] - The id of the remote peer that's connected\n   * @param {string} [options.protocol] - The protocol the stream is running\n   * @returns {MultiaddrConnection} The peerId string or placeholder string\n   */\n\n\n  trackStream(_ref3) {\n    let {\n      stream,\n      remotePeer,\n      protocol\n    } = _ref3;\n    const metrics = this;\n    const _source = stream.source;\n    stream.source = tap(chunk => metrics._onMessage({\n      remotePeer,\n      protocol,\n      direction: 'in',\n      dataLength: chunk.length\n    }))(_source);\n    const _sink = stream.sink;\n\n    stream.sink = source => {\n      return pipe(source, tap(chunk => metrics._onMessage({\n        remotePeer,\n        protocol,\n        direction: 'out',\n        dataLength: chunk.length\n      })), _sink);\n    };\n\n    return stream;\n  }\n  /**\n   * Merges `other` into `target`. `target` will be modified\n   * and returned.\n   *\n   * @param {Stats} target\n   * @param {Stats} other\n   * @returns {Stats}\n   */\n\n\n  static mergeStats(target, other) {\n    target.stop();\n    other.stop(); // Merge queues\n\n    target._queue = [...target._queue, ...other._queue]; // TODO: how to merge moving averages?\n\n    return target;\n  }\n\n}\n\nmodule.exports = Metrics;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p/src/metrics/index.js"],"names":["mergeOptions","require","pipe","tap","oldPeerLRU","METRICS","defaultOptions","Stats","initialCounters","directionToEvent","in","out","Metrics","constructor","options","_options","_globalStats","_peerStats","Map","_protocolStats","_oldPeers","maxOldPeersRetention","_running","_onMessage","bind","_systems","start","stop","stats","values","global","peers","Array","from","keys","getComponentMetrics","updateComponentMetric","system","component","metric","value","has","set","systemMetrics","get","componentMetrics","forPeer","peerId","idString","toB58String","protocols","forProtocol","protocol","onPeerDisconnected","peerStats","delete","remotePeer","direction","dataLength","key","push","protocolStats","updatePlaceholder","placeholder","placeholderStats","peerIdString","existingStats","mergedStats","mergeStats","trackStream","stream","metrics","_source","source","chunk","length","_sink","sink","target","other","_queue","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n'use strict'\n\nconst mergeOptions = require('merge-options')\nconst { pipe } = require('it-pipe')\nconst { tap } = require('streaming-iterables')\nconst oldPeerLRU = require('./old-peers')\nconst { METRICS: defaultOptions } = require('../constants')\nconst Stats = require('./stats')\n\nconst initialCounters = [\n  'dataReceived',\n  'dataSent'\n]\n\nconst directionToEvent = {\n  in: 'dataReceived',\n  out: 'dataSent'\n}\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('libp2p-interfaces/src/transport/types').MultiaddrConnection} MultiaddrConnection\n */\n\n/**\n * @typedef MetricsOptions\n * @property {number} [computeThrottleMaxQueueSize = defaultOptions.computeThrottleMaxQueueSize]\n * @property {number} [computeThrottleTimeout = defaultOptions.computeThrottleTimeout]\n * @property {number[]} [movingAverageIntervals = defaultOptions.movingAverageIntervals]\n * @property {number} [maxOldPeersRetention = defaultOptions.maxOldPeersRetention]\n */\n\nclass Metrics {\n  /**\n   * @class\n   * @param {MetricsOptions} options\n   */\n  constructor (options) {\n    this._options = mergeOptions(defaultOptions, options)\n    this._globalStats = new Stats(initialCounters, this._options)\n    this._peerStats = new Map()\n    this._protocolStats = new Map()\n    this._oldPeers = oldPeerLRU(this._options.maxOldPeersRetention)\n    this._running = false\n    this._onMessage = this._onMessage.bind(this)\n    this._systems = new Map()\n  }\n\n  /**\n   * Must be called for stats to saved. Any data pushed for tracking\n   * will be ignored.\n   */\n  start () {\n    this._running = true\n  }\n\n  /**\n   * Stops all averages timers and prevents new data from being tracked.\n   * Once `stop` is called, `start` must be called to resume stats tracking.\n   */\n  stop () {\n    this._running = false\n    this._globalStats.stop()\n    for (const stats of this._peerStats.values()) {\n      stats.stop()\n    }\n    for (const stats of this._protocolStats.values()) {\n      stats.stop()\n    }\n  }\n\n  /**\n   * Gets the global `Stats` object\n   *\n   * @returns {Stats}\n   */\n  get global () {\n    return this._globalStats\n  }\n\n  /**\n   * Returns a list of `PeerId` strings currently being tracked\n   *\n   * @returns {string[]}\n   */\n  get peers () {\n    return Array.from(this._peerStats.keys())\n  }\n\n  /**\n   * @returns {Map<string, Map<string, Map<string, any>>>}\n   */\n  getComponentMetrics () {\n    return this._systems\n  }\n\n  updateComponentMetric ({ system = 'libp2p', component, metric, value }) {\n    if (!this._systems.has(system)) {\n      this._systems.set(system, new Map())\n    }\n\n    const systemMetrics = this._systems.get(system)\n\n    if (!systemMetrics.has(component)) {\n      systemMetrics.set(component, new Map())\n    }\n\n    const componentMetrics = systemMetrics.get(component)\n\n    componentMetrics.set(metric, value)\n  }\n\n  /**\n   * Returns the `Stats` object for the given `PeerId` whether it\n   * is a live peer, or in the disconnected peer LRU cache.\n   *\n   * @param {PeerId} peerId\n   * @returns {Stats}\n   */\n  forPeer (peerId) {\n    const idString = peerId.toB58String()\n    return this._peerStats.get(idString) || this._oldPeers.get(idString)\n  }\n\n  /**\n   * Returns a list of all protocol strings currently being tracked.\n   *\n   * @returns {string[]}\n   */\n  get protocols () {\n    return Array.from(this._protocolStats.keys())\n  }\n\n  /**\n   * Returns the `Stats` object for the given `protocol`.\n   *\n   * @param {string} protocol\n   * @returns {Stats}\n   */\n  forProtocol (protocol) {\n    return this._protocolStats.get(protocol)\n  }\n\n  /**\n   * Should be called when all connections to a given peer\n   * have closed. The `Stats` collection for the peer will\n   * be stopped and moved to an LRU for temporary retention.\n   *\n   * @param {PeerId} peerId\n   */\n  onPeerDisconnected (peerId) {\n    const idString = peerId.toB58String()\n    const peerStats = this._peerStats.get(idString)\n    if (peerStats) {\n      peerStats.stop()\n      this._peerStats.delete(idString)\n      this._oldPeers.set(idString, peerStats)\n    }\n  }\n\n  /**\n   * Takes the metadata for a message and tracks it in the\n   * appropriate categories. If the protocol is present, protocol\n   * stats will also be tracked.\n   *\n   * @private\n   * @param {object} params\n   * @param {PeerId} params.remotePeer - Remote peer\n   * @param {string} [params.protocol] - Protocol string the stream is running\n   * @param {string} params.direction - One of ['in','out']\n   * @param {number} params.dataLength - Size of the message\n   * @returns {void}\n   */\n  _onMessage ({ remotePeer, protocol, direction, dataLength }) {\n    if (!this._running) return\n\n    const key = directionToEvent[direction]\n\n    let peerStats = this.forPeer(remotePeer)\n    if (!peerStats) {\n      peerStats = new Stats(initialCounters, this._options)\n      this._peerStats.set(remotePeer.toB58String(), peerStats)\n    }\n\n    // Peer and global stats\n    peerStats.push(key, dataLength)\n    this._globalStats.push(key, dataLength)\n\n    // Protocol specific stats\n    if (protocol) {\n      let protocolStats = this.forProtocol(protocol)\n      if (!protocolStats) {\n        protocolStats = new Stats(initialCounters, this._options)\n        this._protocolStats.set(protocol, protocolStats)\n      }\n      protocolStats.push(key, dataLength)\n    }\n  }\n\n  /**\n   * Replaces the `PeerId` string with the given `peerId`.\n   * If stats are already being tracked for the given `peerId`, the\n   * placeholder stats will be merged with the existing stats.\n   *\n   * @param {PeerId} placeholder - A peerId string\n   * @param {PeerId} peerId\n   * @returns {void}\n   */\n  updatePlaceholder (placeholder, peerId) {\n    if (!this._running) return\n    const placeholderStats = this.forPeer(placeholder)\n    const peerIdString = peerId.toB58String()\n    const existingStats = this.forPeer(peerId)\n    let mergedStats = placeholderStats\n\n    // If we already have stats, merge the two\n    if (existingStats) {\n      // If existing, merge\n      mergedStats = Metrics.mergeStats(existingStats, mergedStats)\n      // Attempt to delete from the old peers list just in case it was tracked there\n      this._oldPeers.delete(peerIdString)\n    }\n\n    this._peerStats.delete(placeholder.toB58String())\n    this._peerStats.set(peerIdString, mergedStats)\n    mergedStats.start()\n  }\n\n  /**\n   * Tracks data running through a given Duplex Iterable `stream`. If\n   * the `peerId` is not provided, a placeholder string will be created and\n   * returned. This allows lazy tracking of a peer when the peer is not yet known.\n   * When the `PeerId` is known, `Metrics.updatePlaceholder` should be called\n   * with the placeholder string returned from here, and the known `PeerId`.\n   *\n   * @param {Object} options\n   * @param {MultiaddrConnection} options.stream - A duplex iterable stream\n   * @param {PeerId} [options.remotePeer] - The id of the remote peer that's connected\n   * @param {string} [options.protocol] - The protocol the stream is running\n   * @returns {MultiaddrConnection} The peerId string or placeholder string\n   */\n  trackStream ({ stream, remotePeer, protocol }) {\n    const metrics = this\n    const _source = stream.source\n    stream.source = tap(chunk => metrics._onMessage({\n      remotePeer,\n      protocol,\n      direction: 'in',\n      dataLength: chunk.length\n    }))(_source)\n\n    const _sink = stream.sink\n    stream.sink = source => {\n      return pipe(\n        source,\n        tap(chunk => metrics._onMessage({\n          remotePeer,\n          protocol,\n          direction: 'out',\n          dataLength: chunk.length\n        })),\n        _sink\n      )\n    }\n\n    return stream\n  }\n\n  /**\n   * Merges `other` into `target`. `target` will be modified\n   * and returned.\n   *\n   * @param {Stats} target\n   * @param {Stats} other\n   * @returns {Stats}\n   */\n  static mergeStats (target, other) {\n    target.stop()\n    other.stop()\n\n    // Merge queues\n    target._queue = [...target._queue, ...other._queue]\n\n    // TODO: how to merge moving averages?\n    return target\n  }\n}\n\nmodule.exports = Metrics\n"]},"metadata":{},"sourceType":"script"}