{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar PeerId = require('peer-id');\n\nvar errCode = require('err-code');\n\nvar debug = require('debug');\n\nvar publisher = require('./publisher.js');\n\nvar republisher = require('./republisher.js');\n\nvar resolver = require('./resolver.js');\n\nvar tlru = require('../utils/tlru.js');\n\nvar toString = require('uint8arrays/to-string');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\n\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\n\nconst log = Object.assign(debug__default[\"default\"]('ipfs:ipns'), {\n  error: debug__default[\"default\"]('ipfs:ipns:error')\n});\nconst defaultRecordTtl = 60 * 1000;\n\nclass IPNS {\n  constructor(routing, datastore, peerId, keychain, options) {\n    this.publisher = new publisher.IpnsPublisher(routing, datastore);\n    this.republisher = new republisher.IpnsRepublisher(this.publisher, datastore, peerId, keychain, options);\n    this.resolver = new resolver.IpnsResolver(routing);\n    this.cache = new tlru.TLRU(1000);\n    this.routing = routing;\n  }\n\n  async publish(privKey, value) {\n    let lifetime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : publisher.IpnsPublisher.defaultRecordLifetime;\n\n    try {\n      const peerId = await PeerId.createFromPrivKey(privKey.bytes);\n      await this.publisher.publishWithEOL(privKey, value, lifetime);\n      log(`IPNS value ${toString.toString(value, 'base32')} was published correctly`);\n      const id = peerId.toB58String();\n      const ttEol = parseFloat(lifetime);\n      const ttl = ttEol < defaultRecordTtl ? ttEol : defaultRecordTtl;\n      this.cache.set(id, value, ttl);\n      log(`IPNS value ${toString.toString(value, 'base32')} was cached correctly`);\n      return {\n        name: id,\n        value: value\n      };\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n  }\n\n  async resolve(name) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (typeof name !== 'string') {\n      throw errCode__default[\"default\"](new Error('name received is not valid'), 'ERR_INVALID_NAME');\n    }\n\n    if (!options.nocache && !options.recursive) {\n      const id = name.split('/')[2];\n      const result = this.cache.get(id);\n\n      if (result) {\n        return result;\n      }\n    }\n\n    try {\n      const result = await this.resolver.resolve(name, options);\n      log(`IPNS record from ${name} was resolved correctly`);\n      return result;\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n  }\n\n  async initializeKeyspace(privKey, value) {\n    return this.publish(privKey, value, publisher.IpnsPublisher.defaultRecordLifetime);\n  }\n\n}\n\nexports.IPNS = IPNS;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-core/cjs/src/ipns/index.js"],"names":["Object","defineProperty","exports","value","PeerId","require","errCode","debug","publisher","republisher","resolver","tlru","toString","_interopDefaultLegacy","e","errCode__default","debug__default","log","assign","error","defaultRecordTtl","IPNS","constructor","routing","datastore","peerId","keychain","options","IpnsPublisher","IpnsRepublisher","IpnsResolver","cache","TLRU","publish","privKey","lifetime","defaultRecordLifetime","createFromPrivKey","bytes","publishWithEOL","id","toB58String","ttEol","parseFloat","ttl","set","name","err","resolve","Error","nocache","recursive","split","result","get","initializeKeyspace"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar PeerId = require('peer-id');\nvar errCode = require('err-code');\nvar debug = require('debug');\nvar publisher = require('./publisher.js');\nvar republisher = require('./republisher.js');\nvar resolver = require('./resolver.js');\nvar tlru = require('../utils/tlru.js');\nvar toString = require('uint8arrays/to-string');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\n\nconst log = Object.assign(debug__default[\"default\"]('ipfs:ipns'), { error: debug__default[\"default\"]('ipfs:ipns:error') });\nconst defaultRecordTtl = 60 * 1000;\nclass IPNS {\n  constructor(routing, datastore, peerId, keychain, options) {\n    this.publisher = new publisher.IpnsPublisher(routing, datastore);\n    this.republisher = new republisher.IpnsRepublisher(this.publisher, datastore, peerId, keychain, options);\n    this.resolver = new resolver.IpnsResolver(routing);\n    this.cache = new tlru.TLRU(1000);\n    this.routing = routing;\n  }\n  async publish(privKey, value, lifetime = publisher.IpnsPublisher.defaultRecordLifetime) {\n    try {\n      const peerId = await PeerId.createFromPrivKey(privKey.bytes);\n      await this.publisher.publishWithEOL(privKey, value, lifetime);\n      log(`IPNS value ${ toString.toString(value, 'base32') } was published correctly`);\n      const id = peerId.toB58String();\n      const ttEol = parseFloat(lifetime);\n      const ttl = ttEol < defaultRecordTtl ? ttEol : defaultRecordTtl;\n      this.cache.set(id, value, ttl);\n      log(`IPNS value ${ toString.toString(value, 'base32') } was cached correctly`);\n      return {\n        name: id,\n        value: value\n      };\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n  }\n  async resolve(name, options = {}) {\n    if (typeof name !== 'string') {\n      throw errCode__default[\"default\"](new Error('name received is not valid'), 'ERR_INVALID_NAME');\n    }\n    if (!options.nocache && !options.recursive) {\n      const id = name.split('/')[2];\n      const result = this.cache.get(id);\n      if (result) {\n        return result;\n      }\n    }\n    try {\n      const result = await this.resolver.resolve(name, options);\n      log(`IPNS record from ${ name } was resolved correctly`);\n      return result;\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n  }\n  async initializeKeyspace(privKey, value) {\n    return this.publish(privKey, value, publisher.IpnsPublisher.defaultRecordLifetime);\n  }\n}\n\nexports.IPNS = IPNS;\n"]},"metadata":{},"sourceType":"script"}