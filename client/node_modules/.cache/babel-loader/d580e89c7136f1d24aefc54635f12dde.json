{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst all = require('it-all');\n\nconst filter = require('it-filter');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst log = Object.assign(debug('libp2p:dialer'), {\n  error: debug('libp2p:dialer:err')\n});\n\nconst errCode = require('err-code');\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst {\n  TimeoutController\n} = require('timeout-abort-controller');\n\nconst {\n  AbortError\n} = require('abortable-iterator');\n\nconst {\n  anySignal\n} = require('any-signal'); // @ts-expect-error setMaxListeners is missing from the types\n\n\nconst {\n  setMaxListeners\n} = require('events');\n\nconst DialRequest = require('./dial-request');\n\nconst {\n  publicAddressesFirst\n} = require('libp2p-utils/src/address-sort');\n\nconst getPeer = require('../get-peer');\n\nconst trackedMap = require('../metrics/tracked-map');\n\nconst {\n  codes\n} = require('../errors');\n\nconst {\n  DIAL_TIMEOUT,\n  MAX_PARALLEL_DIALS,\n  MAX_PER_PEER_DIALS,\n  MAX_ADDRS_TO_DIAL\n} = require('../constants');\n\nconst METRICS_COMPONENT = 'dialler';\nconst METRICS_PENDING_DIALS = 'pending-dials';\nconst METRICS_PENDING_DIAL_TARGETS = 'pending-dial-targets';\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../peer-store/types').PeerStore} PeerStore\n * @typedef {import('../peer-store/types').Address} Address\n * @typedef {import('../transport-manager')} TransportManager\n * @typedef {import('../types').ConnectionGater} ConnectionGater\n */\n\n/**\n * @typedef {Object} DialerProperties\n * @property {PeerStore} peerStore\n * @property {TransportManager} transportManager\n * @property {ConnectionGater} connectionGater\n *\n * @typedef {(addr:Multiaddr) => Promise<string[]>} Resolver\n *\n * @typedef {Object} DialerOptions\n * @property {(addresses: Address[]) => Address[]} [options.addressSorter = publicAddressesFirst] - Sort the known addresses of a peer before trying to dial.\n * @property {number} [maxParallelDials = MAX_PARALLEL_DIALS] - Number of max concurrent dials.\n * @property {number} [maxAddrsToDial = MAX_ADDRS_TO_DIAL] - Number of max addresses to dial for a given peer.\n * @property {number} [maxDialsPerPeer = MAX_PER_PEER_DIALS] - Number of max concurrent dials per peer.\n * @property {number} [dialTimeout = DIAL_TIMEOUT] - How long a dial attempt is allowed to take.\n * @property {Record<string, Resolver>} [resolvers = {}] - multiaddr resolvers to use when dialing\n * @property {import('../metrics')} [metrics]\n *\n * @typedef DialTarget\n * @property {string} id\n * @property {Multiaddr[]} addrs\n *\n * @typedef PendingDial\n * @property {import('./dial-request')} dialRequest\n * @property {import('timeout-abort-controller').TimeoutController} controller\n * @property {Promise<Connection>} promise\n * @property {function():void} destroy\n */\n\nclass Dialer {\n  /**\n   * @class\n   * @param {DialerProperties & DialerOptions} options\n   */\n  constructor(_ref) {\n    let {\n      transportManager,\n      peerStore,\n      connectionGater,\n      addressSorter = publicAddressesFirst,\n      maxParallelDials = MAX_PARALLEL_DIALS,\n      maxAddrsToDial = MAX_ADDRS_TO_DIAL,\n      dialTimeout = DIAL_TIMEOUT,\n      maxDialsPerPeer = MAX_PER_PEER_DIALS,\n      resolvers = {},\n      metrics\n    } = _ref;\n    this.connectionGater = connectionGater;\n    this.transportManager = transportManager;\n    this.peerStore = peerStore;\n    this.addressSorter = addressSorter;\n    this.maxParallelDials = maxParallelDials;\n    this.maxAddrsToDial = maxAddrsToDial;\n    this.timeout = dialTimeout;\n    this.maxDialsPerPeer = maxDialsPerPeer;\n    this.tokens = [...new Array(maxParallelDials)].map((_, index) => index);\n    /** @type {Map<string, PendingDial>} */\n\n    this._pendingDials = trackedMap({\n      component: METRICS_COMPONENT,\n      metric: METRICS_PENDING_DIALS,\n      metrics\n    });\n    /** @type {Map<string, { resolve: (value: any) => void, reject: (err: Error) => void}>} */\n\n    this._pendingDialTargets = trackedMap({\n      component: METRICS_COMPONENT,\n      metric: METRICS_PENDING_DIAL_TARGETS,\n      metrics\n    });\n\n    for (const [key, value] of Object.entries(resolvers)) {\n      Multiaddr.resolvers.set(key, value);\n    }\n  }\n  /**\n   * Clears any pending dials\n   */\n\n\n  destroy() {\n    for (const dial of this._pendingDials.values()) {\n      try {\n        dial.controller.abort();\n      } catch (\n      /** @type {any} */\n      err) {\n        log.error(err);\n      }\n    }\n\n    this._pendingDials.clear();\n\n    for (const pendingTarget of this._pendingDialTargets.values()) {\n      pendingTarget.reject(new AbortError('Dialer was destroyed'));\n    }\n\n    this._pendingDialTargets.clear();\n  }\n  /**\n   * Connects to a given `peer` by dialing all of its known addresses.\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used.\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - An AbortController signal\n   * @returns {Promise<Connection>}\n   */\n\n\n  async connectToPeer(peer) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      id\n    } = getPeer(peer);\n\n    if (await this.connectionGater.denyDialPeer(id)) {\n      throw errCode(new Error('The dial request is blocked by gater.allowDialPeer'), codes.ERR_PEER_DIAL_INTERCEPTED);\n    }\n\n    const dialTarget = await this._createCancellableDialTarget(peer);\n\n    if (!dialTarget.addrs.length) {\n      throw errCode(new Error('The dial request has no valid addresses'), codes.ERR_NO_VALID_ADDRESSES);\n    }\n\n    const pendingDial = this._pendingDials.get(dialTarget.id) || this._createPendingDial(dialTarget, options);\n\n    try {\n      const connection = await pendingDial.promise;\n      log('dial succeeded to %s', dialTarget.id);\n      return connection;\n    } catch (\n    /** @type {any} */\n    err) {\n      // Error is a timeout\n      if (pendingDial.controller.signal.aborted) {\n        err.code = codes.ERR_TIMEOUT;\n      }\n\n      log.error(err);\n      throw err;\n    } finally {\n      pendingDial.destroy();\n    }\n  }\n  /**\n   * Connects to a given `peer` by dialing all of its known addresses.\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used.\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @returns {Promise<DialTarget>}\n   */\n\n\n  async _createCancellableDialTarget(peer) {\n    // Make dial target promise cancellable\n    const id = `${parseInt(String(Math.random() * 1e9), 10).toString() + Date.now()}`;\n    const cancellablePromise = new Promise((resolve, reject) => {\n      this._pendingDialTargets.set(id, {\n        resolve,\n        reject\n      });\n    });\n\n    try {\n      const dialTarget = await Promise.race([this._createDialTarget(peer), cancellablePromise]);\n      return dialTarget;\n    } finally {\n      this._pendingDialTargets.delete(id);\n    }\n  }\n  /**\n   * Creates a DialTarget. The DialTarget is used to create and track\n   * the DialRequest to a given peer.\n   * If a multiaddr is received it should be the first address attempted.\n   * Multiaddrs not supported by the available transports will be filtered out.\n   *\n   * @private\n   * @param {PeerId|Multiaddr|string} peer - A PeerId or Multiaddr\n   * @returns {Promise<DialTarget>}\n   */\n\n\n  async _createDialTarget(peer) {\n    const {\n      id,\n      multiaddrs\n    } = getPeer(peer);\n\n    if (multiaddrs) {\n      await this.peerStore.addressBook.add(id, multiaddrs);\n    }\n\n    let knownAddrs = await pipe(await this.peerStore.addressBook.getMultiaddrsForPeer(id, this.addressSorter), source => filter(source, async multiaddr => {\n      return !(await this.connectionGater.denyDialMultiaddr(id, multiaddr));\n    }), source => all(source)); // If received a multiaddr to dial, it should be the first to use\n    // But, if we know other multiaddrs for the peer, we should try them too.\n\n    if (Multiaddr.isMultiaddr(peer)) {\n      knownAddrs = knownAddrs.filter(addr => !peer.equals(addr));\n      knownAddrs.unshift(peer);\n    }\n    /** @type {Multiaddr[]} */\n\n\n    const addrs = [];\n\n    for (const a of knownAddrs) {\n      const resolvedAddrs = await this._resolve(a);\n      resolvedAddrs.forEach(ra => addrs.push(ra));\n    } // Multiaddrs not supported by the available transports will be filtered out.\n\n\n    const supportedAddrs = addrs.filter(a => this.transportManager.transportForMultiaddr(a));\n\n    if (supportedAddrs.length > this.maxAddrsToDial) {\n      await this.peerStore.delete(id);\n      throw errCode(new Error('dial with more addresses than allowed'), codes.ERR_TOO_MANY_ADDRESSES);\n    }\n\n    return {\n      id: id.toB58String(),\n      addrs: supportedAddrs\n    };\n  }\n  /**\n   * Creates a PendingDial that wraps the underlying DialRequest\n   *\n   * @private\n   * @param {DialTarget} dialTarget\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - An AbortController signal\n   * @returns {PendingDial}\n   */\n\n\n  _createPendingDial(dialTarget) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    /**\n     * @param {Multiaddr} addr\n     * @param {{ signal: { aborted: any; }; }} options\n     */\n    const dialAction = (addr, options) => {\n      if (options.signal.aborted) throw errCode(new Error('already aborted'), codes.ERR_ALREADY_ABORTED);\n      return this.transportManager.dial(addr, options);\n    };\n\n    const dialRequest = new DialRequest({\n      addrs: dialTarget.addrs,\n      dialAction,\n      dialer: this\n    }); // Combine the timeout signal and options.signal, if provided\n\n    const timeoutController = new TimeoutController(this.timeout);\n    const signals = [timeoutController.signal];\n    options.signal && signals.push(options.signal);\n    const signal = anySignal(signals); // this signal will potentially be used while dialing lots of\n    // peers so prevent MaxListenersExceededWarning appearing in the console\n\n    try {\n      // fails on node < 15.4\n      setMaxListeners && setMaxListeners(Infinity, signal);\n    } catch {}\n\n    const pendingDial = {\n      dialRequest,\n      controller: timeoutController,\n      promise: dialRequest.run({ ...options,\n        signal\n      }),\n      destroy: () => {\n        timeoutController.clear();\n\n        this._pendingDials.delete(dialTarget.id);\n      }\n    };\n\n    this._pendingDials.set(dialTarget.id, pendingDial);\n\n    return pendingDial;\n  }\n  /**\n   * @param {number} num\n   */\n\n\n  getTokens(num) {\n    const total = Math.min(num, this.maxDialsPerPeer, this.tokens.length);\n    const tokens = this.tokens.splice(0, total);\n    log('%d tokens request, returning %d, %d remaining', num, total, this.tokens.length);\n    return tokens;\n  }\n  /**\n   * @param {number} token\n   */\n\n\n  releaseToken(token) {\n    // Guard against duplicate releases\n    if (this.tokens.indexOf(token) > -1) return;\n    log('token %d released', token);\n    this.tokens.push(token);\n  }\n  /**\n   * Resolve multiaddr recursively.\n   *\n   * @param {Multiaddr} ma\n   * @returns {Promise<Multiaddr[]>}\n   */\n\n\n  async _resolve(ma) {\n    // TODO: recursive logic should live in multiaddr once dns4/dns6 support is in place\n    // Now only supporting resolve for dnsaddr\n    const resolvableProto = ma.protoNames().includes('dnsaddr'); // Multiaddr is not resolvable? End recursion!\n\n    if (!resolvableProto) {\n      return [ma];\n    }\n\n    const resolvedMultiaddrs = await this._resolveRecord(ma);\n    const recursiveMultiaddrs = await Promise.all(resolvedMultiaddrs.map(nm => {\n      return this._resolve(nm);\n    }));\n    const addrs = recursiveMultiaddrs.flat();\n    return addrs.reduce((array, newM) => {\n      if (!array.find(m => m.equals(newM))) {\n        array.push(newM);\n      }\n\n      return array;\n    },\n    /** @type  {Multiaddr[]} */\n    []);\n  }\n  /**\n   * Resolve a given multiaddr. If this fails, an empty array will be returned\n   *\n   * @param {Multiaddr} ma\n   * @returns {Promise<Multiaddr[]>}\n   */\n\n\n  async _resolveRecord(ma) {\n    try {\n      ma = new Multiaddr(ma.toString()); // Use current multiaddr module\n\n      const multiaddrs = await ma.resolve();\n      return multiaddrs;\n    } catch (_) {\n      log.error(`multiaddr ${ma} could not be resolved`);\n      return [];\n    }\n  }\n\n}\n\nmodule.exports = Dialer;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p/src/dialer/index.js"],"names":["debug","require","all","filter","pipe","log","Object","assign","error","errCode","Multiaddr","TimeoutController","AbortError","anySignal","setMaxListeners","DialRequest","publicAddressesFirst","getPeer","trackedMap","codes","DIAL_TIMEOUT","MAX_PARALLEL_DIALS","MAX_PER_PEER_DIALS","MAX_ADDRS_TO_DIAL","METRICS_COMPONENT","METRICS_PENDING_DIALS","METRICS_PENDING_DIAL_TARGETS","Dialer","constructor","transportManager","peerStore","connectionGater","addressSorter","maxParallelDials","maxAddrsToDial","dialTimeout","maxDialsPerPeer","resolvers","metrics","timeout","tokens","Array","map","_","index","_pendingDials","component","metric","_pendingDialTargets","key","value","entries","set","destroy","dial","values","controller","abort","err","clear","pendingTarget","reject","connectToPeer","peer","options","id","denyDialPeer","Error","ERR_PEER_DIAL_INTERCEPTED","dialTarget","_createCancellableDialTarget","addrs","length","ERR_NO_VALID_ADDRESSES","pendingDial","get","_createPendingDial","connection","promise","signal","aborted","code","ERR_TIMEOUT","parseInt","String","Math","random","toString","Date","now","cancellablePromise","Promise","resolve","race","_createDialTarget","delete","multiaddrs","addressBook","add","knownAddrs","getMultiaddrsForPeer","source","multiaddr","denyDialMultiaddr","isMultiaddr","addr","equals","unshift","a","resolvedAddrs","_resolve","forEach","ra","push","supportedAddrs","transportForMultiaddr","ERR_TOO_MANY_ADDRESSES","toB58String","dialAction","ERR_ALREADY_ABORTED","dialRequest","dialer","timeoutController","signals","Infinity","run","getTokens","num","total","min","splice","releaseToken","token","indexOf","ma","resolvableProto","protoNames","includes","resolvedMultiaddrs","_resolveRecord","recursiveMultiaddrs","nm","flat","reduce","array","newM","find","m","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst all = require('it-all')\nconst filter = require('it-filter')\nconst { pipe } = require('it-pipe')\nconst log = Object.assign(debug('libp2p:dialer'), {\n  error: debug('libp2p:dialer:err')\n})\nconst errCode = require('err-code')\nconst { Multiaddr } = require('multiaddr')\nconst { TimeoutController } = require('timeout-abort-controller')\nconst { AbortError } = require('abortable-iterator')\nconst { anySignal } = require('any-signal')\n// @ts-expect-error setMaxListeners is missing from the types\nconst { setMaxListeners } = require('events')\nconst DialRequest = require('./dial-request')\nconst { publicAddressesFirst } = require('libp2p-utils/src/address-sort')\nconst getPeer = require('../get-peer')\nconst trackedMap = require('../metrics/tracked-map')\nconst { codes } = require('../errors')\nconst {\n  DIAL_TIMEOUT,\n  MAX_PARALLEL_DIALS,\n  MAX_PER_PEER_DIALS,\n  MAX_ADDRS_TO_DIAL\n} = require('../constants')\n\nconst METRICS_COMPONENT = 'dialler'\nconst METRICS_PENDING_DIALS = 'pending-dials'\nconst METRICS_PENDING_DIAL_TARGETS = 'pending-dial-targets'\n\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../peer-store/types').PeerStore} PeerStore\n * @typedef {import('../peer-store/types').Address} Address\n * @typedef {import('../transport-manager')} TransportManager\n * @typedef {import('../types').ConnectionGater} ConnectionGater\n */\n\n/**\n * @typedef {Object} DialerProperties\n * @property {PeerStore} peerStore\n * @property {TransportManager} transportManager\n * @property {ConnectionGater} connectionGater\n *\n * @typedef {(addr:Multiaddr) => Promise<string[]>} Resolver\n *\n * @typedef {Object} DialerOptions\n * @property {(addresses: Address[]) => Address[]} [options.addressSorter = publicAddressesFirst] - Sort the known addresses of a peer before trying to dial.\n * @property {number} [maxParallelDials = MAX_PARALLEL_DIALS] - Number of max concurrent dials.\n * @property {number} [maxAddrsToDial = MAX_ADDRS_TO_DIAL] - Number of max addresses to dial for a given peer.\n * @property {number} [maxDialsPerPeer = MAX_PER_PEER_DIALS] - Number of max concurrent dials per peer.\n * @property {number} [dialTimeout = DIAL_TIMEOUT] - How long a dial attempt is allowed to take.\n * @property {Record<string, Resolver>} [resolvers = {}] - multiaddr resolvers to use when dialing\n * @property {import('../metrics')} [metrics]\n *\n * @typedef DialTarget\n * @property {string} id\n * @property {Multiaddr[]} addrs\n *\n * @typedef PendingDial\n * @property {import('./dial-request')} dialRequest\n * @property {import('timeout-abort-controller').TimeoutController} controller\n * @property {Promise<Connection>} promise\n * @property {function():void} destroy\n */\n\nclass Dialer {\n  /**\n   * @class\n   * @param {DialerProperties & DialerOptions} options\n   */\n  constructor ({\n    transportManager,\n    peerStore,\n    connectionGater,\n    addressSorter = publicAddressesFirst,\n    maxParallelDials = MAX_PARALLEL_DIALS,\n    maxAddrsToDial = MAX_ADDRS_TO_DIAL,\n    dialTimeout = DIAL_TIMEOUT,\n    maxDialsPerPeer = MAX_PER_PEER_DIALS,\n    resolvers = {},\n    metrics\n  }) {\n    this.connectionGater = connectionGater\n    this.transportManager = transportManager\n    this.peerStore = peerStore\n    this.addressSorter = addressSorter\n    this.maxParallelDials = maxParallelDials\n    this.maxAddrsToDial = maxAddrsToDial\n    this.timeout = dialTimeout\n    this.maxDialsPerPeer = maxDialsPerPeer\n    this.tokens = [...new Array(maxParallelDials)].map((_, index) => index)\n\n    /** @type {Map<string, PendingDial>} */\n    this._pendingDials = trackedMap({\n      component: METRICS_COMPONENT,\n      metric: METRICS_PENDING_DIALS,\n      metrics\n    })\n\n    /** @type {Map<string, { resolve: (value: any) => void, reject: (err: Error) => void}>} */\n    this._pendingDialTargets = trackedMap({\n      component: METRICS_COMPONENT,\n      metric: METRICS_PENDING_DIAL_TARGETS,\n      metrics\n    })\n\n    for (const [key, value] of Object.entries(resolvers)) {\n      Multiaddr.resolvers.set(key, value)\n    }\n  }\n\n  /**\n   * Clears any pending dials\n   */\n  destroy () {\n    for (const dial of this._pendingDials.values()) {\n      try {\n        dial.controller.abort()\n      } catch (/** @type {any} */ err) {\n        log.error(err)\n      }\n    }\n    this._pendingDials.clear()\n\n    for (const pendingTarget of this._pendingDialTargets.values()) {\n      pendingTarget.reject(new AbortError('Dialer was destroyed'))\n    }\n    this._pendingDialTargets.clear()\n  }\n\n  /**\n   * Connects to a given `peer` by dialing all of its known addresses.\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used.\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - An AbortController signal\n   * @returns {Promise<Connection>}\n   */\n  async connectToPeer (peer, options = {}) {\n    const { id } = getPeer(peer)\n\n    if (await this.connectionGater.denyDialPeer(id)) {\n      throw errCode(new Error('The dial request is blocked by gater.allowDialPeer'), codes.ERR_PEER_DIAL_INTERCEPTED)\n    }\n\n    const dialTarget = await this._createCancellableDialTarget(peer)\n\n    if (!dialTarget.addrs.length) {\n      throw errCode(new Error('The dial request has no valid addresses'), codes.ERR_NO_VALID_ADDRESSES)\n    }\n    const pendingDial = this._pendingDials.get(dialTarget.id) || this._createPendingDial(dialTarget, options)\n\n    try {\n      const connection = await pendingDial.promise\n      log('dial succeeded to %s', dialTarget.id)\n      return connection\n    } catch (/** @type {any} */ err) {\n      // Error is a timeout\n      if (pendingDial.controller.signal.aborted) {\n        err.code = codes.ERR_TIMEOUT\n      }\n      log.error(err)\n      throw err\n    } finally {\n      pendingDial.destroy()\n    }\n  }\n\n  /**\n   * Connects to a given `peer` by dialing all of its known addresses.\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used.\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @returns {Promise<DialTarget>}\n   */\n  async _createCancellableDialTarget (peer) {\n    // Make dial target promise cancellable\n    const id = `${(parseInt(String(Math.random() * 1e9), 10)).toString() + Date.now()}`\n    const cancellablePromise = new Promise((resolve, reject) => {\n      this._pendingDialTargets.set(id, { resolve, reject })\n    })\n\n    try {\n      const dialTarget = await Promise.race([\n        this._createDialTarget(peer),\n        cancellablePromise\n      ])\n\n      return dialTarget\n    } finally {\n      this._pendingDialTargets.delete(id)\n    }\n  }\n\n  /**\n   * Creates a DialTarget. The DialTarget is used to create and track\n   * the DialRequest to a given peer.\n   * If a multiaddr is received it should be the first address attempted.\n   * Multiaddrs not supported by the available transports will be filtered out.\n   *\n   * @private\n   * @param {PeerId|Multiaddr|string} peer - A PeerId or Multiaddr\n   * @returns {Promise<DialTarget>}\n   */\n  async _createDialTarget (peer) {\n    const { id, multiaddrs } = getPeer(peer)\n\n    if (multiaddrs) {\n      await this.peerStore.addressBook.add(id, multiaddrs)\n    }\n\n    let knownAddrs = await pipe(\n      await this.peerStore.addressBook.getMultiaddrsForPeer(id, this.addressSorter),\n      (source) => filter(source, async (multiaddr) => {\n        return !(await this.connectionGater.denyDialMultiaddr(id, multiaddr))\n      }),\n      (source) => all(source)\n    )\n\n    // If received a multiaddr to dial, it should be the first to use\n    // But, if we know other multiaddrs for the peer, we should try them too.\n    if (Multiaddr.isMultiaddr(peer)) {\n      knownAddrs = knownAddrs.filter((addr) => !peer.equals(addr))\n      knownAddrs.unshift(peer)\n    }\n\n    /** @type {Multiaddr[]} */\n    const addrs = []\n    for (const a of knownAddrs) {\n      const resolvedAddrs = await this._resolve(a)\n      resolvedAddrs.forEach(ra => addrs.push(ra))\n    }\n\n    // Multiaddrs not supported by the available transports will be filtered out.\n    const supportedAddrs = addrs.filter(a => this.transportManager.transportForMultiaddr(a))\n\n    if (supportedAddrs.length > this.maxAddrsToDial) {\n      await this.peerStore.delete(id)\n      throw errCode(new Error('dial with more addresses than allowed'), codes.ERR_TOO_MANY_ADDRESSES)\n    }\n\n    return {\n      id: id.toB58String(),\n      addrs: supportedAddrs\n    }\n  }\n\n  /**\n   * Creates a PendingDial that wraps the underlying DialRequest\n   *\n   * @private\n   * @param {DialTarget} dialTarget\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - An AbortController signal\n   * @returns {PendingDial}\n   */\n  _createPendingDial (dialTarget, options = {}) {\n    /**\n     * @param {Multiaddr} addr\n     * @param {{ signal: { aborted: any; }; }} options\n     */\n    const dialAction = (addr, options) => {\n      if (options.signal.aborted) throw errCode(new Error('already aborted'), codes.ERR_ALREADY_ABORTED)\n      return this.transportManager.dial(addr, options)\n    }\n\n    const dialRequest = new DialRequest({\n      addrs: dialTarget.addrs,\n      dialAction,\n      dialer: this\n    })\n\n    // Combine the timeout signal and options.signal, if provided\n    const timeoutController = new TimeoutController(this.timeout)\n\n    const signals = [timeoutController.signal]\n    options.signal && signals.push(options.signal)\n    const signal = anySignal(signals)\n\n    // this signal will potentially be used while dialing lots of\n    // peers so prevent MaxListenersExceededWarning appearing in the console\n    try {\n      // fails on node < 15.4\n      setMaxListeners && setMaxListeners(Infinity, signal)\n    } catch {}\n\n    const pendingDial = {\n      dialRequest,\n      controller: timeoutController,\n      promise: dialRequest.run({ ...options, signal }),\n      destroy: () => {\n        timeoutController.clear()\n        this._pendingDials.delete(dialTarget.id)\n      }\n    }\n    this._pendingDials.set(dialTarget.id, pendingDial)\n\n    return pendingDial\n  }\n\n  /**\n   * @param {number} num\n   */\n  getTokens (num) {\n    const total = Math.min(num, this.maxDialsPerPeer, this.tokens.length)\n    const tokens = this.tokens.splice(0, total)\n    log('%d tokens request, returning %d, %d remaining', num, total, this.tokens.length)\n    return tokens\n  }\n\n  /**\n   * @param {number} token\n   */\n  releaseToken (token) {\n    // Guard against duplicate releases\n    if (this.tokens.indexOf(token) > -1) return\n    log('token %d released', token)\n    this.tokens.push(token)\n  }\n\n  /**\n   * Resolve multiaddr recursively.\n   *\n   * @param {Multiaddr} ma\n   * @returns {Promise<Multiaddr[]>}\n   */\n  async _resolve (ma) {\n    // TODO: recursive logic should live in multiaddr once dns4/dns6 support is in place\n    // Now only supporting resolve for dnsaddr\n    const resolvableProto = ma.protoNames().includes('dnsaddr')\n\n    // Multiaddr is not resolvable? End recursion!\n    if (!resolvableProto) {\n      return [ma]\n    }\n\n    const resolvedMultiaddrs = await this._resolveRecord(ma)\n    const recursiveMultiaddrs = await Promise.all(resolvedMultiaddrs.map((nm) => {\n      return this._resolve(nm)\n    }))\n\n    const addrs = recursiveMultiaddrs.flat()\n    return addrs.reduce((array, newM) => {\n      if (!array.find(m => m.equals(newM))) {\n        array.push(newM)\n      }\n      return array\n    }, /** @type  {Multiaddr[]} */([]))\n  }\n\n  /**\n   * Resolve a given multiaddr. If this fails, an empty array will be returned\n   *\n   * @param {Multiaddr} ma\n   * @returns {Promise<Multiaddr[]>}\n   */\n  async _resolveRecord (ma) {\n    try {\n      ma = new Multiaddr(ma.toString()) // Use current multiaddr module\n      const multiaddrs = await ma.resolve()\n      return multiaddrs\n    } catch (_) {\n      log.error(`multiaddr ${ma} could not be resolved`)\n      return []\n    }\n  }\n}\n\nmodule.exports = Dialer\n"]},"metadata":{},"sourceType":"script"}