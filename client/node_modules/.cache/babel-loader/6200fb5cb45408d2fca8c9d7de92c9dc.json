{"ast":null,"code":"'use strict';\n\nconst errcode = require('err-code');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst lp = require('it-length-prefixed');\n\nconst drain = require('it-drain');\n\nconst first = require('it-first');\n\nconst {\n  Message,\n  MESSAGE_TYPE_LOOKUP\n} = require('./message');\n\nconst utils = require('./utils');\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst {\n  dialingPeerEvent,\n  sendingQueryEvent,\n  peerResponseEvent,\n  queryErrorEvent\n} = require('./query/events');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('./types').QueryEvent} QueryEvent\n * @typedef {import('./types').PeerData} PeerData\n */\n\n/**\n * Handle network operations for the dht\n */\n\n\nclass Network extends EventEmitter {\n  /**\n   * Create a new network\n   *\n   * @param {object} params\n   * @param {import('./types').Dialer} params.dialer\n   * @param {string} params.protocol\n   * @param {boolean} params.lan\n   */\n  constructor(_ref) {\n    let {\n      dialer,\n      protocol,\n      lan\n    } = _ref;\n    super();\n    this._log = utils.logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}:network`);\n    this._running = false;\n    this._dialer = dialer;\n    this._protocol = protocol;\n  }\n  /**\n   * Start the network\n   */\n\n\n  start() {\n    if (this._running) {\n      return;\n    }\n\n    this._running = true;\n  }\n  /**\n   * Stop all network activity\n   */\n\n\n  stop() {\n    this._running = false;\n  }\n  /**\n   * Is the network online?\n   *\n   * @type {boolean}\n   */\n\n\n  get isStarted() {\n    return this._running;\n  }\n  /**\n   * Send a request and record RTT for latency measurements\n   *\n   * @param {PeerId} to - The peer that should receive a message\n   * @param {Message} msg - The message to send\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  async *sendRequest(to, msg) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (!this._running) {\n      return;\n    }\n\n    this._log('sending %s to %p', MESSAGE_TYPE_LOOKUP[msg.type], to);\n\n    try {\n      yield dialingPeerEvent({\n        peer: to\n      });\n      const {\n        stream\n      } = await this._dialer.dialProtocol(to, this._protocol, options);\n      yield sendingQueryEvent({\n        to,\n        type: msg.type\n      });\n      const response = await this._writeReadMessage(stream, msg.serialize(), options);\n      yield peerResponseEvent({\n        from: to,\n        messageType: response.type,\n        closer: response.closerPeers,\n        providers: response.providerPeers,\n        record: response.record\n      });\n    } catch (\n    /** @type {any} */\n    err) {\n      yield queryErrorEvent({\n        from: to,\n        error: err\n      });\n    }\n  }\n  /**\n   * Sends a message without expecting an answer.\n   *\n   * @param {PeerId} to\n   * @param {Message} msg\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  async *sendMessage(to, msg) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (!this._running) {\n      return;\n    }\n\n    this._log('sending %s to %p', MESSAGE_TYPE_LOOKUP[msg.type], to);\n\n    yield dialingPeerEvent({\n      peer: to\n    });\n    const {\n      stream\n    } = await this._dialer.dialProtocol(to, this._protocol, options);\n    yield sendingQueryEvent({\n      to,\n      type: msg.type\n    });\n\n    try {\n      await this._writeMessage(stream, msg.serialize(), options);\n      yield peerResponseEvent({\n        from: to,\n        messageType: msg.type\n      });\n    } catch (\n    /** @type {any} */\n    err) {\n      yield queryErrorEvent({\n        from: to,\n        error: err\n      });\n    }\n  }\n  /**\n   * Write a message to the given stream\n   *\n   * @param {MuxedStream} stream - the stream to use\n   * @param {Uint8Array} msg - the message to send\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  async _writeMessage(stream, msg) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    await pipe([msg], lp.encode(), stream, drain);\n  }\n  /**\n   * Write a message and read its response.\n   * If no response is received after the specified timeout\n   * this will error out.\n   *\n   * @param {MuxedStream} stream - the stream to use\n   * @param {Uint8Array} msg - the message to send\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  async _writeReadMessage(stream, msg) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const res = await pipe([msg], lp.encode(), stream, lp.decode(),\n    /**\n     * @param {AsyncIterable<Uint8Array>} source\n     */\n    async source => {\n      const buf = await first(source);\n\n      if (buf) {\n        return buf.slice();\n      }\n    });\n\n    if (res.length === 0) {\n      throw errcode(new Error('No message received'), 'ERR_NO_MESSAGE_RECEIVED');\n    }\n\n    const message = Message.deserialize(res); // tell any listeners about new peers we've seen\n\n    message.closerPeers.forEach(peerData => {\n      this.emit('peer', peerData);\n    });\n    message.providerPeers.forEach(peerData => {\n      this.emit('peer', peerData);\n    });\n    return message;\n  }\n\n}\n\nmodule.exports.Network = Network;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p-kad-dht/src/network.js"],"names":["errcode","require","pipe","lp","drain","first","Message","MESSAGE_TYPE_LOOKUP","utils","EventEmitter","dialingPeerEvent","sendingQueryEvent","peerResponseEvent","queryErrorEvent","Network","constructor","dialer","protocol","lan","_log","logger","_running","_dialer","_protocol","start","stop","isStarted","sendRequest","to","msg","options","type","peer","stream","dialProtocol","response","_writeReadMessage","serialize","from","messageType","closer","closerPeers","providers","providerPeers","record","err","error","sendMessage","_writeMessage","encode","res","decode","source","buf","slice","length","Error","message","deserialize","forEach","peerData","emit","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAWD,OAAO,CAAC,SAAD,CAAxB;;AACA,MAAME,EAAE,GAAGF,OAAO,CAAC,oBAAD,CAAlB;;AACA,MAAMG,KAAK,GAAGH,OAAO,CAAC,UAAD,CAArB;;AACA,MAAMI,KAAK,GAAGJ,OAAO,CAAC,UAAD,CAArB;;AACA,MAAM;AAAEK,EAAAA,OAAF;AAAWC,EAAAA;AAAX,IAAmCN,OAAO,CAAC,WAAD,CAAhD;;AACA,MAAMO,KAAK,GAAGP,OAAO,CAAC,SAAD,CAArB;;AACA,MAAM;AAAEQ,EAAAA;AAAF,IAAmBR,OAAO,CAAC,QAAD,CAAhC;;AACA,MAAM;AACJS,EAAAA,gBADI;AAEJC,EAAAA,iBAFI;AAGJC,EAAAA,iBAHI;AAIJC,EAAAA;AAJI,IAKFZ,OAAO,CAAC,gBAAD,CALX;AAOA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AACA,MAAMa,OAAN,SAAsBL,YAAtB,CAAmC;AACjC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACEM,EAAAA,WAAW,OAA6B;AAAA,QAA3B;AAAEC,MAAAA,MAAF;AAAUC,MAAAA,QAAV;AAAoBC,MAAAA;AAApB,KAA2B;AACtC;AAEA,SAAKC,IAAL,GAAYX,KAAK,CAACY,MAAN,CAAc,kBAAiBF,GAAG,GAAG,KAAH,GAAW,KAAM,UAAnD,CAAZ;AACA,SAAKG,QAAL,GAAgB,KAAhB;AACA,SAAKC,OAAL,GAAeN,MAAf;AACA,SAAKO,SAAL,GAAiBN,QAAjB;AACD;AAED;AACF;AACA;;;AACEO,EAAAA,KAAK,GAAI;AACP,QAAI,KAAKH,QAAT,EAAmB;AACjB;AACD;;AAED,SAAKA,QAAL,GAAgB,IAAhB;AACD;AAED;AACF;AACA;;;AACEI,EAAAA,IAAI,GAAI;AACN,SAAKJ,QAAL,GAAgB,KAAhB;AACD;AAED;AACF;AACA;AACA;AACA;;;AACe,MAATK,SAAS,GAAI;AACf,WAAO,KAAKL,QAAZ;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACqB,SAAXM,WAAW,CAAEC,EAAF,EAAMC,GAAN,EAAyB;AAAA,QAAdC,OAAc,uEAAJ,EAAI;;AAC1C,QAAI,CAAC,KAAKT,QAAV,EAAoB;AAClB;AACD;;AAED,SAAKF,IAAL,CAAU,kBAAV,EAA8BZ,mBAAmB,CAACsB,GAAG,CAACE,IAAL,CAAjD,EAA6DH,EAA7D;;AAEA,QAAI;AACF,YAAMlB,gBAAgB,CAAC;AAAEsB,QAAAA,IAAI,EAAEJ;AAAR,OAAD,CAAtB;AAEA,YAAM;AAAEK,QAAAA;AAAF,UAAa,MAAM,KAAKX,OAAL,CAAaY,YAAb,CAA0BN,EAA1B,EAA8B,KAAKL,SAAnC,EAA8CO,OAA9C,CAAzB;AAEA,YAAMnB,iBAAiB,CAAC;AAAEiB,QAAAA,EAAF;AAAMG,QAAAA,IAAI,EAAEF,GAAG,CAACE;AAAhB,OAAD,CAAvB;AAEA,YAAMI,QAAQ,GAAG,MAAM,KAAKC,iBAAL,CAAuBH,MAAvB,EAA+BJ,GAAG,CAACQ,SAAJ,EAA/B,EAAgDP,OAAhD,CAAvB;AAEA,YAAMlB,iBAAiB,CAAC;AACtB0B,QAAAA,IAAI,EAAEV,EADgB;AAEtBW,QAAAA,WAAW,EAAEJ,QAAQ,CAACJ,IAFA;AAGtBS,QAAAA,MAAM,EAAEL,QAAQ,CAACM,WAHK;AAItBC,QAAAA,SAAS,EAAEP,QAAQ,CAACQ,aAJE;AAKtBC,QAAAA,MAAM,EAAET,QAAQ,CAACS;AALK,OAAD,CAAvB;AAOD,KAhBD,CAgBE;AAAO;AAAmBC,IAAAA,GAA1B,EAA+B;AAC/B,YAAMhC,eAAe,CAAC;AAAEyB,QAAAA,IAAI,EAAEV,EAAR;AAAYkB,QAAAA,KAAK,EAAED;AAAnB,OAAD,CAArB;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACqB,SAAXE,WAAW,CAAEnB,EAAF,EAAMC,GAAN,EAAyB;AAAA,QAAdC,OAAc,uEAAJ,EAAI;;AAC1C,QAAI,CAAC,KAAKT,QAAV,EAAoB;AAClB;AACD;;AAED,SAAKF,IAAL,CAAU,kBAAV,EAA8BZ,mBAAmB,CAACsB,GAAG,CAACE,IAAL,CAAjD,EAA6DH,EAA7D;;AAEA,UAAMlB,gBAAgB,CAAC;AAAEsB,MAAAA,IAAI,EAAEJ;AAAR,KAAD,CAAtB;AAEA,UAAM;AAAEK,MAAAA;AAAF,QAAa,MAAM,KAAKX,OAAL,CAAaY,YAAb,CAA0BN,EAA1B,EAA8B,KAAKL,SAAnC,EAA8CO,OAA9C,CAAzB;AAEA,UAAMnB,iBAAiB,CAAC;AAAEiB,MAAAA,EAAF;AAAMG,MAAAA,IAAI,EAAEF,GAAG,CAACE;AAAhB,KAAD,CAAvB;;AAEA,QAAI;AACF,YAAM,KAAKiB,aAAL,CAAmBf,MAAnB,EAA2BJ,GAAG,CAACQ,SAAJ,EAA3B,EAA4CP,OAA5C,CAAN;AAEA,YAAMlB,iBAAiB,CAAC;AAAE0B,QAAAA,IAAI,EAAEV,EAAR;AAAYW,QAAAA,WAAW,EAAEV,GAAG,CAACE;AAA7B,OAAD,CAAvB;AACD,KAJD,CAIE;AAAO;AAAmBc,IAAAA,GAA1B,EAA+B;AAC/B,YAAMhC,eAAe,CAAC;AAAEyB,QAAAA,IAAI,EAAEV,EAAR;AAAYkB,QAAAA,KAAK,EAAED;AAAnB,OAAD,CAArB;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACqB,QAAbG,aAAa,CAAEf,MAAF,EAAUJ,GAAV,EAA6B;AAAA,QAAdC,OAAc,uEAAJ,EAAI;AAC9C,UAAM5B,IAAI,CACR,CAAC2B,GAAD,CADQ,EAER1B,EAAE,CAAC8C,MAAH,EAFQ,EAGRhB,MAHQ,EAIR7B,KAJQ,CAAV;AAMD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACyB,QAAjBgC,iBAAiB,CAAEH,MAAF,EAAUJ,GAAV,EAA6B;AAAA,QAAdC,OAAc,uEAAJ,EAAI;AAClD,UAAMoB,GAAG,GAAG,MAAMhD,IAAI,CACpB,CAAC2B,GAAD,CADoB,EAEpB1B,EAAE,CAAC8C,MAAH,EAFoB,EAGpBhB,MAHoB,EAIpB9B,EAAE,CAACgD,MAAH,EAJoB;AAKpB;AACN;AACA;AACM,UAAMC,MAAN,IAAgB;AACd,YAAMC,GAAG,GAAG,MAAMhD,KAAK,CAAC+C,MAAD,CAAvB;;AAEA,UAAIC,GAAJ,EAAS;AACP,eAAOA,GAAG,CAACC,KAAJ,EAAP;AACD;AACF,KAdmB,CAAtB;;AAiBA,QAAIJ,GAAG,CAACK,MAAJ,KAAe,CAAnB,EAAsB;AACpB,YAAMvD,OAAO,CAAC,IAAIwD,KAAJ,CAAU,qBAAV,CAAD,EAAmC,yBAAnC,CAAb;AACD;;AAED,UAAMC,OAAO,GAAGnD,OAAO,CAACoD,WAAR,CAAoBR,GAApB,CAAhB,CAtBkD,CAwBlD;;AACAO,IAAAA,OAAO,CAAChB,WAAR,CAAoBkB,OAApB,CAA4BC,QAAQ,IAAI;AACtC,WAAKC,IAAL,CAAU,MAAV,EAAkBD,QAAlB;AACD,KAFD;AAGAH,IAAAA,OAAO,CAACd,aAAR,CAAsBgB,OAAtB,CAA8BC,QAAQ,IAAI;AACxC,WAAKC,IAAL,CAAU,MAAV,EAAkBD,QAAlB;AACD,KAFD;AAIA,WAAOH,OAAP;AACD;;AA3KgC;;AA8KnCK,MAAM,CAACC,OAAP,CAAejD,OAAf,GAAyBA,OAAzB","sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst { pipe } = require('it-pipe')\nconst lp = require('it-length-prefixed')\nconst drain = require('it-drain')\nconst first = require('it-first')\nconst { Message, MESSAGE_TYPE_LOOKUP } = require('./message')\nconst utils = require('./utils')\nconst { EventEmitter } = require('events')\nconst {\n  dialingPeerEvent,\n  sendingQueryEvent,\n  peerResponseEvent,\n  queryErrorEvent\n} = require('./query/events')\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('./types').QueryEvent} QueryEvent\n * @typedef {import('./types').PeerData} PeerData\n */\n\n/**\n * Handle network operations for the dht\n */\nclass Network extends EventEmitter {\n  /**\n   * Create a new network\n   *\n   * @param {object} params\n   * @param {import('./types').Dialer} params.dialer\n   * @param {string} params.protocol\n   * @param {boolean} params.lan\n   */\n  constructor ({ dialer, protocol, lan }) {\n    super()\n\n    this._log = utils.logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}:network`)\n    this._running = false\n    this._dialer = dialer\n    this._protocol = protocol\n  }\n\n  /**\n   * Start the network\n   */\n  start () {\n    if (this._running) {\n      return\n    }\n\n    this._running = true\n  }\n\n  /**\n   * Stop all network activity\n   */\n  stop () {\n    this._running = false\n  }\n\n  /**\n   * Is the network online?\n   *\n   * @type {boolean}\n   */\n  get isStarted () {\n    return this._running\n  }\n\n  /**\n   * Send a request and record RTT for latency measurements\n   *\n   * @param {PeerId} to - The peer that should receive a message\n   * @param {Message} msg - The message to send\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async * sendRequest (to, msg, options = {}) {\n    if (!this._running) {\n      return\n    }\n\n    this._log('sending %s to %p', MESSAGE_TYPE_LOOKUP[msg.type], to)\n\n    try {\n      yield dialingPeerEvent({ peer: to })\n\n      const { stream } = await this._dialer.dialProtocol(to, this._protocol, options)\n\n      yield sendingQueryEvent({ to, type: msg.type })\n\n      const response = await this._writeReadMessage(stream, msg.serialize(), options)\n\n      yield peerResponseEvent({\n        from: to,\n        messageType: response.type,\n        closer: response.closerPeers,\n        providers: response.providerPeers,\n        record: response.record\n      })\n    } catch (/** @type {any} */ err) {\n      yield queryErrorEvent({ from: to, error: err })\n    }\n  }\n\n  /**\n   * Sends a message without expecting an answer.\n   *\n   * @param {PeerId} to\n   * @param {Message} msg\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async * sendMessage (to, msg, options = {}) {\n    if (!this._running) {\n      return\n    }\n\n    this._log('sending %s to %p', MESSAGE_TYPE_LOOKUP[msg.type], to)\n\n    yield dialingPeerEvent({ peer: to })\n\n    const { stream } = await this._dialer.dialProtocol(to, this._protocol, options)\n\n    yield sendingQueryEvent({ to, type: msg.type })\n\n    try {\n      await this._writeMessage(stream, msg.serialize(), options)\n\n      yield peerResponseEvent({ from: to, messageType: msg.type })\n    } catch (/** @type {any} */ err) {\n      yield queryErrorEvent({ from: to, error: err })\n    }\n  }\n\n  /**\n   * Write a message to the given stream\n   *\n   * @param {MuxedStream} stream - the stream to use\n   * @param {Uint8Array} msg - the message to send\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async _writeMessage (stream, msg, options = {}) {\n    await pipe(\n      [msg],\n      lp.encode(),\n      stream,\n      drain\n    )\n  }\n\n  /**\n   * Write a message and read its response.\n   * If no response is received after the specified timeout\n   * this will error out.\n   *\n   * @param {MuxedStream} stream - the stream to use\n   * @param {Uint8Array} msg - the message to send\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async _writeReadMessage (stream, msg, options = {}) {\n    const res = await pipe(\n      [msg],\n      lp.encode(),\n      stream,\n      lp.decode(),\n      /**\n       * @param {AsyncIterable<Uint8Array>} source\n       */\n      async source => {\n        const buf = await first(source)\n\n        if (buf) {\n          return buf.slice()\n        }\n      }\n    )\n\n    if (res.length === 0) {\n      throw errcode(new Error('No message received'), 'ERR_NO_MESSAGE_RECEIVED')\n    }\n\n    const message = Message.deserialize(res)\n\n    // tell any listeners about new peers we've seen\n    message.closerPeers.forEach(peerData => {\n      this.emit('peer', peerData)\n    })\n    message.providerPeers.forEach(peerData => {\n      this.emit('peer', peerData)\n    })\n\n    return message\n  }\n}\n\nmodule.exports.Network = Network\n"]},"metadata":{},"sourceType":"script"}