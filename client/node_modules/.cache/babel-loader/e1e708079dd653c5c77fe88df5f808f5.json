{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar ipns = require('ipns');\n\nvar crypto = require('libp2p-crypto');\n\nvar PeerId = require('peer-id');\n\nvar errCode = require('err-code');\n\nvar debug = require('debug');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar ipns__namespace = /*#__PURE__*/_interopNamespace(ipns);\n\nvar crypto__default = /*#__PURE__*/_interopDefaultLegacy(crypto);\n\nvar PeerId__default = /*#__PURE__*/_interopDefaultLegacy(PeerId);\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\n\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\n\nconst log = Object.assign(debug__default[\"default\"]('ipfs:ipns:republisher'), {\n  error: debug__default[\"default\"]('ipfs:ipns:republisher:error')\n});\nconst minute = 60 * 1000;\nconst hour = 60 * minute;\nconst defaultBroadcastInterval = 4 * hour;\nconst defaultRecordLifetime = 24 * hour;\n\nclass IpnsRepublisher {\n  constructor(publisher, datastore, peerId, keychain) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n      pass: ''\n    };\n    this._publisher = publisher;\n    this._datastore = datastore;\n    this._peerId = peerId;\n    this._keychain = keychain;\n    this._options = options;\n    this._republishHandle = null;\n  }\n\n  async start() {\n    if (this._republishHandle) {\n      throw errCode__default[\"default\"](new Error('republisher is already running'), 'ERR_REPUBLISH_ALREADY_RUNNING');\n    }\n\n    const republishHandle = {\n      _task: null,\n      _inflightTask: null,\n      _timeoutId: null,\n      runPeriodically: period => {\n        republishHandle._timeoutId = setTimeout(async () => {\n          republishHandle._timeoutId = null;\n\n          try {\n            republishHandle._inflightTask = republishHandle._task();\n            await republishHandle._inflightTask;\n\n            if (republishHandle._task) {\n              republishHandle.runPeriodically(period);\n            }\n          } catch (err) {\n            log.error(err);\n          }\n        }, period());\n      },\n      cancel: async () => {\n        if (republishHandle._timeoutId != null) {\n          clearTimeout(republishHandle._timeoutId);\n        }\n\n        republishHandle._task = null;\n        await republishHandle._inflightTask;\n      }\n    };\n    const {\n      privKey\n    } = this._peerId;\n    const {\n      pass\n    } = this._options;\n    let firstRun = true;\n\n    republishHandle._task = () => this._republishEntries(privKey, pass);\n\n    republishHandle.runPeriodically(() => {\n      if (firstRun) {\n        firstRun = false;\n        return this._options.initialBroadcastInterval || minute;\n      }\n\n      return this._options.broadcastInterval || defaultBroadcastInterval;\n    });\n    this._republishHandle = republishHandle;\n  }\n\n  async stop() {\n    const republishHandle = this._republishHandle;\n\n    if (!republishHandle) {\n      throw errCode__default[\"default\"](new Error('republisher is not running'), 'ERR_REPUBLISH_NOT_RUNNING');\n    }\n\n    this._republishHandle = null;\n    await republishHandle.cancel();\n  }\n\n  async _republishEntries(privateKey, pass) {\n    try {\n      await this._republishEntry(privateKey);\n    } catch (err) {\n      const errMsg = 'cannot republish entry for the node\\'s private key';\n      log.error(errMsg);\n      return;\n    }\n\n    if (pass) {\n      try {\n        const keys = await this._keychain.listKeys();\n\n        for (const key of keys) {\n          if (key.name === 'self') {\n            continue;\n          }\n\n          const pem = await this._keychain.exportKey(key.name, pass);\n          const privKey = await crypto__default[\"default\"].keys.import(pem, pass);\n          await this._republishEntry(privKey);\n        }\n      } catch (err) {\n        log.error(err);\n      }\n    }\n  }\n\n  async _republishEntry(privateKey) {\n    if (!privateKey || !privateKey.bytes) {\n      throw errCode__default[\"default\"](new Error('invalid private key'), 'ERR_INVALID_PRIVATE_KEY');\n    }\n\n    try {\n      const peerId = await PeerId__default[\"default\"].createFromPrivKey(privateKey.bytes);\n      const value = await this._getPreviousValue(peerId);\n      await this._publisher.publishWithEOL(privateKey, value, defaultRecordLifetime);\n    } catch (err) {\n      if (err.code === 'ERR_NO_ENTRY_FOUND') {\n        return;\n      }\n\n      throw err;\n    }\n  }\n\n  async _getPreviousValue(peerId) {\n    if (!PeerId__default[\"default\"].isPeerId(peerId)) {\n      throw errCode__default[\"default\"](new Error('invalid peer ID'), 'ERR_INVALID_PEER_ID');\n    }\n\n    try {\n      const dsVal = await this._datastore.get(ipns__namespace.getLocalKey(peerId.id));\n\n      if (!(dsVal instanceof Uint8Array)) {\n        throw errCode__default[\"default\"](new Error('found ipns record that we couldn\\'t process'), 'ERR_INVALID_IPNS_RECORD');\n      }\n\n      try {\n        const record = ipns__namespace.unmarshal(dsVal);\n        return record.value;\n      } catch (err) {\n        log.error(err);\n        throw errCode__default[\"default\"](new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_IPNS_RECORD');\n      }\n    } catch (err) {\n      if (err && err.notFound) {\n        throw errCode__default[\"default\"](new Error(`no previous entry for record with id: ${peerId.id}`), 'ERR_NO_ENTRY_FOUND');\n      }\n\n      throw err;\n    }\n  }\n\n}\n\nexports.IpnsRepublisher = IpnsRepublisher;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-core/cjs/src/ipns/republisher.js"],"names":["Object","defineProperty","exports","value","ipns","require","crypto","PeerId","errCode","debug","_interopDefaultLegacy","e","_interopNamespace","__esModule","n","create","keys","forEach","k","d","getOwnPropertyDescriptor","get","enumerable","freeze","ipns__namespace","crypto__default","PeerId__default","errCode__default","debug__default","log","assign","error","minute","hour","defaultBroadcastInterval","defaultRecordLifetime","IpnsRepublisher","constructor","publisher","datastore","peerId","keychain","options","pass","_publisher","_datastore","_peerId","_keychain","_options","_republishHandle","start","Error","republishHandle","_task","_inflightTask","_timeoutId","runPeriodically","period","setTimeout","err","cancel","clearTimeout","privKey","firstRun","_republishEntries","initialBroadcastInterval","broadcastInterval","stop","privateKey","_republishEntry","errMsg","listKeys","key","name","pem","exportKey","import","bytes","createFromPrivKey","_getPreviousValue","publishWithEOL","code","isPeerId","dsVal","getLocalKey","id","Uint8Array","record","unmarshal","notFound"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AAEA,IAAIC,IAAI,GAAGC,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,eAAD,CAApB;;AACA,IAAIE,MAAM,GAAGF,OAAO,CAAC,SAAD,CAApB;;AACA,IAAIG,OAAO,GAAGH,OAAO,CAAC,UAAD,CAArB;;AACA,IAAII,KAAK,GAAGJ,OAAO,CAAC,OAAD,CAAnB;;AAEA,SAASK,qBAAT,CAAgCC,CAAhC,EAAmC;AAAE,SAAOA,CAAC,IAAI,OAAOA,CAAP,KAAa,QAAlB,IAA8B,aAAaA,CAA3C,GAA+CA,CAA/C,GAAmD;AAAE,eAAWA;AAAb,GAA1D;AAA6E;;AAElH,SAASC,iBAAT,CAA2BD,CAA3B,EAA8B;AAC5B,MAAIA,CAAC,IAAIA,CAAC,CAACE,UAAX,EAAuB,OAAOF,CAAP;AACvB,MAAIG,CAAC,GAAGd,MAAM,CAACe,MAAP,CAAc,IAAd,CAAR;;AACA,MAAIJ,CAAJ,EAAO;AACLX,IAAAA,MAAM,CAACgB,IAAP,CAAYL,CAAZ,EAAeM,OAAf,CAAuB,UAAUC,CAAV,EAAa;AAClC,UAAIA,CAAC,KAAK,SAAV,EAAqB;AACnB,YAAIC,CAAC,GAAGnB,MAAM,CAACoB,wBAAP,CAAgCT,CAAhC,EAAmCO,CAAnC,CAAR;AACAlB,QAAAA,MAAM,CAACC,cAAP,CAAsBa,CAAtB,EAAyBI,CAAzB,EAA4BC,CAAC,CAACE,GAAF,GAAQF,CAAR,GAAY;AACtCG,UAAAA,UAAU,EAAE,IAD0B;AAEtCD,UAAAA,GAAG,EAAE,YAAY;AAAE,mBAAOV,CAAC,CAACO,CAAD,CAAR;AAAc;AAFK,SAAxC;AAID;AACF,KARD;AASD;;AACDJ,EAAAA,CAAC,CAAC,SAAD,CAAD,GAAeH,CAAf;AACA,SAAOX,MAAM,CAACuB,MAAP,CAAcT,CAAd,CAAP;AACD;;AAED,IAAIU,eAAe,GAAG,aAAaZ,iBAAiB,CAACR,IAAD,CAApD;;AACA,IAAIqB,eAAe,GAAG,aAAaf,qBAAqB,CAACJ,MAAD,CAAxD;;AACA,IAAIoB,eAAe,GAAG,aAAahB,qBAAqB,CAACH,MAAD,CAAxD;;AACA,IAAIoB,gBAAgB,GAAG,aAAajB,qBAAqB,CAACF,OAAD,CAAzD;;AACA,IAAIoB,cAAc,GAAG,aAAalB,qBAAqB,CAACD,KAAD,CAAvD;;AAEA,MAAMoB,GAAG,GAAG7B,MAAM,CAAC8B,MAAP,CAAcF,cAAc,CAAC,SAAD,CAAd,CAA0B,uBAA1B,CAAd,EAAkE;AAAEG,EAAAA,KAAK,EAAEH,cAAc,CAAC,SAAD,CAAd,CAA0B,6BAA1B;AAAT,CAAlE,CAAZ;AACA,MAAMI,MAAM,GAAG,KAAK,IAApB;AACA,MAAMC,IAAI,GAAG,KAAKD,MAAlB;AACA,MAAME,wBAAwB,GAAG,IAAID,IAArC;AACA,MAAME,qBAAqB,GAAG,KAAKF,IAAnC;;AACA,MAAMG,eAAN,CAAsB;AACpBC,EAAAA,WAAW,CAACC,SAAD,EAAYC,SAAZ,EAAuBC,MAAvB,EAA+BC,QAA/B,EAAiE;AAAA,QAAxBC,OAAwB,uEAAd;AAAEC,MAAAA,IAAI,EAAE;AAAR,KAAc;AAC1E,SAAKC,UAAL,GAAkBN,SAAlB;AACA,SAAKO,UAAL,GAAkBN,SAAlB;AACA,SAAKO,OAAL,GAAeN,MAAf;AACA,SAAKO,SAAL,GAAiBN,QAAjB;AACA,SAAKO,QAAL,GAAgBN,OAAhB;AACA,SAAKO,gBAAL,GAAwB,IAAxB;AACD;;AACU,QAALC,KAAK,GAAG;AACZ,QAAI,KAAKD,gBAAT,EAA2B;AACzB,YAAMtB,gBAAgB,CAAC,SAAD,CAAhB,CAA4B,IAAIwB,KAAJ,CAAU,gCAAV,CAA5B,EAAyE,+BAAzE,CAAN;AACD;;AACD,UAAMC,eAAe,GAAG;AACtBC,MAAAA,KAAK,EAAE,IADe;AAEtBC,MAAAA,aAAa,EAAE,IAFO;AAGtBC,MAAAA,UAAU,EAAE,IAHU;AAItBC,MAAAA,eAAe,EAAEC,MAAM,IAAI;AACzBL,QAAAA,eAAe,CAACG,UAAhB,GAA6BG,UAAU,CAAC,YAAY;AAClDN,UAAAA,eAAe,CAACG,UAAhB,GAA6B,IAA7B;;AACA,cAAI;AACFH,YAAAA,eAAe,CAACE,aAAhB,GAAgCF,eAAe,CAACC,KAAhB,EAAhC;AACA,kBAAMD,eAAe,CAACE,aAAtB;;AACA,gBAAIF,eAAe,CAACC,KAApB,EAA2B;AACzBD,cAAAA,eAAe,CAACI,eAAhB,CAAgCC,MAAhC;AACD;AACF,WAND,CAME,OAAOE,GAAP,EAAY;AACZ9B,YAAAA,GAAG,CAACE,KAAJ,CAAU4B,GAAV;AACD;AACF,SAXsC,EAWpCF,MAAM,EAX8B,CAAvC;AAYD,OAjBqB;AAkBtBG,MAAAA,MAAM,EAAE,YAAY;AAClB,YAAIR,eAAe,CAACG,UAAhB,IAA8B,IAAlC,EAAwC;AACtCM,UAAAA,YAAY,CAACT,eAAe,CAACG,UAAjB,CAAZ;AACD;;AACDH,QAAAA,eAAe,CAACC,KAAhB,GAAwB,IAAxB;AACA,cAAMD,eAAe,CAACE,aAAtB;AACD;AAxBqB,KAAxB;AA0BA,UAAM;AAACQ,MAAAA;AAAD,QAAY,KAAKhB,OAAvB;AACA,UAAM;AAACH,MAAAA;AAAD,QAAS,KAAKK,QAApB;AACA,QAAIe,QAAQ,GAAG,IAAf;;AACAX,IAAAA,eAAe,CAACC,KAAhB,GAAwB,MAAM,KAAKW,iBAAL,CAAuBF,OAAvB,EAAgCnB,IAAhC,CAA9B;;AACAS,IAAAA,eAAe,CAACI,eAAhB,CAAgC,MAAM;AACpC,UAAIO,QAAJ,EAAc;AACZA,QAAAA,QAAQ,GAAG,KAAX;AACA,eAAO,KAAKf,QAAL,CAAciB,wBAAd,IAA0CjC,MAAjD;AACD;;AACD,aAAO,KAAKgB,QAAL,CAAckB,iBAAd,IAAmChC,wBAA1C;AACD,KAND;AAOA,SAAKe,gBAAL,GAAwBG,eAAxB;AACD;;AACS,QAAJe,IAAI,GAAG;AACX,UAAMf,eAAe,GAAG,KAAKH,gBAA7B;;AACA,QAAI,CAACG,eAAL,EAAsB;AACpB,YAAMzB,gBAAgB,CAAC,SAAD,CAAhB,CAA4B,IAAIwB,KAAJ,CAAU,4BAAV,CAA5B,EAAqE,2BAArE,CAAN;AACD;;AACD,SAAKF,gBAAL,GAAwB,IAAxB;AACA,UAAMG,eAAe,CAACQ,MAAhB,EAAN;AACD;;AACsB,QAAjBI,iBAAiB,CAACI,UAAD,EAAazB,IAAb,EAAmB;AACxC,QAAI;AACF,YAAM,KAAK0B,eAAL,CAAqBD,UAArB,CAAN;AACD,KAFD,CAEE,OAAOT,GAAP,EAAY;AACZ,YAAMW,MAAM,GAAG,oDAAf;AACAzC,MAAAA,GAAG,CAACE,KAAJ,CAAUuC,MAAV;AACA;AACD;;AACD,QAAI3B,IAAJ,EAAU;AACR,UAAI;AACF,cAAM3B,IAAI,GAAG,MAAM,KAAK+B,SAAL,CAAewB,QAAf,EAAnB;;AACA,aAAK,MAAMC,GAAX,IAAkBxD,IAAlB,EAAwB;AACtB,cAAIwD,GAAG,CAACC,IAAJ,KAAa,MAAjB,EAAyB;AACvB;AACD;;AACD,gBAAMC,GAAG,GAAG,MAAM,KAAK3B,SAAL,CAAe4B,SAAf,CAAyBH,GAAG,CAACC,IAA7B,EAAmC9B,IAAnC,CAAlB;AACA,gBAAMmB,OAAO,GAAG,MAAMrC,eAAe,CAAC,SAAD,CAAf,CAA2BT,IAA3B,CAAgC4D,MAAhC,CAAuCF,GAAvC,EAA4C/B,IAA5C,CAAtB;AACA,gBAAM,KAAK0B,eAAL,CAAqBP,OAArB,CAAN;AACD;AACF,OAVD,CAUE,OAAOH,GAAP,EAAY;AACZ9B,QAAAA,GAAG,CAACE,KAAJ,CAAU4B,GAAV;AACD;AACF;AACF;;AACoB,QAAfU,eAAe,CAACD,UAAD,EAAa;AAChC,QAAI,CAACA,UAAD,IAAe,CAACA,UAAU,CAACS,KAA/B,EAAsC;AACpC,YAAMlD,gBAAgB,CAAC,SAAD,CAAhB,CAA4B,IAAIwB,KAAJ,CAAU,qBAAV,CAA5B,EAA8D,yBAA9D,CAAN;AACD;;AACD,QAAI;AACF,YAAMX,MAAM,GAAG,MAAMd,eAAe,CAAC,SAAD,CAAf,CAA2BoD,iBAA3B,CAA6CV,UAAU,CAACS,KAAxD,CAArB;AACA,YAAM1E,KAAK,GAAG,MAAM,KAAK4E,iBAAL,CAAuBvC,MAAvB,CAApB;AACA,YAAM,KAAKI,UAAL,CAAgBoC,cAAhB,CAA+BZ,UAA/B,EAA2CjE,KAA3C,EAAkDgC,qBAAlD,CAAN;AACD,KAJD,CAIE,OAAOwB,GAAP,EAAY;AACZ,UAAIA,GAAG,CAACsB,IAAJ,KAAa,oBAAjB,EAAuC;AACrC;AACD;;AACD,YAAMtB,GAAN;AACD;AACF;;AACsB,QAAjBoB,iBAAiB,CAACvC,MAAD,EAAS;AAC9B,QAAI,CAACd,eAAe,CAAC,SAAD,CAAf,CAA2BwD,QAA3B,CAAoC1C,MAApC,CAAL,EAAkD;AAChD,YAAMb,gBAAgB,CAAC,SAAD,CAAhB,CAA4B,IAAIwB,KAAJ,CAAU,iBAAV,CAA5B,EAA0D,qBAA1D,CAAN;AACD;;AACD,QAAI;AACF,YAAMgC,KAAK,GAAG,MAAM,KAAKtC,UAAL,CAAgBxB,GAAhB,CAAoBG,eAAe,CAAC4D,WAAhB,CAA4B5C,MAAM,CAAC6C,EAAnC,CAApB,CAApB;;AACA,UAAI,EAAEF,KAAK,YAAYG,UAAnB,CAAJ,EAAoC;AAClC,cAAM3D,gBAAgB,CAAC,SAAD,CAAhB,CAA4B,IAAIwB,KAAJ,CAAU,6CAAV,CAA5B,EAAsF,yBAAtF,CAAN;AACD;;AACD,UAAI;AACF,cAAMoC,MAAM,GAAG/D,eAAe,CAACgE,SAAhB,CAA0BL,KAA1B,CAAf;AACA,eAAOI,MAAM,CAACpF,KAAd;AACD,OAHD,CAGE,OAAOwD,GAAP,EAAY;AACZ9B,QAAAA,GAAG,CAACE,KAAJ,CAAU4B,GAAV;AACA,cAAMhC,gBAAgB,CAAC,SAAD,CAAhB,CAA4B,IAAIwB,KAAJ,CAAU,wDAAV,CAA5B,EAAiG,yBAAjG,CAAN;AACD;AACF,KAZD,CAYE,OAAOQ,GAAP,EAAY;AACZ,UAAIA,GAAG,IAAIA,GAAG,CAAC8B,QAAf,EAAyB;AACvB,cAAM9D,gBAAgB,CAAC,SAAD,CAAhB,CAA4B,IAAIwB,KAAJ,CAAW,yCAAyCX,MAAM,CAAC6C,EAAI,EAA/D,CAA5B,EAA+F,oBAA/F,CAAN;AACD;;AACD,YAAM1B,GAAN;AACD;AACF;;AAzHmB;;AA4HtBzD,OAAO,CAACkC,eAAR,GAA0BA,eAA1B","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar ipns = require('ipns');\nvar crypto = require('libp2p-crypto');\nvar PeerId = require('peer-id');\nvar errCode = require('err-code');\nvar debug = require('debug');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar ipns__namespace = /*#__PURE__*/_interopNamespace(ipns);\nvar crypto__default = /*#__PURE__*/_interopDefaultLegacy(crypto);\nvar PeerId__default = /*#__PURE__*/_interopDefaultLegacy(PeerId);\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\n\nconst log = Object.assign(debug__default[\"default\"]('ipfs:ipns:republisher'), { error: debug__default[\"default\"]('ipfs:ipns:republisher:error') });\nconst minute = 60 * 1000;\nconst hour = 60 * minute;\nconst defaultBroadcastInterval = 4 * hour;\nconst defaultRecordLifetime = 24 * hour;\nclass IpnsRepublisher {\n  constructor(publisher, datastore, peerId, keychain, options = { pass: '' }) {\n    this._publisher = publisher;\n    this._datastore = datastore;\n    this._peerId = peerId;\n    this._keychain = keychain;\n    this._options = options;\n    this._republishHandle = null;\n  }\n  async start() {\n    if (this._republishHandle) {\n      throw errCode__default[\"default\"](new Error('republisher is already running'), 'ERR_REPUBLISH_ALREADY_RUNNING');\n    }\n    const republishHandle = {\n      _task: null,\n      _inflightTask: null,\n      _timeoutId: null,\n      runPeriodically: period => {\n        republishHandle._timeoutId = setTimeout(async () => {\n          republishHandle._timeoutId = null;\n          try {\n            republishHandle._inflightTask = republishHandle._task();\n            await republishHandle._inflightTask;\n            if (republishHandle._task) {\n              republishHandle.runPeriodically(period);\n            }\n          } catch (err) {\n            log.error(err);\n          }\n        }, period());\n      },\n      cancel: async () => {\n        if (republishHandle._timeoutId != null) {\n          clearTimeout(republishHandle._timeoutId);\n        }\n        republishHandle._task = null;\n        await republishHandle._inflightTask;\n      }\n    };\n    const {privKey} = this._peerId;\n    const {pass} = this._options;\n    let firstRun = true;\n    republishHandle._task = () => this._republishEntries(privKey, pass);\n    republishHandle.runPeriodically(() => {\n      if (firstRun) {\n        firstRun = false;\n        return this._options.initialBroadcastInterval || minute;\n      }\n      return this._options.broadcastInterval || defaultBroadcastInterval;\n    });\n    this._republishHandle = republishHandle;\n  }\n  async stop() {\n    const republishHandle = this._republishHandle;\n    if (!republishHandle) {\n      throw errCode__default[\"default\"](new Error('republisher is not running'), 'ERR_REPUBLISH_NOT_RUNNING');\n    }\n    this._republishHandle = null;\n    await republishHandle.cancel();\n  }\n  async _republishEntries(privateKey, pass) {\n    try {\n      await this._republishEntry(privateKey);\n    } catch (err) {\n      const errMsg = 'cannot republish entry for the node\\'s private key';\n      log.error(errMsg);\n      return;\n    }\n    if (pass) {\n      try {\n        const keys = await this._keychain.listKeys();\n        for (const key of keys) {\n          if (key.name === 'self') {\n            continue;\n          }\n          const pem = await this._keychain.exportKey(key.name, pass);\n          const privKey = await crypto__default[\"default\"].keys.import(pem, pass);\n          await this._republishEntry(privKey);\n        }\n      } catch (err) {\n        log.error(err);\n      }\n    }\n  }\n  async _republishEntry(privateKey) {\n    if (!privateKey || !privateKey.bytes) {\n      throw errCode__default[\"default\"](new Error('invalid private key'), 'ERR_INVALID_PRIVATE_KEY');\n    }\n    try {\n      const peerId = await PeerId__default[\"default\"].createFromPrivKey(privateKey.bytes);\n      const value = await this._getPreviousValue(peerId);\n      await this._publisher.publishWithEOL(privateKey, value, defaultRecordLifetime);\n    } catch (err) {\n      if (err.code === 'ERR_NO_ENTRY_FOUND') {\n        return;\n      }\n      throw err;\n    }\n  }\n  async _getPreviousValue(peerId) {\n    if (!PeerId__default[\"default\"].isPeerId(peerId)) {\n      throw errCode__default[\"default\"](new Error('invalid peer ID'), 'ERR_INVALID_PEER_ID');\n    }\n    try {\n      const dsVal = await this._datastore.get(ipns__namespace.getLocalKey(peerId.id));\n      if (!(dsVal instanceof Uint8Array)) {\n        throw errCode__default[\"default\"](new Error('found ipns record that we couldn\\'t process'), 'ERR_INVALID_IPNS_RECORD');\n      }\n      try {\n        const record = ipns__namespace.unmarshal(dsVal);\n        return record.value;\n      } catch (err) {\n        log.error(err);\n        throw errCode__default[\"default\"](new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_IPNS_RECORD');\n      }\n    } catch (err) {\n      if (err && err.notFound) {\n        throw errCode__default[\"default\"](new Error(`no previous entry for record with id: ${ peerId.id }`), 'ERR_NO_ENTRY_FOUND');\n      }\n      throw err;\n    }\n  }\n}\n\nexports.IpnsRepublisher = IpnsRepublisher;\n"]},"metadata":{},"sourceType":"script"}