{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar PeerId = require('peer-id');\n\nvar key = require('interface-datastore/key');\n\nvar Errors = require('datastore-core/errors');\n\nvar errCode = require('err-code');\n\nvar debug = require('debug');\n\nvar toString = require('uint8arrays/to-string');\n\nvar equals = require('uint8arrays/equals');\n\nvar ipns = require('ipns');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar PeerId__default = /*#__PURE__*/_interopDefaultLegacy(PeerId);\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\n\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\n\nvar ipns__namespace = /*#__PURE__*/_interopNamespace(ipns);\n\nconst log = Object.assign(debug__default[\"default\"]('ipfs:ipns:publisher'), {\n  error: debug__default[\"default\"]('ipfs:ipns:publisher:error')\n});\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\nconst defaultRecordLifetime = 60 * 60 * 1000;\n\nclass IpnsPublisher {\n  constructor(routing, datastore) {\n    this._routing = routing;\n    this._datastore = datastore;\n  }\n\n  async publishWithEOL(privKey, value, lifetime) {\n    if (!privKey || !privKey.bytes) {\n      throw errCode__default[\"default\"](new Error('invalid private key'), 'ERR_INVALID_PRIVATE_KEY');\n    }\n\n    const peerId = await PeerId__default[\"default\"].createFromPrivKey(privKey.bytes);\n    const record = await this._updateOrCreateRecord(privKey, value, lifetime, peerId);\n    return this._putRecordToRouting(record, peerId);\n  }\n\n  publish(privKey, value) {\n    return this.publishWithEOL(privKey, value, defaultRecordLifetime);\n  }\n\n  async _putRecordToRouting(record, peerId) {\n    if (!PeerId__default[\"default\"].isPeerId(peerId)) {\n      const errMsg = 'peerId received is not valid';\n      log.error(errMsg);\n      throw errCode__default[\"default\"](new Error(errMsg), 'ERR_INVALID_PEER_ID');\n    }\n\n    const publicKey = peerId.pubKey;\n    const embedPublicKeyRecord = await ipns__namespace.embedPublicKey(publicKey, record);\n    const keys = ipns__namespace.getIdKeys(peerId.toBytes());\n    await this._publishEntry(keys.routingKey, embedPublicKeyRecord || record);\n    return embedPublicKeyRecord || record;\n  }\n\n  async _publishEntry(key$1, entry) {\n    const k = key.Key.asKey(key$1);\n\n    if (!k) {\n      const errMsg = 'datastore key does not have a valid format';\n      log.error(errMsg);\n      throw errCode__default[\"default\"](new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n    }\n\n    let entryData;\n\n    try {\n      entryData = ipns__namespace.marshal(entry);\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n\n    try {\n      const res = await this._routing.put(k.uint8Array(), entryData);\n      log(`ipns record for ${toString.toString(k.uint8Array(), 'base32')} was stored in the routing`);\n      return res;\n    } catch (err) {\n      const errMsg = `ipns record for ${toString.toString(k.uint8Array(), 'base32')} could not be stored in the routing - ${err.stack}`;\n      log.error(errMsg);\n      log.error(err);\n      throw errCode__default[\"default\"](new Error(errMsg), 'ERR_PUTTING_TO_ROUTING');\n    }\n  }\n\n  async _getPublished(peerId) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!PeerId__default[\"default\"].isPeerId(peerId)) {\n      const errMsg = 'peerId received is not valid';\n      log.error(errMsg);\n      throw errCode__default[\"default\"](new Error(errMsg), 'ERR_INVALID_PEER_ID');\n    }\n\n    const checkRouting = options.checkRouting !== false;\n\n    try {\n      const dsVal = await this._datastore.get(ipns__namespace.getLocalKey(peerId.id));\n      return this._unmarshalData(dsVal);\n    } catch (err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error getting the ipns record ${peerId.id} from datastore`;\n        log.error(errMsg);\n        throw errCode__default[\"default\"](new Error(errMsg), 'ERR_UNEXPECTED_DATASTORE_RESPONSE');\n      }\n\n      if (!checkRouting) {\n        throw errCode__default[\"default\"](err, 'ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED');\n      }\n\n      try {\n        const keys = ipns__namespace.getIdKeys(peerId.toBytes());\n        const res = await this._routing.get(keys.routingKey.uint8Array());\n        return this._unmarshalData(res);\n      } catch (err) {\n        log.error(err);\n        throw err;\n      }\n    }\n  }\n\n  _unmarshalData(data) {\n    try {\n      return ipns__namespace.unmarshal(data);\n    } catch (err) {\n      throw errCode__default[\"default\"](err, 'ERR_INVALID_RECORD_DATA');\n    }\n  }\n\n  async _updateOrCreateRecord(privKey, value, lifetime, peerId) {\n    if (!PeerId__default[\"default\"].isPeerId(peerId)) {\n      const errMsg = 'peerId received is not valid';\n      log.error(errMsg);\n      throw errCode__default[\"default\"](new Error(errMsg), 'ERR_INVALID_PEER_ID');\n    }\n\n    const getPublishedOptions = {\n      checkRouting: true\n    };\n    let record;\n\n    try {\n      record = await this._getPublished(peerId, getPublishedOptions);\n    } catch (err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error when determining the last published IPNS record for ${peerId.id} ${err.stack}`;\n        log.error(errMsg);\n        throw errCode__default[\"default\"](new Error(errMsg), 'ERR_DETERMINING_PUBLISHED_RECORD');\n      }\n    }\n\n    let seqNumber = 0;\n\n    if (record && record.sequence !== undefined) {\n      seqNumber = !equals.equals(record.value, value) ? BigInt(record.sequence) + BigInt(1) : BigInt(record.sequence);\n    }\n\n    let entryData;\n\n    try {\n      entryData = await ipns__namespace.create(privKey, value, seqNumber, lifetime);\n    } catch (err) {\n      const errMsg = `ipns record for ${value} could not be created`;\n      log.error(err);\n      throw errCode__default[\"default\"](new Error(errMsg), 'ERR_CREATING_IPNS_RECORD');\n    }\n\n    try {\n      const data = ipns__namespace.marshal(entryData);\n      await this._datastore.put(ipns__namespace.getLocalKey(peerId.id), data);\n      log(`ipns record for ${toString.toString(value, 'base32')} was stored in the datastore`);\n      return entryData;\n    } catch (err) {\n      const errMsg = `ipns record for ${value} could not be stored in the datastore`;\n      log.error(errMsg);\n      throw errCode__default[\"default\"](new Error(errMsg), 'ERR_STORING_IN_DATASTORE');\n    }\n  }\n\n}\n\nIpnsPublisher.defaultRecordLifetime = defaultRecordLifetime;\nexports.IpnsPublisher = IpnsPublisher;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-core/cjs/src/ipns/publisher.js"],"names":["Object","defineProperty","exports","value","PeerId","require","key","Errors","errCode","debug","toString","equals","ipns","_interopDefaultLegacy","e","_interopNamespace","__esModule","n","create","keys","forEach","k","d","getOwnPropertyDescriptor","get","enumerable","freeze","PeerId__default","errCode__default","debug__default","ipns__namespace","log","assign","error","ERR_NOT_FOUND","notFoundError","code","defaultRecordLifetime","IpnsPublisher","constructor","routing","datastore","_routing","_datastore","publishWithEOL","privKey","lifetime","bytes","Error","peerId","createFromPrivKey","record","_updateOrCreateRecord","_putRecordToRouting","publish","isPeerId","errMsg","publicKey","pubKey","embedPublicKeyRecord","embedPublicKey","getIdKeys","toBytes","_publishEntry","routingKey","key$1","entry","Key","asKey","entryData","marshal","err","res","put","uint8Array","stack","_getPublished","options","checkRouting","dsVal","getLocalKey","id","_unmarshalData","data","unmarshal","getPublishedOptions","seqNumber","sequence","undefined","BigInt"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar PeerId = require('peer-id');\nvar key = require('interface-datastore/key');\nvar Errors = require('datastore-core/errors');\nvar errCode = require('err-code');\nvar debug = require('debug');\nvar toString = require('uint8arrays/to-string');\nvar equals = require('uint8arrays/equals');\nvar ipns = require('ipns');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar PeerId__default = /*#__PURE__*/_interopDefaultLegacy(PeerId);\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\nvar ipns__namespace = /*#__PURE__*/_interopNamespace(ipns);\n\nconst log = Object.assign(debug__default[\"default\"]('ipfs:ipns:publisher'), { error: debug__default[\"default\"]('ipfs:ipns:publisher:error') });\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\nconst defaultRecordLifetime = 60 * 60 * 1000;\nclass IpnsPublisher {\n  constructor(routing, datastore) {\n    this._routing = routing;\n    this._datastore = datastore;\n  }\n  async publishWithEOL(privKey, value, lifetime) {\n    if (!privKey || !privKey.bytes) {\n      throw errCode__default[\"default\"](new Error('invalid private key'), 'ERR_INVALID_PRIVATE_KEY');\n    }\n    const peerId = await PeerId__default[\"default\"].createFromPrivKey(privKey.bytes);\n    const record = await this._updateOrCreateRecord(privKey, value, lifetime, peerId);\n    return this._putRecordToRouting(record, peerId);\n  }\n  publish(privKey, value) {\n    return this.publishWithEOL(privKey, value, defaultRecordLifetime);\n  }\n  async _putRecordToRouting(record, peerId) {\n    if (!PeerId__default[\"default\"].isPeerId(peerId)) {\n      const errMsg = 'peerId received is not valid';\n      log.error(errMsg);\n      throw errCode__default[\"default\"](new Error(errMsg), 'ERR_INVALID_PEER_ID');\n    }\n    const publicKey = peerId.pubKey;\n    const embedPublicKeyRecord = await ipns__namespace.embedPublicKey(publicKey, record);\n    const keys = ipns__namespace.getIdKeys(peerId.toBytes());\n    await this._publishEntry(keys.routingKey, embedPublicKeyRecord || record);\n    return embedPublicKeyRecord || record;\n  }\n  async _publishEntry(key$1, entry) {\n    const k = key.Key.asKey(key$1);\n    if (!k) {\n      const errMsg = 'datastore key does not have a valid format';\n      log.error(errMsg);\n      throw errCode__default[\"default\"](new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n    }\n    let entryData;\n    try {\n      entryData = ipns__namespace.marshal(entry);\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n    try {\n      const res = await this._routing.put(k.uint8Array(), entryData);\n      log(`ipns record for ${ toString.toString(k.uint8Array(), 'base32') } was stored in the routing`);\n      return res;\n    } catch (err) {\n      const errMsg = `ipns record for ${ toString.toString(k.uint8Array(), 'base32') } could not be stored in the routing - ${ err.stack }`;\n      log.error(errMsg);\n      log.error(err);\n      throw errCode__default[\"default\"](new Error(errMsg), 'ERR_PUTTING_TO_ROUTING');\n    }\n  }\n  async _getPublished(peerId, options = {}) {\n    if (!PeerId__default[\"default\"].isPeerId(peerId)) {\n      const errMsg = 'peerId received is not valid';\n      log.error(errMsg);\n      throw errCode__default[\"default\"](new Error(errMsg), 'ERR_INVALID_PEER_ID');\n    }\n    const checkRouting = options.checkRouting !== false;\n    try {\n      const dsVal = await this._datastore.get(ipns__namespace.getLocalKey(peerId.id));\n      return this._unmarshalData(dsVal);\n    } catch (err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error getting the ipns record ${ peerId.id } from datastore`;\n        log.error(errMsg);\n        throw errCode__default[\"default\"](new Error(errMsg), 'ERR_UNEXPECTED_DATASTORE_RESPONSE');\n      }\n      if (!checkRouting) {\n        throw errCode__default[\"default\"](err, 'ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED');\n      }\n      try {\n        const keys = ipns__namespace.getIdKeys(peerId.toBytes());\n        const res = await this._routing.get(keys.routingKey.uint8Array());\n        return this._unmarshalData(res);\n      } catch (err) {\n        log.error(err);\n        throw err;\n      }\n    }\n  }\n  _unmarshalData(data) {\n    try {\n      return ipns__namespace.unmarshal(data);\n    } catch (err) {\n      throw errCode__default[\"default\"](err, 'ERR_INVALID_RECORD_DATA');\n    }\n  }\n  async _updateOrCreateRecord(privKey, value, lifetime, peerId) {\n    if (!PeerId__default[\"default\"].isPeerId(peerId)) {\n      const errMsg = 'peerId received is not valid';\n      log.error(errMsg);\n      throw errCode__default[\"default\"](new Error(errMsg), 'ERR_INVALID_PEER_ID');\n    }\n    const getPublishedOptions = { checkRouting: true };\n    let record;\n    try {\n      record = await this._getPublished(peerId, getPublishedOptions);\n    } catch (err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error when determining the last published IPNS record for ${ peerId.id } ${ err.stack }`;\n        log.error(errMsg);\n        throw errCode__default[\"default\"](new Error(errMsg), 'ERR_DETERMINING_PUBLISHED_RECORD');\n      }\n    }\n    let seqNumber = 0;\n    if (record && record.sequence !== undefined) {\n      seqNumber = !equals.equals(record.value, value) ? BigInt(record.sequence) + BigInt(1) : BigInt(record.sequence);\n    }\n    let entryData;\n    try {\n      entryData = await ipns__namespace.create(privKey, value, seqNumber, lifetime);\n    } catch (err) {\n      const errMsg = `ipns record for ${ value } could not be created`;\n      log.error(err);\n      throw errCode__default[\"default\"](new Error(errMsg), 'ERR_CREATING_IPNS_RECORD');\n    }\n    try {\n      const data = ipns__namespace.marshal(entryData);\n      await this._datastore.put(ipns__namespace.getLocalKey(peerId.id), data);\n      log(`ipns record for ${ toString.toString(value, 'base32') } was stored in the datastore`);\n      return entryData;\n    } catch (err) {\n      const errMsg = `ipns record for ${ value } could not be stored in the datastore`;\n      log.error(errMsg);\n      throw errCode__default[\"default\"](new Error(errMsg), 'ERR_STORING_IN_DATASTORE');\n    }\n  }\n}\nIpnsPublisher.defaultRecordLifetime = defaultRecordLifetime;\n\nexports.IpnsPublisher = IpnsPublisher;\n"]},"metadata":{},"sourceType":"script"}