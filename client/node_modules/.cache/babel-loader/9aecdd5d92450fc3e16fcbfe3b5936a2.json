{"ast":null,"code":"/* global indexedDB */\n'use strict';\n\nmodule.exports = Level;\n\nconst AbstractLevelDOWN = require('abstract-leveldown').AbstractLevelDOWN;\n\nconst inherits = require('inherits');\n\nconst parallel = require('run-parallel-limit');\n\nconst Iterator = require('./iterator');\n\nconst serialize = require('./util/serialize');\n\nconst deserialize = require('./util/deserialize');\n\nconst support = require('./util/support');\n\nconst clear = require('./util/clear');\n\nconst createKeyRange = require('./util/key-range');\n\nconst DEFAULT_PREFIX = 'level-js-';\n\nfunction Level(location, opts) {\n  if (!(this instanceof Level)) return new Level(location, opts);\n  AbstractLevelDOWN.call(this, {\n    bufferKeys: support.bufferKeys(indexedDB),\n    snapshots: true,\n    permanence: true,\n    clear: true,\n    getMany: true\n  });\n  opts = opts || {};\n\n  if (typeof location !== 'string') {\n    throw new Error('constructor requires a location string argument');\n  }\n\n  this.location = location;\n  this.prefix = opts.prefix == null ? DEFAULT_PREFIX : opts.prefix;\n  this.version = parseInt(opts.version || 1, 10);\n}\n\ninherits(Level, AbstractLevelDOWN);\nLevel.prototype.type = 'level-js';\n\nLevel.prototype._open = function (options, callback) {\n  const req = indexedDB.open(this.prefix + this.location, this.version);\n\n  req.onerror = function () {\n    callback(req.error || new Error('unknown error'));\n  };\n\n  req.onsuccess = () => {\n    this.db = req.result;\n    callback();\n  };\n\n  req.onupgradeneeded = ev => {\n    const db = ev.target.result;\n\n    if (!db.objectStoreNames.contains(this.location)) {\n      db.createObjectStore(this.location);\n    }\n  };\n};\n\nLevel.prototype.store = function (mode) {\n  const transaction = this.db.transaction([this.location], mode);\n  return transaction.objectStore(this.location);\n};\n\nLevel.prototype.await = function (request, callback) {\n  const transaction = request.transaction; // Take advantage of the fact that a non-canceled request error aborts\n  // the transaction. I.e. no need to listen for \"request.onerror\".\n\n  transaction.onabort = function () {\n    callback(transaction.error || new Error('aborted by user'));\n  };\n\n  transaction.oncomplete = function () {\n    callback(null, request.result);\n  };\n};\n\nLevel.prototype._get = function (key, options, callback) {\n  const store = this.store('readonly');\n  let req;\n\n  try {\n    req = store.get(key);\n  } catch (err) {\n    return this._nextTick(callback, err);\n  }\n\n  this.await(req, function (err, value) {\n    if (err) return callback(err);\n\n    if (value === undefined) {\n      // 'NotFound' error, consistent with LevelDOWN API\n      return callback(new Error('NotFound'));\n    }\n\n    callback(null, deserialize(value, options.asBuffer));\n  });\n};\n\nLevel.prototype._getMany = function (keys, options, callback) {\n  const asBuffer = options.asBuffer;\n  const store = this.store('readonly');\n  const tasks = keys.map(key => next => {\n    let request;\n\n    try {\n      request = store.get(key);\n    } catch (err) {\n      return next(err);\n    }\n\n    request.onsuccess = () => {\n      const value = request.result;\n      next(null, value === undefined ? value : deserialize(value, asBuffer));\n    };\n\n    request.onerror = ev => {\n      ev.stopPropagation();\n      next(request.error);\n    };\n  });\n  parallel(tasks, 16, callback);\n};\n\nLevel.prototype._del = function (key, options, callback) {\n  const store = this.store('readwrite');\n  let req;\n\n  try {\n    req = store.delete(key);\n  } catch (err) {\n    return this._nextTick(callback, err);\n  }\n\n  this.await(req, callback);\n};\n\nLevel.prototype._put = function (key, value, options, callback) {\n  const store = this.store('readwrite');\n  let req;\n\n  try {\n    // Will throw a DataError or DataCloneError if the environment\n    // does not support serializing the key or value respectively.\n    req = store.put(value, key);\n  } catch (err) {\n    return this._nextTick(callback, err);\n  }\n\n  this.await(req, callback);\n};\n\nLevel.prototype._serializeKey = function (key) {\n  return serialize(key, this.supports.bufferKeys);\n};\n\nLevel.prototype._serializeValue = function (value) {\n  return serialize(value, true);\n};\n\nLevel.prototype._iterator = function (options) {\n  return new Iterator(this, this.location, options);\n};\n\nLevel.prototype._batch = function (operations, options, callback) {\n  if (operations.length === 0) return this._nextTick(callback);\n  const store = this.store('readwrite');\n  const transaction = store.transaction;\n  let index = 0;\n  let error;\n\n  transaction.onabort = function () {\n    callback(error || transaction.error || new Error('aborted by user'));\n  };\n\n  transaction.oncomplete = function () {\n    callback();\n  }; // Wait for a request to complete before making the next, saving CPU.\n\n\n  function loop() {\n    const op = operations[index++];\n    const key = op.key;\n    let req;\n\n    try {\n      req = op.type === 'del' ? store.delete(key) : store.put(op.value, key);\n    } catch (err) {\n      error = err;\n      transaction.abort();\n      return;\n    }\n\n    if (index < operations.length) {\n      req.onsuccess = loop;\n    }\n  }\n\n  loop();\n};\n\nLevel.prototype._clear = function (options, callback) {\n  let keyRange;\n  let req;\n\n  try {\n    keyRange = createKeyRange(options);\n  } catch (e) {\n    // The lower key is greater than the upper key.\n    // IndexedDB throws an error, but we'll just do nothing.\n    return this._nextTick(callback);\n  }\n\n  if (options.limit >= 0) {\n    // IDBObjectStore#delete(range) doesn't have such an option.\n    // Fall back to cursor-based implementation.\n    return clear(this, this.location, keyRange, options, callback);\n  }\n\n  try {\n    const store = this.store('readwrite');\n    req = keyRange ? store.delete(keyRange) : store.clear();\n  } catch (err) {\n    return this._nextTick(callback, err);\n  }\n\n  this.await(req, callback);\n};\n\nLevel.prototype._close = function (callback) {\n  this.db.close();\n\n  this._nextTick(callback);\n}; // NOTE: remove in a next major release\n\n\nLevel.prototype.upgrade = function (callback) {\n  if (this.status !== 'open') {\n    return this._nextTick(callback, new Error('cannot upgrade() before open()'));\n  }\n\n  const it = this.iterator();\n  const batchOptions = {};\n  const self = this;\n  it._deserializeKey = it._deserializeValue = identity;\n  next();\n\n  function next(err) {\n    if (err) return finish(err);\n    it.next(each);\n  }\n\n  function each(err, key, value) {\n    if (err || key === undefined) {\n      return finish(err);\n    }\n\n    const newKey = self._serializeKey(deserialize(key, true));\n\n    const newValue = self._serializeValue(deserialize(value, true)); // To bypass serialization on the old key, use _batch() instead of batch().\n    // NOTE: if we disable snapshotting (#86) this could lead to a loop of\n    // inserting and then iterating those same entries, because the new keys\n    // possibly sort after the old keys.\n\n\n    self._batch([{\n      type: 'del',\n      key: key\n    }, {\n      type: 'put',\n      key: newKey,\n      value: newValue\n    }], batchOptions, next);\n  }\n\n  function finish(err) {\n    it.end(function (err2) {\n      callback(err || err2);\n    });\n  }\n\n  function identity(data) {\n    return data;\n  }\n};\n\nLevel.destroy = function (location, prefix, callback) {\n  if (typeof prefix === 'function') {\n    callback = prefix;\n    prefix = DEFAULT_PREFIX;\n  }\n\n  const request = indexedDB.deleteDatabase(prefix + location);\n\n  request.onsuccess = function () {\n    callback();\n  };\n\n  request.onerror = function (err) {\n    callback(err);\n  };\n};","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/level-js/index.js"],"names":["module","exports","Level","AbstractLevelDOWN","require","inherits","parallel","Iterator","serialize","deserialize","support","clear","createKeyRange","DEFAULT_PREFIX","location","opts","call","bufferKeys","indexedDB","snapshots","permanence","getMany","Error","prefix","version","parseInt","prototype","type","_open","options","callback","req","open","onerror","error","onsuccess","db","result","onupgradeneeded","ev","target","objectStoreNames","contains","createObjectStore","store","mode","transaction","objectStore","await","request","onabort","oncomplete","_get","key","get","err","_nextTick","value","undefined","asBuffer","_getMany","keys","tasks","map","next","stopPropagation","_del","delete","_put","put","_serializeKey","supports","_serializeValue","_iterator","_batch","operations","length","index","loop","op","abort","_clear","keyRange","e","limit","_close","close","upgrade","status","it","iterator","batchOptions","self","_deserializeKey","_deserializeValue","identity","finish","each","newKey","newValue","end","err2","data","destroy","deleteDatabase"],"mappings":"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","sourcesContent":["/* global indexedDB */\n\n'use strict'\n\nmodule.exports = Level\n\nconst AbstractLevelDOWN = require('abstract-leveldown').AbstractLevelDOWN\nconst inherits = require('inherits')\nconst parallel = require('run-parallel-limit')\nconst Iterator = require('./iterator')\nconst serialize = require('./util/serialize')\nconst deserialize = require('./util/deserialize')\nconst support = require('./util/support')\nconst clear = require('./util/clear')\nconst createKeyRange = require('./util/key-range')\n\nconst DEFAULT_PREFIX = 'level-js-'\n\nfunction Level (location, opts) {\n  if (!(this instanceof Level)) return new Level(location, opts)\n\n  AbstractLevelDOWN.call(this, {\n    bufferKeys: support.bufferKeys(indexedDB),\n    snapshots: true,\n    permanence: true,\n    clear: true,\n    getMany: true\n  })\n\n  opts = opts || {}\n\n  if (typeof location !== 'string') {\n    throw new Error('constructor requires a location string argument')\n  }\n\n  this.location = location\n  this.prefix = opts.prefix == null ? DEFAULT_PREFIX : opts.prefix\n  this.version = parseInt(opts.version || 1, 10)\n}\n\ninherits(Level, AbstractLevelDOWN)\n\nLevel.prototype.type = 'level-js'\n\nLevel.prototype._open = function (options, callback) {\n  const req = indexedDB.open(this.prefix + this.location, this.version)\n\n  req.onerror = function () {\n    callback(req.error || new Error('unknown error'))\n  }\n\n  req.onsuccess = () => {\n    this.db = req.result\n    callback()\n  }\n\n  req.onupgradeneeded = (ev) => {\n    const db = ev.target.result\n\n    if (!db.objectStoreNames.contains(this.location)) {\n      db.createObjectStore(this.location)\n    }\n  }\n}\n\nLevel.prototype.store = function (mode) {\n  const transaction = this.db.transaction([this.location], mode)\n  return transaction.objectStore(this.location)\n}\n\nLevel.prototype.await = function (request, callback) {\n  const transaction = request.transaction\n\n  // Take advantage of the fact that a non-canceled request error aborts\n  // the transaction. I.e. no need to listen for \"request.onerror\".\n  transaction.onabort = function () {\n    callback(transaction.error || new Error('aborted by user'))\n  }\n\n  transaction.oncomplete = function () {\n    callback(null, request.result)\n  }\n}\n\nLevel.prototype._get = function (key, options, callback) {\n  const store = this.store('readonly')\n  let req\n\n  try {\n    req = store.get(key)\n  } catch (err) {\n    return this._nextTick(callback, err)\n  }\n\n  this.await(req, function (err, value) {\n    if (err) return callback(err)\n\n    if (value === undefined) {\n      // 'NotFound' error, consistent with LevelDOWN API\n      return callback(new Error('NotFound'))\n    }\n\n    callback(null, deserialize(value, options.asBuffer))\n  })\n}\n\nLevel.prototype._getMany = function (keys, options, callback) {\n  const asBuffer = options.asBuffer\n  const store = this.store('readonly')\n  const tasks = keys.map((key) => (next) => {\n    let request\n\n    try {\n      request = store.get(key)\n    } catch (err) {\n      return next(err)\n    }\n\n    request.onsuccess = () => {\n      const value = request.result\n      next(null, value === undefined ? value : deserialize(value, asBuffer))\n    }\n\n    request.onerror = (ev) => {\n      ev.stopPropagation()\n      next(request.error)\n    }\n  })\n\n  parallel(tasks, 16, callback)\n}\n\nLevel.prototype._del = function (key, options, callback) {\n  const store = this.store('readwrite')\n  let req\n\n  try {\n    req = store.delete(key)\n  } catch (err) {\n    return this._nextTick(callback, err)\n  }\n\n  this.await(req, callback)\n}\n\nLevel.prototype._put = function (key, value, options, callback) {\n  const store = this.store('readwrite')\n  let req\n\n  try {\n    // Will throw a DataError or DataCloneError if the environment\n    // does not support serializing the key or value respectively.\n    req = store.put(value, key)\n  } catch (err) {\n    return this._nextTick(callback, err)\n  }\n\n  this.await(req, callback)\n}\n\nLevel.prototype._serializeKey = function (key) {\n  return serialize(key, this.supports.bufferKeys)\n}\n\nLevel.prototype._serializeValue = function (value) {\n  return serialize(value, true)\n}\n\nLevel.prototype._iterator = function (options) {\n  return new Iterator(this, this.location, options)\n}\n\nLevel.prototype._batch = function (operations, options, callback) {\n  if (operations.length === 0) return this._nextTick(callback)\n\n  const store = this.store('readwrite')\n  const transaction = store.transaction\n  let index = 0\n  let error\n\n  transaction.onabort = function () {\n    callback(error || transaction.error || new Error('aborted by user'))\n  }\n\n  transaction.oncomplete = function () {\n    callback()\n  }\n\n  // Wait for a request to complete before making the next, saving CPU.\n  function loop () {\n    const op = operations[index++]\n    const key = op.key\n\n    let req\n\n    try {\n      req = op.type === 'del' ? store.delete(key) : store.put(op.value, key)\n    } catch (err) {\n      error = err\n      transaction.abort()\n      return\n    }\n\n    if (index < operations.length) {\n      req.onsuccess = loop\n    }\n  }\n\n  loop()\n}\n\nLevel.prototype._clear = function (options, callback) {\n  let keyRange\n  let req\n\n  try {\n    keyRange = createKeyRange(options)\n  } catch (e) {\n    // The lower key is greater than the upper key.\n    // IndexedDB throws an error, but we'll just do nothing.\n    return this._nextTick(callback)\n  }\n\n  if (options.limit >= 0) {\n    // IDBObjectStore#delete(range) doesn't have such an option.\n    // Fall back to cursor-based implementation.\n    return clear(this, this.location, keyRange, options, callback)\n  }\n\n  try {\n    const store = this.store('readwrite')\n    req = keyRange ? store.delete(keyRange) : store.clear()\n  } catch (err) {\n    return this._nextTick(callback, err)\n  }\n\n  this.await(req, callback)\n}\n\nLevel.prototype._close = function (callback) {\n  this.db.close()\n  this._nextTick(callback)\n}\n\n// NOTE: remove in a next major release\nLevel.prototype.upgrade = function (callback) {\n  if (this.status !== 'open') {\n    return this._nextTick(callback, new Error('cannot upgrade() before open()'))\n  }\n\n  const it = this.iterator()\n  const batchOptions = {}\n  const self = this\n\n  it._deserializeKey = it._deserializeValue = identity\n  next()\n\n  function next (err) {\n    if (err) return finish(err)\n    it.next(each)\n  }\n\n  function each (err, key, value) {\n    if (err || key === undefined) {\n      return finish(err)\n    }\n\n    const newKey = self._serializeKey(deserialize(key, true))\n    const newValue = self._serializeValue(deserialize(value, true))\n\n    // To bypass serialization on the old key, use _batch() instead of batch().\n    // NOTE: if we disable snapshotting (#86) this could lead to a loop of\n    // inserting and then iterating those same entries, because the new keys\n    // possibly sort after the old keys.\n    self._batch([\n      { type: 'del', key: key },\n      { type: 'put', key: newKey, value: newValue }\n    ], batchOptions, next)\n  }\n\n  function finish (err) {\n    it.end(function (err2) {\n      callback(err || err2)\n    })\n  }\n\n  function identity (data) {\n    return data\n  }\n}\n\nLevel.destroy = function (location, prefix, callback) {\n  if (typeof prefix === 'function') {\n    callback = prefix\n    prefix = DEFAULT_PREFIX\n  }\n  const request = indexedDB.deleteDatabase(prefix + location)\n  request.onsuccess = function () {\n    callback()\n  }\n  request.onerror = function (err) {\n    callback(err)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}