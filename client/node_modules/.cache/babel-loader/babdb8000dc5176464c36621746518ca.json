{"ast":null,"code":"'use strict'; // @ts-expect-error no types\n\nconst Reader = require('it-reader');\n\nconst debug = require('debug');\n\nconst multistream = require('./multistream'); // @ts-expect-error no types\n\n\nconst handshake = require('it-handshake');\n\nconst lp = require('it-length-prefixed');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst log = Object.assign(debug('mss:ls'), {\n  error: debug('mss:ls:error')\n});\n/**\n * @typedef {import('bl/BufferList')} BufferList\n * @typedef {import('./types').DuplexStream<Uint8Array | BufferList>} DuplexStream\n * @typedef {import('./types').AbortOptions} AbortOptions\n */\n\n/**\n * @param {DuplexStream} stream\n * @param {AbortOptions} [options]\n */\n\nmodule.exports = async function ls(stream, options) {\n  const {\n    reader,\n    writer,\n    rest,\n    stream: shakeStream\n  } = handshake(stream);\n  log('write \"ls\"');\n  multistream.write(writer, 'ls');\n  rest(); // Next message from remote will be (e.g. for 2 protocols):\n  // <varint-msg-len><varint-proto-name-len><proto-name>\\n<varint-proto-name-len><proto-name>\\n\n\n  const res = await multistream.read(reader, options); // After reading response we have:\n  // <varint-proto-name-len><proto-name>\\n<varint-proto-name-len><proto-name>\\n\n\n  const protocolsReader = Reader([res]);\n  /**\n   * @type {string[]}\n   */\n\n  const protocols = []; // Decode each of the protocols from the reader\n\n  await pipe(protocolsReader, lp.decode(), async (\n  /** @type {AsyncIterable<BufferList>} */\n  source) => {\n    for await (const protocol of source) {\n      // Remove the newline\n      protocols.push(protocol.shallowSlice(0, -1).toString());\n    }\n  });\n  /** @type {{ stream: DuplexStream, protocols: string[] }} */\n\n  const output = {\n    stream: shakeStream,\n    protocols\n  };\n  return output;\n};","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/multistream-select/src/ls.js"],"names":["Reader","require","debug","multistream","handshake","lp","pipe","log","Object","assign","error","module","exports","ls","stream","options","reader","writer","rest","shakeStream","write","res","read","protocolsReader","protocols","decode","source","protocol","push","shallowSlice","toString","output"],"mappings":"AAAA,a,CAEA;;AACA,MAAMA,MAAM,GAAGC,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAMC,KAAK,GAAGD,OAAO,CAAC,OAAD,CAArB;;AACA,MAAME,WAAW,GAAGF,OAAO,CAAC,eAAD,CAA3B,C,CACA;;;AACA,MAAMG,SAAS,GAAGH,OAAO,CAAC,cAAD,CAAzB;;AACA,MAAMI,EAAE,GAAGJ,OAAO,CAAC,oBAAD,CAAlB;;AACA,MAAM;AAAEK,EAAAA;AAAF,IAAWL,OAAO,CAAC,SAAD,CAAxB;;AAEA,MAAMM,GAAG,GAAGC,MAAM,CAACC,MAAP,CAAcP,KAAK,CAAC,QAAD,CAAnB,EAA+B;AACzCQ,EAAAA,KAAK,EAAER,KAAK,CAAC,cAAD;AAD6B,CAA/B,CAAZ;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACAS,MAAM,CAACC,OAAP,GAAiB,eAAeC,EAAf,CAAmBC,MAAnB,EAA2BC,OAA3B,EAAoC;AACnD,QAAM;AAAEC,IAAAA,MAAF;AAAUC,IAAAA,MAAV;AAAkBC,IAAAA,IAAlB;AAAwBJ,IAAAA,MAAM,EAAEK;AAAhC,MAAgDf,SAAS,CAACU,MAAD,CAA/D;AAEAP,EAAAA,GAAG,CAAC,YAAD,CAAH;AACAJ,EAAAA,WAAW,CAACiB,KAAZ,CAAkBH,MAAlB,EAA0B,IAA1B;AACAC,EAAAA,IAAI,GAL+C,CAOnD;AACA;;AACA,QAAMG,GAAG,GAAG,MAAMlB,WAAW,CAACmB,IAAZ,CAAiBN,MAAjB,EAAyBD,OAAzB,CAAlB,CATmD,CAWnD;AACA;;AACA,QAAMQ,eAAe,GAAGvB,MAAM,CAAC,CAACqB,GAAD,CAAD,CAA9B;AAEA;AACF;AACA;;AACE,QAAMG,SAAS,GAAG,EAAlB,CAlBmD,CAoBnD;;AACA,QAAMlB,IAAI,CACRiB,eADQ,EAERlB,EAAE,CAACoB,MAAH,EAFQ,EAGR;AAAO;AAAyCC,EAAAA,MAAhD,KAA2D;AACzD,eAAW,MAAMC,QAAjB,IAA6BD,MAA7B,EAAqC;AACnC;AACAF,MAAAA,SAAS,CAACI,IAAV,CAAeD,QAAQ,CAACE,YAAT,CAAsB,CAAtB,EAAyB,CAAC,CAA1B,EAA6BC,QAA7B,EAAf;AACD;AACF,GARO,CAAV;AAWA;;AACA,QAAMC,MAAM,GAAG;AAAEjB,IAAAA,MAAM,EAAEK,WAAV;AAAuBK,IAAAA;AAAvB,GAAf;AAEA,SAAOO,MAAP;AACD,CApCD","sourcesContent":["'use strict'\n\n// @ts-expect-error no types\nconst Reader = require('it-reader')\nconst debug = require('debug')\nconst multistream = require('./multistream')\n// @ts-expect-error no types\nconst handshake = require('it-handshake')\nconst lp = require('it-length-prefixed')\nconst { pipe } = require('it-pipe')\n\nconst log = Object.assign(debug('mss:ls'), {\n  error: debug('mss:ls:error')\n})\n\n/**\n * @typedef {import('bl/BufferList')} BufferList\n * @typedef {import('./types').DuplexStream<Uint8Array | BufferList>} DuplexStream\n * @typedef {import('./types').AbortOptions} AbortOptions\n */\n\n/**\n * @param {DuplexStream} stream\n * @param {AbortOptions} [options]\n */\nmodule.exports = async function ls (stream, options) {\n  const { reader, writer, rest, stream: shakeStream } = handshake(stream)\n\n  log('write \"ls\"')\n  multistream.write(writer, 'ls')\n  rest()\n\n  // Next message from remote will be (e.g. for 2 protocols):\n  // <varint-msg-len><varint-proto-name-len><proto-name>\\n<varint-proto-name-len><proto-name>\\n\n  const res = await multistream.read(reader, options)\n\n  // After reading response we have:\n  // <varint-proto-name-len><proto-name>\\n<varint-proto-name-len><proto-name>\\n\n  const protocolsReader = Reader([res])\n\n  /**\n   * @type {string[]}\n   */\n  const protocols = []\n\n  // Decode each of the protocols from the reader\n  await pipe(\n    protocolsReader,\n    lp.decode(),\n    async (/** @type {AsyncIterable<BufferList>} */ source) => {\n      for await (const protocol of source) {\n        // Remove the newline\n        protocols.push(protocol.shallowSlice(0, -1).toString())\n      }\n    }\n  )\n\n  /** @type {{ stream: DuplexStream, protocols: string[] }} */\n  const output = { stream: shakeStream, protocols }\n\n  return output\n}\n"]},"metadata":{},"sourceType":"script"}