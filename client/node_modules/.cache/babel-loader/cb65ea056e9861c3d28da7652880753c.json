{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.logCipherState = exports.logRemoteEphemeralKey = exports.logRemoteStaticKey = exports.logLocalEphemeralKeys = exports.logLocalStaticKeys = exports.logger = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst constants_1 = require(\"./constants\");\n\nconst to_string_1 = require(\"uint8arrays/to-string\");\n\nexports.logger = (0, debug_1.default)('libp2p:noise');\nlet keyLogger;\n\nif (constants_1.DUMP_SESSION_KEYS) {\n  keyLogger = exports.logger;\n} else {\n  keyLogger = () => {};\n}\n\nfunction logLocalStaticKeys(s) {\n  keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${(0, to_string_1.toString)(s.publicKey, 'hex')}`);\n  keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${(0, to_string_1.toString)(s.privateKey, 'hex')}`);\n}\n\nexports.logLocalStaticKeys = logLocalStaticKeys;\n\nfunction logLocalEphemeralKeys(e) {\n  if (e) {\n    keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${(0, to_string_1.toString)(e.publicKey, 'hex')}`);\n    keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${(0, to_string_1.toString)(e.privateKey, 'hex')}`);\n  } else {\n    keyLogger('Missing local ephemeral keys.');\n  }\n}\n\nexports.logLocalEphemeralKeys = logLocalEphemeralKeys;\n\nfunction logRemoteStaticKey(rs) {\n  keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${(0, to_string_1.toString)(rs, 'hex')}`);\n}\n\nexports.logRemoteStaticKey = logRemoteStaticKey;\n\nfunction logRemoteEphemeralKey(re) {\n  keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${(0, to_string_1.toString)(re, 'hex')}`);\n}\n\nexports.logRemoteEphemeralKey = logRemoteEphemeralKey;\n\nfunction logCipherState(session) {\n  if (session.cs1 && session.cs2) {\n    keyLogger(`CIPHER_STATE_1 ${session.cs1.n} ${(0, to_string_1.toString)(session.cs1.k, 'hex')}`);\n    keyLogger(`CIPHER_STATE_2 ${session.cs2.n} ${(0, to_string_1.toString)(session.cs2.k, 'hex')}`);\n  } else {\n    keyLogger('Missing cipher state.');\n  }\n}\n\nexports.logCipherState = logCipherState;","map":{"version":3,"mappings":";;;;;;;;;;;;;AAAA;;AACA;;AAGA;;AAEaA,iBAAS,qBAAM,cAAN,CAAT;AAEb,IAAIC,SAAJ;;AACA,IAAIC,6BAAJ,EAAuB;AACrBD,WAAS,GAAGD,cAAZ;AACD,CAFD,MAEO;AACLC,WAAS,GAAG,MAAK,CAAqB,CAAtC;AACD;;AAED,SAAgBE,kBAAhB,CAAoCC,CAApC,EAA8C;AAC5CH,WAAS,CAAC,2BAA2B,0BAAmBG,CAAC,CAACC,SAArB,EAAgC,KAAhC,CAAsC,EAAlE,CAAT;AACAJ,WAAS,CAAC,4BAA4B,0BAAmBG,CAAC,CAACE,UAArB,EAAiC,KAAjC,CAAuC,EAApE,CAAT;AACD;;AAHDN;;AAKA,SAAgBO,qBAAhB,CAAuCC,CAAvC,EAA2D;AACzD,MAAIA,CAAJ,EAAO;AACLP,aAAS,CAAC,8BAA8B,0BAAmBO,CAAC,CAACH,SAArB,EAAgC,KAAhC,CAAsC,EAArE,CAAT;AACAJ,aAAS,CAAC,+BAA+B,0BAAmBO,CAAC,CAACF,UAArB,EAAiC,KAAjC,CAAuC,EAAvE,CAAT;AACD,GAHD,MAGO;AACLL,aAAS,CAAC,+BAAD,CAAT;AACD;AACF;;AAPDD;;AASA,SAAgBS,kBAAhB,CAAoCC,EAApC,EAAkD;AAChDT,WAAS,CAAC,4BAA4B,0BAAmBS,EAAnB,EAAuB,KAAvB,CAA6B,EAA1D,CAAT;AACD;;AAFDV;;AAIA,SAAgBW,qBAAhB,CAAuCC,EAAvC,EAAqD;AACnDX,WAAS,CAAC,+BAA+B,0BAAmBW,EAAnB,EAAuB,KAAvB,CAA6B,EAA7D,CAAT;AACD;;AAFDZ;;AAIA,SAAgBa,cAAhB,CAAgCC,OAAhC,EAAqD;AACnD,MAAIA,OAAO,CAACC,GAAR,IAAeD,OAAO,CAACE,GAA3B,EAAgC;AAC9Bf,aAAS,CAAC,kBAAkBa,OAAO,CAACC,GAAR,CAAYE,CAAC,IAAI,0BAAmBH,OAAO,CAACC,GAAR,CAAYG,CAA/B,EAAkC,KAAlC,CAAwC,EAA5E,CAAT;AACAjB,aAAS,CAAC,kBAAkBa,OAAO,CAACE,GAAR,CAAYC,CAAC,IAAI,0BAAmBH,OAAO,CAACE,GAAR,CAAYE,CAA/B,EAAkC,KAAlC,CAAwC,EAA5E,CAAT;AACD,GAHD,MAGO;AACLjB,aAAS,CAAC,uBAAD,CAAT;AACD;AACF;;AAPDD","names":["exports","keyLogger","constants_1","logLocalStaticKeys","s","publicKey","privateKey","logLocalEphemeralKeys","e","logRemoteStaticKey","rs","logRemoteEphemeralKey","re","logCipherState","session","cs1","cs2","n","k"],"sourceRoot":"","sources":["../../src/logger.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}