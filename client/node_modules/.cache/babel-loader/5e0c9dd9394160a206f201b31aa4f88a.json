{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar filter = require('it-filter');\n\nvar take = require('it-take');\n\nvar merge = require('it-merge');\n\nvar base = require('./base.js');\n\nvar errors = require('./errors.js');\n\nvar utils = require('./utils.js');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar filter__default = /*#__PURE__*/_interopDefaultLegacy(filter);\n\nvar take__default = /*#__PURE__*/_interopDefaultLegacy(take);\n\nvar merge__default = /*#__PURE__*/_interopDefaultLegacy(merge);\n\nclass MountDatastore extends base.BaseDatastore {\n  constructor(mounts) {\n    super();\n    this.mounts = mounts.slice();\n  }\n\n  async open() {\n    await Promise.all(this.mounts.map(m => m.datastore.open()));\n  }\n\n  _lookup(key) {\n    for (const mount of this.mounts) {\n      if (mount.prefix.toString() === key.toString() || mount.prefix.isAncestorOf(key)) {\n        return {\n          datastore: mount.datastore,\n          mountpoint: mount.prefix\n        };\n      }\n    }\n  }\n\n  put(key, value, options) {\n    const match = this._lookup(key);\n\n    if (match == null) {\n      throw errors.dbWriteFailedError(new Error('No datastore mounted for this key'));\n    }\n\n    return match.datastore.put(key, value, options);\n  }\n\n  get(key, options) {\n    const match = this._lookup(key);\n\n    if (match == null) {\n      throw errors.notFoundError(new Error('No datastore mounted for this key'));\n    }\n\n    return match.datastore.get(key, options);\n  }\n\n  has(key, options) {\n    const match = this._lookup(key);\n\n    if (match == null) {\n      return Promise.resolve(false);\n    }\n\n    return match.datastore.has(key, options);\n  }\n\n  delete(key, options) {\n    const match = this._lookup(key);\n\n    if (match == null) {\n      throw errors.dbDeleteFailedError(new Error('No datastore mounted for this key'));\n    }\n\n    return match.datastore.delete(key, options);\n  }\n\n  async close() {\n    await Promise.all(this.mounts.map(m => {\n      return m.datastore.close();\n    }));\n  }\n\n  batch() {\n    const batchMounts = {};\n\n    const lookup = key => {\n      const match = this._lookup(key);\n\n      if (match == null) {\n        throw new Error('No datastore mounted for this key');\n      }\n\n      const m = match.mountpoint.toString();\n\n      if (batchMounts[m] == null) {\n        batchMounts[m] = match.datastore.batch();\n      }\n\n      return {\n        batch: batchMounts[m]\n      };\n    };\n\n    return {\n      put: (key, value) => {\n        const match = lookup(key);\n        match.batch.put(key, value);\n      },\n      delete: key => {\n        const match = lookup(key);\n        match.batch.delete(key);\n      },\n      commit: async options => {\n        await Promise.all(Object.keys(batchMounts).map(p => batchMounts[p].commit(options)));\n      }\n    };\n  }\n\n  query(q, options) {\n    const qs = this.mounts.map(m => {\n      return m.datastore.query({\n        prefix: q.prefix,\n        filters: q.filters\n      }, options);\n    });\n    let it = merge__default[\"default\"](...qs);\n    if (q.filters) q.filters.forEach(f => {\n      it = filter__default[\"default\"](it, f);\n    });\n    if (q.orders) q.orders.forEach(o => {\n      it = utils.sortAll(it, o);\n    });\n\n    if (q.offset != null) {\n      let i = 0;\n      it = filter__default[\"default\"](it, () => i++ >= q.offset);\n    }\n\n    if (q.limit != null) it = take__default[\"default\"](it, q.limit);\n    return it;\n  }\n\n  queryKeys(q, options) {\n    const qs = this.mounts.map(m => {\n      return m.datastore.queryKeys({\n        prefix: q.prefix,\n        filters: q.filters\n      }, options);\n    });\n    let it = merge__default[\"default\"](...qs);\n    if (q.filters) q.filters.forEach(f => {\n      it = filter__default[\"default\"](it, f);\n    });\n    if (q.orders) q.orders.forEach(o => {\n      it = utils.sortAll(it, o);\n    });\n\n    if (q.offset != null) {\n      let i = 0;\n      it = filter__default[\"default\"](it, () => i++ >= q.offset);\n    }\n\n    if (q.limit != null) it = take__default[\"default\"](it, q.limit);\n    return it;\n  }\n\n}\n\nexports.MountDatastore = MountDatastore;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/datastore-core/cjs/src/mount.js"],"names":["Object","defineProperty","exports","value","filter","require","take","merge","base","errors","utils","_interopDefaultLegacy","e","filter__default","take__default","merge__default","MountDatastore","BaseDatastore","constructor","mounts","slice","open","Promise","all","map","m","datastore","_lookup","key","mount","prefix","toString","isAncestorOf","mountpoint","put","options","match","dbWriteFailedError","Error","get","notFoundError","has","resolve","delete","dbDeleteFailedError","close","batch","batchMounts","lookup","commit","keys","p","query","q","qs","filters","it","forEach","f","orders","o","sortAll","offset","i","limit","queryKeys"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar filter = require('it-filter');\nvar take = require('it-take');\nvar merge = require('it-merge');\nvar base = require('./base.js');\nvar errors = require('./errors.js');\nvar utils = require('./utils.js');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar filter__default = /*#__PURE__*/_interopDefaultLegacy(filter);\nvar take__default = /*#__PURE__*/_interopDefaultLegacy(take);\nvar merge__default = /*#__PURE__*/_interopDefaultLegacy(merge);\n\nclass MountDatastore extends base.BaseDatastore {\n  constructor(mounts) {\n    super();\n    this.mounts = mounts.slice();\n  }\n  async open() {\n    await Promise.all(this.mounts.map(m => m.datastore.open()));\n  }\n  _lookup(key) {\n    for (const mount of this.mounts) {\n      if (mount.prefix.toString() === key.toString() || mount.prefix.isAncestorOf(key)) {\n        return {\n          datastore: mount.datastore,\n          mountpoint: mount.prefix\n        };\n      }\n    }\n  }\n  put(key, value, options) {\n    const match = this._lookup(key);\n    if (match == null) {\n      throw errors.dbWriteFailedError(new Error('No datastore mounted for this key'));\n    }\n    return match.datastore.put(key, value, options);\n  }\n  get(key, options) {\n    const match = this._lookup(key);\n    if (match == null) {\n      throw errors.notFoundError(new Error('No datastore mounted for this key'));\n    }\n    return match.datastore.get(key, options);\n  }\n  has(key, options) {\n    const match = this._lookup(key);\n    if (match == null) {\n      return Promise.resolve(false);\n    }\n    return match.datastore.has(key, options);\n  }\n  delete(key, options) {\n    const match = this._lookup(key);\n    if (match == null) {\n      throw errors.dbDeleteFailedError(new Error('No datastore mounted for this key'));\n    }\n    return match.datastore.delete(key, options);\n  }\n  async close() {\n    await Promise.all(this.mounts.map(m => {\n      return m.datastore.close();\n    }));\n  }\n  batch() {\n    const batchMounts = {};\n    const lookup = key => {\n      const match = this._lookup(key);\n      if (match == null) {\n        throw new Error('No datastore mounted for this key');\n      }\n      const m = match.mountpoint.toString();\n      if (batchMounts[m] == null) {\n        batchMounts[m] = match.datastore.batch();\n      }\n      return { batch: batchMounts[m] };\n    };\n    return {\n      put: (key, value) => {\n        const match = lookup(key);\n        match.batch.put(key, value);\n      },\n      delete: key => {\n        const match = lookup(key);\n        match.batch.delete(key);\n      },\n      commit: async options => {\n        await Promise.all(Object.keys(batchMounts).map(p => batchMounts[p].commit(options)));\n      }\n    };\n  }\n  query(q, options) {\n    const qs = this.mounts.map(m => {\n      return m.datastore.query({\n        prefix: q.prefix,\n        filters: q.filters\n      }, options);\n    });\n    let it = merge__default[\"default\"](...qs);\n    if (q.filters)\n      q.filters.forEach(f => {\n        it = filter__default[\"default\"](it, f);\n      });\n    if (q.orders)\n      q.orders.forEach(o => {\n        it = utils.sortAll(it, o);\n      });\n    if (q.offset != null) {\n      let i = 0;\n      it = filter__default[\"default\"](it, () => i++ >= q.offset);\n    }\n    if (q.limit != null)\n      it = take__default[\"default\"](it, q.limit);\n    return it;\n  }\n  queryKeys(q, options) {\n    const qs = this.mounts.map(m => {\n      return m.datastore.queryKeys({\n        prefix: q.prefix,\n        filters: q.filters\n      }, options);\n    });\n    let it = merge__default[\"default\"](...qs);\n    if (q.filters)\n      q.filters.forEach(f => {\n        it = filter__default[\"default\"](it, f);\n      });\n    if (q.orders)\n      q.orders.forEach(o => {\n        it = utils.sortAll(it, o);\n      });\n    if (q.offset != null) {\n      let i = 0;\n      it = filter__default[\"default\"](it, () => i++ >= q.offset);\n    }\n    if (q.limit != null)\n      it = take__default[\"default\"](it, q.limit);\n    return it;\n  }\n}\n\nexports.MountDatastore = MountDatastore;\n"]},"metadata":{},"sourceType":"script"}