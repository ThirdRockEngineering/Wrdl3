{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar utils = require('../../utils.js');\n\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\n\nvar normaliseInput = require('ipfs-core-utils/pins/normalise-input');\n\nvar pinTypes = require('ipfs-repo/pin-types');\n\nfunction createAddAll(_ref) {\n  let {\n    repo,\n    codecs\n  } = _ref;\n\n  async function* addAll(source) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    const pinAdd = async function* () {\n      for await (const {\n        path,\n        recursive,\n        metadata\n      } of normaliseInput.normaliseInput(source)) {\n        const {\n          cid\n        } = await utils.resolvePath(repo, codecs, path);\n        const {\n          reason\n        } = await repo.pins.isPinnedWithType(cid, [pinTypes.PinTypes.recursive, pinTypes.PinTypes.direct]);\n\n        if (reason === 'recursive' && !recursive) {\n          throw new Error(`${cid} already pinned recursively`);\n        }\n\n        if (recursive) {\n          await repo.pins.pinRecursively(cid, {\n            metadata\n          });\n        } else {\n          await repo.pins.pinDirectly(cid, {\n            metadata\n          });\n        }\n\n        yield cid;\n      }\n    };\n\n    const lock = Boolean(options.lock);\n\n    if (!lock) {\n      yield* pinAdd();\n      return;\n    }\n\n    const release = await repo.gcLock.readLock();\n\n    try {\n      yield* pinAdd();\n    } finally {\n      release();\n    }\n  }\n\n  return withTimeoutOption.withTimeoutOption(addAll);\n}\n\nexports.createAddAll = createAddAll;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-core/cjs/src/components/pin/add-all.js"],"names":["Object","defineProperty","exports","value","utils","require","withTimeoutOption","normaliseInput","pinTypes","createAddAll","repo","codecs","addAll","source","options","pinAdd","path","recursive","metadata","cid","resolvePath","reason","pins","isPinnedWithType","PinTypes","direct","Error","pinRecursively","pinDirectly","lock","Boolean","release","gcLock","readLock"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AAEA,IAAIC,KAAK,GAAGC,OAAO,CAAC,gBAAD,CAAnB;;AACA,IAAIC,iBAAiB,GAAGD,OAAO,CAAC,qCAAD,CAA/B;;AACA,IAAIE,cAAc,GAAGF,OAAO,CAAC,sCAAD,CAA5B;;AACA,IAAIG,QAAQ,GAAGH,OAAO,CAAC,qBAAD,CAAtB;;AAEA,SAASI,YAAT,OAAsC;AAAA,MAAhB;AAACC,IAAAA,IAAD;AAAOC,IAAAA;AAAP,GAAgB;;AACpC,kBAAgBC,MAAhB,CAAuBC,MAAvB,EAA6C;AAAA,QAAdC,OAAc,uEAAJ,EAAI;;AAC3C,UAAMC,MAAM,GAAG,mBAAmB;AAChC,iBAAW,MAAM;AAACC,QAAAA,IAAD;AAAOC,QAAAA,SAAP;AAAkBC,QAAAA;AAAlB,OAAjB,IAAgDX,cAAc,CAACA,cAAf,CAA8BM,MAA9B,CAAhD,EAAuF;AACrF,cAAM;AAACM,UAAAA;AAAD,YAAQ,MAAMf,KAAK,CAACgB,WAAN,CAAkBV,IAAlB,EAAwBC,MAAxB,EAAgCK,IAAhC,CAApB;AACA,cAAM;AAACK,UAAAA;AAAD,YAAW,MAAMX,IAAI,CAACY,IAAL,CAAUC,gBAAV,CAA2BJ,GAA3B,EAAgC,CACrDX,QAAQ,CAACgB,QAAT,CAAkBP,SADmC,EAErDT,QAAQ,CAACgB,QAAT,CAAkBC,MAFmC,CAAhC,CAAvB;;AAIA,YAAIJ,MAAM,KAAK,WAAX,IAA0B,CAACJ,SAA/B,EAA0C;AACxC,gBAAM,IAAIS,KAAJ,CAAW,GAAGP,GAAK,6BAAnB,CAAN;AACD;;AACD,YAAIF,SAAJ,EAAe;AACb,gBAAMP,IAAI,CAACY,IAAL,CAAUK,cAAV,CAAyBR,GAAzB,EAA8B;AAAED,YAAAA;AAAF,WAA9B,CAAN;AACD,SAFD,MAEO;AACL,gBAAMR,IAAI,CAACY,IAAL,CAAUM,WAAV,CAAsBT,GAAtB,EAA2B;AAAED,YAAAA;AAAF,WAA3B,CAAN;AACD;;AACD,cAAMC,GAAN;AACD;AACF,KAjBD;;AAkBA,UAAMU,IAAI,GAAGC,OAAO,CAAChB,OAAO,CAACe,IAAT,CAApB;;AACA,QAAI,CAACA,IAAL,EAAW;AACT,aAAOd,MAAM,EAAb;AACA;AACD;;AACD,UAAMgB,OAAO,GAAG,MAAMrB,IAAI,CAACsB,MAAL,CAAYC,QAAZ,EAAtB;;AACA,QAAI;AACF,aAAOlB,MAAM,EAAb;AACD,KAFD,SAEU;AACRgB,MAAAA,OAAO;AACR;AACF;;AACD,SAAOzB,iBAAiB,CAACA,iBAAlB,CAAoCM,MAApC,CAAP;AACD;;AAEDV,OAAO,CAACO,YAAR,GAAuBA,YAAvB","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar utils = require('../../utils.js');\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\nvar normaliseInput = require('ipfs-core-utils/pins/normalise-input');\nvar pinTypes = require('ipfs-repo/pin-types');\n\nfunction createAddAll({repo, codecs}) {\n  async function* addAll(source, options = {}) {\n    const pinAdd = async function* () {\n      for await (const {path, recursive, metadata} of normaliseInput.normaliseInput(source)) {\n        const {cid} = await utils.resolvePath(repo, codecs, path);\n        const {reason} = await repo.pins.isPinnedWithType(cid, [\n          pinTypes.PinTypes.recursive,\n          pinTypes.PinTypes.direct\n        ]);\n        if (reason === 'recursive' && !recursive) {\n          throw new Error(`${ cid } already pinned recursively`);\n        }\n        if (recursive) {\n          await repo.pins.pinRecursively(cid, { metadata });\n        } else {\n          await repo.pins.pinDirectly(cid, { metadata });\n        }\n        yield cid;\n      }\n    };\n    const lock = Boolean(options.lock);\n    if (!lock) {\n      yield* pinAdd();\n      return;\n    }\n    const release = await repo.gcLock.readLock();\n    try {\n      yield* pinAdd();\n    } finally {\n      release();\n    }\n  }\n  return withTimeoutOption.withTimeoutOption(addAll);\n}\n\nexports.createAddAll = createAddAll;\n"]},"metadata":{},"sourceType":"script"}