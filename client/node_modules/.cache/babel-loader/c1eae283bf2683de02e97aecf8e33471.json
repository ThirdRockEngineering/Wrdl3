{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IKHandshake = void 0;\n\nconst ik_1 = require(\"./handshakes/ik\");\n\nconst encoder_1 = require(\"./encoder\");\n\nconst utils_1 = require(\"./utils\");\n\nconst errors_1 = require(\"./errors\");\n\nconst logger_1 = require(\"./logger\");\n\nclass IKHandshake {\n  constructor(isInitiator, payload, prologue, staticKeypair, connection, remoteStaticKey, remotePeer, handshake) {\n    this.isInitiator = isInitiator;\n    this.payload = payload;\n    this.prologue = prologue;\n    this.staticKeypair = staticKeypair;\n    this.connection = connection;\n\n    if (remotePeer) {\n      this.remotePeer = remotePeer;\n    }\n\n    this.ik = handshake !== null && handshake !== void 0 ? handshake : new ik_1.IK();\n    this.session = this.ik.initSession(this.isInitiator, this.prologue, this.staticKeypair, remoteStaticKey);\n    this.remoteEarlyData = new Uint8Array();\n  }\n\n  async stage0() {\n    (0, logger_1.logLocalStaticKeys)(this.session.hs.s);\n    (0, logger_1.logRemoteStaticKey)(this.session.hs.rs);\n\n    if (this.isInitiator) {\n      (0, logger_1.logger)('IK Stage 0 - Initiator sending message...');\n      const messageBuffer = this.ik.sendMessage(this.session, this.payload);\n      this.connection.writeLP((0, encoder_1.encode1)(messageBuffer));\n      (0, logger_1.logger)('IK Stage 0 - Initiator sent message.');\n      (0, logger_1.logLocalEphemeralKeys)(this.session.hs.e);\n    } else {\n      (0, logger_1.logger)('IK Stage 0 - Responder receiving message...');\n      const receivedMsg = await this.connection.readLP();\n\n      try {\n        const receivedMessageBuffer = (0, encoder_1.decode1)(receivedMsg.slice());\n        const {\n          plaintext,\n          valid\n        } = this.ik.recvMessage(this.session, receivedMessageBuffer);\n\n        if (!valid) {\n          throw new Error('ik handshake stage 0 decryption validation fail');\n        }\n\n        (0, logger_1.logger)('IK Stage 0 - Responder got message, going to verify payload.');\n        const decodedPayload = await (0, utils_1.decodePayload)(plaintext);\n        this.remotePeer = this.remotePeer || (await (0, utils_1.getPeerIdFromPayload)(decodedPayload));\n        await (0, utils_1.verifySignedPayload)(this.session.hs.rs, decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data);\n        (0, logger_1.logger)('IK Stage 0 - Responder successfully verified payload!');\n        (0, logger_1.logRemoteEphemeralKey)(this.session.hs.re);\n      } catch (e) {\n        const err = e;\n        (0, logger_1.logger)('Responder breaking up with IK handshake in stage 0.');\n        throw new errors_1.FailedIKError(receivedMsg, `Error occurred while verifying initiator's signed payload: ${err.message}`);\n      }\n    }\n  }\n\n  async stage1() {\n    if (this.isInitiator) {\n      (0, logger_1.logger)('IK Stage 1 - Initiator receiving message...');\n      const receivedMsg = (await this.connection.readLP()).slice();\n      const receivedMessageBuffer = (0, encoder_1.decode0)(receivedMsg);\n      const {\n        plaintext,\n        valid\n      } = this.ik.recvMessage(this.session, receivedMessageBuffer);\n      (0, logger_1.logger)('IK Stage 1 - Initiator got message, going to verify payload.');\n\n      try {\n        if (!valid) {\n          throw new Error('ik stage 1 decryption validation fail');\n        }\n\n        const decodedPayload = await (0, utils_1.decodePayload)(plaintext);\n        this.remotePeer = this.remotePeer || (await (0, utils_1.getPeerIdFromPayload)(decodedPayload));\n        await (0, utils_1.verifySignedPayload)(receivedMessageBuffer.ns.slice(0, 32), decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data);\n        (0, logger_1.logger)('IK Stage 1 - Initiator successfully verified payload!');\n        (0, logger_1.logRemoteEphemeralKey)(this.session.hs.re);\n      } catch (e) {\n        const err = e;\n        (0, logger_1.logger)('Initiator breaking up with IK handshake in stage 1.');\n        throw new errors_1.FailedIKError(receivedMsg, `Error occurred while verifying responder's signed payload: ${err.message}`);\n      }\n    } else {\n      (0, logger_1.logger)('IK Stage 1 - Responder sending message...');\n      const messageBuffer = this.ik.sendMessage(this.session, this.payload);\n      this.connection.writeLP((0, encoder_1.encode0)(messageBuffer));\n      (0, logger_1.logger)('IK Stage 1 - Responder sent message...');\n      (0, logger_1.logLocalEphemeralKeys)(this.session.hs.e);\n    }\n\n    (0, logger_1.logCipherState)(this.session);\n  }\n\n  decrypt(ciphertext, session) {\n    const cs = this.getCS(session, false);\n    return this.ik.decryptWithAd(cs, new Uint8Array(0), ciphertext);\n  }\n\n  encrypt(plaintext, session) {\n    const cs = this.getCS(session);\n    return this.ik.encryptWithAd(cs, new Uint8Array(0), plaintext);\n  }\n\n  getLocalEphemeralKeys() {\n    if (!this.session.hs.e) {\n      throw new Error('Ephemeral keys do not exist.');\n    }\n\n    return this.session.hs.e;\n  }\n\n  getCS(session) {\n    let encryption = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (!session.cs1 || !session.cs2) {\n      throw new Error('Handshake not completed properly, cipher state does not exist.');\n    }\n\n    if (this.isInitiator) {\n      return encryption ? session.cs1 : session.cs2;\n    } else {\n      return encryption ? session.cs2 : session.cs1;\n    }\n  }\n\n  setRemoteEarlyData(data) {\n    if (data) {\n      this.remoteEarlyData = data;\n    }\n  }\n\n}\n\nexports.IKHandshake = IKHandshake;","map":{"version":3,"mappings":"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","names":["IKHandshake","constructor","isInitiator","payload","prologue","staticKeypair","connection","remoteStaticKey","remotePeer","handshake","ik","ik_1","session","initSession","remoteEarlyData","Uint8Array","stage0","hs","s","rs","messageBuffer","sendMessage","writeLP","e","receivedMsg","readLP","receivedMessageBuffer","slice","plaintext","valid","recvMessage","Error","decodedPayload","setRemoteEarlyData","data","re","err","errors_1","message","stage1","ns","decrypt","ciphertext","cs","getCS","decryptWithAd","encrypt","encryptWithAd","getLocalEphemeralKeys","encryption","cs1","cs2","exports"],"sourceRoot":"","sources":["../../src/handshake-ik.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}