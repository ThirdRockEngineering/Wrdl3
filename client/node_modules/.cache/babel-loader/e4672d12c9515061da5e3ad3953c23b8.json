{"ast":null,"code":"'use strict';\n\nconst {\n  default: Queue\n} = require('p-queue');\n\nconst {\n  xor\n} = require('uint8arrays/xor');\n\nconst {\n  toString\n} = require('uint8arrays/to-string');\n\nconst defer = require('p-defer');\n\nconst errCode = require('err-code');\n\nconst {\n  convertPeerId,\n  convertBuffer\n} = require('../utils');\n\nconst {\n  TimeoutController\n} = require('timeout-abort-controller');\n\nconst {\n  anySignal\n} = require('any-signal');\n\nconst {\n  queryErrorEvent\n} = require('./events');\n\nconst MAX_XOR = BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../types').QueryEvent} QueryEvent\n * @typedef {import('./types').QueryFunc} QueryFunc\n */\n\n/**\n * Walks a path through the DHT, calling the passed query function for\n * every peer encountered that we have not seen before.\n *\n * @param {object} context\n * @param {Uint8Array} context.key - what are we trying to find\n * @param {PeerId} context.startingPeer - where we start our query\n * @param {PeerId} context.ourPeerId - who we are\n * @param {AbortSignal} context.signal - when to stop querying\n * @param {QueryFunc} context.query - the query function to run with each peer\n * @param {number} context.alpha - how many concurrent node/value lookups to run\n * @param {number} context.pathIndex - how many concurrent node/value lookups to run\n * @param {number} context.numPaths - how many concurrent node/value lookups to run\n * @param {import('events').EventEmitter} context.cleanUp - will emit a 'cleanup' event if the caller exits the for..await of early\n * @param {number} [context.queryFuncTimeout] - a timeout for queryFunc in ms\n * @param {ReturnType<import('../utils').logger>} context.log\n */\n\nmodule.exports.queryPath = async function* queryPath(_ref) {\n  let {\n    key,\n    startingPeer,\n    ourPeerId,\n    signal,\n    query,\n    alpha,\n    pathIndex,\n    numPaths,\n    cleanUp,\n    queryFuncTimeout,\n    log\n  } = _ref;\n  // Only ALPHA node/value lookups are allowed at any given time for each process\n  // https://github.com/libp2p/specs/tree/master/kad-dht#alpha-concurrency-parameter-%CE%B1\n  const queue = new Queue({\n    concurrency: alpha\n  }); // perform lookups on kadId, not the actual value\n\n  const kadId = await convertBuffer(key); // make sure we don't get trapped in a loop\n\n  const peersSeen = new Set();\n  /**\n   * Adds the passed peer to the query queue if it's not us and no\n   * other path has passed through this peer\n   *\n   * @param {PeerId} peer\n   * @param {Uint8Array} peerKadId\n   */\n\n  function queryPeer(peer, peerKadId) {\n    if (!peer) {\n      return;\n    }\n\n    peersSeen.add(peer.toB58String());\n    const peerXor = BigInt('0x' + toString(xor(peerKadId, kadId), 'base16'));\n    queue.add(async () => {\n      let timeout;\n      const signals = [signal];\n\n      if (queryFuncTimeout != null) {\n        timeout = new TimeoutController(queryFuncTimeout);\n        signals.push(timeout.signal);\n      }\n\n      const compoundSignal = anySignal(signals);\n\n      try {\n        for await (const event of query({\n          key,\n          peer,\n          signal: compoundSignal,\n          pathIndex,\n          numPaths\n        })) {\n          if (compoundSignal.aborted) {\n            return;\n          } // if there are closer peers and the query has not completed, continue the query\n\n\n          if (event.name === 'PEER_RESPONSE') {\n            for (const closerPeer of event.closer) {\n              if (peersSeen.has(closerPeer.id.toB58String())) {\n                // eslint-disable-line max-depth\n                log('already seen %p in query', closerPeer.id);\n                continue;\n              }\n\n              if (ourPeerId.equals(closerPeer.id)) {\n                // eslint-disable-line max-depth\n                log('not querying ourselves');\n                continue;\n              }\n\n              const closerPeerKadId = await convertPeerId(closerPeer.id);\n              const closerPeerXor = BigInt('0x' + toString(xor(closerPeerKadId, kadId), 'base16')); // only continue query if closer peer is actually closer\n\n              if (closerPeerXor > peerXor) {\n                // eslint-disable-line max-depth\n                log('skipping %p as they are not closer to %b than %p', closerPeer.id, key, peer);\n                continue;\n              }\n\n              log('querying closer peer %p', closerPeer.id);\n              queryPeer(closerPeer.id, closerPeerKadId);\n            }\n          } // @ts-ignore simulate p-queue@7.x.x event\n\n\n          queue.emit('completed', event);\n        }\n\n        timeout && timeout.clear();\n      } catch (\n      /** @type {any} */\n      err) {\n        if (signal.aborted) {\n          // @ts-ignore simulate p-queue@7.x.x event\n          queue.emit('error', err);\n        } else {\n          // @ts-ignore simulate p-queue@7.x.x event\n          queue.emit('completed', queryErrorEvent({\n            from: peer,\n            error: err\n          }));\n        }\n      } finally {\n        timeout && timeout.clear();\n      }\n    }, {\n      // use xor value as the queue priority - closer peers should execute first\n      // subtract it from MAX_XOR because higher priority values execute sooner\n      // @ts-expect-error this is supposed to be a Number but it's ok to use BigInts\n      // as long as all priorities are BigInts since we won't mix BigInts and Number\n      // values in arithmetic operations\n      priority: MAX_XOR - peerXor\n    });\n  } // begin the query with the starting peer\n\n\n  queryPeer(startingPeer, await convertPeerId(startingPeer)); // yield results as they come in\n\n  yield* toGenerator(queue, signal, cleanUp, log);\n};\n/**\n * @param {Queue} queue\n * @param {AbortSignal} signal\n * @param {import('events').EventEmitter} cleanUp\n * @param {ReturnType<import('../utils').logger>} log\n */\n\n\nasync function* toGenerator(queue, signal, cleanUp, log) {\n  let deferred = defer();\n  let running = true;\n  /** @type {QueryEvent[]} */\n\n  const results = [];\n\n  const cleanup = () => {\n    if (!running) {\n      return;\n    }\n\n    log('clean up queue, results %d, queue size %d, pending tasks %d', results.length, queue.size, queue.pending);\n    running = false;\n    queue.clear();\n    results.splice(0, results.length);\n  }; // @ts-expect-error 'completed' event is in p-queue@7.x.x\n\n\n  queue.on('completed', result => {\n    results.push(result);\n    deferred.resolve();\n  }); // @ts-expect-error 'error' event is in p-queue@7.x.x\n\n  queue.on('error', err => {\n    log('queue error', err);\n    cleanup();\n    deferred.reject(err);\n  });\n  queue.on('idle', () => {\n    log('queue idle');\n    running = false;\n    deferred.resolve();\n  }); // clear the queue and throw if the query is aborted\n\n  signal.addEventListener('abort', () => {\n    log('abort queue');\n    const wasRunning = running;\n    cleanup();\n\n    if (wasRunning) {\n      deferred.reject(errCode(new Error('Query aborted'), 'ERR_QUERY_ABORTED'));\n    }\n  }); // the user broke out of the loop early, ensure we resolve the deferred result\n  // promise and clear the queue of any remaining jobs\n\n  cleanUp.on('cleanup', () => {\n    cleanup();\n    deferred.resolve();\n  });\n\n  while (running) {\n    // eslint-disable-line no-unmodified-loop-condition\n    await deferred.promise;\n    deferred = defer(); // yield all available results\n\n    while (results.length) {\n      const result = results.shift();\n\n      if (result) {\n        yield result;\n      }\n    }\n  } // yield any remaining results\n\n\n  yield* results;\n}","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p-kad-dht/src/query/query-path.js"],"names":["default","Queue","require","xor","toString","defer","errCode","convertPeerId","convertBuffer","TimeoutController","anySignal","queryErrorEvent","MAX_XOR","BigInt","module","exports","queryPath","key","startingPeer","ourPeerId","signal","query","alpha","pathIndex","numPaths","cleanUp","queryFuncTimeout","log","queue","concurrency","kadId","peersSeen","Set","queryPeer","peer","peerKadId","add","toB58String","peerXor","timeout","signals","push","compoundSignal","event","aborted","name","closerPeer","closer","has","id","equals","closerPeerKadId","closerPeerXor","emit","clear","err","from","error","priority","toGenerator","deferred","running","results","cleanup","length","size","pending","splice","on","result","resolve","reject","addEventListener","wasRunning","Error","promise","shift"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { default: Queue } = require('p-queue')\nconst { xor } = require('uint8arrays/xor')\nconst { toString } = require('uint8arrays/to-string')\nconst defer = require('p-defer')\nconst errCode = require('err-code')\nconst { convertPeerId, convertBuffer } = require('../utils')\nconst { TimeoutController } = require('timeout-abort-controller')\nconst { anySignal } = require('any-signal')\nconst { queryErrorEvent } = require('./events')\n\nconst MAX_XOR = BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF')\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../types').QueryEvent} QueryEvent\n * @typedef {import('./types').QueryFunc} QueryFunc\n */\n\n/**\n * Walks a path through the DHT, calling the passed query function for\n * every peer encountered that we have not seen before.\n *\n * @param {object} context\n * @param {Uint8Array} context.key - what are we trying to find\n * @param {PeerId} context.startingPeer - where we start our query\n * @param {PeerId} context.ourPeerId - who we are\n * @param {AbortSignal} context.signal - when to stop querying\n * @param {QueryFunc} context.query - the query function to run with each peer\n * @param {number} context.alpha - how many concurrent node/value lookups to run\n * @param {number} context.pathIndex - how many concurrent node/value lookups to run\n * @param {number} context.numPaths - how many concurrent node/value lookups to run\n * @param {import('events').EventEmitter} context.cleanUp - will emit a 'cleanup' event if the caller exits the for..await of early\n * @param {number} [context.queryFuncTimeout] - a timeout for queryFunc in ms\n * @param {ReturnType<import('../utils').logger>} context.log\n */\nmodule.exports.queryPath = async function * queryPath ({ key, startingPeer, ourPeerId, signal, query, alpha, pathIndex, numPaths, cleanUp, queryFuncTimeout, log }) {\n  // Only ALPHA node/value lookups are allowed at any given time for each process\n  // https://github.com/libp2p/specs/tree/master/kad-dht#alpha-concurrency-parameter-%CE%B1\n  const queue = new Queue({\n    concurrency: alpha\n  })\n\n  // perform lookups on kadId, not the actual value\n  const kadId = await convertBuffer(key)\n\n  // make sure we don't get trapped in a loop\n  const peersSeen = new Set()\n\n  /**\n   * Adds the passed peer to the query queue if it's not us and no\n   * other path has passed through this peer\n   *\n   * @param {PeerId} peer\n   * @param {Uint8Array} peerKadId\n   */\n  function queryPeer (peer, peerKadId) {\n    if (!peer) {\n      return\n    }\n\n    peersSeen.add(peer.toB58String())\n\n    const peerXor = BigInt('0x' + toString(xor(peerKadId, kadId), 'base16'))\n\n    queue.add(async () => {\n      let timeout\n      const signals = [signal]\n\n      if (queryFuncTimeout != null) {\n        timeout = new TimeoutController(queryFuncTimeout)\n        signals.push(timeout.signal)\n      }\n\n      const compoundSignal = anySignal(signals)\n\n      try {\n        for await (const event of query({\n          key,\n          peer,\n          signal: compoundSignal,\n          pathIndex,\n          numPaths\n        })) {\n          if (compoundSignal.aborted) {\n            return\n          }\n\n          // if there are closer peers and the query has not completed, continue the query\n          if (event.name === 'PEER_RESPONSE') {\n            for (const closerPeer of event.closer) {\n              if (peersSeen.has(closerPeer.id.toB58String())) { // eslint-disable-line max-depth\n                log('already seen %p in query', closerPeer.id)\n                continue\n              }\n\n              if (ourPeerId.equals(closerPeer.id)) { // eslint-disable-line max-depth\n                log('not querying ourselves')\n                continue\n              }\n\n              const closerPeerKadId = await convertPeerId(closerPeer.id)\n              const closerPeerXor = BigInt('0x' + toString(xor(closerPeerKadId, kadId), 'base16'))\n\n              // only continue query if closer peer is actually closer\n              if (closerPeerXor > peerXor) { // eslint-disable-line max-depth\n                log('skipping %p as they are not closer to %b than %p', closerPeer.id, key, peer)\n                continue\n              }\n\n              log('querying closer peer %p', closerPeer.id)\n              queryPeer(closerPeer.id, closerPeerKadId)\n            }\n          }\n\n          // @ts-ignore simulate p-queue@7.x.x event\n          queue.emit('completed', event)\n        }\n\n        timeout && timeout.clear()\n      } catch (/** @type {any} */ err) {\n        if (signal.aborted) {\n          // @ts-ignore simulate p-queue@7.x.x event\n          queue.emit('error', err)\n        } else {\n          // @ts-ignore simulate p-queue@7.x.x event\n          queue.emit('completed', queryErrorEvent({\n            from: peer,\n            error: err\n          }))\n        }\n      } finally {\n        timeout && timeout.clear()\n      }\n    }, {\n      // use xor value as the queue priority - closer peers should execute first\n      // subtract it from MAX_XOR because higher priority values execute sooner\n\n      // @ts-expect-error this is supposed to be a Number but it's ok to use BigInts\n      // as long as all priorities are BigInts since we won't mix BigInts and Number\n      // values in arithmetic operations\n      priority: MAX_XOR - peerXor\n    })\n  }\n\n  // begin the query with the starting peer\n  queryPeer(startingPeer, await convertPeerId(startingPeer))\n\n  // yield results as they come in\n  yield * toGenerator(queue, signal, cleanUp, log)\n}\n\n/**\n * @param {Queue} queue\n * @param {AbortSignal} signal\n * @param {import('events').EventEmitter} cleanUp\n * @param {ReturnType<import('../utils').logger>} log\n */\nasync function * toGenerator (queue, signal, cleanUp, log) {\n  let deferred = defer()\n  let running = true\n  /** @type {QueryEvent[]} */\n  const results = []\n\n  const cleanup = () => {\n    if (!running) {\n      return\n    }\n\n    log('clean up queue, results %d, queue size %d, pending tasks %d', results.length, queue.size, queue.pending)\n\n    running = false\n    queue.clear()\n    results.splice(0, results.length)\n  }\n\n  // @ts-expect-error 'completed' event is in p-queue@7.x.x\n  queue.on('completed', result => {\n    results.push(result)\n    deferred.resolve()\n  })\n  // @ts-expect-error 'error' event is in p-queue@7.x.x\n  queue.on('error', err => {\n    log('queue error', err)\n    cleanup()\n    deferred.reject(err)\n  })\n  queue.on('idle', () => {\n    log('queue idle')\n    running = false\n    deferred.resolve()\n  })\n\n  // clear the queue and throw if the query is aborted\n  signal.addEventListener('abort', () => {\n    log('abort queue')\n    const wasRunning = running\n    cleanup()\n\n    if (wasRunning) {\n      deferred.reject(errCode(new Error('Query aborted'), 'ERR_QUERY_ABORTED'))\n    }\n  })\n\n  // the user broke out of the loop early, ensure we resolve the deferred result\n  // promise and clear the queue of any remaining jobs\n  cleanUp.on('cleanup', () => {\n    cleanup()\n    deferred.resolve()\n  })\n\n  while (running) { // eslint-disable-line no-unmodified-loop-condition\n    await deferred.promise\n    deferred = defer()\n\n    // yield all available results\n    while (results.length) {\n      const result = results.shift()\n\n      if (result) {\n        yield result\n      }\n    }\n  }\n\n  // yield any remaining results\n  yield * results\n}\n"]},"metadata":{},"sourceType":"script"}