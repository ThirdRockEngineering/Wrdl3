{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar version = require('../version.js');\n\nvar multiaddr = require('multiaddr');\n\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\n\nvar toString = require('uint8arrays/to-string');\n\nvar PeerId = require('peer-id');\n\nvar errors = require('../errors.js');\n\nvar errCode = require('err-code');\n\nvar debug = require('debug');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar PeerId__default = /*#__PURE__*/_interopDefaultLegacy(PeerId);\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\n\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\n\nconst log = Object.assign(debug__default[\"default\"]('ipfs:components:id'), {\n  error: debug__default[\"default\"]('ipfs:components:id:error')\n});\n\nfunction createId(_ref) {\n  let {\n    peerId,\n    network\n  } = _ref;\n\n  async function id() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const net = network.try();\n\n    if (!net) {\n      if (options.peerId) {\n        throw new errors.NotStartedError();\n      }\n\n      const idStr = peerId.toB58String();\n      return {\n        id: idStr,\n        publicKey: toString.toString(peerId.pubKey.bytes, 'base64pad'),\n        addresses: [],\n        agentVersion: `js-ipfs/${version.ipfsCore}`,\n        protocolVersion: '9000',\n        protocols: []\n      };\n    }\n\n    const {\n      libp2p\n    } = net;\n    const peerIdToId = options.peerId ? PeerId__default[\"default\"].parse(options.peerId) : peerId;\n    const peer = await findPeer(peerIdToId, libp2p, options);\n    const agentVersion = toString.toString(peer.metadata.get('AgentVersion') || new Uint8Array());\n    const protocolVersion = toString.toString(peer.metadata.get('ProtocolVersion') || new Uint8Array());\n    const idStr = peer.id.toB58String();\n    const publicKeyStr = peer.publicKey ? toString.toString(peer.publicKey.bytes, 'base64pad') : '';\n    return {\n      id: idStr,\n      publicKey: publicKeyStr,\n      addresses: (peer.addresses || []).map(ma => {\n        const str = ma.toString();\n\n        if (str.endsWith(`/p2p/${idStr}`)) {\n          return str;\n        }\n\n        return `${str}/p2p/${idStr}`;\n      }).sort().map(ma => new multiaddr.Multiaddr(ma)),\n      agentVersion,\n      protocolVersion,\n      protocols: (peer.protocols || []).sort()\n    };\n  }\n\n  return withTimeoutOption.withTimeoutOption(id);\n}\n\nasync function findPeer(peerId, libp2p, options) {\n  let peer = await libp2p.peerStore.get(peerId);\n\n  if (!peer) {\n    peer = await findPeerOnDht(peerId, libp2p, options);\n  }\n\n  let publicKey = peerId.pubKey ? peerId.pubKey : await libp2p.peerStore.keyBook.get(peerId);\n\n  if (!publicKey) {\n    try {\n      publicKey = await libp2p._dht.getPublicKey(peerId, options);\n    } catch (err) {\n      log.error('Could not load public key for', peerId.toB58String(), err);\n    }\n  }\n\n  return { ...peer,\n    publicKey,\n    metadata: peer.metadata || new Map(),\n    addresses: peer.addresses.map(addr => addr.multiaddr)\n  };\n}\n\nasync function findPeerOnDht(peerId, libp2p, options) {\n  for await (const event of libp2p._dht.findPeer(peerId, options)) {\n    if (event.name === 'FINAL_PEER') {\n      break;\n    }\n  }\n\n  const peer = await libp2p.peerStore.get(peerId);\n\n  if (!peer) {\n    throw errCode__default[\"default\"](new Error('Could not find peer'), 'ERR_NOT_FOUND');\n  }\n\n  return peer;\n}\n\nexports.createId = createId;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-core/cjs/src/components/id.js"],"names":["Object","defineProperty","exports","value","version","require","multiaddr","withTimeoutOption","toString","PeerId","errors","errCode","debug","_interopDefaultLegacy","e","PeerId__default","errCode__default","debug__default","log","assign","error","createId","peerId","network","id","options","net","try","NotStartedError","idStr","toB58String","publicKey","pubKey","bytes","addresses","agentVersion","ipfsCore","protocolVersion","protocols","libp2p","peerIdToId","parse","peer","findPeer","metadata","get","Uint8Array","publicKeyStr","map","ma","str","endsWith","sort","Multiaddr","peerStore","findPeerOnDht","keyBook","_dht","getPublicKey","err","Map","addr","event","name","Error"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar version = require('../version.js');\nvar multiaddr = require('multiaddr');\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\nvar toString = require('uint8arrays/to-string');\nvar PeerId = require('peer-id');\nvar errors = require('../errors.js');\nvar errCode = require('err-code');\nvar debug = require('debug');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar PeerId__default = /*#__PURE__*/_interopDefaultLegacy(PeerId);\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\n\nconst log = Object.assign(debug__default[\"default\"]('ipfs:components:id'), { error: debug__default[\"default\"]('ipfs:components:id:error') });\nfunction createId({peerId, network}) {\n  async function id(options = {}) {\n    const net = network.try();\n    if (!net) {\n      if (options.peerId) {\n        throw new errors.NotStartedError();\n      }\n      const idStr = peerId.toB58String();\n      return {\n        id: idStr,\n        publicKey: toString.toString(peerId.pubKey.bytes, 'base64pad'),\n        addresses: [],\n        agentVersion: `js-ipfs/${ version.ipfsCore }`,\n        protocolVersion: '9000',\n        protocols: []\n      };\n    }\n    const {libp2p} = net;\n    const peerIdToId = options.peerId ? PeerId__default[\"default\"].parse(options.peerId) : peerId;\n    const peer = await findPeer(peerIdToId, libp2p, options);\n    const agentVersion = toString.toString(peer.metadata.get('AgentVersion') || new Uint8Array());\n    const protocolVersion = toString.toString(peer.metadata.get('ProtocolVersion') || new Uint8Array());\n    const idStr = peer.id.toB58String();\n    const publicKeyStr = peer.publicKey ? toString.toString(peer.publicKey.bytes, 'base64pad') : '';\n    return {\n      id: idStr,\n      publicKey: publicKeyStr,\n      addresses: (peer.addresses || []).map(ma => {\n        const str = ma.toString();\n        if (str.endsWith(`/p2p/${ idStr }`)) {\n          return str;\n        }\n        return `${ str }/p2p/${ idStr }`;\n      }).sort().map(ma => new multiaddr.Multiaddr(ma)),\n      agentVersion,\n      protocolVersion,\n      protocols: (peer.protocols || []).sort()\n    };\n  }\n  return withTimeoutOption.withTimeoutOption(id);\n}\nasync function findPeer(peerId, libp2p, options) {\n  let peer = await libp2p.peerStore.get(peerId);\n  if (!peer) {\n    peer = await findPeerOnDht(peerId, libp2p, options);\n  }\n  let publicKey = peerId.pubKey ? peerId.pubKey : await libp2p.peerStore.keyBook.get(peerId);\n  if (!publicKey) {\n    try {\n      publicKey = await libp2p._dht.getPublicKey(peerId, options);\n    } catch (err) {\n      log.error('Could not load public key for', peerId.toB58String(), err);\n    }\n  }\n  return {\n    ...peer,\n    publicKey,\n    metadata: peer.metadata || new Map(),\n    addresses: peer.addresses.map(addr => addr.multiaddr)\n  };\n}\nasync function findPeerOnDht(peerId, libp2p, options) {\n  for await (const event of libp2p._dht.findPeer(peerId, options)) {\n    if (event.name === 'FINAL_PEER') {\n      break;\n    }\n  }\n  const peer = await libp2p.peerStore.get(peerId);\n  if (!peer) {\n    throw errCode__default[\"default\"](new Error('Could not find peer'), 'ERR_NOT_FOUND');\n  }\n  return peer;\n}\n\nexports.createId = createId;\n"]},"metadata":{},"sourceType":"script"}