{"ast":null,"code":"'use strict';\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst PeerId = require('peer-id');\n\nconst utils = require('./utils');\n\nconst errCode = require('err-code');\n\nconst merge = require('it-merge');\n\nconst {\n  queryErrorEvent\n} = require('./query/events');\n\nconst log = utils.logger('libp2p:kad-dht');\n/**\n * @typedef {import('libp2p')} Libp2p\n * @typedef {import('libp2p/src/peer-store')} PeerStore\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('libp2p/src/dialer')} Dialer\n * @typedef {import('libp2p/src/registrar')} Registrar\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('./kad-dht').KadDHT} KadDHT\n * @typedef {import('./types').DHT} DHT\n * @typedef {import('./types').QueryEvent} QueryEvent\n * @typedef {import('./types').SendingQueryEvent} SendingQueryEvent\n * @typedef {import('./types').PeerResponseEvent} PeerResponseEvent\n * @typedef {import('./types').FinalPeerEvent} FinalPeerEvent\n * @typedef {import('./types').QueryErrorEvent} QueryErrorEvent\n * @typedef {import('./types').ProviderEvent} ProviderEvent\n * @typedef {import('./types').ValueEvent} ValueEvent\n * @typedef {import('./types').AddingPeerEvent} AddingPeerEvent\n * @typedef {import('./types').DialingPeerEvent} DialingPeerEvent\n *\n * @typedef {object} KadDHTOps\n * @property {Libp2p} libp2p - the libp2p instance\n * @property {string} [protocol = '/ipfs/kad/1.0.0'] - libp2p registrar handle protocol\n * @property {number} kBucketSize - k-bucket size (default 20)\n * @property {boolean} clientMode - If true, the DHT will not respond to queries. This should be true if your node will not be dialable. (default: false)\n * @property {import('libp2p-interfaces/src/types').DhtValidators} validators - validators object with namespace as keys and function(key, record, callback)\n * @property {object} selectors - selectors object with namespace as keys and function(key, records)\n * @property {number} querySelfInterval - how often to search the network for peers close to ourselves\n */\n\n/**\n * A DHT implementation modelled after Kademlia with S/Kademlia modifications.\n * Original implementation in go: https://github.com/libp2p/go-libp2p-kad-dht.\n */\n\nclass DualKadDHT extends EventEmitter {\n  /**\n   * Create a new KadDHT.\n   *\n   * @param {KadDHT} wan\n   * @param {KadDHT} lan\n   * @param {Libp2p} libp2p\n   */\n  constructor(wan, lan, libp2p) {\n    super();\n    this._wan = wan;\n    this._lan = lan;\n    this._libp2p = libp2p; // handle peers being discovered during processing of DHT messages\n\n    this._wan.on('peer', peerData => {\n      this.emit('peer', peerData);\n    });\n\n    this._lan.on('peer', peerData => {\n      this.emit('peer', peerData);\n    });\n  }\n  /**\n   * Is this DHT running.\n   */\n\n\n  isStarted() {\n    return this._wan.isStarted() && this._lan.isStarted();\n  }\n  /**\n   * Whether we are in client or server mode\n   */\n\n\n  async enableServerMode() {\n    await this._wan.enableServerMode();\n  }\n  /**\n   * Whether we are in client or server mode\n   */\n\n\n  async enableClientMode() {\n    await this._wan.enableClientMode();\n  }\n  /**\n   * Start listening to incoming connections.\n   */\n\n\n  async start() {\n    await Promise.all([this._lan.start(), this._wan.start()]);\n  }\n  /**\n   * Stop accepting incoming connections and sending outgoing\n   * messages.\n   */\n\n\n  async stop() {\n    await Promise.all([this._lan.stop(), this._wan.stop()]);\n  }\n  /**\n   * Store the given key/value pair in the DHT\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} value\n   * @param {object} [options] - put options\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.minPeers] - minimum number of peers required to successfully put (default: closestPeers.length)\n   */\n\n\n  async *put(key, value) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // eslint-disable-line require-await\n    let counterAll = 0;\n    let counterSuccess = 0;\n\n    for await (const event of merge(this._lan.put(key, value, options), this._wan.put(key, value, options))) {\n      yield event;\n\n      if (event.name === 'SENDING_QUERY' && event.messageName === 'PUT_VALUE') {\n        counterAll++;\n      }\n\n      if (event.name === 'PEER_RESPONSE' && event.messageName === 'PUT_VALUE') {\n        counterSuccess++;\n      }\n    } // Ensure we have a default `minPeers`\n\n\n    const minPeers = options.minPeers == null ? counterAll || 1 : options.minPeers; // verify if we were able to put to enough peers\n\n    if (counterSuccess < minPeers) {\n      const error = errCode(new Error(`Failed to put value to enough peers: ${counterSuccess}/${minPeers}`), 'ERR_NOT_ENOUGH_PUT_PEERS');\n      log.error(error);\n      throw error;\n    }\n  }\n  /**\n   * Get the value that corresponds to the passed key\n   *\n   * @param {Uint8Array} key\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.queryFuncTimeout]\n   */\n\n\n  async *get(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // eslint-disable-line require-await\n    let queriedPeers = false;\n    let foundValue = false;\n\n    for await (const event of merge(this._lan.get(key, options), this._wan.get(key, options))) {\n      yield event;\n\n      if (event.name === 'DIALING_PEER') {\n        queriedPeers = true;\n      }\n\n      if (event.name === 'VALUE') {\n        queriedPeers = true;\n\n        if (event.value != null) {\n          foundValue = true;\n        }\n      }\n\n      if (event.name === 'SENDING_QUERY') {\n        queriedPeers = true;\n      }\n    }\n\n    if (!queriedPeers) {\n      throw errCode(new Error('No peers found in routing table!'), 'ERR_NO_PEERS_IN_ROUTING_TABLE');\n    }\n\n    if (!foundValue) {\n      yield queryErrorEvent({\n        from: this._libp2p.peerId,\n        error: errCode(new Error('Not found'), 'ERR_NOT_FOUND')\n      });\n    }\n  } // ----------- Content Routing\n\n  /**\n   * Announce to the network that we can provide given key's value\n   *\n   * @param {CID} key\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  async *provide(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // eslint-disable-line require-await\n    let sent = 0;\n    let success = 0;\n    const errors = [];\n    const dhts = [this._lan]; // only run provide on the wan if we are in server mode\n\n    if (this._wan.isServer()) {\n      dhts.push(this._wan);\n    }\n\n    for await (const event of merge(...dhts.map(dht => dht.provide(key, options)))) {\n      yield event;\n\n      if (event.name === 'SENDING_QUERY') {\n        sent++;\n      }\n\n      if (event.name === 'QUERY_ERROR') {\n        errors.push(event.error);\n      }\n\n      if (event.name === 'PEER_RESPONSE' && event.messageName === 'ADD_PROVIDER') {\n        log('sent provider record for %s to %p', key, event.from.id);\n        success++;\n      }\n    }\n\n    if (success === 0) {\n      if (errors.length) {\n        // if all sends failed, throw an error to inform the caller\n        throw errCode(new Error(`Failed to provide to ${errors.length} of ${sent} peers`), 'ERR_PROVIDES_FAILED', {\n          errors\n        });\n      }\n\n      throw errCode(new Error('Failed to provide - no peers found'), 'ERR_PROVIDES_FAILED');\n    }\n  }\n  /**\n   * Search the dht for up to `K` providers of the given CID.\n   *\n   * @param {CID} key\n   * @param {object} [options] - findProviders options\n   * @param {number} [options.maxNumProviders=5] - maximum number of providers to find\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.queryFuncTimeout]\n   */\n\n\n  async *findProviders(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      maxNumProviders: 5\n    };\n    yield* merge(this._lan.findProviders(key, options), this._wan.findProviders(key, options));\n  } // ----------- Peer Routing -----------\n\n  /**\n   * Search for a peer with the given ID\n   *\n   * @param {PeerId} id\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.queryFuncTimeout]\n   */\n\n\n  async *findPeer(id) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // eslint-disable-line require-await\n    let queriedPeers = false;\n\n    for await (const event of merge(this._lan.findPeer(id, options), this._wan.findPeer(id, options))) {\n      yield event;\n\n      if (event.name === 'SENDING_QUERY' || event.name === 'FINAL_PEER') {\n        queriedPeers = true;\n      }\n    }\n\n    if (!queriedPeers) {\n      throw errCode(new Error('Peer lookup failed'), 'ERR_LOOKUP_FAILED');\n    }\n  }\n  /**\n   * Kademlia 'node lookup' operation.\n   *\n   * @param {Uint8Array} key\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.queryFuncTimeout]\n   */\n\n\n  async *getClosestPeers(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    yield* merge(this._lan.getClosestPeers(key, options), this._wan.getClosestPeers(key, options));\n  }\n  /**\n   * Get the public key for the given peer id\n   *\n   * @param {PeerId} peer\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  async getPublicKey(peer) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    log('getPublicKey %p', peer);\n    let peerData; // local check\n\n    try {\n      peerData = await this._libp2p.peerStore.get(peer);\n\n      if (peerData.pubKey) {\n        log('getPublicKey: found local copy');\n        return peerData.pubKey;\n      }\n\n      if (peerData.id.pubKey) {\n        log('getPublicKey: found local copy');\n        return peerData.id.pubKey;\n      }\n    } catch (\n    /** @type {any} */\n    err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        throw err;\n      }\n    } // try the node directly\n\n\n    const pks = await Promise.all([this._lan.getPublicKey(peer, options), this._wan.getPublicKey(peer, options)]);\n\n    if (pks[0] && pks[1] && !pks[0].equals(pks[1])) {\n      throw errCode(new Error('Inconsistent public key loaded from wan and lan DHTs'), 'ERR_FAILED_TO_LOAD_KEY');\n    }\n\n    const pk = pks[0] || pks[1];\n\n    if (!pk) {\n      throw errCode(new Error('Failed to load public key'), 'ERR_FAILED_TO_LOAD_KEY');\n    }\n\n    const peerId = new PeerId(peer.id, undefined, pk);\n    const addrs = (peerData && peerData.addresses || []).map(address => address.multiaddr);\n    await this._libp2p.peerStore.addressBook.add(peerId, addrs);\n    await this._libp2p.peerStore.keyBook.set(peerId, pk);\n    return pk;\n  }\n\n  async refreshRoutingTable() {\n    await Promise.all([this._lan.refreshRoutingTable(), this._wan.refreshRoutingTable()]);\n  }\n\n}\n\nmodule.exports = {\n  DualKadDHT\n};","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p-kad-dht/src/dual-kad-dht.js"],"names":["EventEmitter","require","PeerId","utils","errCode","merge","queryErrorEvent","log","logger","DualKadDHT","constructor","wan","lan","libp2p","_wan","_lan","_libp2p","on","peerData","emit","isStarted","enableServerMode","enableClientMode","start","Promise","all","stop","put","key","value","options","counterAll","counterSuccess","event","name","messageName","minPeers","error","Error","get","queriedPeers","foundValue","from","peerId","provide","sent","success","errors","dhts","isServer","push","map","dht","id","length","findProviders","maxNumProviders","findPeer","getClosestPeers","getPublicKey","peer","peerStore","pubKey","err","code","pks","equals","pk","undefined","addrs","addresses","address","multiaddr","addressBook","add","keyBook","set","refreshRoutingTable","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { EventEmitter } = require('events')\nconst PeerId = require('peer-id')\nconst utils = require('./utils')\nconst errCode = require('err-code')\nconst merge = require('it-merge')\nconst { queryErrorEvent } = require('./query/events')\n\nconst log = utils.logger('libp2p:kad-dht')\n\n/**\n * @typedef {import('libp2p')} Libp2p\n * @typedef {import('libp2p/src/peer-store')} PeerStore\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('libp2p/src/dialer')} Dialer\n * @typedef {import('libp2p/src/registrar')} Registrar\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('./kad-dht').KadDHT} KadDHT\n * @typedef {import('./types').DHT} DHT\n * @typedef {import('./types').QueryEvent} QueryEvent\n * @typedef {import('./types').SendingQueryEvent} SendingQueryEvent\n * @typedef {import('./types').PeerResponseEvent} PeerResponseEvent\n * @typedef {import('./types').FinalPeerEvent} FinalPeerEvent\n * @typedef {import('./types').QueryErrorEvent} QueryErrorEvent\n * @typedef {import('./types').ProviderEvent} ProviderEvent\n * @typedef {import('./types').ValueEvent} ValueEvent\n * @typedef {import('./types').AddingPeerEvent} AddingPeerEvent\n * @typedef {import('./types').DialingPeerEvent} DialingPeerEvent\n *\n * @typedef {object} KadDHTOps\n * @property {Libp2p} libp2p - the libp2p instance\n * @property {string} [protocol = '/ipfs/kad/1.0.0'] - libp2p registrar handle protocol\n * @property {number} kBucketSize - k-bucket size (default 20)\n * @property {boolean} clientMode - If true, the DHT will not respond to queries. This should be true if your node will not be dialable. (default: false)\n * @property {import('libp2p-interfaces/src/types').DhtValidators} validators - validators object with namespace as keys and function(key, record, callback)\n * @property {object} selectors - selectors object with namespace as keys and function(key, records)\n * @property {number} querySelfInterval - how often to search the network for peers close to ourselves\n */\n\n/**\n * A DHT implementation modelled after Kademlia with S/Kademlia modifications.\n * Original implementation in go: https://github.com/libp2p/go-libp2p-kad-dht.\n */\nclass DualKadDHT extends EventEmitter {\n  /**\n   * Create a new KadDHT.\n   *\n   * @param {KadDHT} wan\n   * @param {KadDHT} lan\n   * @param {Libp2p} libp2p\n   */\n  constructor (wan, lan, libp2p) {\n    super()\n\n    this._wan = wan\n    this._lan = lan\n    this._libp2p = libp2p\n\n    // handle peers being discovered during processing of DHT messages\n    this._wan.on('peer', (peerData) => {\n      this.emit('peer', peerData)\n    })\n    this._lan.on('peer', (peerData) => {\n      this.emit('peer', peerData)\n    })\n  }\n\n  /**\n   * Is this DHT running.\n   */\n  isStarted () {\n    return this._wan.isStarted() && this._lan.isStarted()\n  }\n\n  /**\n   * Whether we are in client or server mode\n   */\n  async enableServerMode () {\n    await this._wan.enableServerMode()\n  }\n\n  /**\n   * Whether we are in client or server mode\n   */\n  async enableClientMode () {\n    await this._wan.enableClientMode()\n  }\n\n  /**\n   * Start listening to incoming connections.\n   */\n  async start () {\n    await Promise.all([\n      this._lan.start(),\n      this._wan.start()\n    ])\n  }\n\n  /**\n   * Stop accepting incoming connections and sending outgoing\n   * messages.\n   */\n  async stop () {\n    await Promise.all([\n      this._lan.stop(),\n      this._wan.stop()\n    ])\n  }\n\n  /**\n   * Store the given key/value pair in the DHT\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} value\n   * @param {object} [options] - put options\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.minPeers] - minimum number of peers required to successfully put (default: closestPeers.length)\n   */\n  async * put (key, value, options = {}) { // eslint-disable-line require-await\n    let counterAll = 0\n    let counterSuccess = 0\n\n    for await (const event of merge(\n      this._lan.put(key, value, options),\n      this._wan.put(key, value, options)\n    )) {\n      yield event\n\n      if (event.name === 'SENDING_QUERY' && event.messageName === 'PUT_VALUE') {\n        counterAll++\n      }\n\n      if (event.name === 'PEER_RESPONSE' && event.messageName === 'PUT_VALUE') {\n        counterSuccess++\n      }\n    }\n\n    // Ensure we have a default `minPeers`\n    const minPeers = options.minPeers == null ? counterAll || 1 : options.minPeers\n\n    // verify if we were able to put to enough peers\n    if (counterSuccess < minPeers) {\n      const error = errCode(new Error(`Failed to put value to enough peers: ${counterSuccess}/${minPeers}`), 'ERR_NOT_ENOUGH_PUT_PEERS')\n      log.error(error)\n      throw error\n    }\n  }\n\n  /**\n   * Get the value that corresponds to the passed key\n   *\n   * @param {Uint8Array} key\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.queryFuncTimeout]\n   */\n  async * get (key, options = {}) { // eslint-disable-line require-await\n    let queriedPeers = false\n    let foundValue = false\n\n    for await (const event of merge(\n      this._lan.get(key, options),\n      this._wan.get(key, options)\n    )) {\n      yield event\n\n      if (event.name === 'DIALING_PEER') {\n        queriedPeers = true\n      }\n\n      if (event.name === 'VALUE') {\n        queriedPeers = true\n\n        if (event.value != null) {\n          foundValue = true\n        }\n      }\n\n      if (event.name === 'SENDING_QUERY') {\n        queriedPeers = true\n      }\n    }\n\n    if (!queriedPeers) {\n      throw errCode(new Error('No peers found in routing table!'), 'ERR_NO_PEERS_IN_ROUTING_TABLE')\n    }\n\n    if (!foundValue) {\n      yield queryErrorEvent({\n        from: this._libp2p.peerId,\n        error: errCode(new Error('Not found'), 'ERR_NOT_FOUND')\n      })\n    }\n  }\n\n  // ----------- Content Routing\n\n  /**\n   * Announce to the network that we can provide given key's value\n   *\n   * @param {CID} key\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async * provide (key, options = {}) { // eslint-disable-line require-await\n    let sent = 0\n    let success = 0\n    const errors = []\n\n    const dhts = [this._lan]\n\n    // only run provide on the wan if we are in server mode\n    if (this._wan.isServer()) {\n      dhts.push(this._wan)\n    }\n\n    for await (const event of merge(...dhts.map(dht => dht.provide(key, options)))) {\n      yield event\n\n      if (event.name === 'SENDING_QUERY') {\n        sent++\n      }\n\n      if (event.name === 'QUERY_ERROR') {\n        errors.push(event.error)\n      }\n\n      if (event.name === 'PEER_RESPONSE' && event.messageName === 'ADD_PROVIDER') {\n        log('sent provider record for %s to %p', key, event.from.id)\n        success++\n      }\n    }\n\n    if (success === 0) {\n      if (errors.length) {\n        // if all sends failed, throw an error to inform the caller\n        throw errCode(new Error(`Failed to provide to ${errors.length} of ${sent} peers`), 'ERR_PROVIDES_FAILED', { errors })\n      }\n\n      throw errCode(new Error('Failed to provide - no peers found'), 'ERR_PROVIDES_FAILED')\n    }\n  }\n\n  /**\n   * Search the dht for up to `K` providers of the given CID.\n   *\n   * @param {CID} key\n   * @param {object} [options] - findProviders options\n   * @param {number} [options.maxNumProviders=5] - maximum number of providers to find\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.queryFuncTimeout]\n   */\n  async * findProviders (key, options = { maxNumProviders: 5 }) {\n    yield * merge(\n      this._lan.findProviders(key, options),\n      this._wan.findProviders(key, options)\n    )\n  }\n\n  // ----------- Peer Routing -----------\n\n  /**\n   * Search for a peer with the given ID\n   *\n   * @param {PeerId} id\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.queryFuncTimeout]\n   */\n  async * findPeer (id, options = {}) { // eslint-disable-line require-await\n    let queriedPeers = false\n\n    for await (const event of merge(\n      this._lan.findPeer(id, options),\n      this._wan.findPeer(id, options)\n    )) {\n      yield event\n\n      if (event.name === 'SENDING_QUERY' || event.name === 'FINAL_PEER') {\n        queriedPeers = true\n      }\n    }\n\n    if (!queriedPeers) {\n      throw errCode(new Error('Peer lookup failed'), 'ERR_LOOKUP_FAILED')\n    }\n  }\n\n  /**\n   * Kademlia 'node lookup' operation.\n   *\n   * @param {Uint8Array} key\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.queryFuncTimeout]\n   */\n  async * getClosestPeers (key, options = {}) {\n    yield * merge(\n      this._lan.getClosestPeers(key, options),\n      this._wan.getClosestPeers(key, options)\n    )\n  }\n\n  /**\n   * Get the public key for the given peer id\n   *\n   * @param {PeerId} peer\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async getPublicKey (peer, options = {}) {\n    log('getPublicKey %p', peer)\n\n    let peerData\n\n    // local check\n    try {\n      peerData = await this._libp2p.peerStore.get(peer)\n\n      if (peerData.pubKey) {\n        log('getPublicKey: found local copy')\n        return peerData.pubKey\n      }\n\n      if (peerData.id.pubKey) {\n        log('getPublicKey: found local copy')\n        return peerData.id.pubKey\n      }\n    } catch (/** @type {any} */ err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        throw err\n      }\n    }\n\n    // try the node directly\n    const pks = await Promise.all([\n      this._lan.getPublicKey(peer, options),\n      this._wan.getPublicKey(peer, options)\n    ])\n\n    if (pks[0] && pks[1] && !pks[0].equals(pks[1])) {\n      throw errCode(new Error('Inconsistent public key loaded from wan and lan DHTs'), 'ERR_FAILED_TO_LOAD_KEY')\n    }\n\n    const pk = pks[0] || pks[1]\n\n    if (!pk) {\n      throw errCode(new Error('Failed to load public key'), 'ERR_FAILED_TO_LOAD_KEY')\n    }\n\n    const peerId = new PeerId(peer.id, undefined, pk)\n    const addrs = ((peerData && peerData.addresses) || []).map((address) => address.multiaddr)\n    await this._libp2p.peerStore.addressBook.add(peerId, addrs)\n    await this._libp2p.peerStore.keyBook.set(peerId, pk)\n\n    return pk\n  }\n\n  async refreshRoutingTable () {\n    await Promise.all([\n      this._lan.refreshRoutingTable(),\n      this._wan.refreshRoutingTable()\n    ])\n  }\n}\n\nmodule.exports = {\n  DualKadDHT\n}\n"]},"metadata":{},"sourceType":"script"}