{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:upgrader'), {\n  error: debug('libp2p:upgrader:err')\n});\n\nconst errCode = require('err-code');\n\nconst Multistream = require('multistream-select');\n\nconst {\n  Connection\n} = require('libp2p-interfaces/src/connection');\n\nconst PeerId = require('peer-id');\n\nconst {\n  pipe\n} = require('it-pipe'); // @ts-ignore mutable-proxy does not export types\n\n\nconst mutableProxy = require('mutable-proxy');\n\nconst {\n  codes\n} = require('./errors');\n/**\n * @typedef {import('libp2p-interfaces/src/transport/types').MultiaddrConnection} MultiaddrConnection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxerFactory} MuxerFactory\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').Muxer} Muxer\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('libp2p-interfaces/src/crypto/types').Crypto} Crypto\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('./types').ConnectionGater} ConnectionGater\n */\n\n/**\n * @typedef CryptoResult\n * @property {MultiaddrConnection} conn A duplex iterable\n * @property {PeerId} remotePeer\n * @property {string} protocol\n */\n\n\nclass Upgrader {\n  /**\n   * @param {object} options\n   * @param {PeerId} options.localPeer\n   * @param {ConnectionGater} options.connectionGater\n   *\n   * @param {import('./metrics')} [options.metrics]\n   * @param {Map<string, Crypto>} [options.cryptos]\n   * @param {Map<string, MuxerFactory>} [options.muxers]\n   * @param {(connection: Connection) => void} options.onConnection - Called when a connection is upgraded\n   * @param {(connection: Connection) => void} options.onConnectionEnd\n   */\n  constructor(_ref) {\n    let {\n      localPeer,\n      metrics,\n      connectionGater,\n      cryptos = new Map(),\n      muxers = new Map(),\n      onConnectionEnd = () => {},\n      onConnection = () => {}\n    } = _ref;\n    this.connectionGater = connectionGater;\n    this.localPeer = localPeer;\n    this.metrics = metrics;\n    this.cryptos = cryptos;\n    this.muxers = muxers;\n    /** @type {import(\"./pnet\") | null} */\n\n    this.protector = null;\n    this.protocols = new Map();\n    this.onConnection = onConnection;\n    this.onConnectionEnd = onConnectionEnd;\n  }\n  /**\n   * Upgrades an inbound connection\n   *\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n\n\n  async upgradeInbound(maConn) {\n    let encryptedConn;\n    let remotePeer;\n    let upgradedConn;\n    let Muxer;\n    let cryptoProtocol;\n    let setPeer;\n    let proxyPeer;\n\n    if (await this.connectionGater.denyInboundConnection(maConn)) {\n      throw errCode(new Error('The multiaddr connection is blocked by gater.acceptConnection'), codes.ERR_CONNECTION_INTERCEPTED);\n    }\n\n    if (this.metrics) {\n      ({\n        setTarget: setPeer,\n        proxy: proxyPeer\n      } = mutableProxy());\n      const idString = (Math.random() * 1e9).toString(36) + Date.now();\n      setPeer({\n        toB58String: () => idString\n      });\n      maConn = this.metrics.trackStream({\n        stream: maConn,\n        remotePeer: proxyPeer\n      });\n    }\n\n    log('Starting the inbound connection upgrade'); // Protect\n\n    let protectedConn = maConn;\n\n    if (this.protector) {\n      protectedConn = await this.protector.protect(maConn);\n    }\n\n    try {\n      // Encrypt the connection\n      ({\n        conn: encryptedConn,\n        remotePeer,\n        protocol: cryptoProtocol\n      } = await this._encryptInbound(this.localPeer, protectedConn, this.cryptos));\n\n      if (await this.connectionGater.denyInboundEncryptedConnection(remotePeer, encryptedConn)) {\n        throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED);\n      } // Multiplex the connection\n\n\n      if (this.muxers.size) {\n        ({\n          stream: upgradedConn,\n          Muxer\n        } = await this._multiplexInbound(encryptedConn, this.muxers));\n      } else {\n        upgradedConn = encryptedConn;\n      }\n    } catch (\n    /** @type {any} */\n    err) {\n      log.error('Failed to upgrade inbound connection', err);\n      await maConn.close(err);\n      throw err;\n    }\n\n    if (await this.connectionGater.denyInboundUpgradedConnection(remotePeer, encryptedConn)) {\n      throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED);\n    }\n\n    if (this.metrics) {\n      this.metrics.updatePlaceholder(proxyPeer, remotePeer);\n      setPeer(remotePeer);\n    }\n\n    log('Successfully upgraded inbound connection');\n    return this._createConnection({\n      cryptoProtocol,\n      direction: 'inbound',\n      maConn,\n      upgradedConn,\n      Muxer,\n      remotePeer\n    });\n  }\n  /**\n   * Upgrades an outbound connection\n   *\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n\n\n  async upgradeOutbound(maConn) {\n    const idStr = maConn.remoteAddr.getPeerId();\n\n    if (!idStr) {\n      throw errCode(new Error('outbound connection must have a peer id'), codes.ERR_INVALID_MULTIADDR);\n    }\n\n    const remotePeerId = PeerId.createFromB58String(idStr);\n\n    if (await this.connectionGater.denyOutboundConnection(remotePeerId, maConn)) {\n      throw errCode(new Error('The multiaddr connection is blocked by connectionGater.denyOutboundConnection'), codes.ERR_CONNECTION_INTERCEPTED);\n    }\n\n    let encryptedConn;\n    let remotePeer;\n    let upgradedConn;\n    let cryptoProtocol;\n    let Muxer;\n    let setPeer;\n    let proxyPeer;\n\n    if (this.metrics) {\n      ({\n        setTarget: setPeer,\n        proxy: proxyPeer\n      } = mutableProxy());\n      const idString = (Math.random() * 1e9).toString(36) + Date.now();\n      setPeer({\n        toB58String: () => idString\n      });\n      maConn = this.metrics.trackStream({\n        stream: maConn,\n        remotePeer: proxyPeer\n      });\n    }\n\n    log('Starting the outbound connection upgrade'); // Protect\n\n    let protectedConn = maConn;\n\n    if (this.protector) {\n      protectedConn = await this.protector.protect(maConn);\n    }\n\n    try {\n      // Encrypt the connection\n      ({\n        conn: encryptedConn,\n        remotePeer,\n        protocol: cryptoProtocol\n      } = await this._encryptOutbound(this.localPeer, protectedConn, remotePeerId, this.cryptos));\n\n      if (await this.connectionGater.denyOutboundEncryptedConnection(remotePeer, encryptedConn)) {\n        throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED);\n      } // Multiplex the connection\n\n\n      if (this.muxers.size) {\n        ({\n          stream: upgradedConn,\n          Muxer\n        } = await this._multiplexOutbound(encryptedConn, this.muxers));\n      } else {\n        upgradedConn = encryptedConn;\n      }\n    } catch (\n    /** @type {any} */\n    err) {\n      log.error('Failed to upgrade outbound connection', err);\n      await maConn.close(err);\n      throw err;\n    }\n\n    if (await this.connectionGater.denyOutboundUpgradedConnection(remotePeer, encryptedConn)) {\n      throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED);\n    }\n\n    if (this.metrics) {\n      this.metrics.updatePlaceholder(proxyPeer, remotePeer);\n      setPeer(remotePeer);\n    }\n\n    log('Successfully upgraded outbound connection');\n    return this._createConnection({\n      cryptoProtocol,\n      direction: 'outbound',\n      maConn,\n      upgradedConn,\n      Muxer,\n      remotePeer\n    });\n  }\n  /**\n   * A convenience method for generating a new `Connection`\n   *\n   * @private\n   * @param {object} options\n   * @param {string} options.cryptoProtocol - The crypto protocol that was negotiated\n   * @param {'inbound' | 'outbound'} options.direction - One of ['inbound', 'outbound']\n   * @param {MultiaddrConnection} options.maConn - The transport layer connection\n   * @param {MuxedStream | MultiaddrConnection} options.upgradedConn - A duplex connection returned from multiplexer and/or crypto selection\n   * @param {MuxerFactory} [options.Muxer] - The muxer to be used for muxing\n   * @param {PeerId} options.remotePeer - The peer the connection is with\n   * @returns {Connection}\n   */\n\n\n  _createConnection(_ref2) {\n    var _this = this;\n\n    let {\n      cryptoProtocol,\n      direction,\n      maConn,\n      upgradedConn,\n      Muxer,\n      remotePeer\n    } = _ref2;\n\n    /** @type {import(\"libp2p-interfaces/src/stream-muxer/types\").Muxer} */\n    let muxer;\n    /** @type {import(\"libp2p-interfaces/src/connection/connection\").CreatedMuxedStream | undefined} */\n\n    let newStream;\n    /** @type {Connection} */\n\n    let connection; // eslint-disable-line prefer-const\n\n    if (Muxer) {\n      // Create the muxer\n      muxer = new Muxer({\n        // Run anytime a remote stream is created\n        onStream: async muxedStream => {\n          if (!connection) return;\n          const mss = new Multistream.Listener(muxedStream);\n\n          try {\n            const {\n              stream,\n              protocol\n            } = await mss.handle(Array.from(this.protocols.keys()));\n            log('%s: incoming stream opened on %s', direction, protocol);\n            if (this.metrics) this.metrics.trackStream({\n              stream,\n              remotePeer,\n              protocol\n            });\n            connection.addStream(muxedStream, {\n              protocol\n            });\n\n            this._onStream({\n              connection,\n              stream: { ...muxedStream,\n                ...stream\n              },\n              protocol\n            });\n          } catch (\n          /** @type {any} */\n          err) {\n            log.error(err);\n          }\n        },\n        // Run anytime a stream closes\n        onStreamEnd: muxedStream => {\n          connection.removeStream(muxedStream.id);\n        }\n      });\n\n      newStream = async protocols => {\n        log('%s: starting new stream on %s', direction, protocols);\n        const muxedStream = muxer.newStream();\n        const mss = new Multistream.Dialer(muxedStream);\n\n        try {\n          const {\n            stream,\n            protocol\n          } = await mss.select(protocols);\n          if (this.metrics) this.metrics.trackStream({\n            stream,\n            remotePeer,\n            protocol\n          });\n          return {\n            stream: { ...muxedStream,\n              ...stream\n            },\n            protocol\n          };\n        } catch (\n        /** @type {any} */\n        err) {\n          log.error('could not create new stream', err);\n          throw errCode(err, codes.ERR_UNSUPPORTED_PROTOCOL);\n        }\n      }; // Pipe all data through the muxer\n\n\n      pipe(upgradedConn, muxer, upgradedConn).catch(log.error);\n    }\n\n    const _timeline = maConn.timeline;\n    maConn.timeline = new Proxy(_timeline, {\n      set: function () {\n        if (connection && (arguments.length <= 1 ? undefined : arguments[1]) === 'close' && (arguments.length <= 2 ? undefined : arguments[2]) && !_timeline.close) {\n          // Wait for close to finish before notifying of the closure\n          (async () => {\n            try {\n              if (connection.stat.status === 'open') {\n                await connection.close();\n              }\n            } catch (\n            /** @type {any} */\n            err) {\n              log.error(err);\n            } finally {\n              _this.onConnectionEnd(connection);\n            }\n          })().catch(err => {\n            log.error(err);\n          });\n        }\n\n        return Reflect.set(...arguments);\n      }\n    });\n    maConn.timeline.upgraded = Date.now();\n\n    const errConnectionNotMultiplexed = () => {\n      throw errCode(new Error('connection is not multiplexed'), codes.ERR_CONNECTION_NOT_MULTIPLEXED);\n    }; // Create the connection\n\n\n    connection = new Connection({\n      localAddr: maConn.localAddr,\n      remoteAddr: maConn.remoteAddr,\n      localPeer: this.localPeer,\n      remotePeer: remotePeer,\n      stat: {\n        direction,\n        // @ts-ignore\n        timeline: maConn.timeline,\n        multiplexer: Muxer && Muxer.multicodec,\n        encryption: cryptoProtocol\n      },\n      newStream: newStream || errConnectionNotMultiplexed,\n      getStreams: () => muxer ? muxer.streams : errConnectionNotMultiplexed(),\n      close: async () => {\n        await maConn.close(); // Ensure remaining streams are aborted\n\n        if (muxer) {\n          muxer.streams.map(stream => stream.abort());\n        }\n      }\n    });\n    this.onConnection(connection);\n    return connection;\n  }\n  /**\n   * Routes incoming streams to the correct handler\n   *\n   * @private\n   * @param {object} options\n   * @param {Connection} options.connection - The connection the stream belongs to\n   * @param {MuxedStream} options.stream\n   * @param {string} options.protocol\n   */\n\n\n  _onStream(_ref3) {\n    let {\n      connection,\n      stream,\n      protocol\n    } = _ref3;\n    const handler = this.protocols.get(protocol);\n    handler({\n      connection,\n      stream,\n      protocol\n    });\n  }\n  /**\n   * Attempts to encrypt the incoming `connection` with the provided `cryptos`.\n   *\n   * @private\n   * @async\n   * @param {PeerId} localPeer - The initiators PeerId\n   * @param {*} connection\n   * @param {Map<string, Crypto>} cryptos\n   * @returns {Promise<CryptoResult>} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n   */\n\n\n  async _encryptInbound(localPeer, connection, cryptos) {\n    const mss = new Multistream.Listener(connection);\n    const protocols = Array.from(cryptos.keys());\n    log('handling inbound crypto protocol selection', protocols);\n\n    try {\n      const {\n        stream,\n        protocol\n      } = await mss.handle(protocols);\n      const crypto = cryptos.get(protocol);\n      log('encrypting inbound connection...');\n\n      if (!crypto) {\n        throw new Error(`no crypto module found for ${protocol}`);\n      }\n\n      return { ...(await crypto.secureInbound(localPeer, stream)),\n        protocol\n      };\n    } catch (\n    /** @type {any} */\n    err) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED);\n    }\n  }\n  /**\n   * Attempts to encrypt the given `connection` with the provided `cryptos`.\n   * The first `Crypto` module to succeed will be used\n   *\n   * @private\n   * @async\n   * @param {PeerId} localPeer - The initiators PeerId\n   * @param {MultiaddrConnection} connection\n   * @param {PeerId} remotePeerId\n   * @param {Map<string, Crypto>} cryptos\n   * @returns {Promise<CryptoResult>} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n   */\n\n\n  async _encryptOutbound(localPeer, connection, remotePeerId, cryptos) {\n    const mss = new Multistream.Dialer(connection);\n    const protocols = Array.from(cryptos.keys());\n    log('selecting outbound crypto protocol', protocols);\n\n    try {\n      const {\n        stream,\n        protocol\n      } = await mss.select(protocols);\n      const crypto = cryptos.get(protocol);\n      log('encrypting outbound connection to %j', remotePeerId);\n\n      if (!crypto) {\n        throw new Error(`no crypto module found for ${protocol}`);\n      }\n\n      return { ...(await crypto.secureOutbound(localPeer, stream, remotePeerId)),\n        protocol\n      };\n    } catch (\n    /** @type {any} */\n    err) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED);\n    }\n  }\n  /**\n   * Selects one of the given muxers via multistream-select. That\n   * muxer will be used for all future streams on the connection.\n   *\n   * @private\n   * @async\n   * @param {MultiaddrConnection} connection - A basic duplex connection to multiplex\n   * @param {Map<string, MuxerFactory>} muxers - The muxers to attempt multiplexing with\n   * @returns {Promise<{ stream: MuxedStream, Muxer?: MuxerFactory}>} A muxed connection\n   */\n\n\n  async _multiplexOutbound(connection, muxers) {\n    const dialer = new Multistream.Dialer(connection);\n    const protocols = Array.from(muxers.keys());\n    log('outbound selecting muxer %s', protocols);\n\n    try {\n      const {\n        stream,\n        protocol\n      } = await dialer.select(protocols);\n      log('%s selected as muxer protocol', protocol);\n      const Muxer = muxers.get(protocol);\n      return {\n        stream,\n        Muxer\n      };\n    } catch (\n    /** @type {any} */\n    err) {\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE);\n    }\n  }\n  /**\n   * Registers support for one of the given muxers via multistream-select. The\n   * selected muxer will be used for all future streams on the connection.\n   *\n   * @private\n   * @async\n   * @param {MultiaddrConnection} connection - A basic duplex connection to multiplex\n   * @param {Map<string, MuxerFactory>} muxers - The muxers to attempt multiplexing with\n   * @returns {Promise<{ stream: MuxedStream, Muxer?: MuxerFactory}>} A muxed connection\n   */\n\n\n  async _multiplexInbound(connection, muxers) {\n    const listener = new Multistream.Listener(connection);\n    const protocols = Array.from(muxers.keys());\n    log('inbound handling muxers %s', protocols);\n\n    try {\n      const {\n        stream,\n        protocol\n      } = await listener.handle(protocols);\n      const Muxer = muxers.get(protocol);\n      return {\n        stream,\n        Muxer\n      };\n    } catch (\n    /** @type {any} */\n    err) {\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE);\n    }\n  }\n\n}\n\nmodule.exports = Upgrader;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p/src/upgrader.js"],"names":["debug","require","log","Object","assign","error","errCode","Multistream","Connection","PeerId","pipe","mutableProxy","codes","Upgrader","constructor","localPeer","metrics","connectionGater","cryptos","Map","muxers","onConnectionEnd","onConnection","protector","protocols","upgradeInbound","maConn","encryptedConn","remotePeer","upgradedConn","Muxer","cryptoProtocol","setPeer","proxyPeer","denyInboundConnection","Error","ERR_CONNECTION_INTERCEPTED","setTarget","proxy","idString","Math","random","toString","Date","now","toB58String","trackStream","stream","protectedConn","protect","conn","protocol","_encryptInbound","denyInboundEncryptedConnection","size","_multiplexInbound","err","close","denyInboundUpgradedConnection","updatePlaceholder","_createConnection","direction","upgradeOutbound","idStr","remoteAddr","getPeerId","ERR_INVALID_MULTIADDR","remotePeerId","createFromB58String","denyOutboundConnection","_encryptOutbound","denyOutboundEncryptedConnection","_multiplexOutbound","denyOutboundUpgradedConnection","muxer","newStream","connection","onStream","muxedStream","mss","Listener","handle","Array","from","keys","addStream","_onStream","onStreamEnd","removeStream","id","Dialer","select","ERR_UNSUPPORTED_PROTOCOL","catch","_timeline","timeline","Proxy","set","stat","status","Reflect","upgraded","errConnectionNotMultiplexed","ERR_CONNECTION_NOT_MULTIPLEXED","localAddr","multiplexer","multicodec","encryption","getStreams","streams","map","abort","handler","get","crypto","secureInbound","ERR_ENCRYPTION_FAILED","secureOutbound","dialer","ERR_MUXER_UNAVAILABLE","listener","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:upgrader'), {\n  error: debug('libp2p:upgrader:err')\n})\nconst errCode = require('err-code')\nconst Multistream = require('multistream-select')\nconst { Connection } = require('libp2p-interfaces/src/connection')\nconst PeerId = require('peer-id')\nconst { pipe } = require('it-pipe')\n// @ts-ignore mutable-proxy does not export types\nconst mutableProxy = require('mutable-proxy')\n\nconst { codes } = require('./errors')\n\n/**\n * @typedef {import('libp2p-interfaces/src/transport/types').MultiaddrConnection} MultiaddrConnection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxerFactory} MuxerFactory\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').Muxer} Muxer\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('libp2p-interfaces/src/crypto/types').Crypto} Crypto\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('./types').ConnectionGater} ConnectionGater\n */\n\n/**\n * @typedef CryptoResult\n * @property {MultiaddrConnection} conn A duplex iterable\n * @property {PeerId} remotePeer\n * @property {string} protocol\n */\n\nclass Upgrader {\n  /**\n   * @param {object} options\n   * @param {PeerId} options.localPeer\n   * @param {ConnectionGater} options.connectionGater\n   *\n   * @param {import('./metrics')} [options.metrics]\n   * @param {Map<string, Crypto>} [options.cryptos]\n   * @param {Map<string, MuxerFactory>} [options.muxers]\n   * @param {(connection: Connection) => void} options.onConnection - Called when a connection is upgraded\n   * @param {(connection: Connection) => void} options.onConnectionEnd\n   */\n  constructor ({\n    localPeer,\n    metrics,\n    connectionGater,\n    cryptos = new Map(),\n    muxers = new Map(),\n    onConnectionEnd = () => {},\n    onConnection = () => {}\n  }) {\n    this.connectionGater = connectionGater\n    this.localPeer = localPeer\n    this.metrics = metrics\n    this.cryptos = cryptos\n    this.muxers = muxers\n    /** @type {import(\"./pnet\") | null} */\n    this.protector = null\n    this.protocols = new Map()\n    this.onConnection = onConnection\n    this.onConnectionEnd = onConnectionEnd\n  }\n\n  /**\n   * Upgrades an inbound connection\n   *\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n  async upgradeInbound (maConn) {\n    let encryptedConn\n    let remotePeer\n    let upgradedConn\n    let Muxer\n    let cryptoProtocol\n    let setPeer\n    let proxyPeer\n\n    if (await this.connectionGater.denyInboundConnection(maConn)) {\n      throw errCode(new Error('The multiaddr connection is blocked by gater.acceptConnection'), codes.ERR_CONNECTION_INTERCEPTED)\n    }\n\n    if (this.metrics) {\n      ({ setTarget: setPeer, proxy: proxyPeer } = mutableProxy())\n      const idString = (Math.random() * 1e9).toString(36) + Date.now()\n      setPeer({ toB58String: () => idString })\n      maConn = this.metrics.trackStream({ stream: maConn, remotePeer: proxyPeer })\n    }\n\n    log('Starting the inbound connection upgrade')\n\n    // Protect\n    let protectedConn = maConn\n    if (this.protector) {\n      protectedConn = await this.protector.protect(maConn)\n    }\n\n    try {\n      // Encrypt the connection\n      ({\n        conn: encryptedConn,\n        remotePeer,\n        protocol: cryptoProtocol\n      } = await this._encryptInbound(this.localPeer, protectedConn, this.cryptos))\n\n      if (await this.connectionGater.denyInboundEncryptedConnection(remotePeer, encryptedConn)) {\n        throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED)\n      }\n\n      // Multiplex the connection\n      if (this.muxers.size) {\n        ({ stream: upgradedConn, Muxer } = await this._multiplexInbound(encryptedConn, this.muxers))\n      } else {\n        upgradedConn = encryptedConn\n      }\n    } catch (/** @type {any} */ err) {\n      log.error('Failed to upgrade inbound connection', err)\n      await maConn.close(err)\n      throw err\n    }\n\n    if (await this.connectionGater.denyInboundUpgradedConnection(remotePeer, encryptedConn)) {\n      throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED)\n    }\n\n    if (this.metrics) {\n      this.metrics.updatePlaceholder(proxyPeer, remotePeer)\n      setPeer(remotePeer)\n    }\n\n    log('Successfully upgraded inbound connection')\n\n    return this._createConnection({\n      cryptoProtocol,\n      direction: 'inbound',\n      maConn,\n      upgradedConn,\n      Muxer,\n      remotePeer\n    })\n  }\n\n  /**\n   * Upgrades an outbound connection\n   *\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n  async upgradeOutbound (maConn) {\n    const idStr = maConn.remoteAddr.getPeerId()\n    if (!idStr) {\n      throw errCode(new Error('outbound connection must have a peer id'), codes.ERR_INVALID_MULTIADDR)\n    }\n\n    const remotePeerId = PeerId.createFromB58String(idStr)\n\n    if (await this.connectionGater.denyOutboundConnection(remotePeerId, maConn)) {\n      throw errCode(new Error('The multiaddr connection is blocked by connectionGater.denyOutboundConnection'), codes.ERR_CONNECTION_INTERCEPTED)\n    }\n\n    let encryptedConn\n    let remotePeer\n    let upgradedConn\n    let cryptoProtocol\n    let Muxer\n    let setPeer\n    let proxyPeer\n\n    if (this.metrics) {\n      ({ setTarget: setPeer, proxy: proxyPeer } = mutableProxy())\n      const idString = (Math.random() * 1e9).toString(36) + Date.now()\n      setPeer({ toB58String: () => idString })\n      maConn = this.metrics.trackStream({ stream: maConn, remotePeer: proxyPeer })\n    }\n\n    log('Starting the outbound connection upgrade')\n\n    // Protect\n    let protectedConn = maConn\n    if (this.protector) {\n      protectedConn = await this.protector.protect(maConn)\n    }\n\n    try {\n      // Encrypt the connection\n      ({\n        conn: encryptedConn,\n        remotePeer,\n        protocol: cryptoProtocol\n      } = await this._encryptOutbound(this.localPeer, protectedConn, remotePeerId, this.cryptos))\n\n      if (await this.connectionGater.denyOutboundEncryptedConnection(remotePeer, encryptedConn)) {\n        throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED)\n      }\n\n      // Multiplex the connection\n      if (this.muxers.size) {\n        ({ stream: upgradedConn, Muxer } = await this._multiplexOutbound(encryptedConn, this.muxers))\n      } else {\n        upgradedConn = encryptedConn\n      }\n    } catch (/** @type {any} */ err) {\n      log.error('Failed to upgrade outbound connection', err)\n      await maConn.close(err)\n      throw err\n    }\n\n    if (await this.connectionGater.denyOutboundUpgradedConnection(remotePeer, encryptedConn)) {\n      throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED)\n    }\n\n    if (this.metrics) {\n      this.metrics.updatePlaceholder(proxyPeer, remotePeer)\n      setPeer(remotePeer)\n    }\n\n    log('Successfully upgraded outbound connection')\n\n    return this._createConnection({\n      cryptoProtocol,\n      direction: 'outbound',\n      maConn,\n      upgradedConn,\n      Muxer,\n      remotePeer\n    })\n  }\n\n  /**\n   * A convenience method for generating a new `Connection`\n   *\n   * @private\n   * @param {object} options\n   * @param {string} options.cryptoProtocol - The crypto protocol that was negotiated\n   * @param {'inbound' | 'outbound'} options.direction - One of ['inbound', 'outbound']\n   * @param {MultiaddrConnection} options.maConn - The transport layer connection\n   * @param {MuxedStream | MultiaddrConnection} options.upgradedConn - A duplex connection returned from multiplexer and/or crypto selection\n   * @param {MuxerFactory} [options.Muxer] - The muxer to be used for muxing\n   * @param {PeerId} options.remotePeer - The peer the connection is with\n   * @returns {Connection}\n   */\n  _createConnection ({\n    cryptoProtocol,\n    direction,\n    maConn,\n    upgradedConn,\n    Muxer,\n    remotePeer\n  }) {\n    /** @type {import(\"libp2p-interfaces/src/stream-muxer/types\").Muxer} */\n    let muxer\n    /** @type {import(\"libp2p-interfaces/src/connection/connection\").CreatedMuxedStream | undefined} */\n    let newStream\n    /** @type {Connection} */\n    let connection // eslint-disable-line prefer-const\n\n    if (Muxer) {\n      // Create the muxer\n      muxer = new Muxer({\n        // Run anytime a remote stream is created\n        onStream: async muxedStream => {\n          if (!connection) return\n          const mss = new Multistream.Listener(muxedStream)\n          try {\n            const { stream, protocol } = await mss.handle(Array.from(this.protocols.keys()))\n            log('%s: incoming stream opened on %s', direction, protocol)\n            if (this.metrics) this.metrics.trackStream({ stream, remotePeer, protocol })\n            connection.addStream(muxedStream, { protocol })\n            this._onStream({ connection, stream: { ...muxedStream, ...stream }, protocol })\n          } catch (/** @type {any} */ err) {\n            log.error(err)\n          }\n        },\n        // Run anytime a stream closes\n        onStreamEnd: muxedStream => {\n          connection.removeStream(muxedStream.id)\n        }\n      })\n\n      newStream = async (protocols) => {\n        log('%s: starting new stream on %s', direction, protocols)\n        const muxedStream = muxer.newStream()\n        const mss = new Multistream.Dialer(muxedStream)\n        try {\n          const { stream, protocol } = await mss.select(protocols)\n          if (this.metrics) this.metrics.trackStream({ stream, remotePeer, protocol })\n          return { stream: { ...muxedStream, ...stream }, protocol }\n        } catch (/** @type {any} */ err) {\n          log.error('could not create new stream', err)\n          throw errCode(err, codes.ERR_UNSUPPORTED_PROTOCOL)\n        }\n      }\n\n      // Pipe all data through the muxer\n      pipe(upgradedConn, muxer, upgradedConn).catch(log.error)\n    }\n\n    const _timeline = maConn.timeline\n    maConn.timeline = new Proxy(_timeline, {\n      set: (...args) => {\n        if (connection && args[1] === 'close' && args[2] && !_timeline.close) {\n          // Wait for close to finish before notifying of the closure\n          (async () => {\n            try {\n              if (connection.stat.status === 'open') {\n                await connection.close()\n              }\n            } catch (/** @type {any} */ err) {\n              log.error(err)\n            } finally {\n              this.onConnectionEnd(connection)\n            }\n          })().catch(err => {\n            log.error(err)\n          })\n        }\n\n        return Reflect.set(...args)\n      }\n    })\n    maConn.timeline.upgraded = Date.now()\n\n    const errConnectionNotMultiplexed = () => {\n      throw errCode(new Error('connection is not multiplexed'), codes.ERR_CONNECTION_NOT_MULTIPLEXED)\n    }\n\n    // Create the connection\n    connection = new Connection({\n      localAddr: maConn.localAddr,\n      remoteAddr: maConn.remoteAddr,\n      localPeer: this.localPeer,\n      remotePeer: remotePeer,\n      stat: {\n        direction,\n        // @ts-ignore\n        timeline: maConn.timeline,\n        multiplexer: Muxer && Muxer.multicodec,\n        encryption: cryptoProtocol\n      },\n      newStream: newStream || errConnectionNotMultiplexed,\n      getStreams: () => muxer ? muxer.streams : errConnectionNotMultiplexed(),\n      close: async () => {\n        await maConn.close()\n        // Ensure remaining streams are aborted\n        if (muxer) {\n          muxer.streams.map(stream => stream.abort())\n        }\n      }\n    })\n\n    this.onConnection(connection)\n\n    return connection\n  }\n\n  /**\n   * Routes incoming streams to the correct handler\n   *\n   * @private\n   * @param {object} options\n   * @param {Connection} options.connection - The connection the stream belongs to\n   * @param {MuxedStream} options.stream\n   * @param {string} options.protocol\n   */\n  _onStream ({ connection, stream, protocol }) {\n    const handler = this.protocols.get(protocol)\n    handler({ connection, stream, protocol })\n  }\n\n  /**\n   * Attempts to encrypt the incoming `connection` with the provided `cryptos`.\n   *\n   * @private\n   * @async\n   * @param {PeerId} localPeer - The initiators PeerId\n   * @param {*} connection\n   * @param {Map<string, Crypto>} cryptos\n   * @returns {Promise<CryptoResult>} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n   */\n  async _encryptInbound (localPeer, connection, cryptos) {\n    const mss = new Multistream.Listener(connection)\n    const protocols = Array.from(cryptos.keys())\n    log('handling inbound crypto protocol selection', protocols)\n\n    try {\n      const { stream, protocol } = await mss.handle(protocols)\n      const crypto = cryptos.get(protocol)\n      log('encrypting inbound connection...')\n\n      if (!crypto) {\n        throw new Error(`no crypto module found for ${protocol}`)\n      }\n\n      return {\n        ...await crypto.secureInbound(localPeer, stream),\n        protocol\n      }\n    } catch (/** @type {any} */ err) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED)\n    }\n  }\n\n  /**\n   * Attempts to encrypt the given `connection` with the provided `cryptos`.\n   * The first `Crypto` module to succeed will be used\n   *\n   * @private\n   * @async\n   * @param {PeerId} localPeer - The initiators PeerId\n   * @param {MultiaddrConnection} connection\n   * @param {PeerId} remotePeerId\n   * @param {Map<string, Crypto>} cryptos\n   * @returns {Promise<CryptoResult>} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n   */\n  async _encryptOutbound (localPeer, connection, remotePeerId, cryptos) {\n    const mss = new Multistream.Dialer(connection)\n    const protocols = Array.from(cryptos.keys())\n    log('selecting outbound crypto protocol', protocols)\n\n    try {\n      const { stream, protocol } = await mss.select(protocols)\n      const crypto = cryptos.get(protocol)\n      log('encrypting outbound connection to %j', remotePeerId)\n\n      if (!crypto) {\n        throw new Error(`no crypto module found for ${protocol}`)\n      }\n\n      return {\n        ...await crypto.secureOutbound(localPeer, stream, remotePeerId),\n        protocol\n      }\n    } catch (/** @type {any} */ err) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED)\n    }\n  }\n\n  /**\n   * Selects one of the given muxers via multistream-select. That\n   * muxer will be used for all future streams on the connection.\n   *\n   * @private\n   * @async\n   * @param {MultiaddrConnection} connection - A basic duplex connection to multiplex\n   * @param {Map<string, MuxerFactory>} muxers - The muxers to attempt multiplexing with\n   * @returns {Promise<{ stream: MuxedStream, Muxer?: MuxerFactory}>} A muxed connection\n   */\n  async _multiplexOutbound (connection, muxers) {\n    const dialer = new Multistream.Dialer(connection)\n    const protocols = Array.from(muxers.keys())\n    log('outbound selecting muxer %s', protocols)\n    try {\n      const { stream, protocol } = await dialer.select(protocols)\n      log('%s selected as muxer protocol', protocol)\n      const Muxer = muxers.get(protocol)\n      return { stream, Muxer }\n    } catch (/** @type {any} */ err) {\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE)\n    }\n  }\n\n  /**\n   * Registers support for one of the given muxers via multistream-select. The\n   * selected muxer will be used for all future streams on the connection.\n   *\n   * @private\n   * @async\n   * @param {MultiaddrConnection} connection - A basic duplex connection to multiplex\n   * @param {Map<string, MuxerFactory>} muxers - The muxers to attempt multiplexing with\n   * @returns {Promise<{ stream: MuxedStream, Muxer?: MuxerFactory}>} A muxed connection\n   */\n  async _multiplexInbound (connection, muxers) {\n    const listener = new Multistream.Listener(connection)\n    const protocols = Array.from(muxers.keys())\n    log('inbound handling muxers %s', protocols)\n    try {\n      const { stream, protocol } = await listener.handle(protocols)\n      const Muxer = muxers.get(protocol)\n      return { stream, Muxer }\n    } catch (/** @type {any} */ err) {\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE)\n    }\n  }\n}\n\nmodule.exports = Upgrader\n"]},"metadata":{},"sourceType":"script"}