{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar withMfsRoot = require('./with-mfs-root.js');\n\nvar toPathComponents = require('./to-path-components.js');\n\nvar ipfsUnixfsExporter = require('ipfs-unixfs-exporter');\n\nvar errCode = require('err-code');\n\nvar cid = require('multiformats/cid');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\n\nconst IPFS_PREFIX = 'ipfs';\n\nconst toMfsPath = async (context, path, options) => {\n  const root = await withMfsRoot.loadMfsRoot(context, options);\n  let output = {\n    entryType: 'file'\n  };\n  let ipfsPath = '';\n\n  if (cid.CID.asCID(path)) {\n    ipfsPath = `/ipfs/${path}`;\n  } else {\n    ipfsPath = path.toString();\n  }\n\n  ipfsPath = ipfsPath.trim();\n  ipfsPath = ipfsPath.replace(/(\\/\\/+)/g, '/');\n\n  if (ipfsPath.endsWith('/') && ipfsPath.length > 1) {\n    ipfsPath = ipfsPath.substring(0, ipfsPath.length - 1);\n  }\n\n  if (!ipfsPath) {\n    throw errCode__default[\"default\"](new Error('paths must not be empty'), 'ERR_NO_PATH');\n  }\n\n  if (ipfsPath.substring(0, 1) !== '/') {\n    throw errCode__default[\"default\"](new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH');\n  }\n\n  if (ipfsPath.substring(ipfsPath.length - 1) === '/') {\n    ipfsPath = ipfsPath.substring(0, ipfsPath.length - 1);\n  }\n\n  const pathComponents = toPathComponents.toPathComponents(ipfsPath);\n\n  if (pathComponents[0] === IPFS_PREFIX) {\n    let mfsDirectory;\n\n    if (pathComponents.length === 2) {\n      mfsDirectory = `/${pathComponents.join('/')}`;\n    } else {\n      mfsDirectory = `/${pathComponents.slice(0, pathComponents.length - 1).join('/')}`;\n    }\n\n    output = {\n      type: 'ipfs',\n      depth: pathComponents.length - 2,\n      entryType: 'file',\n      mfsPath: `/${pathComponents.join('/')}`,\n      mfsDirectory,\n      parts: pathComponents,\n      path: `/${pathComponents.join('/')}`,\n      name: pathComponents[pathComponents.length - 1]\n    };\n  } else {\n    const mfsPath = `/${IPFS_PREFIX}/${root}${pathComponents.length ? '/' + pathComponents.join('/') : ''}`;\n    const mfsDirectory = `/${IPFS_PREFIX}/${root}/${pathComponents.slice(0, pathComponents.length - 1).join('/')}`;\n    output = {\n      type: 'mfs',\n      depth: pathComponents.length,\n      entryType: 'file',\n      mfsDirectory,\n      mfsPath,\n      parts: pathComponents,\n      path: `/${pathComponents.join('/')}`,\n      name: pathComponents[pathComponents.length - 1]\n    };\n  }\n\n  const cidPath = output.type === 'mfs' ? output.mfsPath : output.path;\n\n  try {\n    const res = await ipfsUnixfsExporter.exporter(cidPath, context.repo.blocks, options);\n    output.cid = res.cid;\n    output.mfsPath = `/ipfs/${res.path}`;\n    output.entryType = res.type;\n    output.content = res.content;\n\n    if ((output.entryType === 'file' || output.entryType === 'directory') && (res.type === 'file' || res.type === 'directory')) {\n      output.unixfs = res.unixfs;\n    }\n  } catch (err) {\n    if (err.code !== 'ERR_NOT_FOUND') {\n      throw err;\n    }\n  }\n\n  output.exists = Boolean(output.cid);\n  return output;\n};\n\nexports.toMfsPath = toMfsPath;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-core/cjs/src/components/files/utils/to-mfs-path.js"],"names":["Object","defineProperty","exports","value","withMfsRoot","require","toPathComponents","ipfsUnixfsExporter","errCode","cid","_interopDefaultLegacy","e","errCode__default","IPFS_PREFIX","toMfsPath","context","path","options","root","loadMfsRoot","output","entryType","ipfsPath","CID","asCID","toString","trim","replace","endsWith","length","substring","Error","pathComponents","mfsDirectory","join","slice","type","depth","mfsPath","parts","name","cidPath","res","exporter","repo","blocks","content","unixfs","err","code","exists","Boolean"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar withMfsRoot = require('./with-mfs-root.js');\nvar toPathComponents = require('./to-path-components.js');\nvar ipfsUnixfsExporter = require('ipfs-unixfs-exporter');\nvar errCode = require('err-code');\nvar cid = require('multiformats/cid');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\n\nconst IPFS_PREFIX = 'ipfs';\nconst toMfsPath = async (context, path, options) => {\n  const root = await withMfsRoot.loadMfsRoot(context, options);\n  let output = { entryType: 'file' };\n  let ipfsPath = '';\n  if (cid.CID.asCID(path)) {\n    ipfsPath = `/ipfs/${ path }`;\n  } else {\n    ipfsPath = path.toString();\n  }\n  ipfsPath = ipfsPath.trim();\n  ipfsPath = ipfsPath.replace(/(\\/\\/+)/g, '/');\n  if (ipfsPath.endsWith('/') && ipfsPath.length > 1) {\n    ipfsPath = ipfsPath.substring(0, ipfsPath.length - 1);\n  }\n  if (!ipfsPath) {\n    throw errCode__default[\"default\"](new Error('paths must not be empty'), 'ERR_NO_PATH');\n  }\n  if (ipfsPath.substring(0, 1) !== '/') {\n    throw errCode__default[\"default\"](new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH');\n  }\n  if (ipfsPath.substring(ipfsPath.length - 1) === '/') {\n    ipfsPath = ipfsPath.substring(0, ipfsPath.length - 1);\n  }\n  const pathComponents = toPathComponents.toPathComponents(ipfsPath);\n  if (pathComponents[0] === IPFS_PREFIX) {\n    let mfsDirectory;\n    if (pathComponents.length === 2) {\n      mfsDirectory = `/${ pathComponents.join('/') }`;\n    } else {\n      mfsDirectory = `/${ pathComponents.slice(0, pathComponents.length - 1).join('/') }`;\n    }\n    output = {\n      type: 'ipfs',\n      depth: pathComponents.length - 2,\n      entryType: 'file',\n      mfsPath: `/${ pathComponents.join('/') }`,\n      mfsDirectory,\n      parts: pathComponents,\n      path: `/${ pathComponents.join('/') }`,\n      name: pathComponents[pathComponents.length - 1]\n    };\n  } else {\n    const mfsPath = `/${ IPFS_PREFIX }/${ root }${ pathComponents.length ? '/' + pathComponents.join('/') : '' }`;\n    const mfsDirectory = `/${ IPFS_PREFIX }/${ root }/${ pathComponents.slice(0, pathComponents.length - 1).join('/') }`;\n    output = {\n      type: 'mfs',\n      depth: pathComponents.length,\n      entryType: 'file',\n      mfsDirectory,\n      mfsPath,\n      parts: pathComponents,\n      path: `/${ pathComponents.join('/') }`,\n      name: pathComponents[pathComponents.length - 1]\n    };\n  }\n  const cidPath = output.type === 'mfs' ? output.mfsPath : output.path;\n  try {\n    const res = await ipfsUnixfsExporter.exporter(cidPath, context.repo.blocks, options);\n    output.cid = res.cid;\n    output.mfsPath = `/ipfs/${ res.path }`;\n    output.entryType = res.type;\n    output.content = res.content;\n    if ((output.entryType === 'file' || output.entryType === 'directory') && (res.type === 'file' || res.type === 'directory')) {\n      output.unixfs = res.unixfs;\n    }\n  } catch (err) {\n    if (err.code !== 'ERR_NOT_FOUND') {\n      throw err;\n    }\n  }\n  output.exists = Boolean(output.cid);\n  return output;\n};\n\nexports.toMfsPath = toMfsPath;\n"]},"metadata":{},"sourceType":"script"}