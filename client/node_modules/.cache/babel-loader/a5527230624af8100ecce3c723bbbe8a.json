{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:identify'), {\n  error: debug('libp2p:identify:err')\n});\n\nconst errCode = require('err-code');\n\nconst lp = require('it-length-prefixed');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst {\n  collect,\n  take,\n  consume\n} = require('streaming-iterables');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst PeerId = require('peer-id');\n\nconst {\n  Multiaddr\n} = require('multiaddr'); // @ts-ignore it-buffer does not have types\n\n\nconst {\n  toBuffer\n} = require('it-buffer');\n\nconst Message = require('./message');\n\nconst Envelope = require('../record/envelope');\n\nconst PeerRecord = require('../record/peer-record');\n\nconst {\n  MULTICODEC_IDENTIFY,\n  MULTICODEC_IDENTIFY_PUSH,\n  IDENTIFY_PROTOCOL_VERSION,\n  MULTICODEC_IDENTIFY_PROTOCOL_NAME,\n  MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME,\n  MULTICODEC_IDENTIFY_PROTOCOL_VERSION,\n  MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION\n} = require('./consts');\n\nconst {\n  codes\n} = require('../errors');\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n */\n\n/**\n * @typedef {Object} HostProperties\n * @property {string} agentVersion\n */\n\n\nclass IdentifyService {\n  /**\n   * @param {import('../')} libp2p\n   */\n  static getProtocolStr(libp2p) {\n    return {\n      identifyProtocolStr: `/${libp2p._config.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`,\n      identifyPushProtocolStr: `/${libp2p._config.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`\n    };\n  }\n  /**\n   * @class\n   * @param {Object} options\n   * @param {import('../')} options.libp2p\n   */\n\n\n  constructor(_ref) {\n    let {\n      libp2p\n    } = _ref;\n    this._libp2p = libp2p;\n    this.peerStore = libp2p.peerStore;\n    this.addressManager = libp2p.addressManager;\n    this.connectionManager = libp2p.connectionManager;\n    this.peerId = libp2p.peerId;\n    this.handleMessage = this.handleMessage.bind(this);\n    const protocolStr = IdentifyService.getProtocolStr(libp2p);\n    this.identifyProtocolStr = protocolStr.identifyProtocolStr;\n    this.identifyPushProtocolStr = protocolStr.identifyPushProtocolStr; // Store self host metadata\n\n    this._host = {\n      protocolVersion: `${libp2p._config.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,\n      ...libp2p._options.host\n    }; // When a new connection happens, trigger identify\n\n    this.connectionManager.on('peer:connect', connection => {\n      this.identify(connection).catch(log.error);\n    }); // When self multiaddrs change, trigger identify-push\n\n    this.peerStore.on('change:multiaddrs', _ref2 => {\n      let {\n        peerId\n      } = _ref2;\n\n      if (peerId.toString() === this.peerId.toString()) {\n        this.pushToPeerStore().catch(err => log.error(err));\n      }\n    }); // When self protocols change, trigger identify-push\n\n    this.peerStore.on('change:protocols', _ref3 => {\n      let {\n        peerId\n      } = _ref3;\n\n      if (peerId.toString() === this.peerId.toString()) {\n        this.pushToPeerStore().catch(err => log.error(err));\n      }\n    });\n  }\n\n  async start() {\n    await this.peerStore.metadataBook.setValue(this.peerId, 'AgentVersion', uint8ArrayFromString(this._host.agentVersion));\n    await this.peerStore.metadataBook.setValue(this.peerId, 'ProtocolVersion', uint8ArrayFromString(this._host.protocolVersion));\n  }\n\n  async stop() {}\n  /**\n   * Send an Identify Push update to the list of connections\n   *\n   * @param {Connection[]} connections\n   * @returns {Promise<void[]>}\n   */\n\n\n  async push(connections) {\n    const signedPeerRecord = await this.peerStore.addressBook.getRawEnvelope(this.peerId);\n\n    const listenAddrs = this._libp2p.multiaddrs.map(ma => ma.bytes);\n\n    const protocols = await this.peerStore.protoBook.get(this.peerId);\n    const pushes = connections.map(async connection => {\n      try {\n        const {\n          stream\n        } = await connection.newStream(this.identifyPushProtocolStr);\n        await pipe([Message.Identify.encode({\n          listenAddrs,\n          signedPeerRecord,\n          protocols\n        }).finish()], lp.encode(), stream, consume);\n      } catch (\n      /** @type {any} */\n      err) {\n        // Just log errors\n        log.error('could not push identify update to peer', err);\n      }\n    });\n    return Promise.all(pushes);\n  }\n  /**\n   * Calls `push` for all peers in the `peerStore` that are connected\n   */\n\n\n  async pushToPeerStore() {\n    // Do not try to push if libp2p node is not running\n    if (!this._libp2p.isStarted()) {\n      return;\n    }\n\n    const connections = [];\n    let connection;\n\n    for await (const peer of this.peerStore.getPeers()) {\n      if (peer.protocols.includes(this.identifyPushProtocolStr) && (connection = this.connectionManager.get(peer.id))) {\n        connections.push(connection);\n      }\n    }\n\n    await this.push(connections);\n  }\n  /**\n   * Requests the `Identify` message from peer associated with the given `connection`.\n   * If the identified peer does not match the `PeerId` associated with the connection,\n   * an error will be thrown.\n   *\n   * @async\n   * @param {Connection} connection\n   * @returns {Promise<void>}\n   */\n\n\n  async identify(connection) {\n    const {\n      stream\n    } = await connection.newStream(this.identifyProtocolStr);\n    const [data] = await pipe([], stream, lp.decode(), take(1), toBuffer, collect);\n\n    if (!data) {\n      throw errCode(new Error('No data could be retrieved'), codes.ERR_CONNECTION_ENDED);\n    }\n\n    let message;\n\n    try {\n      message = Message.Identify.decode(data);\n    } catch (\n    /** @type {any} */\n    err) {\n      throw errCode(err, codes.ERR_INVALID_MESSAGE);\n    }\n\n    const {\n      publicKey,\n      listenAddrs,\n      protocols,\n      observedAddr,\n      signedPeerRecord\n    } = message;\n    const id = await PeerId.createFromPubKey(publicKey);\n\n    if (connection.remotePeer.toB58String() !== id.toB58String()) {\n      throw errCode(new Error('identified peer does not match the expected peer'), codes.ERR_INVALID_PEER);\n    } // Get the observedAddr if there is one\n\n\n    const cleanObservedAddr = IdentifyService.getCleanMultiaddr(observedAddr);\n\n    try {\n      const envelope = await Envelope.openAndCertify(signedPeerRecord, PeerRecord.DOMAIN);\n\n      if (await this.peerStore.addressBook.consumePeerRecord(envelope)) {\n        await this.peerStore.protoBook.set(id, protocols);\n        await this.peerStore.metadataBook.setValue(id, 'AgentVersion', uint8ArrayFromString(message.agentVersion));\n        await this.peerStore.metadataBook.setValue(id, 'ProtocolVersion', uint8ArrayFromString(message.protocolVersion));\n        return;\n      }\n    } catch (\n    /** @type {any} */\n    err) {\n      log('received invalid envelope, discard it and fallback to listenAddrs is available', err);\n    } // LEGACY: Update peers data in PeerStore\n\n\n    try {\n      await this.peerStore.addressBook.set(id, listenAddrs.map(addr => new Multiaddr(addr)));\n    } catch (\n    /** @type {any} */\n    err) {\n      log.error('received invalid addrs', err);\n    }\n\n    await this.peerStore.protoBook.set(id, protocols);\n    await this.peerStore.metadataBook.setValue(id, 'AgentVersion', uint8ArrayFromString(message.agentVersion));\n    await this.peerStore.metadataBook.setValue(id, 'ProtocolVersion', uint8ArrayFromString(message.protocolVersion)); // TODO: Add and score our observed addr\n\n    log('received observed address of %s', cleanObservedAddr); // this.addressManager.addObservedAddr(observedAddr)\n  }\n  /**\n   * A handler to register with Libp2p to process identify messages.\n   *\n   * @param {Object} options\n   * @param {Connection} options.connection\n   * @param {MuxedStream} options.stream\n   * @param {string} options.protocol\n   * @returns {Promise<void>|undefined}\n   */\n\n\n  handleMessage(_ref4) {\n    let {\n      connection,\n      stream,\n      protocol\n    } = _ref4;\n\n    switch (protocol) {\n      case this.identifyProtocolStr:\n        return this._handleIdentify({\n          connection,\n          stream\n        });\n\n      case this.identifyPushProtocolStr:\n        return this._handlePush({\n          connection,\n          stream\n        });\n\n      default:\n        log.error('cannot handle unknown protocol %s', protocol);\n    }\n  }\n  /**\n   * Sends the `Identify` response with the Signed Peer Record\n   * to the requesting peer over the given `connection`\n   *\n   * @private\n   * @param {Object} options\n   * @param {MuxedStream} options.stream\n   * @param {Connection} options.connection\n   * @returns {Promise<void>}\n   */\n\n\n  async _handleIdentify(_ref5) {\n    let {\n      connection,\n      stream\n    } = _ref5;\n\n    try {\n      let publicKey = new Uint8Array(0);\n\n      if (this.peerId.pubKey) {\n        publicKey = this.peerId.pubKey.bytes;\n      }\n\n      const signedPeerRecord = await this.peerStore.addressBook.getRawEnvelope(this.peerId);\n      const protocols = await this.peerStore.protoBook.get(this.peerId);\n      const message = Message.Identify.encode({\n        protocolVersion: this._host.protocolVersion,\n        agentVersion: this._host.agentVersion,\n        publicKey,\n        listenAddrs: this._libp2p.multiaddrs.map(ma => ma.bytes),\n        signedPeerRecord,\n        observedAddr: connection.remoteAddr.bytes,\n        protocols\n      }).finish();\n      await pipe([message], lp.encode(), stream, consume);\n    } catch (\n    /** @type {any} */\n    err) {\n      log.error('could not respond to identify request', err);\n    }\n  }\n  /**\n   * Reads the Identify Push message from the given `connection`\n   *\n   * @private\n   * @param {object} options\n   * @param {MuxedStream} options.stream\n   * @param {Connection} options.connection\n   * @returns {Promise<void>}\n   */\n\n\n  async _handlePush(_ref6) {\n    let {\n      connection,\n      stream\n    } = _ref6;\n    let message;\n\n    try {\n      const [data] = await pipe([], stream, lp.decode(), take(1), toBuffer, collect);\n      message = Message.Identify.decode(data);\n    } catch (\n    /** @type {any} */\n    err) {\n      return log.error('received invalid message', err);\n    }\n\n    const id = connection.remotePeer;\n\n    try {\n      const envelope = await Envelope.openAndCertify(message.signedPeerRecord, PeerRecord.DOMAIN);\n\n      if (await this.peerStore.addressBook.consumePeerRecord(envelope)) {\n        await this.peerStore.protoBook.set(id, message.protocols);\n        return;\n      }\n    } catch (\n    /** @type {any} */\n    err) {\n      log('received invalid envelope, discard it and fallback to listenAddrs is available', err);\n    } // LEGACY: Update peers data in PeerStore\n\n\n    try {\n      await this.peerStore.addressBook.set(id, message.listenAddrs.map(addr => new Multiaddr(addr)));\n    } catch (\n    /** @type {any} */\n    err) {\n      log.error('received invalid addrs', err);\n    } // Update the protocols\n\n\n    try {\n      await this.peerStore.protoBook.set(id, message.protocols);\n    } catch (\n    /** @type {any} */\n    err) {\n      log.error('received invalid protocols', err);\n    }\n  }\n  /**\n   * Takes the `addr` and converts it to a Multiaddr if possible\n   *\n   * @param {Uint8Array | string} addr\n   * @returns {Multiaddr|null}\n   */\n\n\n  static getCleanMultiaddr(addr) {\n    if (addr && addr.length > 0) {\n      try {\n        return new Multiaddr(addr);\n      } catch (_) {\n        return null;\n      }\n    }\n\n    return null;\n  }\n\n}\n/**\n * The protocols the IdentifyService supports\n *\n * @property multicodecs\n */\n\n\nconst multicodecs = {\n  IDENTIFY: MULTICODEC_IDENTIFY,\n  IDENTIFY_PUSH: MULTICODEC_IDENTIFY_PUSH\n};\nIdentifyService.multicodecs = multicodecs;\nIdentifyService.Messsage = Message;\nmodule.exports = IdentifyService;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p/src/identify/index.js"],"names":["debug","require","log","Object","assign","error","errCode","lp","pipe","collect","take","consume","fromString","uint8ArrayFromString","PeerId","Multiaddr","toBuffer","Message","Envelope","PeerRecord","MULTICODEC_IDENTIFY","MULTICODEC_IDENTIFY_PUSH","IDENTIFY_PROTOCOL_VERSION","MULTICODEC_IDENTIFY_PROTOCOL_NAME","MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME","MULTICODEC_IDENTIFY_PROTOCOL_VERSION","MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION","codes","IdentifyService","getProtocolStr","libp2p","identifyProtocolStr","_config","protocolPrefix","identifyPushProtocolStr","constructor","_libp2p","peerStore","addressManager","connectionManager","peerId","handleMessage","bind","protocolStr","_host","protocolVersion","_options","host","on","connection","identify","catch","toString","pushToPeerStore","err","start","metadataBook","setValue","agentVersion","stop","push","connections","signedPeerRecord","addressBook","getRawEnvelope","listenAddrs","multiaddrs","map","ma","bytes","protocols","protoBook","get","pushes","stream","newStream","Identify","encode","finish","Promise","all","isStarted","peer","getPeers","includes","id","data","decode","Error","ERR_CONNECTION_ENDED","message","ERR_INVALID_MESSAGE","publicKey","observedAddr","createFromPubKey","remotePeer","toB58String","ERR_INVALID_PEER","cleanObservedAddr","getCleanMultiaddr","envelope","openAndCertify","DOMAIN","consumePeerRecord","set","addr","protocol","_handleIdentify","_handlePush","Uint8Array","pubKey","remoteAddr","length","_","multicodecs","IDENTIFY","IDENTIFY_PUSH","Messsage","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMC,GAAG,GAAGC,MAAM,CAACC,MAAP,CAAcJ,KAAK,CAAC,iBAAD,CAAnB,EAAwC;AAClDK,EAAAA,KAAK,EAAEL,KAAK,CAAC,qBAAD;AADsC,CAAxC,CAAZ;;AAGA,MAAMM,OAAO,GAAGL,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAMM,EAAE,GAAGN,OAAO,CAAC,oBAAD,CAAlB;;AACA,MAAM;AAAEO,EAAAA;AAAF,IAAWP,OAAO,CAAC,SAAD,CAAxB;;AACA,MAAM;AAAEQ,EAAAA,OAAF;AAAWC,EAAAA,IAAX;AAAiBC,EAAAA;AAAjB,IAA6BV,OAAO,CAAC,qBAAD,CAA1C;;AACA,MAAM;AAAEW,EAAAA,UAAU,EAAEC;AAAd,IAAuCZ,OAAO,CAAC,yBAAD,CAApD;;AAEA,MAAMa,MAAM,GAAGb,OAAO,CAAC,SAAD,CAAtB;;AACA,MAAM;AAAEc,EAAAA;AAAF,IAAgBd,OAAO,CAAC,WAAD,CAA7B,C,CACA;;;AACA,MAAM;AAAEe,EAAAA;AAAF,IAAef,OAAO,CAAC,WAAD,CAA5B;;AAEA,MAAMgB,OAAO,GAAGhB,OAAO,CAAC,WAAD,CAAvB;;AAEA,MAAMiB,QAAQ,GAAGjB,OAAO,CAAC,oBAAD,CAAxB;;AACA,MAAMkB,UAAU,GAAGlB,OAAO,CAAC,uBAAD,CAA1B;;AAEA,MAAM;AACJmB,EAAAA,mBADI;AAEJC,EAAAA,wBAFI;AAGJC,EAAAA,yBAHI;AAIJC,EAAAA,iCAJI;AAKJC,EAAAA,sCALI;AAMJC,EAAAA,oCANI;AAOJC,EAAAA;AAPI,IAQFzB,OAAO,CAAC,UAAD,CARX;;AAUA,MAAM;AAAE0B,EAAAA;AAAF,IAAY1B,OAAO,CAAC,WAAD,CAAzB;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAEA,MAAM2B,eAAN,CAAsB;AACpB;AACF;AACA;AACuB,SAAdC,cAAc,CAAEC,MAAF,EAAU;AAC7B,WAAO;AACLC,MAAAA,mBAAmB,EAAG,IAAGD,MAAM,CAACE,OAAP,CAAeC,cAAe,IAAGV,iCAAkC,IAAGE,oCAAqC,EAD/H;AAELS,MAAAA,uBAAuB,EAAG,IAAGJ,MAAM,CAACE,OAAP,CAAeC,cAAe,IAAGT,sCAAuC,IAAGE,yCAA0C;AAF7I,KAAP;AAID;AAED;AACF;AACA;AACA;AACA;;;AACES,EAAAA,WAAW,OAAc;AAAA,QAAZ;AAAEL,MAAAA;AAAF,KAAY;AACvB,SAAKM,OAAL,GAAeN,MAAf;AACA,SAAKO,SAAL,GAAiBP,MAAM,CAACO,SAAxB;AACA,SAAKC,cAAL,GAAsBR,MAAM,CAACQ,cAA7B;AACA,SAAKC,iBAAL,GAAyBT,MAAM,CAACS,iBAAhC;AACA,SAAKC,MAAL,GAAcV,MAAM,CAACU,MAArB;AAEA,SAAKC,aAAL,GAAqB,KAAKA,aAAL,CAAmBC,IAAnB,CAAwB,IAAxB,CAArB;AAEA,UAAMC,WAAW,GAAGf,eAAe,CAACC,cAAhB,CAA+BC,MAA/B,CAApB;AACA,SAAKC,mBAAL,GAA2BY,WAAW,CAACZ,mBAAvC;AACA,SAAKG,uBAAL,GAA+BS,WAAW,CAACT,uBAA3C,CAXuB,CAavB;;AACA,SAAKU,KAAL,GAAa;AACXC,MAAAA,eAAe,EAAG,GAAEf,MAAM,CAACE,OAAP,CAAeC,cAAe,IAAGX,yBAA0B,EADpE;AAEX,SAAGQ,MAAM,CAACgB,QAAP,CAAgBC;AAFR,KAAb,CAduB,CAmBvB;;AACA,SAAKR,iBAAL,CAAuBS,EAAvB,CAA0B,cAA1B,EAA2CC,UAAD,IAAgB;AACxD,WAAKC,QAAL,CAAcD,UAAd,EAA0BE,KAA1B,CAAgCjD,GAAG,CAACG,KAApC;AACD,KAFD,EApBuB,CAwBvB;;AACA,SAAKgC,SAAL,CAAeW,EAAf,CAAkB,mBAAlB,EAAuC,SAAgB;AAAA,UAAf;AAAER,QAAAA;AAAF,OAAe;;AACrD,UAAIA,MAAM,CAACY,QAAP,OAAsB,KAAKZ,MAAL,CAAYY,QAAZ,EAA1B,EAAkD;AAChD,aAAKC,eAAL,GAAuBF,KAAvB,CAA6BG,GAAG,IAAIpD,GAAG,CAACG,KAAJ,CAAUiD,GAAV,CAApC;AACD;AACF,KAJD,EAzBuB,CA+BvB;;AACA,SAAKjB,SAAL,CAAeW,EAAf,CAAkB,kBAAlB,EAAsC,SAAgB;AAAA,UAAf;AAAER,QAAAA;AAAF,OAAe;;AACpD,UAAIA,MAAM,CAACY,QAAP,OAAsB,KAAKZ,MAAL,CAAYY,QAAZ,EAA1B,EAAkD;AAChD,aAAKC,eAAL,GAAuBF,KAAvB,CAA6BG,GAAG,IAAIpD,GAAG,CAACG,KAAJ,CAAUiD,GAAV,CAApC;AACD;AACF,KAJD;AAKD;;AAEU,QAALC,KAAK,GAAI;AACb,UAAM,KAAKlB,SAAL,CAAemB,YAAf,CAA4BC,QAA5B,CAAqC,KAAKjB,MAA1C,EAAkD,cAAlD,EAAkE3B,oBAAoB,CAAC,KAAK+B,KAAL,CAAWc,YAAZ,CAAtF,CAAN;AACA,UAAM,KAAKrB,SAAL,CAAemB,YAAf,CAA4BC,QAA5B,CAAqC,KAAKjB,MAA1C,EAAkD,iBAAlD,EAAqE3B,oBAAoB,CAAC,KAAK+B,KAAL,CAAWC,eAAZ,CAAzF,CAAN;AACD;;AAES,QAAJc,IAAI,GAAI,CAEb;AAED;AACF;AACA;AACA;AACA;AACA;;;AACY,QAAJC,IAAI,CAAEC,WAAF,EAAe;AACvB,UAAMC,gBAAgB,GAAG,MAAM,KAAKzB,SAAL,CAAe0B,WAAf,CAA2BC,cAA3B,CAA0C,KAAKxB,MAA/C,CAA/B;;AACA,UAAMyB,WAAW,GAAG,KAAK7B,OAAL,CAAa8B,UAAb,CAAwBC,GAAxB,CAA6BC,EAAD,IAAQA,EAAE,CAACC,KAAvC,CAApB;;AACA,UAAMC,SAAS,GAAG,MAAM,KAAKjC,SAAL,CAAekC,SAAf,CAAyBC,GAAzB,CAA6B,KAAKhC,MAAlC,CAAxB;AAEA,UAAMiC,MAAM,GAAGZ,WAAW,CAACM,GAAZ,CAAgB,MAAMlB,UAAN,IAAoB;AACjD,UAAI;AACF,cAAM;AAAEyB,UAAAA;AAAF,YAAa,MAAMzB,UAAU,CAAC0B,SAAX,CAAqB,KAAKzC,uBAA1B,CAAzB;AAEA,cAAM1B,IAAI,CACR,CAACS,OAAO,CAAC2D,QAAR,CAAiBC,MAAjB,CAAwB;AACvBZ,UAAAA,WADuB;AAEvBH,UAAAA,gBAFuB;AAGvBQ,UAAAA;AAHuB,SAAxB,EAIEQ,MAJF,EAAD,CADQ,EAMRvE,EAAE,CAACsE,MAAH,EANQ,EAORH,MAPQ,EAQR/D,OARQ,CAAV;AAUD,OAbD,CAaE;AAAO;AAAmB2C,MAAAA,GAA1B,EAA+B;AAC/B;AACApD,QAAAA,GAAG,CAACG,KAAJ,CAAU,wCAAV,EAAoDiD,GAApD;AACD;AACF,KAlBc,CAAf;AAoBA,WAAOyB,OAAO,CAACC,GAAR,CAAYP,MAAZ,CAAP;AACD;AAED;AACF;AACA;;;AACuB,QAAfpB,eAAe,GAAI;AACvB;AACA,QAAI,CAAC,KAAKjB,OAAL,CAAa6C,SAAb,EAAL,EAA+B;AAC7B;AACD;;AAED,UAAMpB,WAAW,GAAG,EAApB;AACA,QAAIZ,UAAJ;;AACA,eAAW,MAAMiC,IAAjB,IAAyB,KAAK7C,SAAL,CAAe8C,QAAf,EAAzB,EAAoD;AAClD,UAAID,IAAI,CAACZ,SAAL,CAAec,QAAf,CAAwB,KAAKlD,uBAA7B,MAA0De,UAAU,GAAG,KAAKV,iBAAL,CAAuBiC,GAAvB,CAA2BU,IAAI,CAACG,EAAhC,CAAvE,CAAJ,EAAiH;AAC/GxB,QAAAA,WAAW,CAACD,IAAZ,CAAiBX,UAAjB;AACD;AACF;;AAED,UAAM,KAAKW,IAAL,CAAUC,WAAV,CAAN;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACgB,QAARX,QAAQ,CAAED,UAAF,EAAc;AAC1B,UAAM;AAAEyB,MAAAA;AAAF,QAAa,MAAMzB,UAAU,CAAC0B,SAAX,CAAqB,KAAK5C,mBAA1B,CAAzB;AACA,UAAM,CAACuD,IAAD,IAAS,MAAM9E,IAAI,CACvB,EADuB,EAEvBkE,MAFuB,EAGvBnE,EAAE,CAACgF,MAAH,EAHuB,EAIvB7E,IAAI,CAAC,CAAD,CAJmB,EAKvBM,QALuB,EAMvBP,OANuB,CAAzB;;AASA,QAAI,CAAC6E,IAAL,EAAW;AACT,YAAMhF,OAAO,CAAC,IAAIkF,KAAJ,CAAU,4BAAV,CAAD,EAA0C7D,KAAK,CAAC8D,oBAAhD,CAAb;AACD;;AAED,QAAIC,OAAJ;;AACA,QAAI;AACFA,MAAAA,OAAO,GAAGzE,OAAO,CAAC2D,QAAR,CAAiBW,MAAjB,CAAwBD,IAAxB,CAAV;AACD,KAFD,CAEE;AAAO;AAAmBhC,IAAAA,GAA1B,EAA+B;AAC/B,YAAMhD,OAAO,CAACgD,GAAD,EAAM3B,KAAK,CAACgE,mBAAZ,CAAb;AACD;;AAED,UAAM;AACJC,MAAAA,SADI;AAEJ3B,MAAAA,WAFI;AAGJK,MAAAA,SAHI;AAIJuB,MAAAA,YAJI;AAKJ/B,MAAAA;AALI,QAMF4B,OANJ;AAQA,UAAML,EAAE,GAAG,MAAMvE,MAAM,CAACgF,gBAAP,CAAwBF,SAAxB,CAAjB;;AAEA,QAAI3C,UAAU,CAAC8C,UAAX,CAAsBC,WAAtB,OAAwCX,EAAE,CAACW,WAAH,EAA5C,EAA8D;AAC5D,YAAM1F,OAAO,CAAC,IAAIkF,KAAJ,CAAU,kDAAV,CAAD,EAAgE7D,KAAK,CAACsE,gBAAtE,CAAb;AACD,KAlCyB,CAoC1B;;;AACA,UAAMC,iBAAiB,GAAGtE,eAAe,CAACuE,iBAAhB,CAAkCN,YAAlC,CAA1B;;AAEA,QAAI;AACF,YAAMO,QAAQ,GAAG,MAAMlF,QAAQ,CAACmF,cAAT,CAAwBvC,gBAAxB,EAA0C3C,UAAU,CAACmF,MAArD,CAAvB;;AACA,UAAI,MAAM,KAAKjE,SAAL,CAAe0B,WAAf,CAA2BwC,iBAA3B,CAA6CH,QAA7C,CAAV,EAAkE;AAChE,cAAM,KAAK/D,SAAL,CAAekC,SAAf,CAAyBiC,GAAzB,CAA6BnB,EAA7B,EAAiCf,SAAjC,CAAN;AACA,cAAM,KAAKjC,SAAL,CAAemB,YAAf,CAA4BC,QAA5B,CAAqC4B,EAArC,EAAyC,cAAzC,EAAyDxE,oBAAoB,CAAC6E,OAAO,CAAChC,YAAT,CAA7E,CAAN;AACA,cAAM,KAAKrB,SAAL,CAAemB,YAAf,CAA4BC,QAA5B,CAAqC4B,EAArC,EAAyC,iBAAzC,EAA4DxE,oBAAoB,CAAC6E,OAAO,CAAC7C,eAAT,CAAhF,CAAN;AACA;AACD;AACF,KARD,CAQE;AAAO;AAAmBS,IAAAA,GAA1B,EAA+B;AAC/BpD,MAAAA,GAAG,CAAC,gFAAD,EAAmFoD,GAAnF,CAAH;AACD,KAjDyB,CAmD1B;;;AACA,QAAI;AACF,YAAM,KAAKjB,SAAL,CAAe0B,WAAf,CAA2ByC,GAA3B,CAA+BnB,EAA/B,EAAmCpB,WAAW,CAACE,GAAZ,CAAiBsC,IAAD,IAAU,IAAI1F,SAAJ,CAAc0F,IAAd,CAA1B,CAAnC,CAAN;AACD,KAFD,CAEE;AAAO;AAAmBnD,IAAAA,GAA1B,EAA+B;AAC/BpD,MAAAA,GAAG,CAACG,KAAJ,CAAU,wBAAV,EAAoCiD,GAApC;AACD;;AAED,UAAM,KAAKjB,SAAL,CAAekC,SAAf,CAAyBiC,GAAzB,CAA6BnB,EAA7B,EAAiCf,SAAjC,CAAN;AACA,UAAM,KAAKjC,SAAL,CAAemB,YAAf,CAA4BC,QAA5B,CAAqC4B,EAArC,EAAyC,cAAzC,EAAyDxE,oBAAoB,CAAC6E,OAAO,CAAChC,YAAT,CAA7E,CAAN;AACA,UAAM,KAAKrB,SAAL,CAAemB,YAAf,CAA4BC,QAA5B,CAAqC4B,EAArC,EAAyC,iBAAzC,EAA4DxE,oBAAoB,CAAC6E,OAAO,CAAC7C,eAAT,CAAhF,CAAN,CA5D0B,CA8D1B;;AACA3C,IAAAA,GAAG,CAAC,iCAAD,EAAoCgG,iBAApC,CAAH,CA/D0B,CAgE1B;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEzD,EAAAA,aAAa,QAAoC;AAAA,QAAlC;AAAEQ,MAAAA,UAAF;AAAcyB,MAAAA,MAAd;AAAsBgC,MAAAA;AAAtB,KAAkC;;AAC/C,YAAQA,QAAR;AACE,WAAK,KAAK3E,mBAAV;AACE,eAAO,KAAK4E,eAAL,CAAqB;AAAE1D,UAAAA,UAAF;AAAcyB,UAAAA;AAAd,SAArB,CAAP;;AACF,WAAK,KAAKxC,uBAAV;AACE,eAAO,KAAK0E,WAAL,CAAiB;AAAE3D,UAAAA,UAAF;AAAcyB,UAAAA;AAAd,SAAjB,CAAP;;AACF;AACExE,QAAAA,GAAG,CAACG,KAAJ,CAAU,mCAAV,EAA+CqG,QAA/C;AANJ;AAQD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACuB,QAAfC,eAAe,QAA0B;AAAA,QAAxB;AAAE1D,MAAAA,UAAF;AAAcyB,MAAAA;AAAd,KAAwB;;AAC7C,QAAI;AACF,UAAIkB,SAAS,GAAG,IAAIiB,UAAJ,CAAe,CAAf,CAAhB;;AACA,UAAI,KAAKrE,MAAL,CAAYsE,MAAhB,EAAwB;AACtBlB,QAAAA,SAAS,GAAG,KAAKpD,MAAL,CAAYsE,MAAZ,CAAmBzC,KAA/B;AACD;;AAED,YAAMP,gBAAgB,GAAG,MAAM,KAAKzB,SAAL,CAAe0B,WAAf,CAA2BC,cAA3B,CAA0C,KAAKxB,MAA/C,CAA/B;AACA,YAAM8B,SAAS,GAAG,MAAM,KAAKjC,SAAL,CAAekC,SAAf,CAAyBC,GAAzB,CAA6B,KAAKhC,MAAlC,CAAxB;AAEA,YAAMkD,OAAO,GAAGzE,OAAO,CAAC2D,QAAR,CAAiBC,MAAjB,CAAwB;AACtChC,QAAAA,eAAe,EAAE,KAAKD,KAAL,CAAWC,eADU;AAEtCa,QAAAA,YAAY,EAAE,KAAKd,KAAL,CAAWc,YAFa;AAGtCkC,QAAAA,SAHsC;AAItC3B,QAAAA,WAAW,EAAE,KAAK7B,OAAL,CAAa8B,UAAb,CAAwBC,GAAxB,CAA6BC,EAAD,IAAQA,EAAE,CAACC,KAAvC,CAJyB;AAKtCP,QAAAA,gBALsC;AAMtC+B,QAAAA,YAAY,EAAE5C,UAAU,CAAC8D,UAAX,CAAsB1C,KANE;AAOtCC,QAAAA;AAPsC,OAAxB,EAQbQ,MARa,EAAhB;AAUA,YAAMtE,IAAI,CACR,CAACkF,OAAD,CADQ,EAERnF,EAAE,CAACsE,MAAH,EAFQ,EAGRH,MAHQ,EAIR/D,OAJQ,CAAV;AAMD,KAzBD,CAyBE;AAAO;AAAmB2C,IAAAA,GAA1B,EAA+B;AAC/BpD,MAAAA,GAAG,CAACG,KAAJ,CAAU,uCAAV,EAAmDiD,GAAnD;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACmB,QAAXsD,WAAW,QAA0B;AAAA,QAAxB;AAAE3D,MAAAA,UAAF;AAAcyB,MAAAA;AAAd,KAAwB;AACzC,QAAIgB,OAAJ;;AACA,QAAI;AACF,YAAM,CAACJ,IAAD,IAAS,MAAM9E,IAAI,CACvB,EADuB,EAEvBkE,MAFuB,EAGvBnE,EAAE,CAACgF,MAAH,EAHuB,EAIvB7E,IAAI,CAAC,CAAD,CAJmB,EAKvBM,QALuB,EAMvBP,OANuB,CAAzB;AAQAiF,MAAAA,OAAO,GAAGzE,OAAO,CAAC2D,QAAR,CAAiBW,MAAjB,CAAwBD,IAAxB,CAAV;AACD,KAVD,CAUE;AAAO;AAAmBhC,IAAAA,GAA1B,EAA+B;AAC/B,aAAOpD,GAAG,CAACG,KAAJ,CAAU,0BAAV,EAAsCiD,GAAtC,CAAP;AACD;;AAED,UAAM+B,EAAE,GAAGpC,UAAU,CAAC8C,UAAtB;;AAEA,QAAI;AACF,YAAMK,QAAQ,GAAG,MAAMlF,QAAQ,CAACmF,cAAT,CAAwBX,OAAO,CAAC5B,gBAAhC,EAAkD3C,UAAU,CAACmF,MAA7D,CAAvB;;AACA,UAAI,MAAM,KAAKjE,SAAL,CAAe0B,WAAf,CAA2BwC,iBAA3B,CAA6CH,QAA7C,CAAV,EAAkE;AAChE,cAAM,KAAK/D,SAAL,CAAekC,SAAf,CAAyBiC,GAAzB,CAA6BnB,EAA7B,EAAiCK,OAAO,CAACpB,SAAzC,CAAN;AACA;AACD;AACF,KAND,CAME;AAAO;AAAmBhB,IAAAA,GAA1B,EAA+B;AAC/BpD,MAAAA,GAAG,CAAC,gFAAD,EAAmFoD,GAAnF,CAAH;AACD,KA1BwC,CA4BzC;;;AACA,QAAI;AACF,YAAM,KAAKjB,SAAL,CAAe0B,WAAf,CAA2ByC,GAA3B,CAA+BnB,EAA/B,EACJK,OAAO,CAACzB,WAAR,CAAoBE,GAApB,CAAyBsC,IAAD,IAAU,IAAI1F,SAAJ,CAAc0F,IAAd,CAAlC,CADI,CAAN;AAED,KAHD,CAGE;AAAO;AAAmBnD,IAAAA,GAA1B,EAA+B;AAC/BpD,MAAAA,GAAG,CAACG,KAAJ,CAAU,wBAAV,EAAoCiD,GAApC;AACD,KAlCwC,CAoCzC;;;AACA,QAAI;AACF,YAAM,KAAKjB,SAAL,CAAekC,SAAf,CAAyBiC,GAAzB,CAA6BnB,EAA7B,EAAiCK,OAAO,CAACpB,SAAzC,CAAN;AACD,KAFD,CAEE;AAAO;AAAmBhB,IAAAA,GAA1B,EAA+B;AAC/BpD,MAAAA,GAAG,CAACG,KAAJ,CAAU,4BAAV,EAAwCiD,GAAxC;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;;;AAC0B,SAAjB6C,iBAAiB,CAAEM,IAAF,EAAQ;AAC9B,QAAIA,IAAI,IAAIA,IAAI,CAACO,MAAL,GAAc,CAA1B,EAA6B;AAC3B,UAAI;AACF,eAAO,IAAIjG,SAAJ,CAAc0F,IAAd,CAAP;AACD,OAFD,CAEE,OAAOQ,CAAP,EAAU;AACV,eAAO,IAAP;AACD;AACF;;AACD,WAAO,IAAP;AACD;;AAnUmB;AAsUtB;AACA;AACA;AACA;AACA;;;AACA,MAAMC,WAAW,GAAG;AAClBC,EAAAA,QAAQ,EAAE/F,mBADQ;AAElBgG,EAAAA,aAAa,EAAE/F;AAFG,CAApB;AAKAO,eAAe,CAACsF,WAAhB,GAA8BA,WAA9B;AACAtF,eAAe,CAACyF,QAAhB,GAA2BpG,OAA3B;AAEAqG,MAAM,CAACC,OAAP,GAAiB3F,eAAjB","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:identify'), {\n  error: debug('libp2p:identify:err')\n})\nconst errCode = require('err-code')\nconst lp = require('it-length-prefixed')\nconst { pipe } = require('it-pipe')\nconst { collect, take, consume } = require('streaming-iterables')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\n\nconst PeerId = require('peer-id')\nconst { Multiaddr } = require('multiaddr')\n// @ts-ignore it-buffer does not have types\nconst { toBuffer } = require('it-buffer')\n\nconst Message = require('./message')\n\nconst Envelope = require('../record/envelope')\nconst PeerRecord = require('../record/peer-record')\n\nconst {\n  MULTICODEC_IDENTIFY,\n  MULTICODEC_IDENTIFY_PUSH,\n  IDENTIFY_PROTOCOL_VERSION,\n  MULTICODEC_IDENTIFY_PROTOCOL_NAME,\n  MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME,\n  MULTICODEC_IDENTIFY_PROTOCOL_VERSION,\n  MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION\n} = require('./consts')\n\nconst { codes } = require('../errors')\n\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n */\n\n/**\n * @typedef {Object} HostProperties\n * @property {string} agentVersion\n */\n\nclass IdentifyService {\n  /**\n   * @param {import('../')} libp2p\n   */\n  static getProtocolStr (libp2p) {\n    return {\n      identifyProtocolStr: `/${libp2p._config.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`,\n      identifyPushProtocolStr: `/${libp2p._config.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`\n    }\n  }\n\n  /**\n   * @class\n   * @param {Object} options\n   * @param {import('../')} options.libp2p\n   */\n  constructor ({ libp2p }) {\n    this._libp2p = libp2p\n    this.peerStore = libp2p.peerStore\n    this.addressManager = libp2p.addressManager\n    this.connectionManager = libp2p.connectionManager\n    this.peerId = libp2p.peerId\n\n    this.handleMessage = this.handleMessage.bind(this)\n\n    const protocolStr = IdentifyService.getProtocolStr(libp2p)\n    this.identifyProtocolStr = protocolStr.identifyProtocolStr\n    this.identifyPushProtocolStr = protocolStr.identifyPushProtocolStr\n\n    // Store self host metadata\n    this._host = {\n      protocolVersion: `${libp2p._config.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,\n      ...libp2p._options.host\n    }\n\n    // When a new connection happens, trigger identify\n    this.connectionManager.on('peer:connect', (connection) => {\n      this.identify(connection).catch(log.error)\n    })\n\n    // When self multiaddrs change, trigger identify-push\n    this.peerStore.on('change:multiaddrs', ({ peerId }) => {\n      if (peerId.toString() === this.peerId.toString()) {\n        this.pushToPeerStore().catch(err => log.error(err))\n      }\n    })\n\n    // When self protocols change, trigger identify-push\n    this.peerStore.on('change:protocols', ({ peerId }) => {\n      if (peerId.toString() === this.peerId.toString()) {\n        this.pushToPeerStore().catch(err => log.error(err))\n      }\n    })\n  }\n\n  async start () {\n    await this.peerStore.metadataBook.setValue(this.peerId, 'AgentVersion', uint8ArrayFromString(this._host.agentVersion))\n    await this.peerStore.metadataBook.setValue(this.peerId, 'ProtocolVersion', uint8ArrayFromString(this._host.protocolVersion))\n  }\n\n  async stop () {\n\n  }\n\n  /**\n   * Send an Identify Push update to the list of connections\n   *\n   * @param {Connection[]} connections\n   * @returns {Promise<void[]>}\n   */\n  async push (connections) {\n    const signedPeerRecord = await this.peerStore.addressBook.getRawEnvelope(this.peerId)\n    const listenAddrs = this._libp2p.multiaddrs.map((ma) => ma.bytes)\n    const protocols = await this.peerStore.protoBook.get(this.peerId)\n\n    const pushes = connections.map(async connection => {\n      try {\n        const { stream } = await connection.newStream(this.identifyPushProtocolStr)\n\n        await pipe(\n          [Message.Identify.encode({\n            listenAddrs,\n            signedPeerRecord,\n            protocols\n          }).finish()],\n          lp.encode(),\n          stream,\n          consume\n        )\n      } catch (/** @type {any} */ err) {\n        // Just log errors\n        log.error('could not push identify update to peer', err)\n      }\n    })\n\n    return Promise.all(pushes)\n  }\n\n  /**\n   * Calls `push` for all peers in the `peerStore` that are connected\n   */\n  async pushToPeerStore () {\n    // Do not try to push if libp2p node is not running\n    if (!this._libp2p.isStarted()) {\n      return\n    }\n\n    const connections = []\n    let connection\n    for await (const peer of this.peerStore.getPeers()) {\n      if (peer.protocols.includes(this.identifyPushProtocolStr) && (connection = this.connectionManager.get(peer.id))) {\n        connections.push(connection)\n      }\n    }\n\n    await this.push(connections)\n  }\n\n  /**\n   * Requests the `Identify` message from peer associated with the given `connection`.\n   * If the identified peer does not match the `PeerId` associated with the connection,\n   * an error will be thrown.\n   *\n   * @async\n   * @param {Connection} connection\n   * @returns {Promise<void>}\n   */\n  async identify (connection) {\n    const { stream } = await connection.newStream(this.identifyProtocolStr)\n    const [data] = await pipe(\n      [],\n      stream,\n      lp.decode(),\n      take(1),\n      toBuffer,\n      collect\n    )\n\n    if (!data) {\n      throw errCode(new Error('No data could be retrieved'), codes.ERR_CONNECTION_ENDED)\n    }\n\n    let message\n    try {\n      message = Message.Identify.decode(data)\n    } catch (/** @type {any} */ err) {\n      throw errCode(err, codes.ERR_INVALID_MESSAGE)\n    }\n\n    const {\n      publicKey,\n      listenAddrs,\n      protocols,\n      observedAddr,\n      signedPeerRecord\n    } = message\n\n    const id = await PeerId.createFromPubKey(publicKey)\n\n    if (connection.remotePeer.toB58String() !== id.toB58String()) {\n      throw errCode(new Error('identified peer does not match the expected peer'), codes.ERR_INVALID_PEER)\n    }\n\n    // Get the observedAddr if there is one\n    const cleanObservedAddr = IdentifyService.getCleanMultiaddr(observedAddr)\n\n    try {\n      const envelope = await Envelope.openAndCertify(signedPeerRecord, PeerRecord.DOMAIN)\n      if (await this.peerStore.addressBook.consumePeerRecord(envelope)) {\n        await this.peerStore.protoBook.set(id, protocols)\n        await this.peerStore.metadataBook.setValue(id, 'AgentVersion', uint8ArrayFromString(message.agentVersion))\n        await this.peerStore.metadataBook.setValue(id, 'ProtocolVersion', uint8ArrayFromString(message.protocolVersion))\n        return\n      }\n    } catch (/** @type {any} */ err) {\n      log('received invalid envelope, discard it and fallback to listenAddrs is available', err)\n    }\n\n    // LEGACY: Update peers data in PeerStore\n    try {\n      await this.peerStore.addressBook.set(id, listenAddrs.map((addr) => new Multiaddr(addr)))\n    } catch (/** @type {any} */ err) {\n      log.error('received invalid addrs', err)\n    }\n\n    await this.peerStore.protoBook.set(id, protocols)\n    await this.peerStore.metadataBook.setValue(id, 'AgentVersion', uint8ArrayFromString(message.agentVersion))\n    await this.peerStore.metadataBook.setValue(id, 'ProtocolVersion', uint8ArrayFromString(message.protocolVersion))\n\n    // TODO: Add and score our observed addr\n    log('received observed address of %s', cleanObservedAddr)\n    // this.addressManager.addObservedAddr(observedAddr)\n  }\n\n  /**\n   * A handler to register with Libp2p to process identify messages.\n   *\n   * @param {Object} options\n   * @param {Connection} options.connection\n   * @param {MuxedStream} options.stream\n   * @param {string} options.protocol\n   * @returns {Promise<void>|undefined}\n   */\n  handleMessage ({ connection, stream, protocol }) {\n    switch (protocol) {\n      case this.identifyProtocolStr:\n        return this._handleIdentify({ connection, stream })\n      case this.identifyPushProtocolStr:\n        return this._handlePush({ connection, stream })\n      default:\n        log.error('cannot handle unknown protocol %s', protocol)\n    }\n  }\n\n  /**\n   * Sends the `Identify` response with the Signed Peer Record\n   * to the requesting peer over the given `connection`\n   *\n   * @private\n   * @param {Object} options\n   * @param {MuxedStream} options.stream\n   * @param {Connection} options.connection\n   * @returns {Promise<void>}\n   */\n  async _handleIdentify ({ connection, stream }) {\n    try {\n      let publicKey = new Uint8Array(0)\n      if (this.peerId.pubKey) {\n        publicKey = this.peerId.pubKey.bytes\n      }\n\n      const signedPeerRecord = await this.peerStore.addressBook.getRawEnvelope(this.peerId)\n      const protocols = await this.peerStore.protoBook.get(this.peerId)\n\n      const message = Message.Identify.encode({\n        protocolVersion: this._host.protocolVersion,\n        agentVersion: this._host.agentVersion,\n        publicKey,\n        listenAddrs: this._libp2p.multiaddrs.map((ma) => ma.bytes),\n        signedPeerRecord,\n        observedAddr: connection.remoteAddr.bytes,\n        protocols\n      }).finish()\n\n      await pipe(\n        [message],\n        lp.encode(),\n        stream,\n        consume\n      )\n    } catch (/** @type {any} */ err) {\n      log.error('could not respond to identify request', err)\n    }\n  }\n\n  /**\n   * Reads the Identify Push message from the given `connection`\n   *\n   * @private\n   * @param {object} options\n   * @param {MuxedStream} options.stream\n   * @param {Connection} options.connection\n   * @returns {Promise<void>}\n   */\n  async _handlePush ({ connection, stream }) {\n    let message\n    try {\n      const [data] = await pipe(\n        [],\n        stream,\n        lp.decode(),\n        take(1),\n        toBuffer,\n        collect\n      )\n      message = Message.Identify.decode(data)\n    } catch (/** @type {any} */ err) {\n      return log.error('received invalid message', err)\n    }\n\n    const id = connection.remotePeer\n\n    try {\n      const envelope = await Envelope.openAndCertify(message.signedPeerRecord, PeerRecord.DOMAIN)\n      if (await this.peerStore.addressBook.consumePeerRecord(envelope)) {\n        await this.peerStore.protoBook.set(id, message.protocols)\n        return\n      }\n    } catch (/** @type {any} */ err) {\n      log('received invalid envelope, discard it and fallback to listenAddrs is available', err)\n    }\n\n    // LEGACY: Update peers data in PeerStore\n    try {\n      await this.peerStore.addressBook.set(id,\n        message.listenAddrs.map((addr) => new Multiaddr(addr)))\n    } catch (/** @type {any} */ err) {\n      log.error('received invalid addrs', err)\n    }\n\n    // Update the protocols\n    try {\n      await this.peerStore.protoBook.set(id, message.protocols)\n    } catch (/** @type {any} */ err) {\n      log.error('received invalid protocols', err)\n    }\n  }\n\n  /**\n   * Takes the `addr` and converts it to a Multiaddr if possible\n   *\n   * @param {Uint8Array | string} addr\n   * @returns {Multiaddr|null}\n   */\n  static getCleanMultiaddr (addr) {\n    if (addr && addr.length > 0) {\n      try {\n        return new Multiaddr(addr)\n      } catch (_) {\n        return null\n      }\n    }\n    return null\n  }\n}\n\n/**\n * The protocols the IdentifyService supports\n *\n * @property multicodecs\n */\nconst multicodecs = {\n  IDENTIFY: MULTICODEC_IDENTIFY,\n  IDENTIFY_PUSH: MULTICODEC_IDENTIFY_PUSH\n}\n\nIdentifyService.multicodecs = multicodecs\nIdentifyService.Messsage = Message\n\nmodule.exports = IdentifyService\n"]},"metadata":{},"sourceType":"script"}