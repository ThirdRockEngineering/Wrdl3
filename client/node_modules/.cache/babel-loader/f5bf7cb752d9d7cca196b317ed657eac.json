{"ast":null,"code":"'use strict';\n\nconst defer = require('p-defer');\n\nconst EventEmitter = require('events').EventEmitter;\n/**\n * @template T\n * @typedef {object} Operation\n * @property {boolean} done\n * @property {boolean} ok\n * @property {Error} err\n * @property {T} value\n */\n\n/**\n * Takes an (async) iterator that emits promise-returning functions,\n * invokes them in parallel and emits the results as they become available but\n * in the same order as the input\n *\n * @template T\n * @param {Iterable<() => Promise<T>> | AsyncIterable<() => Promise<T>>} source\n * @param {object} [options]\n * @param {number} [options.concurrency=Infinity]\n * @param {boolean} [options.ordered=false]\n * @returns {AsyncIterable<T>}\n */\n\n\nasync function* parallel(source) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let concurrency = options.concurrency || Infinity;\n\n  if (concurrency < 1) {\n    concurrency = Infinity;\n  }\n\n  const ordered = options.ordered == null ? false : options.ordered;\n  const emitter = new EventEmitter();\n  /** @type {Operation<T>[]}} */\n\n  const ops = [];\n  let slotAvailable = defer();\n  let resultAvailable = defer();\n  let sourceFinished = false;\n  let sourceErr;\n  let opErred = false;\n  emitter.on('task-complete', () => {\n    resultAvailable.resolve();\n  });\n  Promise.resolve().then(async () => {\n    try {\n      for await (const task of source) {\n        if (ops.length === concurrency) {\n          slotAvailable = defer();\n          await slotAvailable.promise;\n        }\n\n        if (opErred) {\n          break;\n        }\n        /**\n         * @type {any}\n         */\n\n\n        const op = {\n          done: false\n        };\n        ops.push(op);\n        task().then(result => {\n          op.done = true;\n          op.ok = true;\n          op.value = result;\n          emitter.emit('task-complete');\n        }, err => {\n          op.done = true;\n          op.err = err;\n          emitter.emit('task-complete');\n        });\n      }\n\n      sourceFinished = true;\n      emitter.emit('task-complete');\n    } catch (err) {\n      sourceErr = err;\n      emitter.emit('task-complete');\n    }\n  });\n\n  function valuesAvailable() {\n    if (ordered) {\n      return Boolean(ops[0] && ops[0].done);\n    }\n\n    return Boolean(ops.find(op => op.done));\n  }\n\n  function* yieldOrderedValues() {\n    while (ops.length && ops[0].done) {\n      const op = ops[0];\n      ops.shift();\n\n      if (op.ok) {\n        yield op.value;\n      } else {\n        // allow the source to exit\n        opErred = true;\n        slotAvailable.resolve();\n        throw op.err;\n      }\n\n      slotAvailable.resolve();\n    }\n  }\n\n  function* yieldUnOrderedValues() {\n    // more values can become available while we wait for `yield`\n    // to return control to this function\n    while (valuesAvailable()) {\n      for (let i = 0; i < ops.length; i++) {\n        if (ops[i].done) {\n          const op = ops[i];\n          ops.splice(i, 1);\n          i--;\n\n          if (op.ok) {\n            yield op.value;\n          } else {\n            opErred = true;\n            slotAvailable.resolve();\n            throw op.err;\n          }\n\n          slotAvailable.resolve();\n        }\n      }\n    }\n  }\n\n  while (true) {\n    if (!valuesAvailable()) {\n      resultAvailable = defer();\n      await resultAvailable.promise;\n    }\n\n    if (sourceErr) {\n      // the source threw an error, propagate it\n      throw sourceErr;\n    }\n\n    if (ordered) {\n      yield* yieldOrderedValues();\n    } else {\n      yield* yieldUnOrderedValues();\n    }\n\n    if (sourceFinished && ops.length === 0) {\n      // not waiting for any results and no more tasks so we are done\n      break;\n    }\n  }\n}\n\nmodule.exports = parallel;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/it-parallel/index.js"],"names":["defer","require","EventEmitter","parallel","source","options","concurrency","Infinity","ordered","emitter","ops","slotAvailable","resultAvailable","sourceFinished","sourceErr","opErred","on","resolve","Promise","then","task","length","promise","op","done","push","result","ok","value","emit","err","valuesAvailable","Boolean","find","yieldOrderedValues","shift","yieldUnOrderedValues","i","splice","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst defer = require('p-defer')\nconst EventEmitter = require('events').EventEmitter\n\n/**\n * @template T\n * @typedef {object} Operation\n * @property {boolean} done\n * @property {boolean} ok\n * @property {Error} err\n * @property {T} value\n */\n\n/**\n * Takes an (async) iterator that emits promise-returning functions,\n * invokes them in parallel and emits the results as they become available but\n * in the same order as the input\n *\n * @template T\n * @param {Iterable<() => Promise<T>> | AsyncIterable<() => Promise<T>>} source\n * @param {object} [options]\n * @param {number} [options.concurrency=Infinity]\n * @param {boolean} [options.ordered=false]\n * @returns {AsyncIterable<T>}\n */\nasync function * parallel (source, options = {}) {\n  let concurrency = options.concurrency || Infinity\n\n  if (concurrency < 1) {\n    concurrency = Infinity\n  }\n\n  const ordered = options.ordered == null ? false : options.ordered\n  const emitter = new EventEmitter()\n\n  /** @type {Operation<T>[]}} */\n  const ops = []\n  let slotAvailable = defer()\n  let resultAvailable = defer()\n  let sourceFinished = false\n  let sourceErr\n  let opErred = false\n\n  emitter.on('task-complete', () => {\n    resultAvailable.resolve()\n  })\n\n  Promise.resolve().then(async () => {\n    try {\n      for await (const task of source) {\n        if (ops.length === concurrency) {\n          slotAvailable = defer()\n          await slotAvailable.promise\n        }\n\n        if (opErred) {\n          break\n        }\n\n        /**\n         * @type {any}\n         */\n        const op = {\n          done: false\n        }\n        ops.push(op)\n\n        task()\n          .then(result => {\n            op.done = true\n            op.ok = true\n            op.value = result\n            emitter.emit('task-complete')\n          }, err => {\n            op.done = true\n            op.err = err\n            emitter.emit('task-complete')\n          })\n      }\n\n      sourceFinished = true\n      emitter.emit('task-complete')\n    } catch (err) {\n      sourceErr = err\n      emitter.emit('task-complete')\n    }\n  })\n\n  function valuesAvailable () {\n    if (ordered) {\n      return Boolean(ops[0] && ops[0].done)\n    }\n\n    return Boolean(ops.find(op => op.done))\n  }\n\n  function * yieldOrderedValues () {\n    while (ops.length && ops[0].done) {\n      const op = ops[0]\n      ops.shift()\n\n      if (op.ok) {\n        yield op.value\n      } else {\n        // allow the source to exit\n        opErred = true\n        slotAvailable.resolve()\n\n        throw op.err\n      }\n\n      slotAvailable.resolve()\n    }\n  }\n\n  function * yieldUnOrderedValues () {\n    // more values can become available while we wait for `yield`\n    // to return control to this function\n    while (valuesAvailable()) {\n      for (let i = 0; i < ops.length; i++) {\n        if (ops[i].done) {\n          const op = ops[i]\n          ops.splice(i, 1)\n          i--\n\n          if (op.ok) {\n            yield op.value\n          } else {\n            opErred = true\n            slotAvailable.resolve()\n\n            throw op.err\n          }\n\n          slotAvailable.resolve()\n        }\n      }\n    }\n  }\n\n  while (true) {\n    if (!valuesAvailable()) {\n      resultAvailable = defer()\n      await resultAvailable.promise\n    }\n\n    if (sourceErr) {\n      // the source threw an error, propagate it\n      throw sourceErr\n    }\n\n    if (ordered) {\n      yield * yieldOrderedValues()\n    } else {\n      yield * yieldUnOrderedValues()\n    }\n\n    if (sourceFinished && ops.length === 0) {\n      // not waiting for any results and no more tasks so we are done\n      break\n    }\n  }\n}\n\nmodule.exports = parallel\n"]},"metadata":{},"sourceType":"script"}