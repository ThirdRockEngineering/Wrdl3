{"ast":null,"code":"'use strict';\n\nconst BufferList = require('bl/BufferList');\n\nconst lp = require('it-length-prefixed');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst errCode = require('err-code');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst first = require('it-first');\n\nconst {\n  source\n} = require('abortable-iterator');\n/**\n * @typedef {import('it-pushable').Pushable<Uint8Array | BufferList>} Pushable\n * @typedef {import('./types').AbortOptions} AbortOptions\n */\n\n\nconst NewLine = uint8ArrayFromString('\\n');\n/**\n * @param {Uint8Array | BufferList | string} buffer\n * @returns {Uint8Array}\n */\n\nfunction encode(buffer) {\n  // @ts-expect-error BufferList accepts Buffer[], we pass Uint8Array[]\n  return lp.encode.single(new BufferList([buffer, NewLine]));\n}\n/**\n * `write` encodes and writes a single buffer\n *\n * @param {Pushable} writer\n * @param {Uint8Array | BufferList | string} buffer\n */\n\n\nfunction write(writer, buffer) {\n  writer.push(encode(buffer));\n}\n/**\n * `writeAll` behaves like `write`, except it encodes an array of items as a single write\n *\n * @param {Pushable} writer\n * @param {(Uint8Array | BufferList | string)[]} buffers\n */\n\n\nasync function writeAll(writer, buffers) {\n  // @ts-expect-error BufferList cannot append Uint8Arrays\n  writer.push(buffers.reduce((bl, buffer) => bl.append(encode(buffer)), new BufferList()));\n}\n/**\n * @param {AsyncGenerator<Uint8Array | BufferList, void, number>} reader\n * @param {AbortOptions} [options]\n */\n\n\nasync function read(reader, options) {\n  let byteLength = 1; // Read single byte chunks until the length is known\n\n  const varByteSource = {\n    // No return impl - we want the reader to remain readable\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n\n    next: () => reader.next(byteLength)\n  };\n  /** @type {AsyncIterable<Uint8Array | BufferList>} */\n\n  let input = varByteSource; // If we have been passed an abort signal, wrap the input source in an abortable\n  // iterator that will throw if the operation is aborted\n\n  if (options && options.signal) {\n    input = source(varByteSource, options.signal);\n  } // Once the length has been parsed, read chunk for that length\n\n\n  const onLength = (\n  /** @type {number} */\n  l) => {\n    byteLength = l;\n  };\n  /** @type {BufferList} */\n\n\n  const buf = await pipe(input, lp.decode({\n    onLength\n  }), first);\n\n  if (buf.get(buf.length - 1) !== NewLine[0]) {\n    throw errCode(new Error('missing newline'), 'ERR_INVALID_MULTISTREAM_SELECT_MESSAGE');\n  }\n\n  return buf.shallowSlice(0, -1); // Remove newline\n}\n\nmodule.exports = {\n  encode,\n  write,\n  writeAll,\n  read\n};","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/multistream-select/src/multistream.js"],"names":["BufferList","require","lp","pipe","errCode","fromString","uint8ArrayFromString","first","source","NewLine","encode","buffer","single","write","writer","push","writeAll","buffers","reduce","bl","append","read","reader","options","byteLength","varByteSource","Symbol","asyncIterator","next","input","signal","onLength","l","buf","decode","get","length","Error","shallowSlice","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst BufferList = require('bl/BufferList')\nconst lp = require('it-length-prefixed')\nconst { pipe } = require('it-pipe')\nconst errCode = require('err-code')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst first = require('it-first')\nconst { source } = require('abortable-iterator')\n\n/**\n * @typedef {import('it-pushable').Pushable<Uint8Array | BufferList>} Pushable\n * @typedef {import('./types').AbortOptions} AbortOptions\n */\n\nconst NewLine = uint8ArrayFromString('\\n')\n\n/**\n * @param {Uint8Array | BufferList | string} buffer\n * @returns {Uint8Array}\n */\nfunction encode (buffer) {\n  // @ts-expect-error BufferList accepts Buffer[], we pass Uint8Array[]\n  return lp.encode.single(new BufferList([buffer, NewLine]))\n}\n\n/**\n * `write` encodes and writes a single buffer\n *\n * @param {Pushable} writer\n * @param {Uint8Array | BufferList | string} buffer\n */\nfunction write (writer, buffer) {\n  writer.push(encode(buffer))\n}\n\n/**\n * `writeAll` behaves like `write`, except it encodes an array of items as a single write\n *\n * @param {Pushable} writer\n * @param {(Uint8Array | BufferList | string)[]} buffers\n */\nasync function writeAll (writer, buffers) {\n  // @ts-expect-error BufferList cannot append Uint8Arrays\n  writer.push(buffers.reduce((bl, buffer) => bl.append(encode(buffer)), new BufferList()))\n}\n\n/**\n * @param {AsyncGenerator<Uint8Array | BufferList, void, number>} reader\n * @param {AbortOptions} [options]\n */\nasync function read (reader, options) {\n  let byteLength = 1 // Read single byte chunks until the length is known\n  const varByteSource = { // No return impl - we want the reader to remain readable\n    [Symbol.asyncIterator] () { return this },\n    next: () => reader.next(byteLength)\n  }\n\n  /** @type {AsyncIterable<Uint8Array | BufferList>} */\n  let input = varByteSource\n\n  // If we have been passed an abort signal, wrap the input source in an abortable\n  // iterator that will throw if the operation is aborted\n  if (options && options.signal) {\n    input = source(varByteSource, options.signal)\n  }\n\n  // Once the length has been parsed, read chunk for that length\n  const onLength = (/** @type {number} */ l) => { byteLength = l }\n\n  /** @type {BufferList} */\n  const buf = await pipe(\n    input,\n    lp.decode({ onLength }),\n    first\n  )\n\n  if (buf.get(buf.length - 1) !== NewLine[0]) {\n    throw errCode(new Error('missing newline'), 'ERR_INVALID_MULTISTREAM_SELECT_MESSAGE')\n  }\n\n  return buf.shallowSlice(0, -1) // Remove newline\n}\n\nmodule.exports = {\n  encode,\n  write,\n  writeAll,\n  read\n}\n"]},"metadata":{},"sourceType":"script"}