{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar mergeOpts = require('merge-options');\n\nvar toMfsPath = require('./utils/to-mfs-path.js');\n\nvar debug = require('debug');\n\nvar errCode = require('err-code');\n\nvar ipfsUnixfs = require('ipfs-unixfs');\n\nvar toTrail = require('./utils/to-trail.js');\n\nvar addLink = require('./utils/add-link.js');\n\nvar updateTree = require('./utils/update-tree.js');\n\nvar updateMfsRoot = require('./utils/update-mfs-root.js');\n\nvar dagPB = require('@ipld/dag-pb');\n\nvar cid = require('multiformats/cid');\n\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar mergeOpts__default = /*#__PURE__*/_interopDefaultLegacy(mergeOpts);\n\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\n\nvar dagPB__namespace = /*#__PURE__*/_interopNamespace(dagPB);\n\nconst mergeOptions = mergeOpts__default[\"default\"].bind({\n  ignoreUndefined: true\n});\nconst log = debug__default[\"default\"]('ipfs:mfs:touch');\nconst defaultOptions = {\n  flush: true,\n  shardSplitThreshold: 1000,\n  cidVersion: 0,\n  hashAlg: 'sha2-256'\n};\n\nfunction createTouch(context) {\n  async function mfsTouch(path) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const settings = mergeOptions(defaultOptions, options);\n    settings.mtime = settings.mtime || new Date();\n    log(`Touching ${path} mtime: ${settings.mtime}`);\n    const {\n      cid: cid$1,\n      mfsDirectory,\n      name,\n      exists\n    } = await toMfsPath.toMfsPath(context, path, settings);\n    const hashAlg = options.hashAlg || defaultOptions.hashAlg;\n    const hasher = await context.hashers.getHasher(hashAlg);\n    let updatedBlock;\n    let updatedCid;\n    let cidVersion = settings.cidVersion;\n\n    if (!exists) {\n      const metadata = new ipfsUnixfs.UnixFS({\n        type: 'file',\n        mtime: settings.mtime\n      });\n      updatedBlock = dagPB__namespace.encode({\n        Data: metadata.marshal(),\n        Links: []\n      });\n      const hash = await hasher.digest(updatedBlock);\n      updatedCid = cid.CID.create(settings.cidVersion, dagPB__namespace.code, hash);\n\n      if (settings.flush) {\n        await context.repo.blocks.put(updatedCid, updatedBlock);\n      }\n    } else {\n      if (cid$1.code !== dagPB__namespace.code) {\n        throw errCode__default[\"default\"](new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS');\n      }\n\n      cidVersion = cid$1.version;\n      const block = await context.repo.blocks.get(cid$1);\n      const node = dagPB__namespace.decode(block);\n\n      if (!node.Data) {\n        throw errCode__default[\"default\"](new Error(`${path} had no data`), 'ERR_INVALID_NODE');\n      }\n\n      const metadata = ipfsUnixfs.UnixFS.unmarshal(node.Data);\n      metadata.mtime = settings.mtime;\n      updatedBlock = dagPB__namespace.encode({\n        Data: metadata.marshal(),\n        Links: node.Links\n      });\n      const hash = await hasher.digest(updatedBlock);\n      updatedCid = cid.CID.create(settings.cidVersion, dagPB__namespace.code, hash);\n\n      if (settings.flush) {\n        await context.repo.blocks.put(updatedCid, updatedBlock);\n      }\n    }\n\n    const trail = await toTrail.toTrail(context, mfsDirectory);\n    const parent = trail[trail.length - 1];\n    const parentCid = parent.cid;\n    const parentBlock = await context.repo.blocks.get(parentCid);\n    const parentNode = dagPB__namespace.decode(parentBlock);\n    const result = await addLink.addLink(context, {\n      parent: parentNode,\n      name: name,\n      cid: updatedCid,\n      size: updatedBlock.length,\n      flush: settings.flush,\n      shardSplitThreshold: settings.shardSplitThreshold,\n      hashAlg: settings.hashAlg,\n      cidVersion\n    });\n    parent.cid = result.cid;\n    const newRootCid = await updateTree.updateTree(context, trail, settings);\n    await updateMfsRoot.updateMfsRoot(context, newRootCid, settings);\n  }\n\n  return withTimeoutOption.withTimeoutOption(mfsTouch);\n}\n\nexports.createTouch = createTouch;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-core/cjs/src/components/files/touch.js"],"names":["Object","defineProperty","exports","value","mergeOpts","require","toMfsPath","debug","errCode","ipfsUnixfs","toTrail","addLink","updateTree","updateMfsRoot","dagPB","cid","withTimeoutOption","_interopDefaultLegacy","e","_interopNamespace","__esModule","n","create","keys","forEach","k","d","getOwnPropertyDescriptor","get","enumerable","freeze","mergeOpts__default","debug__default","errCode__default","dagPB__namespace","mergeOptions","bind","ignoreUndefined","log","defaultOptions","flush","shardSplitThreshold","cidVersion","hashAlg","createTouch","context","mfsTouch","path","options","settings","mtime","Date","cid$1","mfsDirectory","name","exists","hasher","hashers","getHasher","updatedBlock","updatedCid","metadata","UnixFS","type","encode","Data","marshal","Links","hash","digest","CID","code","repo","blocks","put","Error","version","block","node","decode","unmarshal","trail","parent","length","parentCid","parentBlock","parentNode","result","size","newRootCid"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar mergeOpts = require('merge-options');\nvar toMfsPath = require('./utils/to-mfs-path.js');\nvar debug = require('debug');\nvar errCode = require('err-code');\nvar ipfsUnixfs = require('ipfs-unixfs');\nvar toTrail = require('./utils/to-trail.js');\nvar addLink = require('./utils/add-link.js');\nvar updateTree = require('./utils/update-tree.js');\nvar updateMfsRoot = require('./utils/update-mfs-root.js');\nvar dagPB = require('@ipld/dag-pb');\nvar cid = require('multiformats/cid');\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar mergeOpts__default = /*#__PURE__*/_interopDefaultLegacy(mergeOpts);\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\nvar dagPB__namespace = /*#__PURE__*/_interopNamespace(dagPB);\n\nconst mergeOptions = mergeOpts__default[\"default\"].bind({ ignoreUndefined: true });\nconst log = debug__default[\"default\"]('ipfs:mfs:touch');\nconst defaultOptions = {\n  flush: true,\n  shardSplitThreshold: 1000,\n  cidVersion: 0,\n  hashAlg: 'sha2-256'\n};\nfunction createTouch(context) {\n  async function mfsTouch(path, options = {}) {\n    const settings = mergeOptions(defaultOptions, options);\n    settings.mtime = settings.mtime || new Date();\n    log(`Touching ${ path } mtime: ${ settings.mtime }`);\n    const {cid: cid$1, mfsDirectory, name, exists} = await toMfsPath.toMfsPath(context, path, settings);\n    const hashAlg = options.hashAlg || defaultOptions.hashAlg;\n    const hasher = await context.hashers.getHasher(hashAlg);\n    let updatedBlock;\n    let updatedCid;\n    let cidVersion = settings.cidVersion;\n    if (!exists) {\n      const metadata = new ipfsUnixfs.UnixFS({\n        type: 'file',\n        mtime: settings.mtime\n      });\n      updatedBlock = dagPB__namespace.encode({\n        Data: metadata.marshal(),\n        Links: []\n      });\n      const hash = await hasher.digest(updatedBlock);\n      updatedCid = cid.CID.create(settings.cidVersion, dagPB__namespace.code, hash);\n      if (settings.flush) {\n        await context.repo.blocks.put(updatedCid, updatedBlock);\n      }\n    } else {\n      if (cid$1.code !== dagPB__namespace.code) {\n        throw errCode__default[\"default\"](new Error(`${ path } was not a UnixFS node`), 'ERR_NOT_UNIXFS');\n      }\n      cidVersion = cid$1.version;\n      const block = await context.repo.blocks.get(cid$1);\n      const node = dagPB__namespace.decode(block);\n      if (!node.Data) {\n        throw errCode__default[\"default\"](new Error(`${ path } had no data`), 'ERR_INVALID_NODE');\n      }\n      const metadata = ipfsUnixfs.UnixFS.unmarshal(node.Data);\n      metadata.mtime = settings.mtime;\n      updatedBlock = dagPB__namespace.encode({\n        Data: metadata.marshal(),\n        Links: node.Links\n      });\n      const hash = await hasher.digest(updatedBlock);\n      updatedCid = cid.CID.create(settings.cidVersion, dagPB__namespace.code, hash);\n      if (settings.flush) {\n        await context.repo.blocks.put(updatedCid, updatedBlock);\n      }\n    }\n    const trail = await toTrail.toTrail(context, mfsDirectory);\n    const parent = trail[trail.length - 1];\n    const parentCid = parent.cid;\n    const parentBlock = await context.repo.blocks.get(parentCid);\n    const parentNode = dagPB__namespace.decode(parentBlock);\n    const result = await addLink.addLink(context, {\n      parent: parentNode,\n      name: name,\n      cid: updatedCid,\n      size: updatedBlock.length,\n      flush: settings.flush,\n      shardSplitThreshold: settings.shardSplitThreshold,\n      hashAlg: settings.hashAlg,\n      cidVersion\n    });\n    parent.cid = result.cid;\n    const newRootCid = await updateTree.updateTree(context, trail, settings);\n    await updateMfsRoot.updateMfsRoot(context, newRootCid, settings);\n  }\n  return withTimeoutOption.withTimeoutOption(mfsTouch);\n}\n\nexports.createTouch = createTouch;\n"]},"metadata":{},"sourceType":"script"}