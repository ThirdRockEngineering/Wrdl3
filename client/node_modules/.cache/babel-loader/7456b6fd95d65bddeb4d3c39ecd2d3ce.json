{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar ipfsUnixfsImporter = require('ipfs-unixfs-importer');\n\nvar normaliseInputMultiple = require('ipfs-core-utils/files/normalise-input-multiple');\n\nvar utils = require('./utils.js');\n\nvar itPipe = require('it-pipe');\n\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\n\nvar mergeOpts = require('merge-options');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar mergeOpts__default = /*#__PURE__*/_interopDefaultLegacy(mergeOpts);\n\nconst mergeOptions = mergeOpts__default[\"default\"].bind({\n  ignoreUndefined: true\n});\n\nfunction createAddAll(_ref) {\n  let {\n    repo,\n    preload,\n    hashers,\n    options\n  } = _ref;\n  const isShardingEnabled = options && options.sharding;\n\n  async function* addAll(source) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const opts = mergeOptions({\n      shardSplitThreshold: isShardingEnabled ? 1000 : Infinity,\n      strategy: 'balanced'\n    }, options, { ...utils.parseChunkerString(options.chunker)\n    });\n\n    if (opts.hashAlg && opts.hashAlg !== 'sha2-256' && opts.cidVersion !== 1) {\n      opts.cidVersion = 1;\n    }\n\n    if (opts.trickle) {\n      opts.strategy = 'trickle';\n    }\n\n    if (opts.strategy === 'trickle') {\n      opts.leafType = 'raw';\n      opts.reduceSingleLeafToSelf = false;\n    }\n\n    if (opts.cidVersion > 0 && opts.rawLeaves === undefined) {\n      opts.rawLeaves = true;\n    }\n\n    if (opts.hashAlg !== undefined && opts.rawLeaves === undefined) {\n      opts.rawLeaves = true;\n    }\n\n    delete opts.trickle;\n    const totals = {};\n\n    if (opts.progress) {\n      const prog = opts.progress;\n\n      opts.progress = (bytes, path) => {\n        if (!totals[path]) {\n          totals[path] = 0;\n        }\n\n        totals[path] += bytes;\n        prog(totals[path], path);\n      };\n    }\n\n    let hasher;\n\n    if (opts.hashAlg != null) {\n      hasher = await hashers.getHasher(opts.hashAlg);\n    }\n\n    const iterator = itPipe.pipe(normaliseInputMultiple.normaliseInput(source), source => ipfsUnixfsImporter.importer(source, repo.blocks, { ...opts,\n      hasher,\n      pin: false\n    }), transformFile(opts), preloadFile(preload, opts), pinFile(repo, opts));\n    const releaseLock = await repo.gcLock.readLock();\n\n    try {\n      for await (const added of iterator) {\n        delete totals[added.path];\n        yield added;\n      }\n    } finally {\n      releaseLock();\n    }\n  }\n\n  return withTimeoutOption.withTimeoutOption(addAll);\n}\n\nfunction transformFile(opts) {\n  async function* transformFile(source) {\n    for await (const file of source) {\n      let cid = file.cid;\n\n      if (opts.cidVersion === 1) {\n        cid = cid.toV1();\n      }\n\n      let path = file.path ? file.path : cid.toString();\n\n      if (opts.wrapWithDirectory && !file.path) {\n        path = '';\n      }\n\n      yield {\n        path,\n        cid: cid,\n        size: file.size,\n        mode: file.unixfs && file.unixfs.mode,\n        mtime: file.unixfs && file.unixfs.mtime\n      };\n    }\n  }\n\n  return transformFile;\n}\n\nfunction preloadFile(preload, opts) {\n  async function* maybePreloadFile(source) {\n    for await (const file of source) {\n      const isRootFile = !file.path || opts.wrapWithDirectory ? file.path === '' : !file.path.includes('/');\n      const shouldPreload = isRootFile && !opts.onlyHash && opts.preload !== false;\n\n      if (shouldPreload) {\n        preload(file.cid);\n      }\n\n      yield file;\n    }\n  }\n\n  return maybePreloadFile;\n}\n\nfunction pinFile(repo, opts) {\n  async function* maybePinFile(source) {\n    for await (const file of source) {\n      const isRootDir = !(file.path && file.path.includes('/'));\n      const shouldPin = (opts.pin == null ? true : opts.pin) && isRootDir && !opts.onlyHash;\n\n      if (shouldPin) {\n        await repo.pins.pinRecursively(file.cid);\n      }\n\n      yield file;\n    }\n  }\n\n  return maybePinFile;\n}\n\nexports.createAddAll = createAddAll;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-core/cjs/src/components/add-all/index.js"],"names":["Object","defineProperty","exports","value","ipfsUnixfsImporter","require","normaliseInputMultiple","utils","itPipe","withTimeoutOption","mergeOpts","_interopDefaultLegacy","e","mergeOpts__default","mergeOptions","bind","ignoreUndefined","createAddAll","repo","preload","hashers","options","isShardingEnabled","sharding","addAll","source","opts","shardSplitThreshold","Infinity","strategy","parseChunkerString","chunker","hashAlg","cidVersion","trickle","leafType","reduceSingleLeafToSelf","rawLeaves","undefined","totals","progress","prog","bytes","path","hasher","getHasher","iterator","pipe","normaliseInput","importer","blocks","pin","transformFile","preloadFile","pinFile","releaseLock","gcLock","readLock","added","file","cid","toV1","toString","wrapWithDirectory","size","mode","unixfs","mtime","maybePreloadFile","isRootFile","includes","shouldPreload","onlyHash","maybePinFile","isRootDir","shouldPin","pins","pinRecursively"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AAEA,IAAIC,kBAAkB,GAAGC,OAAO,CAAC,sBAAD,CAAhC;;AACA,IAAIC,sBAAsB,GAAGD,OAAO,CAAC,gDAAD,CAApC;;AACA,IAAIE,KAAK,GAAGF,OAAO,CAAC,YAAD,CAAnB;;AACA,IAAIG,MAAM,GAAGH,OAAO,CAAC,SAAD,CAApB;;AACA,IAAII,iBAAiB,GAAGJ,OAAO,CAAC,qCAAD,CAA/B;;AACA,IAAIK,SAAS,GAAGL,OAAO,CAAC,eAAD,CAAvB;;AAEA,SAASM,qBAAT,CAAgCC,CAAhC,EAAmC;AAAE,SAAOA,CAAC,IAAI,OAAOA,CAAP,KAAa,QAAlB,IAA8B,aAAaA,CAA3C,GAA+CA,CAA/C,GAAmD;AAAE,eAAWA;AAAb,GAA1D;AAA6E;;AAElH,IAAIC,kBAAkB,GAAG,aAAaF,qBAAqB,CAACD,SAAD,CAA3D;;AAEA,MAAMI,YAAY,GAAGD,kBAAkB,CAAC,SAAD,CAAlB,CAA8BE,IAA9B,CAAmC;AAAEC,EAAAA,eAAe,EAAE;AAAnB,CAAnC,CAArB;;AACA,SAASC,YAAT,OAAyD;AAAA,MAAnC;AAACC,IAAAA,IAAD;AAAOC,IAAAA,OAAP;AAAgBC,IAAAA,OAAhB;AAAyBC,IAAAA;AAAzB,GAAmC;AACvD,QAAMC,iBAAiB,GAAGD,OAAO,IAAIA,OAAO,CAACE,QAA7C;;AACA,kBAAgBC,MAAhB,CAAuBC,MAAvB,EAA6C;AAAA,QAAdJ,OAAc,uEAAJ,EAAI;AAC3C,UAAMK,IAAI,GAAGZ,YAAY,CAAC;AACxBa,MAAAA,mBAAmB,EAAEL,iBAAiB,GAAG,IAAH,GAAUM,QADxB;AAExBC,MAAAA,QAAQ,EAAE;AAFc,KAAD,EAGtBR,OAHsB,EAGb,EAAE,GAAGd,KAAK,CAACuB,kBAAN,CAAyBT,OAAO,CAACU,OAAjC;AAAL,KAHa,CAAzB;;AAIA,QAAIL,IAAI,CAACM,OAAL,IAAgBN,IAAI,CAACM,OAAL,KAAiB,UAAjC,IAA+CN,IAAI,CAACO,UAAL,KAAoB,CAAvE,EAA0E;AACxEP,MAAAA,IAAI,CAACO,UAAL,GAAkB,CAAlB;AACD;;AACD,QAAIP,IAAI,CAACQ,OAAT,EAAkB;AAChBR,MAAAA,IAAI,CAACG,QAAL,GAAgB,SAAhB;AACD;;AACD,QAAIH,IAAI,CAACG,QAAL,KAAkB,SAAtB,EAAiC;AAC/BH,MAAAA,IAAI,CAACS,QAAL,GAAgB,KAAhB;AACAT,MAAAA,IAAI,CAACU,sBAAL,GAA8B,KAA9B;AACD;;AACD,QAAIV,IAAI,CAACO,UAAL,GAAkB,CAAlB,IAAuBP,IAAI,CAACW,SAAL,KAAmBC,SAA9C,EAAyD;AACvDZ,MAAAA,IAAI,CAACW,SAAL,GAAiB,IAAjB;AACD;;AACD,QAAIX,IAAI,CAACM,OAAL,KAAiBM,SAAjB,IAA8BZ,IAAI,CAACW,SAAL,KAAmBC,SAArD,EAAgE;AAC9DZ,MAAAA,IAAI,CAACW,SAAL,GAAiB,IAAjB;AACD;;AACD,WAAOX,IAAI,CAACQ,OAAZ;AACA,UAAMK,MAAM,GAAG,EAAf;;AACA,QAAIb,IAAI,CAACc,QAAT,EAAmB;AACjB,YAAMC,IAAI,GAAGf,IAAI,CAACc,QAAlB;;AACAd,MAAAA,IAAI,CAACc,QAAL,GAAgB,CAACE,KAAD,EAAQC,IAAR,KAAiB;AAC/B,YAAI,CAACJ,MAAM,CAACI,IAAD,CAAX,EAAmB;AACjBJ,UAAAA,MAAM,CAACI,IAAD,CAAN,GAAe,CAAf;AACD;;AACDJ,QAAAA,MAAM,CAACI,IAAD,CAAN,IAAgBD,KAAhB;AACAD,QAAAA,IAAI,CAACF,MAAM,CAACI,IAAD,CAAP,EAAeA,IAAf,CAAJ;AACD,OAND;AAOD;;AACD,QAAIC,MAAJ;;AACA,QAAIlB,IAAI,CAACM,OAAL,IAAgB,IAApB,EAA0B;AACxBY,MAAAA,MAAM,GAAG,MAAMxB,OAAO,CAACyB,SAAR,CAAkBnB,IAAI,CAACM,OAAvB,CAAf;AACD;;AACD,UAAMc,QAAQ,GAAGtC,MAAM,CAACuC,IAAP,CAAYzC,sBAAsB,CAAC0C,cAAvB,CAAsCvB,MAAtC,CAAZ,EAA2DA,MAAM,IAAIrB,kBAAkB,CAAC6C,QAAnB,CAA4BxB,MAA5B,EAAoCP,IAAI,CAACgC,MAAzC,EAAiD,EACrI,GAAGxB,IADkI;AAErIkB,MAAAA,MAFqI;AAGrIO,MAAAA,GAAG,EAAE;AAHgI,KAAjD,CAArE,EAIbC,aAAa,CAAC1B,IAAD,CAJA,EAIQ2B,WAAW,CAAClC,OAAD,EAAUO,IAAV,CAJnB,EAIoC4B,OAAO,CAACpC,IAAD,EAAOQ,IAAP,CAJ3C,CAAjB;AAKA,UAAM6B,WAAW,GAAG,MAAMrC,IAAI,CAACsC,MAAL,CAAYC,QAAZ,EAA1B;;AACA,QAAI;AACF,iBAAW,MAAMC,KAAjB,IAA0BZ,QAA1B,EAAoC;AAClC,eAAOP,MAAM,CAACmB,KAAK,CAACf,IAAP,CAAb;AACA,cAAMe,KAAN;AACD;AACF,KALD,SAKU;AACRH,MAAAA,WAAW;AACZ;AACF;;AACD,SAAO9C,iBAAiB,CAACA,iBAAlB,CAAoCe,MAApC,CAAP;AACD;;AACD,SAAS4B,aAAT,CAAuB1B,IAAvB,EAA6B;AAC3B,kBAAgB0B,aAAhB,CAA8B3B,MAA9B,EAAsC;AACpC,eAAW,MAAMkC,IAAjB,IAAyBlC,MAAzB,EAAiC;AAC/B,UAAImC,GAAG,GAAGD,IAAI,CAACC,GAAf;;AACA,UAAIlC,IAAI,CAACO,UAAL,KAAoB,CAAxB,EAA2B;AACzB2B,QAAAA,GAAG,GAAGA,GAAG,CAACC,IAAJ,EAAN;AACD;;AACD,UAAIlB,IAAI,GAAGgB,IAAI,CAAChB,IAAL,GAAYgB,IAAI,CAAChB,IAAjB,GAAwBiB,GAAG,CAACE,QAAJ,EAAnC;;AACA,UAAIpC,IAAI,CAACqC,iBAAL,IAA0B,CAACJ,IAAI,CAAChB,IAApC,EAA0C;AACxCA,QAAAA,IAAI,GAAG,EAAP;AACD;;AACD,YAAM;AACJA,QAAAA,IADI;AAEJiB,QAAAA,GAAG,EAAEA,GAFD;AAGJI,QAAAA,IAAI,EAAEL,IAAI,CAACK,IAHP;AAIJC,QAAAA,IAAI,EAAEN,IAAI,CAACO,MAAL,IAAeP,IAAI,CAACO,MAAL,CAAYD,IAJ7B;AAKJE,QAAAA,KAAK,EAAER,IAAI,CAACO,MAAL,IAAeP,IAAI,CAACO,MAAL,CAAYC;AAL9B,OAAN;AAOD;AACF;;AACD,SAAOf,aAAP;AACD;;AACD,SAASC,WAAT,CAAqBlC,OAArB,EAA8BO,IAA9B,EAAoC;AAClC,kBAAgB0C,gBAAhB,CAAiC3C,MAAjC,EAAyC;AACvC,eAAW,MAAMkC,IAAjB,IAAyBlC,MAAzB,EAAiC;AAC/B,YAAM4C,UAAU,GAAG,CAACV,IAAI,CAAChB,IAAN,IAAcjB,IAAI,CAACqC,iBAAnB,GAAuCJ,IAAI,CAAChB,IAAL,KAAc,EAArD,GAA0D,CAACgB,IAAI,CAAChB,IAAL,CAAU2B,QAAV,CAAmB,GAAnB,CAA9E;AACA,YAAMC,aAAa,GAAGF,UAAU,IAAI,CAAC3C,IAAI,CAAC8C,QAApB,IAAgC9C,IAAI,CAACP,OAAL,KAAiB,KAAvE;;AACA,UAAIoD,aAAJ,EAAmB;AACjBpD,QAAAA,OAAO,CAACwC,IAAI,CAACC,GAAN,CAAP;AACD;;AACD,YAAMD,IAAN;AACD;AACF;;AACD,SAAOS,gBAAP;AACD;;AACD,SAASd,OAAT,CAAiBpC,IAAjB,EAAuBQ,IAAvB,EAA6B;AAC3B,kBAAgB+C,YAAhB,CAA6BhD,MAA7B,EAAqC;AACnC,eAAW,MAAMkC,IAAjB,IAAyBlC,MAAzB,EAAiC;AAC/B,YAAMiD,SAAS,GAAG,EAAEf,IAAI,CAAChB,IAAL,IAAagB,IAAI,CAAChB,IAAL,CAAU2B,QAAV,CAAmB,GAAnB,CAAf,CAAlB;AACA,YAAMK,SAAS,GAAG,CAACjD,IAAI,CAACyB,GAAL,IAAY,IAAZ,GAAmB,IAAnB,GAA0BzB,IAAI,CAACyB,GAAhC,KAAwCuB,SAAxC,IAAqD,CAAChD,IAAI,CAAC8C,QAA7E;;AACA,UAAIG,SAAJ,EAAe;AACb,cAAMzD,IAAI,CAAC0D,IAAL,CAAUC,cAAV,CAAyBlB,IAAI,CAACC,GAA9B,CAAN;AACD;;AACD,YAAMD,IAAN;AACD;AACF;;AACD,SAAOc,YAAP;AACD;;AAEDvE,OAAO,CAACe,YAAR,GAAuBA,YAAvB","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar ipfsUnixfsImporter = require('ipfs-unixfs-importer');\nvar normaliseInputMultiple = require('ipfs-core-utils/files/normalise-input-multiple');\nvar utils = require('./utils.js');\nvar itPipe = require('it-pipe');\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\nvar mergeOpts = require('merge-options');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar mergeOpts__default = /*#__PURE__*/_interopDefaultLegacy(mergeOpts);\n\nconst mergeOptions = mergeOpts__default[\"default\"].bind({ ignoreUndefined: true });\nfunction createAddAll({repo, preload, hashers, options}) {\n  const isShardingEnabled = options && options.sharding;\n  async function* addAll(source, options = {}) {\n    const opts = mergeOptions({\n      shardSplitThreshold: isShardingEnabled ? 1000 : Infinity,\n      strategy: 'balanced'\n    }, options, { ...utils.parseChunkerString(options.chunker) });\n    if (opts.hashAlg && opts.hashAlg !== 'sha2-256' && opts.cidVersion !== 1) {\n      opts.cidVersion = 1;\n    }\n    if (opts.trickle) {\n      opts.strategy = 'trickle';\n    }\n    if (opts.strategy === 'trickle') {\n      opts.leafType = 'raw';\n      opts.reduceSingleLeafToSelf = false;\n    }\n    if (opts.cidVersion > 0 && opts.rawLeaves === undefined) {\n      opts.rawLeaves = true;\n    }\n    if (opts.hashAlg !== undefined && opts.rawLeaves === undefined) {\n      opts.rawLeaves = true;\n    }\n    delete opts.trickle;\n    const totals = {};\n    if (opts.progress) {\n      const prog = opts.progress;\n      opts.progress = (bytes, path) => {\n        if (!totals[path]) {\n          totals[path] = 0;\n        }\n        totals[path] += bytes;\n        prog(totals[path], path);\n      };\n    }\n    let hasher;\n    if (opts.hashAlg != null) {\n      hasher = await hashers.getHasher(opts.hashAlg);\n    }\n    const iterator = itPipe.pipe(normaliseInputMultiple.normaliseInput(source), source => ipfsUnixfsImporter.importer(source, repo.blocks, {\n      ...opts,\n      hasher,\n      pin: false\n    }), transformFile(opts), preloadFile(preload, opts), pinFile(repo, opts));\n    const releaseLock = await repo.gcLock.readLock();\n    try {\n      for await (const added of iterator) {\n        delete totals[added.path];\n        yield added;\n      }\n    } finally {\n      releaseLock();\n    }\n  }\n  return withTimeoutOption.withTimeoutOption(addAll);\n}\nfunction transformFile(opts) {\n  async function* transformFile(source) {\n    for await (const file of source) {\n      let cid = file.cid;\n      if (opts.cidVersion === 1) {\n        cid = cid.toV1();\n      }\n      let path = file.path ? file.path : cid.toString();\n      if (opts.wrapWithDirectory && !file.path) {\n        path = '';\n      }\n      yield {\n        path,\n        cid: cid,\n        size: file.size,\n        mode: file.unixfs && file.unixfs.mode,\n        mtime: file.unixfs && file.unixfs.mtime\n      };\n    }\n  }\n  return transformFile;\n}\nfunction preloadFile(preload, opts) {\n  async function* maybePreloadFile(source) {\n    for await (const file of source) {\n      const isRootFile = !file.path || opts.wrapWithDirectory ? file.path === '' : !file.path.includes('/');\n      const shouldPreload = isRootFile && !opts.onlyHash && opts.preload !== false;\n      if (shouldPreload) {\n        preload(file.cid);\n      }\n      yield file;\n    }\n  }\n  return maybePreloadFile;\n}\nfunction pinFile(repo, opts) {\n  async function* maybePinFile(source) {\n    for await (const file of source) {\n      const isRootDir = !(file.path && file.path.includes('/'));\n      const shouldPin = (opts.pin == null ? true : opts.pin) && isRootDir && !opts.onlyHash;\n      if (shouldPin) {\n        await repo.pins.pinRecursively(file.cid);\n      }\n      yield file;\n    }\n  }\n  return maybePinFile;\n}\n\nexports.createAddAll = createAddAll;\n"]},"metadata":{},"sourceType":"script"}