{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar nanoid = require('nanoid');\n\nvar toString = require('uint8arrays/to-string');\n\nvar fromString = require('uint8arrays/from-string');\n\nconst pathSepS = '/';\nconst pathSepB = new TextEncoder().encode(pathSepS);\nconst pathSep = pathSepB[0];\n\nclass Key {\n  constructor(s, clean) {\n    if (typeof s === 'string') {\n      this._buf = fromString.fromString(s);\n    } else if (s instanceof Uint8Array) {\n      this._buf = s;\n    } else {\n      throw new Error('Invalid key, should be String of Uint8Array');\n    }\n\n    if (clean == null) {\n      clean = true;\n    }\n\n    if (clean) {\n      this.clean();\n    }\n\n    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {\n      throw new Error('Invalid key');\n    }\n  }\n\n  toString() {\n    let encoding = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'utf8';\n    return toString.toString(this._buf, encoding);\n  }\n\n  uint8Array() {\n    return this._buf;\n  }\n\n  get [Symbol.toStringTag]() {\n    return `Key(${this.toString()})`;\n  }\n\n  static withNamespaces(list) {\n    return new Key(list.join(pathSepS));\n  }\n\n  static random() {\n    return new Key(nanoid.nanoid().replace(/-/g, ''));\n  }\n\n  static asKey(other) {\n    if (other instanceof Uint8Array || typeof other === 'string') {\n      return new Key(other);\n    }\n\n    if (other.uint8Array) {\n      return new Key(other.uint8Array());\n    }\n\n    return null;\n  }\n\n  clean() {\n    if (!this._buf || this._buf.byteLength === 0) {\n      this._buf = pathSepB;\n    }\n\n    if (this._buf[0] !== pathSep) {\n      const bytes = new Uint8Array(this._buf.byteLength + 1);\n      bytes.fill(pathSep, 0, 1);\n      bytes.set(this._buf, 1);\n      this._buf = bytes;\n    }\n\n    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {\n      this._buf = this._buf.subarray(0, -1);\n    }\n  }\n\n  less(key) {\n    const list1 = this.list();\n    const list2 = key.list();\n\n    for (let i = 0; i < list1.length; i++) {\n      if (list2.length < i + 1) {\n        return false;\n      }\n\n      const c1 = list1[i];\n      const c2 = list2[i];\n\n      if (c1 < c2) {\n        return true;\n      } else if (c1 > c2) {\n        return false;\n      }\n    }\n\n    return list1.length < list2.length;\n  }\n\n  reverse() {\n    return Key.withNamespaces(this.list().slice().reverse());\n  }\n\n  namespaces() {\n    return this.list();\n  }\n\n  baseNamespace() {\n    const ns = this.namespaces();\n    return ns[ns.length - 1];\n  }\n\n  list() {\n    return this.toString().split(pathSepS).slice(1);\n  }\n\n  type() {\n    return namespaceType(this.baseNamespace());\n  }\n\n  name() {\n    return namespaceValue(this.baseNamespace());\n  }\n\n  instance(s) {\n    return new Key(this.toString() + ':' + s);\n  }\n\n  path() {\n    let p = this.parent().toString();\n\n    if (!p.endsWith(pathSepS)) {\n      p += pathSepS;\n    }\n\n    p += this.type();\n    return new Key(p);\n  }\n\n  parent() {\n    const list = this.list();\n\n    if (list.length === 1) {\n      return new Key(pathSepS);\n    }\n\n    return new Key(list.slice(0, -1).join(pathSepS));\n  }\n\n  child(key) {\n    if (this.toString() === pathSepS) {\n      return key;\n    } else if (key.toString() === pathSepS) {\n      return this;\n    }\n\n    return new Key(this.toString() + key.toString(), false);\n  }\n\n  isAncestorOf(other) {\n    if (other.toString() === this.toString()) {\n      return false;\n    }\n\n    return other.toString().startsWith(this.toString());\n  }\n\n  isDecendantOf(other) {\n    if (other.toString() === this.toString()) {\n      return false;\n    }\n\n    return this.toString().startsWith(other.toString());\n  }\n\n  isTopLevel() {\n    return this.list().length === 1;\n  }\n\n  concat() {\n    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {\n      keys[_key] = arguments[_key];\n    }\n\n    return Key.withNamespaces([...this.namespaces(), ...flatten(keys.map(key => key.namespaces()))]);\n  }\n\n}\n\nfunction namespaceType(ns) {\n  const parts = ns.split(':');\n\n  if (parts.length < 2) {\n    return '';\n  }\n\n  return parts.slice(0, -1).join(':');\n}\n\nfunction namespaceValue(ns) {\n  const parts = ns.split(':');\n  return parts[parts.length - 1];\n}\n\nfunction flatten(arr) {\n  return [].concat(...arr);\n}\n\nexports.Key = Key;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/interface-datastore/cjs/src/key.js"],"names":["Object","defineProperty","exports","value","nanoid","require","toString","fromString","pathSepS","pathSepB","TextEncoder","encode","pathSep","Key","constructor","s","clean","_buf","Uint8Array","Error","byteLength","encoding","uint8Array","Symbol","toStringTag","withNamespaces","list","join","random","replace","asKey","other","bytes","fill","set","subarray","less","key","list1","list2","i","length","c1","c2","reverse","slice","namespaces","baseNamespace","ns","split","type","namespaceType","name","namespaceValue","instance","path","p","parent","endsWith","child","isAncestorOf","startsWith","isDecendantOf","isTopLevel","concat","keys","flatten","map","parts","arr"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar nanoid = require('nanoid');\nvar toString = require('uint8arrays/to-string');\nvar fromString = require('uint8arrays/from-string');\n\nconst pathSepS = '/';\nconst pathSepB = new TextEncoder().encode(pathSepS);\nconst pathSep = pathSepB[0];\nclass Key {\n  constructor(s, clean) {\n    if (typeof s === 'string') {\n      this._buf = fromString.fromString(s);\n    } else if (s instanceof Uint8Array) {\n      this._buf = s;\n    } else {\n      throw new Error('Invalid key, should be String of Uint8Array');\n    }\n    if (clean == null) {\n      clean = true;\n    }\n    if (clean) {\n      this.clean();\n    }\n    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {\n      throw new Error('Invalid key');\n    }\n  }\n  toString(encoding = 'utf8') {\n    return toString.toString(this._buf, encoding);\n  }\n  uint8Array() {\n    return this._buf;\n  }\n  get [Symbol.toStringTag]() {\n    return `Key(${ this.toString() })`;\n  }\n  static withNamespaces(list) {\n    return new Key(list.join(pathSepS));\n  }\n  static random() {\n    return new Key(nanoid.nanoid().replace(/-/g, ''));\n  }\n  static asKey(other) {\n    if (other instanceof Uint8Array || typeof other === 'string') {\n      return new Key(other);\n    }\n    if (other.uint8Array) {\n      return new Key(other.uint8Array());\n    }\n    return null;\n  }\n  clean() {\n    if (!this._buf || this._buf.byteLength === 0) {\n      this._buf = pathSepB;\n    }\n    if (this._buf[0] !== pathSep) {\n      const bytes = new Uint8Array(this._buf.byteLength + 1);\n      bytes.fill(pathSep, 0, 1);\n      bytes.set(this._buf, 1);\n      this._buf = bytes;\n    }\n    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {\n      this._buf = this._buf.subarray(0, -1);\n    }\n  }\n  less(key) {\n    const list1 = this.list();\n    const list2 = key.list();\n    for (let i = 0; i < list1.length; i++) {\n      if (list2.length < i + 1) {\n        return false;\n      }\n      const c1 = list1[i];\n      const c2 = list2[i];\n      if (c1 < c2) {\n        return true;\n      } else if (c1 > c2) {\n        return false;\n      }\n    }\n    return list1.length < list2.length;\n  }\n  reverse() {\n    return Key.withNamespaces(this.list().slice().reverse());\n  }\n  namespaces() {\n    return this.list();\n  }\n  baseNamespace() {\n    const ns = this.namespaces();\n    return ns[ns.length - 1];\n  }\n  list() {\n    return this.toString().split(pathSepS).slice(1);\n  }\n  type() {\n    return namespaceType(this.baseNamespace());\n  }\n  name() {\n    return namespaceValue(this.baseNamespace());\n  }\n  instance(s) {\n    return new Key(this.toString() + ':' + s);\n  }\n  path() {\n    let p = this.parent().toString();\n    if (!p.endsWith(pathSepS)) {\n      p += pathSepS;\n    }\n    p += this.type();\n    return new Key(p);\n  }\n  parent() {\n    const list = this.list();\n    if (list.length === 1) {\n      return new Key(pathSepS);\n    }\n    return new Key(list.slice(0, -1).join(pathSepS));\n  }\n  child(key) {\n    if (this.toString() === pathSepS) {\n      return key;\n    } else if (key.toString() === pathSepS) {\n      return this;\n    }\n    return new Key(this.toString() + key.toString(), false);\n  }\n  isAncestorOf(other) {\n    if (other.toString() === this.toString()) {\n      return false;\n    }\n    return other.toString().startsWith(this.toString());\n  }\n  isDecendantOf(other) {\n    if (other.toString() === this.toString()) {\n      return false;\n    }\n    return this.toString().startsWith(other.toString());\n  }\n  isTopLevel() {\n    return this.list().length === 1;\n  }\n  concat(...keys) {\n    return Key.withNamespaces([\n      ...this.namespaces(),\n      ...flatten(keys.map(key => key.namespaces()))\n    ]);\n  }\n}\nfunction namespaceType(ns) {\n  const parts = ns.split(':');\n  if (parts.length < 2) {\n    return '';\n  }\n  return parts.slice(0, -1).join(':');\n}\nfunction namespaceValue(ns) {\n  const parts = ns.split(':');\n  return parts[parts.length - 1];\n}\nfunction flatten(arr) {\n  return [].concat(...arr);\n}\n\nexports.Key = Key;\n"]},"metadata":{},"sourceType":"script"}