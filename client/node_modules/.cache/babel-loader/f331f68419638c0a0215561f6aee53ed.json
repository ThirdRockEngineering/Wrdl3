{"ast":null,"code":"'use strict';\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst errcode = require('err-code');\n\nconst {\n  Message\n} = require('../../message');\n\nconst utils = require('../../utils');\n\nconst log = utils.logger('libp2p:kad-dht:rpc:handlers:get-providers');\n\nconst {\n  removePrivateAddresses,\n  removePublicAddresses\n} = require('../../utils');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../types').DHTMessageHandler} DHTMessageHandler\n * @typedef {import('../../types').PeerData} PeerData\n */\n\n/**\n * @implements {DHTMessageHandler}\n */\n\n\nclass GetProvidersHandler {\n  /**\n   * @param {object} params\n   * @param {PeerId} params.peerId\n   * @param {import('../../peer-routing').PeerRouting} params.peerRouting\n   * @param {import('../../providers').Providers} params.providers\n   * @param {import('libp2p/src/peer-store/types').PeerStore} params.peerStore\n   * @param {import('../../types').Addressable} params.addressable\n   * @param {boolean} [params.lan]\n   */\n  constructor(_ref) {\n    let {\n      peerId,\n      peerRouting,\n      providers,\n      peerStore,\n      addressable,\n      lan\n    } = _ref;\n    this._peerId = peerId;\n    this._peerRouting = peerRouting;\n    this._providers = providers;\n    this._peerStore = peerStore;\n    this._addressable = addressable;\n    this._lan = Boolean(lan);\n  }\n  /**\n   * Process `GetProviders` DHT messages.\n   *\n   * @param {PeerId} peerId\n   * @param {Message} msg\n   */\n\n\n  async handle(peerId, msg) {\n    let cid;\n\n    try {\n      cid = CID.decode(msg.key);\n    } catch (\n    /** @type {any} */\n    err) {\n      throw errcode(new Error(`Invalid CID: ${err.message}`), 'ERR_INVALID_CID');\n    }\n\n    log('%p asking for providers for %s', peerId, cid);\n    const [peers, closer] = await Promise.all([this._providers.getProviders(cid), this._peerRouting.getCloserPeersOffline(msg.key, peerId)]);\n    const providerPeers = await this._getPeers(peers);\n    const closerPeers = await this._getPeers(closer.map(_ref2 => {\n      let {\n        id\n      } = _ref2;\n      return id;\n    }));\n    const response = new Message(msg.type, msg.key, msg.clusterLevel);\n\n    if (providerPeers.length > 0) {\n      response.providerPeers = providerPeers;\n    }\n\n    if (closerPeers.length > 0) {\n      response.closerPeers = closerPeers;\n    }\n\n    log('got %s providers %s closerPeers', providerPeers.length, closerPeers.length);\n    return response;\n  }\n  /**\n   * @param {PeerId} peerId\n   */\n\n\n  async _getAddresses(peerId) {\n    return this._peerId.equals(peerId) ? this._addressable.multiaddrs : ((await this._peerStore.addressBook.get(peerId)) || []).map(address => address.multiaddr);\n  }\n  /**\n   * @param {PeerId[]} peerIds\n   */\n\n\n  async _getPeers(peerIds) {\n    /** @type {PeerData[]} */\n    const output = [];\n    const addrFilter = this._lan ? removePublicAddresses : removePrivateAddresses;\n\n    for (const peerId of peerIds) {\n      const peer = addrFilter({\n        id: peerId,\n        multiaddrs: await this._getAddresses(peerId)\n      });\n\n      if (peer.multiaddrs.length) {\n        output.push(peer);\n      }\n    }\n\n    return output;\n  }\n\n}\n\nmodule.exports.GetProvidersHandler = GetProvidersHandler;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p-kad-dht/src/rpc/handlers/get-providers.js"],"names":["CID","require","errcode","Message","utils","log","logger","removePrivateAddresses","removePublicAddresses","GetProvidersHandler","constructor","peerId","peerRouting","providers","peerStore","addressable","lan","_peerId","_peerRouting","_providers","_peerStore","_addressable","_lan","Boolean","handle","msg","cid","decode","key","err","Error","message","peers","closer","Promise","all","getProviders","getCloserPeersOffline","providerPeers","_getPeers","closerPeers","map","id","response","type","clusterLevel","length","_getAddresses","equals","multiaddrs","addressBook","get","address","multiaddr","peerIds","output","addrFilter","peer","push","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { CID } = require('multiformats/cid')\nconst errcode = require('err-code')\nconst { Message } = require('../../message')\nconst utils = require('../../utils')\nconst log = utils.logger('libp2p:kad-dht:rpc:handlers:get-providers')\nconst {\n  removePrivateAddresses,\n  removePublicAddresses\n} = require('../../utils')\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../types').DHTMessageHandler} DHTMessageHandler\n * @typedef {import('../../types').PeerData} PeerData\n */\n\n/**\n * @implements {DHTMessageHandler}\n */\nclass GetProvidersHandler {\n  /**\n   * @param {object} params\n   * @param {PeerId} params.peerId\n   * @param {import('../../peer-routing').PeerRouting} params.peerRouting\n   * @param {import('../../providers').Providers} params.providers\n   * @param {import('libp2p/src/peer-store/types').PeerStore} params.peerStore\n   * @param {import('../../types').Addressable} params.addressable\n   * @param {boolean} [params.lan]\n   */\n  constructor ({ peerId, peerRouting, providers, peerStore, addressable, lan }) {\n    this._peerId = peerId\n    this._peerRouting = peerRouting\n    this._providers = providers\n    this._peerStore = peerStore\n    this._addressable = addressable\n    this._lan = Boolean(lan)\n  }\n\n  /**\n   * Process `GetProviders` DHT messages.\n   *\n   * @param {PeerId} peerId\n   * @param {Message} msg\n   */\n  async handle (peerId, msg) {\n    let cid\n    try {\n      cid = CID.decode(msg.key)\n    } catch (/** @type {any} */ err) {\n      throw errcode(new Error(`Invalid CID: ${err.message}`), 'ERR_INVALID_CID')\n    }\n\n    log('%p asking for providers for %s', peerId, cid)\n\n    const [peers, closer] = await Promise.all([\n      this._providers.getProviders(cid),\n      this._peerRouting.getCloserPeersOffline(msg.key, peerId)\n    ])\n\n    const providerPeers = await this._getPeers(peers)\n    const closerPeers = await this._getPeers(closer.map(({ id }) => id))\n    const response = new Message(msg.type, msg.key, msg.clusterLevel)\n\n    if (providerPeers.length > 0) {\n      response.providerPeers = providerPeers\n    }\n\n    if (closerPeers.length > 0) {\n      response.closerPeers = closerPeers\n    }\n\n    log('got %s providers %s closerPeers', providerPeers.length, closerPeers.length)\n    return response\n  }\n\n  /**\n   * @param {PeerId} peerId\n   */\n  async _getAddresses (peerId) {\n    return this._peerId.equals(peerId) ? this._addressable.multiaddrs : (await (this._peerStore.addressBook.get(peerId)) || []).map(address => address.multiaddr)\n  }\n\n  /**\n   * @param {PeerId[]} peerIds\n   */\n  async _getPeers (peerIds) {\n    /** @type {PeerData[]} */\n    const output = []\n    const addrFilter = this._lan ? removePublicAddresses : removePrivateAddresses\n\n    for (const peerId of peerIds) {\n      const peer = addrFilter({\n        id: peerId,\n        multiaddrs: await this._getAddresses(peerId)\n      })\n\n      if (peer.multiaddrs.length) {\n        output.push(peer)\n      }\n    }\n\n    return output\n  }\n}\n\nmodule.exports.GetProvidersHandler = GetProvidersHandler\n"]},"metadata":{},"sourceType":"script"}