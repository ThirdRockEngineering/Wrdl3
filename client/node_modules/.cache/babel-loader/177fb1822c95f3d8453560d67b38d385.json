{"ast":null,"code":"'use strict';\n\nconst {\n  Message\n} = require('../../message');\n\nconst utils = require('../../utils');\n\nconst log = utils.logger('libp2p:kad-dht:rpc:handlers:find-node');\n\nconst {\n  removePrivateAddresses,\n  removePublicAddresses\n} = require('../../utils');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../types').DHTMessageHandler} DHTMessageHandler\n */\n\n/**\n * @implements {DHTMessageHandler}\n */\n\n\nclass FindNodeHandler {\n  /**\n   * @param {object} params\n   * @param {PeerId} params.peerId\n   * @param {import('../../types').Addressable} params.addressable\n   * @param {import('../../peer-routing').PeerRouting} params.peerRouting\n   * @param {boolean} [params.lan]\n   */\n  constructor(_ref) {\n    let {\n      peerId,\n      addressable,\n      peerRouting,\n      lan\n    } = _ref;\n    this._peerId = peerId;\n    this._addressable = addressable;\n    this._peerRouting = peerRouting;\n    this._lan = Boolean(lan);\n  }\n  /**\n   * Process `FindNode` DHT messages\n   *\n   * @param {PeerId} peerId\n   * @param {Message} msg\n   */\n\n\n  async handle(peerId, msg) {\n    log('incoming request from %p for peers closer to %b', peerId, msg.key);\n    let closer;\n\n    if (this._peerId.equals(msg.key)) {\n      closer = [{\n        id: this._peerId,\n        multiaddrs: this._addressable.multiaddrs\n      }];\n    } else {\n      closer = await this._peerRouting.getCloserPeersOffline(msg.key, peerId);\n    }\n\n    closer = closer.map(this._lan ? removePublicAddresses : removePrivateAddresses).filter(_ref2 => {\n      let {\n        multiaddrs\n      } = _ref2;\n      return multiaddrs.length;\n    });\n    const response = new Message(msg.type, new Uint8Array(0), msg.clusterLevel);\n\n    if (closer.length > 0) {\n      response.closerPeers = closer;\n    } else {\n      log('could not find any peers closer to %p', peerId);\n    }\n\n    return response;\n  }\n\n}\n\nmodule.exports.FindNodeHandler = FindNodeHandler;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p-kad-dht/src/rpc/handlers/find-node.js"],"names":["Message","require","utils","log","logger","removePrivateAddresses","removePublicAddresses","FindNodeHandler","constructor","peerId","addressable","peerRouting","lan","_peerId","_addressable","_peerRouting","_lan","Boolean","handle","msg","key","closer","equals","id","multiaddrs","getCloserPeersOffline","map","filter","length","response","type","Uint8Array","clusterLevel","closerPeers","module","exports"],"mappings":"AAAA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAcC,OAAO,CAAC,eAAD,CAA3B;;AACA,MAAMC,KAAK,GAAGD,OAAO,CAAC,aAAD,CAArB;;AACA,MAAME,GAAG,GAAGD,KAAK,CAACE,MAAN,CAAa,uCAAb,CAAZ;;AACA,MAAM;AACJC,EAAAA,sBADI;AAEJC,EAAAA;AAFI,IAGFL,OAAO,CAAC,aAAD,CAHX;AAKA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AACA,MAAMM,eAAN,CAAsB;AACpB;AACF;AACA;AACA;AACA;AACA;AACA;AACEC,EAAAA,WAAW,OAA6C;AAAA,QAA3C;AAAEC,MAAAA,MAAF;AAAUC,MAAAA,WAAV;AAAuBC,MAAAA,WAAvB;AAAoCC,MAAAA;AAApC,KAA2C;AACtD,SAAKC,OAAL,GAAeJ,MAAf;AACA,SAAKK,YAAL,GAAoBJ,WAApB;AACA,SAAKK,YAAL,GAAoBJ,WAApB;AACA,SAAKK,IAAL,GAAYC,OAAO,CAACL,GAAD,CAAnB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACc,QAANM,MAAM,CAAET,MAAF,EAAUU,GAAV,EAAe;AACzBhB,IAAAA,GAAG,CAAC,iDAAD,EAAoDM,MAApD,EAA4DU,GAAG,CAACC,GAAhE,CAAH;AAEA,QAAIC,MAAJ;;AACA,QAAI,KAAKR,OAAL,CAAaS,MAAb,CAAoBH,GAAG,CAACC,GAAxB,CAAJ,EAAkC;AAChCC,MAAAA,MAAM,GAAG,CAAC;AACRE,QAAAA,EAAE,EAAE,KAAKV,OADD;AAERW,QAAAA,UAAU,EAAE,KAAKV,YAAL,CAAkBU;AAFtB,OAAD,CAAT;AAID,KALD,MAKO;AACLH,MAAAA,MAAM,GAAG,MAAM,KAAKN,YAAL,CAAkBU,qBAAlB,CAAwCN,GAAG,CAACC,GAA5C,EAAiDX,MAAjD,CAAf;AACD;;AAEDY,IAAAA,MAAM,GAAGA,MAAM,CACZK,GADM,CACF,KAAKV,IAAL,GAAYV,qBAAZ,GAAoCD,sBADlC,EAENsB,MAFM,CAEC;AAAA,UAAC;AAAEH,QAAAA;AAAF,OAAD;AAAA,aAAoBA,UAAU,CAACI,MAA/B;AAAA,KAFD,CAAT;AAIA,UAAMC,QAAQ,GAAG,IAAI7B,OAAJ,CAAYmB,GAAG,CAACW,IAAhB,EAAsB,IAAIC,UAAJ,CAAe,CAAf,CAAtB,EAAyCZ,GAAG,CAACa,YAA7C,CAAjB;;AAEA,QAAIX,MAAM,CAACO,MAAP,GAAgB,CAApB,EAAuB;AACrBC,MAAAA,QAAQ,CAACI,WAAT,GAAuBZ,MAAvB;AACD,KAFD,MAEO;AACLlB,MAAAA,GAAG,CAAC,uCAAD,EAA0CM,MAA1C,CAAH;AACD;;AAED,WAAOoB,QAAP;AACD;;AA/CmB;;AAkDtBK,MAAM,CAACC,OAAP,CAAe5B,eAAf,GAAiCA,eAAjC","sourcesContent":["'use strict'\n\nconst { Message } = require('../../message')\nconst utils = require('../../utils')\nconst log = utils.logger('libp2p:kad-dht:rpc:handlers:find-node')\nconst {\n  removePrivateAddresses,\n  removePublicAddresses\n} = require('../../utils')\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../types').DHTMessageHandler} DHTMessageHandler\n */\n\n/**\n * @implements {DHTMessageHandler}\n */\nclass FindNodeHandler {\n  /**\n   * @param {object} params\n   * @param {PeerId} params.peerId\n   * @param {import('../../types').Addressable} params.addressable\n   * @param {import('../../peer-routing').PeerRouting} params.peerRouting\n   * @param {boolean} [params.lan]\n   */\n  constructor ({ peerId, addressable, peerRouting, lan }) {\n    this._peerId = peerId\n    this._addressable = addressable\n    this._peerRouting = peerRouting\n    this._lan = Boolean(lan)\n  }\n\n  /**\n   * Process `FindNode` DHT messages\n   *\n   * @param {PeerId} peerId\n   * @param {Message} msg\n   */\n  async handle (peerId, msg) {\n    log('incoming request from %p for peers closer to %b', peerId, msg.key)\n\n    let closer\n    if (this._peerId.equals(msg.key)) {\n      closer = [{\n        id: this._peerId,\n        multiaddrs: this._addressable.multiaddrs\n      }]\n    } else {\n      closer = await this._peerRouting.getCloserPeersOffline(msg.key, peerId)\n    }\n\n    closer = closer\n      .map(this._lan ? removePublicAddresses : removePrivateAddresses)\n      .filter(({ multiaddrs }) => multiaddrs.length)\n\n    const response = new Message(msg.type, new Uint8Array(0), msg.clusterLevel)\n\n    if (closer.length > 0) {\n      response.closerPeers = closer\n    } else {\n      log('could not find any peers closer to %p', peerId)\n    }\n\n    return response\n  }\n}\n\nmodule.exports.FindNodeHandler = FindNodeHandler\n"]},"metadata":{},"sourceType":"script"}