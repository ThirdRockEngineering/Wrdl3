{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar cid = require('multiformats/cid');\n\nvar pin = require('./pin.js');\n\nvar fnv1a = require('fnv1a');\n\nvar varint = require('varint');\n\nvar dagPb = require('@ipld/dag-pb');\n\nvar utils = require('./utils.js');\n\nvar concat = require('uint8arrays/concat');\n\nvar compare = require('uint8arrays/compare');\n\nvar toString = require('uint8arrays/to-string');\n\nvar fromString = require('uint8arrays/from-string');\n\nvar sha2 = require('multiformats/hashes/sha2');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar fnv1a__default = /*#__PURE__*/_interopDefaultLegacy(fnv1a);\n\nvar varint__default = /*#__PURE__*/_interopDefaultLegacy(varint);\n\nvar dagPb__namespace = /*#__PURE__*/_interopNamespace(dagPb);\n\nconst PinSet = pin.ipfs.pin.Set;\n\nfunction readHeader(rootNode) {\n  const rootData = rootNode.Data;\n\n  if (!rootData) {\n    throw new Error('No data present');\n  }\n\n  const hdrLength = varint__default[\"default\"].decode(rootData);\n  const vBytes = varint__default[\"default\"].decode.bytes;\n\n  if (vBytes <= 0) {\n    throw new Error('Invalid Set header length');\n  }\n\n  if (vBytes + hdrLength > rootData.length) {\n    throw new Error('Impossibly large set header length');\n  }\n\n  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes);\n  const header = PinSet.toObject(PinSet.decode(hdrSlice), {\n    defaults: false,\n    arrays: true,\n    longs: Number,\n    objects: false\n  });\n\n  if (header.version !== 1) {\n    throw new Error(`Unsupported Set version: ${header.version}`);\n  }\n\n  if (header.fanout > rootNode.Links.length) {\n    throw new Error('Impossibly large fanout');\n  }\n\n  return {\n    header: header,\n    data: rootData.slice(hdrLength + vBytes)\n  };\n}\n\nfunction hash(seed, key) {\n  const buffer = new Uint8Array(4);\n  const dataView = new DataView(buffer.buffer);\n  dataView.setUint32(0, seed, true);\n  const encodedKey = fromString.fromString(key.toString());\n  const data = concat.concat([buffer, encodedKey], buffer.byteLength + encodedKey.byteLength);\n  return fnv1a__default[\"default\"](toString.toString(data));\n}\n\nasync function* walkItems(blockstore, node) {\n  const pbh = readHeader(node);\n  let idx = 0;\n\n  for (const link of node.Links) {\n    if (idx < pbh.header.fanout) {\n      const linkHash = link.Hash;\n\n      if (!utils.EMPTY_KEY.equals(linkHash)) {\n        const buf = await blockstore.get(linkHash);\n        const node = dagPb__namespace.decode(buf);\n        yield* walkItems(blockstore, node);\n      }\n    } else {\n      yield link.Hash;\n    }\n\n    idx++;\n  }\n}\n\nasync function* loadSet(blockstore, rootNode, name) {\n  const link = rootNode.Links.find(l => l.Name === name);\n\n  if (!link) {\n    throw new Error('No link found with name ' + name);\n  }\n\n  const buf = await blockstore.get(link.Hash);\n  const node = dagPb__namespace.decode(buf);\n  yield* walkItems(blockstore, node);\n}\n\nfunction storeItems(blockstore, items) {\n  return storePins(items, 0);\n\n  async function storePins(pins, depth) {\n    const pbHeader = PinSet.encode({\n      version: 1,\n      fanout: utils.DEFAULT_FANOUT,\n      seed: depth\n    }).finish();\n    const header = varint__default[\"default\"].encode(pbHeader.length);\n    const headerBuf = concat.concat([header, pbHeader]);\n    const fanoutLinks = [];\n\n    for (let i = 0; i < utils.DEFAULT_FANOUT; i++) {\n      fanoutLinks.push({\n        Name: '',\n        Tsize: 1,\n        Hash: utils.EMPTY_KEY\n      });\n    }\n\n    if (pins.length <= utils.MAX_ITEMS) {\n      const nodes = pins.map(item => {\n        return {\n          link: {\n            Name: '',\n            Tsize: 1,\n            Hash: item.key\n          },\n          data: item.data || new Uint8Array()\n        };\n      }).sort((a, b) => {\n        return compare.compare(a.link.Hash.bytes, b.link.Hash.bytes);\n      });\n      const rootLinks = fanoutLinks.concat(nodes.map(item => item.link));\n      const rootData = concat.concat([headerBuf, ...nodes.map(item => item.data)]);\n      return {\n        Data: rootData,\n        Links: rootLinks\n      };\n    } else {\n      const bins = pins.reduce((bins, pin) => {\n        const n = hash(depth, pin.key) % utils.DEFAULT_FANOUT;\n        bins[n] = n in bins ? bins[n].concat([pin]) : [pin];\n        return bins;\n      }, []);\n      let idx = 0;\n\n      for (const bin of bins) {\n        const child = await storePins(bin, depth + 1);\n        await storeChild(child, idx);\n        idx++;\n      }\n\n      return {\n        Data: headerBuf,\n        Links: fanoutLinks\n      };\n    }\n\n    async function storeChild(child, binIdx) {\n      const buf = dagPb__namespace.encode(child);\n      const digest = await sha2.sha256.digest(buf);\n      const cid$1 = cid.CID.createV0(digest);\n      await blockstore.put(cid$1, buf);\n      const size = child.Links.reduce((acc, curr) => acc + (curr.Tsize || 0), 0) + buf.length;\n      fanoutLinks[binIdx] = {\n        Name: '',\n        Tsize: size,\n        Hash: cid$1\n      };\n    }\n  }\n}\n\nasync function storeSet(blockstore, type, cids) {\n  const rootNode = await storeItems(blockstore, cids.map(cid => {\n    return {\n      key: cid\n    };\n  }));\n  const buf = dagPb__namespace.encode(rootNode);\n  const digest = await sha2.sha256.digest(buf);\n  const cid$1 = cid.CID.createV0(digest);\n  await blockstore.put(cid$1, buf);\n  const size = rootNode.Links.reduce((acc, curr) => acc + curr.Tsize, 0) + buf.length;\n  return {\n    Name: type,\n    Tsize: size,\n    Hash: cid$1\n  };\n}\n\nexports.loadSet = loadSet;\nexports.storeSet = storeSet;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-repo-migrations/cjs/migrations/migration-9/pin-set.js"],"names":["Object","defineProperty","exports","value","cid","require","pin","fnv1a","varint","dagPb","utils","concat","compare","toString","fromString","sha2","_interopDefaultLegacy","e","_interopNamespace","__esModule","n","create","keys","forEach","k","d","getOwnPropertyDescriptor","get","enumerable","freeze","fnv1a__default","varint__default","dagPb__namespace","PinSet","ipfs","Set","readHeader","rootNode","rootData","Data","Error","hdrLength","decode","vBytes","bytes","length","hdrSlice","slice","header","toObject","defaults","arrays","longs","Number","objects","version","fanout","Links","data","hash","seed","key","buffer","Uint8Array","dataView","DataView","setUint32","encodedKey","byteLength","walkItems","blockstore","node","pbh","idx","link","linkHash","Hash","EMPTY_KEY","equals","buf","loadSet","name","find","l","Name","storeItems","items","storePins","pins","depth","pbHeader","encode","DEFAULT_FANOUT","finish","headerBuf","fanoutLinks","i","push","Tsize","MAX_ITEMS","nodes","map","item","sort","a","b","rootLinks","bins","reduce","bin","child","storeChild","binIdx","digest","sha256","cid$1","CID","createV0","put","size","acc","curr","storeSet","type","cids"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AAEA,IAAIC,GAAG,GAAGC,OAAO,CAAC,kBAAD,CAAjB;;AACA,IAAIC,GAAG,GAAGD,OAAO,CAAC,UAAD,CAAjB;;AACA,IAAIE,KAAK,GAAGF,OAAO,CAAC,OAAD,CAAnB;;AACA,IAAIG,MAAM,GAAGH,OAAO,CAAC,QAAD,CAApB;;AACA,IAAII,KAAK,GAAGJ,OAAO,CAAC,cAAD,CAAnB;;AACA,IAAIK,KAAK,GAAGL,OAAO,CAAC,YAAD,CAAnB;;AACA,IAAIM,MAAM,GAAGN,OAAO,CAAC,oBAAD,CAApB;;AACA,IAAIO,OAAO,GAAGP,OAAO,CAAC,qBAAD,CAArB;;AACA,IAAIQ,QAAQ,GAAGR,OAAO,CAAC,uBAAD,CAAtB;;AACA,IAAIS,UAAU,GAAGT,OAAO,CAAC,yBAAD,CAAxB;;AACA,IAAIU,IAAI,GAAGV,OAAO,CAAC,0BAAD,CAAlB;;AAEA,SAASW,qBAAT,CAAgCC,CAAhC,EAAmC;AAAE,SAAOA,CAAC,IAAI,OAAOA,CAAP,KAAa,QAAlB,IAA8B,aAAaA,CAA3C,GAA+CA,CAA/C,GAAmD;AAAE,eAAWA;AAAb,GAA1D;AAA6E;;AAElH,SAASC,iBAAT,CAA2BD,CAA3B,EAA8B;AAC5B,MAAIA,CAAC,IAAIA,CAAC,CAACE,UAAX,EAAuB,OAAOF,CAAP;AACvB,MAAIG,CAAC,GAAGpB,MAAM,CAACqB,MAAP,CAAc,IAAd,CAAR;;AACA,MAAIJ,CAAJ,EAAO;AACLjB,IAAAA,MAAM,CAACsB,IAAP,CAAYL,CAAZ,EAAeM,OAAf,CAAuB,UAAUC,CAAV,EAAa;AAClC,UAAIA,CAAC,KAAK,SAAV,EAAqB;AACnB,YAAIC,CAAC,GAAGzB,MAAM,CAAC0B,wBAAP,CAAgCT,CAAhC,EAAmCO,CAAnC,CAAR;AACAxB,QAAAA,MAAM,CAACC,cAAP,CAAsBmB,CAAtB,EAAyBI,CAAzB,EAA4BC,CAAC,CAACE,GAAF,GAAQF,CAAR,GAAY;AACtCG,UAAAA,UAAU,EAAE,IAD0B;AAEtCD,UAAAA,GAAG,EAAE,YAAY;AAAE,mBAAOV,CAAC,CAACO,CAAD,CAAR;AAAc;AAFK,SAAxC;AAID;AACF,KARD;AASD;;AACDJ,EAAAA,CAAC,CAAC,SAAD,CAAD,GAAeH,CAAf;AACA,SAAOjB,MAAM,CAAC6B,MAAP,CAAcT,CAAd,CAAP;AACD;;AAED,IAAIU,cAAc,GAAG,aAAad,qBAAqB,CAACT,KAAD,CAAvD;;AACA,IAAIwB,eAAe,GAAG,aAAaf,qBAAqB,CAACR,MAAD,CAAxD;;AACA,IAAIwB,gBAAgB,GAAG,aAAad,iBAAiB,CAACT,KAAD,CAArD;;AAEA,MAAMwB,MAAM,GAAG3B,GAAG,CAAC4B,IAAJ,CAAS5B,GAAT,CAAa6B,GAA5B;;AACA,SAASC,UAAT,CAAoBC,QAApB,EAA8B;AAC5B,QAAMC,QAAQ,GAAGD,QAAQ,CAACE,IAA1B;;AACA,MAAI,CAACD,QAAL,EAAe;AACb,UAAM,IAAIE,KAAJ,CAAU,iBAAV,CAAN;AACD;;AACD,QAAMC,SAAS,GAAGV,eAAe,CAAC,SAAD,CAAf,CAA2BW,MAA3B,CAAkCJ,QAAlC,CAAlB;AACA,QAAMK,MAAM,GAAGZ,eAAe,CAAC,SAAD,CAAf,CAA2BW,MAA3B,CAAkCE,KAAjD;;AACA,MAAID,MAAM,IAAI,CAAd,EAAiB;AACf,UAAM,IAAIH,KAAJ,CAAU,2BAAV,CAAN;AACD;;AACD,MAAIG,MAAM,GAAGF,SAAT,GAAqBH,QAAQ,CAACO,MAAlC,EAA0C;AACxC,UAAM,IAAIL,KAAJ,CAAU,oCAAV,CAAN;AACD;;AACD,QAAMM,QAAQ,GAAGR,QAAQ,CAACS,KAAT,CAAeJ,MAAf,EAAuBF,SAAS,GAAGE,MAAnC,CAAjB;AACA,QAAMK,MAAM,GAAGf,MAAM,CAACgB,QAAP,CAAgBhB,MAAM,CAACS,MAAP,CAAcI,QAAd,CAAhB,EAAyC;AACtDI,IAAAA,QAAQ,EAAE,KAD4C;AAEtDC,IAAAA,MAAM,EAAE,IAF8C;AAGtDC,IAAAA,KAAK,EAAEC,MAH+C;AAItDC,IAAAA,OAAO,EAAE;AAJ6C,GAAzC,CAAf;;AAMA,MAAIN,MAAM,CAACO,OAAP,KAAmB,CAAvB,EAA0B;AACxB,UAAM,IAAIf,KAAJ,CAAW,4BAA4BQ,MAAM,CAACO,OAAS,EAAvD,CAAN;AACD;;AACD,MAAIP,MAAM,CAACQ,MAAP,GAAgBnB,QAAQ,CAACoB,KAAT,CAAeZ,MAAnC,EAA2C;AACzC,UAAM,IAAIL,KAAJ,CAAU,yBAAV,CAAN;AACD;;AACD,SAAO;AACLQ,IAAAA,MAAM,EAAEA,MADH;AAELU,IAAAA,IAAI,EAAEpB,QAAQ,CAACS,KAAT,CAAeN,SAAS,GAAGE,MAA3B;AAFD,GAAP;AAID;;AACD,SAASgB,IAAT,CAAcC,IAAd,EAAoBC,GAApB,EAAyB;AACvB,QAAMC,MAAM,GAAG,IAAIC,UAAJ,CAAe,CAAf,CAAf;AACA,QAAMC,QAAQ,GAAG,IAAIC,QAAJ,CAAaH,MAAM,CAACA,MAApB,CAAjB;AACAE,EAAAA,QAAQ,CAACE,SAAT,CAAmB,CAAnB,EAAsBN,IAAtB,EAA4B,IAA5B;AACA,QAAMO,UAAU,GAAGrD,UAAU,CAACA,UAAX,CAAsB+C,GAAG,CAAChD,QAAJ,EAAtB,CAAnB;AACA,QAAM6C,IAAI,GAAG/C,MAAM,CAACA,MAAP,CAAc,CACzBmD,MADyB,EAEzBK,UAFyB,CAAd,EAGVL,MAAM,CAACM,UAAP,GAAoBD,UAAU,CAACC,UAHrB,CAAb;AAIA,SAAOtC,cAAc,CAAC,SAAD,CAAd,CAA0BjB,QAAQ,CAACA,QAAT,CAAkB6C,IAAlB,CAA1B,CAAP;AACD;;AACD,gBAAgBW,SAAhB,CAA0BC,UAA1B,EAAsCC,IAAtC,EAA4C;AAC1C,QAAMC,GAAG,GAAGpC,UAAU,CAACmC,IAAD,CAAtB;AACA,MAAIE,GAAG,GAAG,CAAV;;AACA,OAAK,MAAMC,IAAX,IAAmBH,IAAI,CAACd,KAAxB,EAA+B;AAC7B,QAAIgB,GAAG,GAAGD,GAAG,CAACxB,MAAJ,CAAWQ,MAArB,EAA6B;AAC3B,YAAMmB,QAAQ,GAAGD,IAAI,CAACE,IAAtB;;AACA,UAAI,CAAClE,KAAK,CAACmE,SAAN,CAAgBC,MAAhB,CAAuBH,QAAvB,CAAL,EAAuC;AACrC,cAAMI,GAAG,GAAG,MAAMT,UAAU,CAAC3C,GAAX,CAAegD,QAAf,CAAlB;AACA,cAAMJ,IAAI,GAAGvC,gBAAgB,CAACU,MAAjB,CAAwBqC,GAAxB,CAAb;AACA,eAAOV,SAAS,CAACC,UAAD,EAAaC,IAAb,CAAhB;AACD;AACF,KAPD,MAOO;AACL,YAAMG,IAAI,CAACE,IAAX;AACD;;AACDH,IAAAA,GAAG;AACJ;AACF;;AACD,gBAAgBO,OAAhB,CAAwBV,UAAxB,EAAoCjC,QAApC,EAA8C4C,IAA9C,EAAoD;AAClD,QAAMP,IAAI,GAAGrC,QAAQ,CAACoB,KAAT,CAAeyB,IAAf,CAAoBC,CAAC,IAAIA,CAAC,CAACC,IAAF,KAAWH,IAApC,CAAb;;AACA,MAAI,CAACP,IAAL,EAAW;AACT,UAAM,IAAIlC,KAAJ,CAAU,6BAA6ByC,IAAvC,CAAN;AACD;;AACD,QAAMF,GAAG,GAAG,MAAMT,UAAU,CAAC3C,GAAX,CAAe+C,IAAI,CAACE,IAApB,CAAlB;AACA,QAAML,IAAI,GAAGvC,gBAAgB,CAACU,MAAjB,CAAwBqC,GAAxB,CAAb;AACA,SAAOV,SAAS,CAACC,UAAD,EAAaC,IAAb,CAAhB;AACD;;AACD,SAASc,UAAT,CAAoBf,UAApB,EAAgCgB,KAAhC,EAAuC;AACrC,SAAOC,SAAS,CAACD,KAAD,EAAQ,CAAR,CAAhB;;AACA,iBAAeC,SAAf,CAAyBC,IAAzB,EAA+BC,KAA/B,EAAsC;AACpC,UAAMC,QAAQ,GAAGzD,MAAM,CAAC0D,MAAP,CAAc;AAC7BpC,MAAAA,OAAO,EAAE,CADoB;AAE7BC,MAAAA,MAAM,EAAE9C,KAAK,CAACkF,cAFe;AAG7BhC,MAAAA,IAAI,EAAE6B;AAHuB,KAAd,EAIdI,MAJc,EAAjB;AAKA,UAAM7C,MAAM,GAAGjB,eAAe,CAAC,SAAD,CAAf,CAA2B4D,MAA3B,CAAkCD,QAAQ,CAAC7C,MAA3C,CAAf;AACA,UAAMiD,SAAS,GAAGnF,MAAM,CAACA,MAAP,CAAc,CAC9BqC,MAD8B,EAE9B0C,QAF8B,CAAd,CAAlB;AAIA,UAAMK,WAAW,GAAG,EAApB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGtF,KAAK,CAACkF,cAA1B,EAA0CI,CAAC,EAA3C,EAA+C;AAC7CD,MAAAA,WAAW,CAACE,IAAZ,CAAiB;AACfb,QAAAA,IAAI,EAAE,EADS;AAEfc,QAAAA,KAAK,EAAE,CAFQ;AAGftB,QAAAA,IAAI,EAAElE,KAAK,CAACmE;AAHG,OAAjB;AAKD;;AACD,QAAIW,IAAI,CAAC3C,MAAL,IAAenC,KAAK,CAACyF,SAAzB,EAAoC;AAClC,YAAMC,KAAK,GAAGZ,IAAI,CAACa,GAAL,CAASC,IAAI,IAAI;AAC7B,eAAO;AACL5B,UAAAA,IAAI,EAAE;AACJU,YAAAA,IAAI,EAAE,EADF;AAEJc,YAAAA,KAAK,EAAE,CAFH;AAGJtB,YAAAA,IAAI,EAAE0B,IAAI,CAACzC;AAHP,WADD;AAMLH,UAAAA,IAAI,EAAE4C,IAAI,CAAC5C,IAAL,IAAa,IAAIK,UAAJ;AANd,SAAP;AAQD,OATa,EASXwC,IATW,CASN,CAACC,CAAD,EAAIC,CAAJ,KAAU;AAChB,eAAO7F,OAAO,CAACA,OAAR,CAAgB4F,CAAC,CAAC9B,IAAF,CAAOE,IAAP,CAAYhC,KAA5B,EAAmC6D,CAAC,CAAC/B,IAAF,CAAOE,IAAP,CAAYhC,KAA/C,CAAP;AACD,OAXa,CAAd;AAYA,YAAM8D,SAAS,GAAGX,WAAW,CAACpF,MAAZ,CAAmByF,KAAK,CAACC,GAAN,CAAUC,IAAI,IAAIA,IAAI,CAAC5B,IAAvB,CAAnB,CAAlB;AACA,YAAMpC,QAAQ,GAAG3B,MAAM,CAACA,MAAP,CAAc,CAC7BmF,SAD6B,EAE7B,GAAGM,KAAK,CAACC,GAAN,CAAUC,IAAI,IAAIA,IAAI,CAAC5C,IAAvB,CAF0B,CAAd,CAAjB;AAIA,aAAO;AACLnB,QAAAA,IAAI,EAAED,QADD;AAELmB,QAAAA,KAAK,EAAEiD;AAFF,OAAP;AAID,KAtBD,MAsBO;AACL,YAAMC,IAAI,GAAGnB,IAAI,CAACoB,MAAL,CAAY,CAACD,IAAD,EAAOrG,GAAP,KAAe;AACtC,cAAMc,CAAC,GAAGuC,IAAI,CAAC8B,KAAD,EAAQnF,GAAG,CAACuD,GAAZ,CAAJ,GAAuBnD,KAAK,CAACkF,cAAvC;AACAe,QAAAA,IAAI,CAACvF,CAAD,CAAJ,GAAUA,CAAC,IAAIuF,IAAL,GAAYA,IAAI,CAACvF,CAAD,CAAJ,CAAQT,MAAR,CAAe,CAACL,GAAD,CAAf,CAAZ,GAAoC,CAACA,GAAD,CAA9C;AACA,eAAOqG,IAAP;AACD,OAJY,EAIV,EAJU,CAAb;AAKA,UAAIlC,GAAG,GAAG,CAAV;;AACA,WAAK,MAAMoC,GAAX,IAAkBF,IAAlB,EAAwB;AACtB,cAAMG,KAAK,GAAG,MAAMvB,SAAS,CAACsB,GAAD,EAAMpB,KAAK,GAAG,CAAd,CAA7B;AACA,cAAMsB,UAAU,CAACD,KAAD,EAAQrC,GAAR,CAAhB;AACAA,QAAAA,GAAG;AACJ;;AACD,aAAO;AACLlC,QAAAA,IAAI,EAAEuD,SADD;AAELrC,QAAAA,KAAK,EAAEsC;AAFF,OAAP;AAID;;AACD,mBAAegB,UAAf,CAA0BD,KAA1B,EAAiCE,MAAjC,EAAyC;AACvC,YAAMjC,GAAG,GAAG/C,gBAAgB,CAAC2D,MAAjB,CAAwBmB,KAAxB,CAAZ;AACA,YAAMG,MAAM,GAAG,MAAMlG,IAAI,CAACmG,MAAL,CAAYD,MAAZ,CAAmBlC,GAAnB,CAArB;AACA,YAAMoC,KAAK,GAAG/G,GAAG,CAACgH,GAAJ,CAAQC,QAAR,CAAiBJ,MAAjB,CAAd;AACA,YAAM3C,UAAU,CAACgD,GAAX,CAAeH,KAAf,EAAsBpC,GAAtB,CAAN;AACA,YAAMwC,IAAI,GAAGT,KAAK,CAACrD,KAAN,CAAYmD,MAAZ,CAAmB,CAACY,GAAD,EAAMC,IAAN,KAAeD,GAAG,IAAIC,IAAI,CAACvB,KAAL,IAAc,CAAlB,CAArC,EAA2D,CAA3D,IAAgEnB,GAAG,CAAClC,MAAjF;AACAkD,MAAAA,WAAW,CAACiB,MAAD,CAAX,GAAsB;AACpB5B,QAAAA,IAAI,EAAE,EADc;AAEpBc,QAAAA,KAAK,EAAEqB,IAFa;AAGpB3C,QAAAA,IAAI,EAAEuC;AAHc,OAAtB;AAKD;AACF;AACF;;AACD,eAAeO,QAAf,CAAwBpD,UAAxB,EAAoCqD,IAApC,EAA0CC,IAA1C,EAAgD;AAC9C,QAAMvF,QAAQ,GAAG,MAAMgD,UAAU,CAACf,UAAD,EAAasD,IAAI,CAACvB,GAAL,CAASjG,GAAG,IAAI;AAC5D,WAAO;AAAEyD,MAAAA,GAAG,EAAEzD;AAAP,KAAP;AACD,GAF6C,CAAb,CAAjC;AAGA,QAAM2E,GAAG,GAAG/C,gBAAgB,CAAC2D,MAAjB,CAAwBtD,QAAxB,CAAZ;AACA,QAAM4E,MAAM,GAAG,MAAMlG,IAAI,CAACmG,MAAL,CAAYD,MAAZ,CAAmBlC,GAAnB,CAArB;AACA,QAAMoC,KAAK,GAAG/G,GAAG,CAACgH,GAAJ,CAAQC,QAAR,CAAiBJ,MAAjB,CAAd;AACA,QAAM3C,UAAU,CAACgD,GAAX,CAAeH,KAAf,EAAsBpC,GAAtB,CAAN;AACA,QAAMwC,IAAI,GAAGlF,QAAQ,CAACoB,KAAT,CAAemD,MAAf,CAAsB,CAACY,GAAD,EAAMC,IAAN,KAAeD,GAAG,GAAGC,IAAI,CAACvB,KAAhD,EAAuD,CAAvD,IAA4DnB,GAAG,CAAClC,MAA7E;AACA,SAAO;AACLuC,IAAAA,IAAI,EAAEuC,IADD;AAELzB,IAAAA,KAAK,EAAEqB,IAFF;AAGL3C,IAAAA,IAAI,EAAEuC;AAHD,GAAP;AAKD;;AAEDjH,OAAO,CAAC8E,OAAR,GAAkBA,OAAlB;AACA9E,OAAO,CAACwH,QAAR,GAAmBA,QAAnB","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar cid = require('multiformats/cid');\nvar pin = require('./pin.js');\nvar fnv1a = require('fnv1a');\nvar varint = require('varint');\nvar dagPb = require('@ipld/dag-pb');\nvar utils = require('./utils.js');\nvar concat = require('uint8arrays/concat');\nvar compare = require('uint8arrays/compare');\nvar toString = require('uint8arrays/to-string');\nvar fromString = require('uint8arrays/from-string');\nvar sha2 = require('multiformats/hashes/sha2');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar fnv1a__default = /*#__PURE__*/_interopDefaultLegacy(fnv1a);\nvar varint__default = /*#__PURE__*/_interopDefaultLegacy(varint);\nvar dagPb__namespace = /*#__PURE__*/_interopNamespace(dagPb);\n\nconst PinSet = pin.ipfs.pin.Set;\nfunction readHeader(rootNode) {\n  const rootData = rootNode.Data;\n  if (!rootData) {\n    throw new Error('No data present');\n  }\n  const hdrLength = varint__default[\"default\"].decode(rootData);\n  const vBytes = varint__default[\"default\"].decode.bytes;\n  if (vBytes <= 0) {\n    throw new Error('Invalid Set header length');\n  }\n  if (vBytes + hdrLength > rootData.length) {\n    throw new Error('Impossibly large set header length');\n  }\n  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes);\n  const header = PinSet.toObject(PinSet.decode(hdrSlice), {\n    defaults: false,\n    arrays: true,\n    longs: Number,\n    objects: false\n  });\n  if (header.version !== 1) {\n    throw new Error(`Unsupported Set version: ${ header.version }`);\n  }\n  if (header.fanout > rootNode.Links.length) {\n    throw new Error('Impossibly large fanout');\n  }\n  return {\n    header: header,\n    data: rootData.slice(hdrLength + vBytes)\n  };\n}\nfunction hash(seed, key) {\n  const buffer = new Uint8Array(4);\n  const dataView = new DataView(buffer.buffer);\n  dataView.setUint32(0, seed, true);\n  const encodedKey = fromString.fromString(key.toString());\n  const data = concat.concat([\n    buffer,\n    encodedKey\n  ], buffer.byteLength + encodedKey.byteLength);\n  return fnv1a__default[\"default\"](toString.toString(data));\n}\nasync function* walkItems(blockstore, node) {\n  const pbh = readHeader(node);\n  let idx = 0;\n  for (const link of node.Links) {\n    if (idx < pbh.header.fanout) {\n      const linkHash = link.Hash;\n      if (!utils.EMPTY_KEY.equals(linkHash)) {\n        const buf = await blockstore.get(linkHash);\n        const node = dagPb__namespace.decode(buf);\n        yield* walkItems(blockstore, node);\n      }\n    } else {\n      yield link.Hash;\n    }\n    idx++;\n  }\n}\nasync function* loadSet(blockstore, rootNode, name) {\n  const link = rootNode.Links.find(l => l.Name === name);\n  if (!link) {\n    throw new Error('No link found with name ' + name);\n  }\n  const buf = await blockstore.get(link.Hash);\n  const node = dagPb__namespace.decode(buf);\n  yield* walkItems(blockstore, node);\n}\nfunction storeItems(blockstore, items) {\n  return storePins(items, 0);\n  async function storePins(pins, depth) {\n    const pbHeader = PinSet.encode({\n      version: 1,\n      fanout: utils.DEFAULT_FANOUT,\n      seed: depth\n    }).finish();\n    const header = varint__default[\"default\"].encode(pbHeader.length);\n    const headerBuf = concat.concat([\n      header,\n      pbHeader\n    ]);\n    const fanoutLinks = [];\n    for (let i = 0; i < utils.DEFAULT_FANOUT; i++) {\n      fanoutLinks.push({\n        Name: '',\n        Tsize: 1,\n        Hash: utils.EMPTY_KEY\n      });\n    }\n    if (pins.length <= utils.MAX_ITEMS) {\n      const nodes = pins.map(item => {\n        return {\n          link: {\n            Name: '',\n            Tsize: 1,\n            Hash: item.key\n          },\n          data: item.data || new Uint8Array()\n        };\n      }).sort((a, b) => {\n        return compare.compare(a.link.Hash.bytes, b.link.Hash.bytes);\n      });\n      const rootLinks = fanoutLinks.concat(nodes.map(item => item.link));\n      const rootData = concat.concat([\n        headerBuf,\n        ...nodes.map(item => item.data)\n      ]);\n      return {\n        Data: rootData,\n        Links: rootLinks\n      };\n    } else {\n      const bins = pins.reduce((bins, pin) => {\n        const n = hash(depth, pin.key) % utils.DEFAULT_FANOUT;\n        bins[n] = n in bins ? bins[n].concat([pin]) : [pin];\n        return bins;\n      }, []);\n      let idx = 0;\n      for (const bin of bins) {\n        const child = await storePins(bin, depth + 1);\n        await storeChild(child, idx);\n        idx++;\n      }\n      return {\n        Data: headerBuf,\n        Links: fanoutLinks\n      };\n    }\n    async function storeChild(child, binIdx) {\n      const buf = dagPb__namespace.encode(child);\n      const digest = await sha2.sha256.digest(buf);\n      const cid$1 = cid.CID.createV0(digest);\n      await blockstore.put(cid$1, buf);\n      const size = child.Links.reduce((acc, curr) => acc + (curr.Tsize || 0), 0) + buf.length;\n      fanoutLinks[binIdx] = {\n        Name: '',\n        Tsize: size,\n        Hash: cid$1\n      };\n    }\n  }\n}\nasync function storeSet(blockstore, type, cids) {\n  const rootNode = await storeItems(blockstore, cids.map(cid => {\n    return { key: cid };\n  }));\n  const buf = dagPb__namespace.encode(rootNode);\n  const digest = await sha2.sha256.digest(buf);\n  const cid$1 = cid.CID.createV0(digest);\n  await blockstore.put(cid$1, buf);\n  const size = rootNode.Links.reduce((acc, curr) => acc + curr.Tsize, 0) + buf.length;\n  return {\n    Name: type,\n    Tsize: size,\n    Hash: cid$1\n  };\n}\n\nexports.loadSet = loadSet;\nexports.storeSet = storeSet;\n"]},"metadata":{},"sourceType":"script"}