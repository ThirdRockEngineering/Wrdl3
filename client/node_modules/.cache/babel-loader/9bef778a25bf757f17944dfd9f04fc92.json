{"ast":null,"code":"'use strict';\n\nconst {\n  xor: uint8ArrayXor\n} = require('uint8arrays/xor');\n\nconst GENERATED_PREFIXES = require('./generated-prefix-list.json');\n\nconst {\n  sha256\n} = require('multiformats/hashes/sha2');\n\nconst crypto = require('libp2p-crypto');\n\nconst PeerId = require('peer-id');\n\nconst utils = require('../utils');\n\nconst length = require('it-length');\n\nconst {\n  TimeoutController\n} = require('timeout-abort-controller');\n\nconst {\n  TABLE_REFRESH_INTERVAL,\n  TABLE_REFRESH_QUERY_TIMEOUT\n} = require('../constants');\n/**\n * @typedef {import('./types').KBucketPeer} KBucketPeer\n * @typedef {import('./types').KBucket} KBucket\n * @typedef {import('./types').KBucketTree} KBucketTree\n */\n\n/**\n * Cannot generate random KadIds longer than this + 1\n */\n\n\nconst MAX_COMMON_PREFIX_LENGTH = 15;\n/**\n * A wrapper around `k-bucket`, to provide easy store and\n * retrieval for peers.\n */\n\nclass RoutingTableRefresh {\n  /**\n   * @param {object} params\n   * @param {import('../peer-routing').PeerRouting} params.peerRouting\n   * @param {import('./').RoutingTable} params.routingTable\n   * @param {boolean} params.lan\n   * @param {number} [params.refreshInterval]\n   * @param {number} [params.refreshQueryTimeout]\n   */\n  constructor(_ref) {\n    let {\n      peerRouting,\n      routingTable,\n      refreshInterval,\n      refreshQueryTimeout,\n      lan\n    } = _ref;\n    this._log = utils.logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}:routing-table:refresh`);\n    this._peerRouting = peerRouting;\n    this._routingTable = routingTable;\n    this._refreshInterval = refreshInterval || TABLE_REFRESH_INTERVAL;\n    this._refreshQueryTimeout = refreshQueryTimeout || TABLE_REFRESH_QUERY_TIMEOUT;\n    /** @type {Date[]} */\n\n    this.commonPrefixLengthRefreshedAt = [];\n    this.refreshTable = this.refreshTable.bind(this);\n  }\n\n  async start() {\n    this._log(`refreshing routing table every ${this._refreshInterval}ms`);\n\n    await this.refreshTable(true);\n  }\n\n  async stop() {\n    if (this._refreshTimeoutId) {\n      clearTimeout(this._refreshTimeoutId);\n    }\n  }\n  /**\n   * To speed lookups, we seed the table with random PeerIds. This means\n   * when we are asked to locate a peer on the network, we can find a KadId\n   * that is close to the requested peer ID and query that, then network\n   * peers will tell us who they know who is close to the fake ID\n   *\n   * @param {boolean} [force=false]\n   */\n\n\n  async refreshTable(force) {\n    this._log('refreshing routing table');\n\n    const prefixLength = this._maxCommonPrefix();\n\n    const refreshCpls = this._getTrackedCommonPrefixLengthsForRefresh(prefixLength);\n\n    this._log(`max common prefix length ${prefixLength}`);\n\n    this._log(`tracked CPLs [ ${refreshCpls.map(date => date.toISOString()).join(', ')} ]`);\n    /**\n     * If we see a gap at a common prefix length in the Routing table, we ONLY refresh up until\n     * the maximum cpl we have in the Routing Table OR (2 * (Cpl+ 1) with the gap), whichever\n     * is smaller.\n     *\n     * This is to prevent refreshes for Cpls that have no peers in the network but happen to be\n     * before a very high max Cpl for which we do have peers in the network.\n     *\n     * The number of 2 * (Cpl + 1) can be proved and a proof would have been written here if\n     * the programmer had paid more attention in the Math classes at university.\n     *\n     * So, please be patient and a doc explaining it will be published soon.\n     *\n     * https://github.com/libp2p/go-libp2p-kad-dht/commit/2851c88acb0a3f86bcfe3cfd0f4604a03db801d8#diff-ad45f4ba97ffbc4083c2eb87a4420c1157057b233f048030d67c6b551855ccf6R219\n     */\n\n\n    await Promise.all(refreshCpls.map(async (lastRefresh, index) => {\n      try {\n        await this._refreshCommonPrefixLength(index, lastRefresh, force === true);\n\n        if (this._numPeersForCpl(prefixLength) === 0) {\n          const lastCpl = Math.min(2 * (index + 1), refreshCpls.length - 1);\n\n          for (let n = index + 1; n < lastCpl + 1; n++) {\n            try {\n              await this._refreshCommonPrefixLength(n, lastRefresh, force === true);\n            } catch (\n            /** @type {any} */\n            err) {\n              this._log.error(err);\n            }\n          }\n        }\n      } catch (\n      /** @type {any} */\n      err) {\n        this._log.error(err);\n      }\n    }));\n    this._refreshTimeoutId = setTimeout(this.refreshTable, this._refreshInterval); // @ts-ignore\n\n    if (this._refreshTimeoutId.unref) {\n      // @ts-ignore\n      this._refreshTimeoutId.unref();\n    }\n  }\n  /**\n   * @param {number} cpl\n   * @param {Date} lastRefresh\n   * @param {boolean} force\n   */\n\n\n  async _refreshCommonPrefixLength(cpl, lastRefresh, force) {\n    if (!force && lastRefresh.getTime() > Date.now() - this._refreshInterval) {\n      this._log('not running refresh for cpl %s as time since last refresh not above interval', cpl);\n\n      return;\n    } // gen a key for the query to refresh the cpl\n\n\n    const peerId = await this._generateRandomPeerId(cpl);\n\n    this._log('starting refreshing cpl %s with key %p (routing table size was %s)', cpl, peerId, this._routingTable.kb.count());\n\n    const controller = new TimeoutController(this._refreshQueryTimeout);\n\n    try {\n      const peers = await length(this._peerRouting.getClosestPeers(peerId.toBytes(), {\n        signal: controller.signal\n      }));\n\n      this._log(`found ${peers} peers that were close to imaginary peer %p`, peerId);\n\n      this._log('finished refreshing cpl %s with key %p (routing table size is now %s)', cpl, peerId, this._routingTable.kb.count());\n    } finally {\n      controller.clear();\n    }\n  }\n  /**\n   * @param {number} maxCommonPrefix\n   */\n\n\n  _getTrackedCommonPrefixLengthsForRefresh(maxCommonPrefix) {\n    if (maxCommonPrefix > MAX_COMMON_PREFIX_LENGTH) {\n      maxCommonPrefix = MAX_COMMON_PREFIX_LENGTH;\n    }\n\n    const dates = [];\n\n    for (let i = 0; i <= maxCommonPrefix; i++) {\n      // defaults to the zero value if we haven't refreshed it yet.\n      dates[i] = this.commonPrefixLengthRefreshedAt[i] || new Date();\n    }\n\n    return dates;\n  }\n  /**\n   *\n   * @param {number} targetCommonPrefixLength\n   */\n\n\n  async _generateRandomPeerId(targetCommonPrefixLength) {\n    const randomBytes = crypto.randomBytes(2);\n    const randomUint16 = (randomBytes[1] << 8) + randomBytes[0];\n    const key = await this._makePeerId(this._routingTable.kb.localNodeId, randomUint16, targetCommonPrefixLength);\n    return PeerId.createFromBytes(key);\n  }\n  /**\n   * @param {Uint8Array} localKadId\n   * @param {number} randomPrefix\n   * @param {number} targetCommonPrefixLength\n   */\n\n\n  async _makePeerId(localKadId, randomPrefix, targetCommonPrefixLength) {\n    if (targetCommonPrefixLength > MAX_COMMON_PREFIX_LENGTH) {\n      throw new Error(`Cannot generate peer ID for common prefix length greater than ${MAX_COMMON_PREFIX_LENGTH}`);\n    }\n\n    const view = new DataView(localKadId.buffer, localKadId.byteOffset, localKadId.byteLength);\n    const localPrefix = view.getUint16(0, false); // For host with ID `L`, an ID `K` belongs to a bucket with ID `B` ONLY IF CommonPrefixLen(L,K) is EXACTLY B.\n    // Hence, to achieve a targetPrefix `T`, we must toggle the (T+1)th bit in L & then copy (T+1) bits from L\n    // to our randomly generated prefix.\n\n    const toggledLocalPrefix = localPrefix ^ 0x8000 >> targetCommonPrefixLength; // Combine the toggled local prefix and the random bits at the correct offset\n    // such that ONLY the first `targetCommonPrefixLength` bits match the local ID.\n\n    const mask = 65535 << 16 - (targetCommonPrefixLength + 1);\n    const targetPrefix = toggledLocalPrefix & mask | randomPrefix & ~mask; // Convert to a known peer ID.\n\n    const keyPrefix = GENERATED_PREFIXES[targetPrefix];\n    const keyBuffer = new ArrayBuffer(34);\n    const keyView = new DataView(keyBuffer, 0, keyBuffer.byteLength);\n    keyView.setUint8(0, sha256.code);\n    keyView.setUint8(1, 32);\n    keyView.setUint32(2, keyPrefix, false);\n    return new Uint8Array(keyView.buffer, keyView.byteOffset, keyView.byteLength);\n  }\n  /**\n   * returns the maximum common prefix length between any peer in the table\n   * and the current peer\n   */\n\n\n  _maxCommonPrefix() {\n    // xor our KadId with every KadId in the k-bucket tree,\n    // return the longest id prefix that is the same\n    let prefixLength = 0;\n\n    for (const length of this._prefixLengths()) {\n      if (length > prefixLength) {\n        prefixLength = length;\n      }\n    }\n\n    return prefixLength;\n  }\n  /**\n   * Returns the number of peers in the table with a given prefix length\n   *\n   * @param {number} prefixLength\n   */\n\n\n  _numPeersForCpl(prefixLength) {\n    let count = 0;\n\n    for (const length of this._prefixLengths()) {\n      if (length === prefixLength) {\n        count++;\n      }\n    }\n\n    return count;\n  }\n  /**\n   * Yields the common prefix length of every peer in the table\n   */\n\n\n  *_prefixLengths() {\n    if (!this._routingTable.kb) {\n      return;\n    }\n\n    for (const {\n      id\n    } of this._routingTable.kb.toIterable()) {\n      const distance = uint8ArrayXor(this._routingTable.kb.localNodeId, id);\n      let leadingZeros = 0;\n\n      for (const byte of distance) {\n        if (byte === 0) {\n          leadingZeros++;\n        } else {\n          break;\n        }\n      }\n\n      yield leadingZeros;\n    }\n  }\n\n}\n\nmodule.exports.RoutingTableRefresh = RoutingTableRefresh;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p-kad-dht/src/routing-table/refresh.js"],"names":["xor","uint8ArrayXor","require","GENERATED_PREFIXES","sha256","crypto","PeerId","utils","length","TimeoutController","TABLE_REFRESH_INTERVAL","TABLE_REFRESH_QUERY_TIMEOUT","MAX_COMMON_PREFIX_LENGTH","RoutingTableRefresh","constructor","peerRouting","routingTable","refreshInterval","refreshQueryTimeout","lan","_log","logger","_peerRouting","_routingTable","_refreshInterval","_refreshQueryTimeout","commonPrefixLengthRefreshedAt","refreshTable","bind","start","stop","_refreshTimeoutId","clearTimeout","force","prefixLength","_maxCommonPrefix","refreshCpls","_getTrackedCommonPrefixLengthsForRefresh","map","date","toISOString","join","Promise","all","lastRefresh","index","_refreshCommonPrefixLength","_numPeersForCpl","lastCpl","Math","min","n","err","error","setTimeout","unref","cpl","getTime","Date","now","peerId","_generateRandomPeerId","kb","count","controller","peers","getClosestPeers","toBytes","signal","clear","maxCommonPrefix","dates","i","targetCommonPrefixLength","randomBytes","randomUint16","key","_makePeerId","localNodeId","createFromBytes","localKadId","randomPrefix","Error","view","DataView","buffer","byteOffset","byteLength","localPrefix","getUint16","toggledLocalPrefix","mask","targetPrefix","keyPrefix","keyBuffer","ArrayBuffer","keyView","setUint8","code","setUint32","Uint8Array","_prefixLengths","id","toIterable","distance","leadingZeros","byte","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { xor: uint8ArrayXor } = require('uint8arrays/xor')\nconst GENERATED_PREFIXES = require('./generated-prefix-list.json')\nconst { sha256 } = require('multiformats/hashes/sha2')\nconst crypto = require('libp2p-crypto')\nconst PeerId = require('peer-id')\nconst utils = require('../utils')\nconst length = require('it-length')\nconst { TimeoutController } = require('timeout-abort-controller')\nconst { TABLE_REFRESH_INTERVAL, TABLE_REFRESH_QUERY_TIMEOUT } = require('../constants')\n\n/**\n * @typedef {import('./types').KBucketPeer} KBucketPeer\n * @typedef {import('./types').KBucket} KBucket\n * @typedef {import('./types').KBucketTree} KBucketTree\n */\n\n/**\n * Cannot generate random KadIds longer than this + 1\n */\nconst MAX_COMMON_PREFIX_LENGTH = 15\n\n/**\n * A wrapper around `k-bucket`, to provide easy store and\n * retrieval for peers.\n */\nclass RoutingTableRefresh {\n  /**\n   * @param {object} params\n   * @param {import('../peer-routing').PeerRouting} params.peerRouting\n   * @param {import('./').RoutingTable} params.routingTable\n   * @param {boolean} params.lan\n   * @param {number} [params.refreshInterval]\n   * @param {number} [params.refreshQueryTimeout]\n   */\n  constructor ({ peerRouting, routingTable, refreshInterval, refreshQueryTimeout, lan }) {\n    this._log = utils.logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}:routing-table:refresh`)\n    this._peerRouting = peerRouting\n    this._routingTable = routingTable\n    this._refreshInterval = refreshInterval || TABLE_REFRESH_INTERVAL\n    this._refreshQueryTimeout = refreshQueryTimeout || TABLE_REFRESH_QUERY_TIMEOUT\n\n    /** @type {Date[]} */\n    this.commonPrefixLengthRefreshedAt = []\n\n    this.refreshTable = this.refreshTable.bind(this)\n  }\n\n  async start () {\n    this._log(`refreshing routing table every ${this._refreshInterval}ms`)\n    await this.refreshTable(true)\n  }\n\n  async stop () {\n    if (this._refreshTimeoutId) {\n      clearTimeout(this._refreshTimeoutId)\n    }\n  }\n\n  /**\n   * To speed lookups, we seed the table with random PeerIds. This means\n   * when we are asked to locate a peer on the network, we can find a KadId\n   * that is close to the requested peer ID and query that, then network\n   * peers will tell us who they know who is close to the fake ID\n   *\n   * @param {boolean} [force=false]\n   */\n  async refreshTable (force) {\n    this._log('refreshing routing table')\n\n    const prefixLength = this._maxCommonPrefix()\n    const refreshCpls = this._getTrackedCommonPrefixLengthsForRefresh(prefixLength)\n\n    this._log(`max common prefix length ${prefixLength}`)\n    this._log(`tracked CPLs [ ${refreshCpls.map(date => date.toISOString()).join(', ')} ]`)\n\n    /**\n     * If we see a gap at a common prefix length in the Routing table, we ONLY refresh up until\n     * the maximum cpl we have in the Routing Table OR (2 * (Cpl+ 1) with the gap), whichever\n     * is smaller.\n     *\n     * This is to prevent refreshes for Cpls that have no peers in the network but happen to be\n     * before a very high max Cpl for which we do have peers in the network.\n     *\n     * The number of 2 * (Cpl + 1) can be proved and a proof would have been written here if\n     * the programmer had paid more attention in the Math classes at university.\n     *\n     * So, please be patient and a doc explaining it will be published soon.\n     *\n     * https://github.com/libp2p/go-libp2p-kad-dht/commit/2851c88acb0a3f86bcfe3cfd0f4604a03db801d8#diff-ad45f4ba97ffbc4083c2eb87a4420c1157057b233f048030d67c6b551855ccf6R219\n     */\n    await Promise.all(\n      refreshCpls.map(async (lastRefresh, index) => {\n        try {\n          await this._refreshCommonPrefixLength(index, lastRefresh, force === true)\n\n          if (this._numPeersForCpl(prefixLength) === 0) {\n            const lastCpl = Math.min(2 * (index + 1), refreshCpls.length - 1)\n\n            for (let n = index + 1; n < lastCpl + 1; n++) {\n              try {\n                await this._refreshCommonPrefixLength(n, lastRefresh, force === true)\n              } catch (/** @type {any} */ err) {\n                this._log.error(err)\n              }\n            }\n          }\n        } catch (/** @type {any} */ err) {\n          this._log.error(err)\n        }\n      })\n    )\n\n    this._refreshTimeoutId = setTimeout(this.refreshTable, this._refreshInterval)\n\n    // @ts-ignore\n    if (this._refreshTimeoutId.unref) {\n      // @ts-ignore\n      this._refreshTimeoutId.unref()\n    }\n  }\n\n  /**\n   * @param {number} cpl\n   * @param {Date} lastRefresh\n   * @param {boolean} force\n   */\n  async _refreshCommonPrefixLength (cpl, lastRefresh, force) {\n    if (!force && lastRefresh.getTime() > (Date.now() - this._refreshInterval)) {\n      this._log('not running refresh for cpl %s as time since last refresh not above interval', cpl)\n      return\n    }\n\n    // gen a key for the query to refresh the cpl\n    const peerId = await this._generateRandomPeerId(cpl)\n\n    this._log('starting refreshing cpl %s with key %p (routing table size was %s)', cpl, peerId, this._routingTable.kb.count())\n\n    const controller = new TimeoutController(this._refreshQueryTimeout)\n\n    try {\n      const peers = await length(this._peerRouting.getClosestPeers(peerId.toBytes(), { signal: controller.signal }))\n\n      this._log(`found ${peers} peers that were close to imaginary peer %p`, peerId)\n      this._log('finished refreshing cpl %s with key %p (routing table size is now %s)', cpl, peerId, this._routingTable.kb.count())\n    } finally {\n      controller.clear()\n    }\n  }\n\n  /**\n   * @param {number} maxCommonPrefix\n   */\n  _getTrackedCommonPrefixLengthsForRefresh (maxCommonPrefix) {\n    if (maxCommonPrefix > MAX_COMMON_PREFIX_LENGTH) {\n      maxCommonPrefix = MAX_COMMON_PREFIX_LENGTH\n    }\n\n    const dates = []\n\n    for (let i = 0; i <= maxCommonPrefix; i++) {\n      // defaults to the zero value if we haven't refreshed it yet.\n      dates[i] = this.commonPrefixLengthRefreshedAt[i] || new Date()\n    }\n\n    return dates\n  }\n\n  /**\n   *\n   * @param {number} targetCommonPrefixLength\n   */\n  async _generateRandomPeerId (targetCommonPrefixLength) {\n    const randomBytes = crypto.randomBytes(2)\n    const randomUint16 = (randomBytes[1] << 8) + randomBytes[0]\n\n    const key = await this._makePeerId(this._routingTable.kb.localNodeId, randomUint16, targetCommonPrefixLength)\n\n    return PeerId.createFromBytes(key)\n  }\n\n  /**\n   * @param {Uint8Array} localKadId\n   * @param {number} randomPrefix\n   * @param {number} targetCommonPrefixLength\n   */\n  async _makePeerId (localKadId, randomPrefix, targetCommonPrefixLength) {\n    if (targetCommonPrefixLength > MAX_COMMON_PREFIX_LENGTH) {\n      throw new Error(`Cannot generate peer ID for common prefix length greater than ${MAX_COMMON_PREFIX_LENGTH}`)\n    }\n\n    const view = new DataView(localKadId.buffer, localKadId.byteOffset, localKadId.byteLength)\n    const localPrefix = view.getUint16(0, false)\n\n    // For host with ID `L`, an ID `K` belongs to a bucket with ID `B` ONLY IF CommonPrefixLen(L,K) is EXACTLY B.\n    // Hence, to achieve a targetPrefix `T`, we must toggle the (T+1)th bit in L & then copy (T+1) bits from L\n    // to our randomly generated prefix.\n    const toggledLocalPrefix = localPrefix ^ (0x8000 >> targetCommonPrefixLength)\n\n    // Combine the toggled local prefix and the random bits at the correct offset\n    // such that ONLY the first `targetCommonPrefixLength` bits match the local ID.\n    const mask = 65535 << (16 - (targetCommonPrefixLength + 1))\n    const targetPrefix = (toggledLocalPrefix & mask) | (randomPrefix & ~mask)\n\n    // Convert to a known peer ID.\n    const keyPrefix = GENERATED_PREFIXES[targetPrefix]\n\n    const keyBuffer = new ArrayBuffer(34)\n    const keyView = new DataView(keyBuffer, 0, keyBuffer.byteLength)\n    keyView.setUint8(0, sha256.code)\n    keyView.setUint8(1, 32)\n    keyView.setUint32(2, keyPrefix, false)\n\n    return new Uint8Array(keyView.buffer, keyView.byteOffset, keyView.byteLength)\n  }\n\n  /**\n   * returns the maximum common prefix length between any peer in the table\n   * and the current peer\n   */\n  _maxCommonPrefix () {\n    // xor our KadId with every KadId in the k-bucket tree,\n    // return the longest id prefix that is the same\n    let prefixLength = 0\n\n    for (const length of this._prefixLengths()) {\n      if (length > prefixLength) {\n        prefixLength = length\n      }\n    }\n\n    return prefixLength\n  }\n\n  /**\n   * Returns the number of peers in the table with a given prefix length\n   *\n   * @param {number} prefixLength\n   */\n  _numPeersForCpl (prefixLength) {\n    let count = 0\n\n    for (const length of this._prefixLengths()) {\n      if (length === prefixLength) {\n        count++\n      }\n    }\n\n    return count\n  }\n\n  /**\n   * Yields the common prefix length of every peer in the table\n   */\n  * _prefixLengths () {\n    if (!this._routingTable.kb) {\n      return\n    }\n\n    for (const { id } of this._routingTable.kb.toIterable()) {\n      const distance = uint8ArrayXor(this._routingTable.kb.localNodeId, id)\n      let leadingZeros = 0\n\n      for (const byte of distance) {\n        if (byte === 0) {\n          leadingZeros++\n        } else {\n          break\n        }\n      }\n\n      yield leadingZeros\n    }\n  }\n}\n\nmodule.exports.RoutingTableRefresh = RoutingTableRefresh\n"]},"metadata":{},"sourceType":"script"}