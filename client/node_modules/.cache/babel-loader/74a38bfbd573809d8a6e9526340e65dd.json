{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst errcode = require('err-code');\n\nconst {\n  codes\n} = require('../errors');\n\nconst PeerId = require('peer-id');\n/**\n * @typedef {import('./types').PeerStore} PeerStore\n * @typedef {import('./types').ProtoBook} ProtoBook\n */\n\n\nconst log = Object.assign(debug('libp2p:peer-store:proto-book'), {\n  error: debug('libp2p:peer-store:proto-book:err')\n});\nconst EVENT_NAME = 'change:protocols';\n/**\n * @implements {ProtoBook}\n */\n\nclass PersistentProtoBook {\n  /**\n   * @param {PeerStore[\"emit\"]} emit\n   * @param {import('./types').Store} store\n   */\n  constructor(emit, store) {\n    this._emit = emit;\n    this._store = store;\n  }\n  /**\n   * @param {PeerId} peerId\n   */\n\n\n  async get(peerId) {\n    log('get wait for read lock');\n    const release = await this._store.lock.readLock();\n    log('get got read lock');\n\n    try {\n      const peer = await this._store.load(peerId);\n      return peer.protocols;\n    } catch (\n    /** @type {any} */\n    err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err;\n      }\n    } finally {\n      log('get release read lock');\n      release();\n    }\n\n    return [];\n  }\n  /**\n   * @param {PeerId} peerId\n   * @param {string[]} protocols\n   */\n\n\n  async set(peerId, protocols) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    if (!Array.isArray(protocols)) {\n      log.error('protocols must be provided to store data');\n      throw errcode(new Error('protocols must be provided'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log('set await write lock');\n    const release = await this._store.lock.writeLock();\n    log('set got write lock');\n    let updatedPeer;\n\n    try {\n      try {\n        const peer = await this._store.load(peerId);\n\n        if (new Set([...protocols]).size === peer.protocols.length) {\n          return;\n        }\n      } catch (\n      /** @type {any} */\n      err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err;\n        }\n      }\n\n      updatedPeer = await this._store.patchOrCreate(peerId, {\n        protocols\n      });\n      log(`stored provided protocols for ${peerId.toB58String()}`);\n    } finally {\n      log('set release write lock');\n      release();\n    }\n\n    this._emit(EVENT_NAME, {\n      peerId,\n      protocols: updatedPeer.protocols\n    });\n  }\n  /**\n   * @param {PeerId} peerId\n   * @param {string[]} protocols\n   */\n\n\n  async add(peerId, protocols) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    if (!Array.isArray(protocols)) {\n      log.error('protocols must be provided to store data');\n      throw errcode(new Error('protocols must be provided'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log('add await write lock');\n    const release = await this._store.lock.writeLock();\n    log('add got write lock');\n    let updatedPeer;\n\n    try {\n      try {\n        const peer = await this._store.load(peerId);\n\n        if (new Set([...peer.protocols, ...protocols]).size === peer.protocols.length) {\n          return;\n        }\n      } catch (\n      /** @type {any} */\n      err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err;\n        }\n      }\n\n      updatedPeer = await this._store.mergeOrCreate(peerId, {\n        protocols\n      });\n      log(`added provided protocols for ${peerId.toB58String()}`);\n    } finally {\n      log('add release write lock');\n      release();\n    }\n\n    this._emit(EVENT_NAME, {\n      peerId,\n      protocols: updatedPeer.protocols\n    });\n  }\n  /**\n   * @param {PeerId} peerId\n   * @param {string[]} protocols\n   */\n\n\n  async remove(peerId, protocols) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    if (!Array.isArray(protocols)) {\n      log.error('protocols must be provided to store data');\n      throw errcode(new Error('protocols must be provided'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log('remove await write lock');\n    const release = await this._store.lock.writeLock();\n    log('remove got write lock');\n    let updatedPeer;\n\n    try {\n      try {\n        const peer = await this._store.load(peerId);\n        const protocolSet = new Set(peer.protocols);\n\n        for (const protocol of protocols) {\n          protocolSet.delete(protocol);\n        }\n\n        if (peer.protocols.length === protocolSet.size) {\n          return;\n        }\n\n        protocols = Array.from(protocolSet);\n      } catch (\n      /** @type {any} */\n      err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err;\n        }\n      }\n\n      updatedPeer = await this._store.patchOrCreate(peerId, {\n        protocols\n      });\n    } finally {\n      log('remove release write lock');\n      release();\n    }\n\n    this._emit(EVENT_NAME, {\n      peerId,\n      protocols: updatedPeer.protocols\n    });\n  }\n  /**\n   * @param {PeerId} peerId\n   */\n\n\n  async delete(peerId) {\n    log('delete await write lock');\n    const release = await this._store.lock.writeLock();\n    log('delete got write lock');\n    let has;\n\n    try {\n      has = await this._store.has(peerId);\n      await this._store.patchOrCreate(peerId, {\n        protocols: []\n      });\n    } catch (\n    /** @type {any} */\n    err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err;\n      }\n    } finally {\n      log('delete release write lock');\n      release();\n    }\n\n    if (has) {\n      this._emit(EVENT_NAME, {\n        peerId,\n        protocols: []\n      });\n    }\n  }\n\n}\n\nmodule.exports = PersistentProtoBook;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p/src/peer-store/proto-book.js"],"names":["debug","require","errcode","codes","PeerId","log","Object","assign","error","EVENT_NAME","PersistentProtoBook","constructor","emit","store","_emit","_store","get","peerId","release","lock","readLock","peer","load","protocols","err","code","ERR_NOT_FOUND","set","isPeerId","Error","ERR_INVALID_PARAMETERS","Array","isArray","writeLock","updatedPeer","Set","size","length","patchOrCreate","toB58String","add","mergeOrCreate","remove","protocolSet","protocol","delete","from","has","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAM;AAAEE,EAAAA;AAAF,IAAYF,OAAO,CAAC,WAAD,CAAzB;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,SAAD,CAAtB;AAEA;AACA;AACA;AACA;;;AAEA,MAAMI,GAAG,GAAGC,MAAM,CAACC,MAAP,CAAcP,KAAK,CAAC,8BAAD,CAAnB,EAAqD;AAC/DQ,EAAAA,KAAK,EAAER,KAAK,CAAC,kCAAD;AADmD,CAArD,CAAZ;AAIA,MAAMS,UAAU,GAAG,kBAAnB;AAEA;AACA;AACA;;AACA,MAAMC,mBAAN,CAA0B;AACxB;AACF;AACA;AACA;AACEC,EAAAA,WAAW,CAAEC,IAAF,EAAQC,KAAR,EAAe;AACxB,SAAKC,KAAL,GAAaF,IAAb;AACA,SAAKG,MAAL,GAAcF,KAAd;AACD;AAED;AACF;AACA;;;AACW,QAAHG,GAAG,CAAEC,MAAF,EAAU;AACjBZ,IAAAA,GAAG,CAAC,wBAAD,CAAH;AACA,UAAMa,OAAO,GAAG,MAAM,KAAKH,MAAL,CAAYI,IAAZ,CAAiBC,QAAjB,EAAtB;AACAf,IAAAA,GAAG,CAAC,mBAAD,CAAH;;AAEA,QAAI;AACF,YAAMgB,IAAI,GAAG,MAAM,KAAKN,MAAL,CAAYO,IAAZ,CAAiBL,MAAjB,CAAnB;AAEA,aAAOI,IAAI,CAACE,SAAZ;AACD,KAJD,CAIE;AAAO;AAAmBC,IAAAA,GAA1B,EAA+B;AAC/B,UAAIA,GAAG,CAACC,IAAJ,KAAatB,KAAK,CAACuB,aAAvB,EAAsC;AACpC,cAAMF,GAAN;AACD;AACF,KARD,SAQU;AACRnB,MAAAA,GAAG,CAAC,uBAAD,CAAH;AACAa,MAAAA,OAAO;AACR;;AAED,WAAO,EAAP;AACD;AAED;AACF;AACA;AACA;;;AACW,QAAHS,GAAG,CAAEV,MAAF,EAAUM,SAAV,EAAqB;AAC5B,QAAI,CAACnB,MAAM,CAACwB,QAAP,CAAgBX,MAAhB,CAAL,EAA8B;AAC5BZ,MAAAA,GAAG,CAACG,KAAJ,CAAU,qDAAV;AACA,YAAMN,OAAO,CAAC,IAAI2B,KAAJ,CAAU,uCAAV,CAAD,EAAqD1B,KAAK,CAAC2B,sBAA3D,CAAb;AACD;;AAED,QAAI,CAACC,KAAK,CAACC,OAAN,CAAcT,SAAd,CAAL,EAA+B;AAC7BlB,MAAAA,GAAG,CAACG,KAAJ,CAAU,0CAAV;AACA,YAAMN,OAAO,CAAC,IAAI2B,KAAJ,CAAU,4BAAV,CAAD,EAA0C1B,KAAK,CAAC2B,sBAAhD,CAAb;AACD;;AAEDzB,IAAAA,GAAG,CAAC,sBAAD,CAAH;AACA,UAAMa,OAAO,GAAG,MAAM,KAAKH,MAAL,CAAYI,IAAZ,CAAiBc,SAAjB,EAAtB;AACA5B,IAAAA,GAAG,CAAC,oBAAD,CAAH;AAEA,QAAI6B,WAAJ;;AAEA,QAAI;AACF,UAAI;AACF,cAAMb,IAAI,GAAG,MAAM,KAAKN,MAAL,CAAYO,IAAZ,CAAiBL,MAAjB,CAAnB;;AAEA,YAAI,IAAIkB,GAAJ,CAAQ,CACV,GAAGZ,SADO,CAAR,EAEDa,IAFC,KAEQf,IAAI,CAACE,SAAL,CAAec,MAF3B,EAEmC;AACjC;AACD;AACF,OARD,CAQE;AAAO;AAAmBb,MAAAA,GAA1B,EAA+B;AAC/B,YAAIA,GAAG,CAACC,IAAJ,KAAatB,KAAK,CAACuB,aAAvB,EAAsC;AACpC,gBAAMF,GAAN;AACD;AACF;;AAEDU,MAAAA,WAAW,GAAG,MAAM,KAAKnB,MAAL,CAAYuB,aAAZ,CAA0BrB,MAA1B,EAAkC;AACpDM,QAAAA;AADoD,OAAlC,CAApB;AAIAlB,MAAAA,GAAG,CAAE,iCAAgCY,MAAM,CAACsB,WAAP,EAAqB,EAAvD,CAAH;AACD,KApBD,SAoBU;AACRlC,MAAAA,GAAG,CAAC,wBAAD,CAAH;AACAa,MAAAA,OAAO;AACR;;AAED,SAAKJ,KAAL,CAAWL,UAAX,EAAuB;AAAEQ,MAAAA,MAAF;AAAUM,MAAAA,SAAS,EAAEW,WAAW,CAACX;AAAjC,KAAvB;AACD;AAED;AACF;AACA;AACA;;;AACW,QAAHiB,GAAG,CAAEvB,MAAF,EAAUM,SAAV,EAAqB;AAC5B,QAAI,CAACnB,MAAM,CAACwB,QAAP,CAAgBX,MAAhB,CAAL,EAA8B;AAC5BZ,MAAAA,GAAG,CAACG,KAAJ,CAAU,qDAAV;AACA,YAAMN,OAAO,CAAC,IAAI2B,KAAJ,CAAU,uCAAV,CAAD,EAAqD1B,KAAK,CAAC2B,sBAA3D,CAAb;AACD;;AAED,QAAI,CAACC,KAAK,CAACC,OAAN,CAAcT,SAAd,CAAL,EAA+B;AAC7BlB,MAAAA,GAAG,CAACG,KAAJ,CAAU,0CAAV;AACA,YAAMN,OAAO,CAAC,IAAI2B,KAAJ,CAAU,4BAAV,CAAD,EAA0C1B,KAAK,CAAC2B,sBAAhD,CAAb;AACD;;AAEDzB,IAAAA,GAAG,CAAC,sBAAD,CAAH;AACA,UAAMa,OAAO,GAAG,MAAM,KAAKH,MAAL,CAAYI,IAAZ,CAAiBc,SAAjB,EAAtB;AACA5B,IAAAA,GAAG,CAAC,oBAAD,CAAH;AAEA,QAAI6B,WAAJ;;AAEA,QAAI;AACF,UAAI;AACF,cAAMb,IAAI,GAAG,MAAM,KAAKN,MAAL,CAAYO,IAAZ,CAAiBL,MAAjB,CAAnB;;AAEA,YAAI,IAAIkB,GAAJ,CAAQ,CACV,GAAGd,IAAI,CAACE,SADE,EAEV,GAAGA,SAFO,CAAR,EAGDa,IAHC,KAGQf,IAAI,CAACE,SAAL,CAAec,MAH3B,EAGmC;AACjC;AACD;AACF,OATD,CASE;AAAO;AAAmBb,MAAAA,GAA1B,EAA+B;AAC/B,YAAIA,GAAG,CAACC,IAAJ,KAAatB,KAAK,CAACuB,aAAvB,EAAsC;AACpC,gBAAMF,GAAN;AACD;AACF;;AAEDU,MAAAA,WAAW,GAAG,MAAM,KAAKnB,MAAL,CAAY0B,aAAZ,CAA0BxB,MAA1B,EAAkC;AACpDM,QAAAA;AADoD,OAAlC,CAApB;AAIAlB,MAAAA,GAAG,CAAE,gCAA+BY,MAAM,CAACsB,WAAP,EAAqB,EAAtD,CAAH;AACD,KArBD,SAqBU;AACRlC,MAAAA,GAAG,CAAC,wBAAD,CAAH;AACAa,MAAAA,OAAO;AACR;;AAED,SAAKJ,KAAL,CAAWL,UAAX,EAAuB;AAAEQ,MAAAA,MAAF;AAAUM,MAAAA,SAAS,EAAEW,WAAW,CAACX;AAAjC,KAAvB;AACD;AAED;AACF;AACA;AACA;;;AACc,QAANmB,MAAM,CAAEzB,MAAF,EAAUM,SAAV,EAAqB;AAC/B,QAAI,CAACnB,MAAM,CAACwB,QAAP,CAAgBX,MAAhB,CAAL,EAA8B;AAC5BZ,MAAAA,GAAG,CAACG,KAAJ,CAAU,qDAAV;AACA,YAAMN,OAAO,CAAC,IAAI2B,KAAJ,CAAU,uCAAV,CAAD,EAAqD1B,KAAK,CAAC2B,sBAA3D,CAAb;AACD;;AAED,QAAI,CAACC,KAAK,CAACC,OAAN,CAAcT,SAAd,CAAL,EAA+B;AAC7BlB,MAAAA,GAAG,CAACG,KAAJ,CAAU,0CAAV;AACA,YAAMN,OAAO,CAAC,IAAI2B,KAAJ,CAAU,4BAAV,CAAD,EAA0C1B,KAAK,CAAC2B,sBAAhD,CAAb;AACD;;AAEDzB,IAAAA,GAAG,CAAC,yBAAD,CAAH;AACA,UAAMa,OAAO,GAAG,MAAM,KAAKH,MAAL,CAAYI,IAAZ,CAAiBc,SAAjB,EAAtB;AACA5B,IAAAA,GAAG,CAAC,uBAAD,CAAH;AAEA,QAAI6B,WAAJ;;AAEA,QAAI;AACF,UAAI;AACF,cAAMb,IAAI,GAAG,MAAM,KAAKN,MAAL,CAAYO,IAAZ,CAAiBL,MAAjB,CAAnB;AACA,cAAM0B,WAAW,GAAG,IAAIR,GAAJ,CAAQd,IAAI,CAACE,SAAb,CAApB;;AAEA,aAAK,MAAMqB,QAAX,IAAuBrB,SAAvB,EAAkC;AAChCoB,UAAAA,WAAW,CAACE,MAAZ,CAAmBD,QAAnB;AACD;;AAED,YAAIvB,IAAI,CAACE,SAAL,CAAec,MAAf,KAA0BM,WAAW,CAACP,IAA1C,EAAgD;AAC9C;AACD;;AAEDb,QAAAA,SAAS,GAAGQ,KAAK,CAACe,IAAN,CAAWH,WAAX,CAAZ;AACD,OAbD,CAaE;AAAO;AAAmBnB,MAAAA,GAA1B,EAA+B;AAC/B,YAAIA,GAAG,CAACC,IAAJ,KAAatB,KAAK,CAACuB,aAAvB,EAAsC;AACpC,gBAAMF,GAAN;AACD;AACF;;AAEDU,MAAAA,WAAW,GAAG,MAAM,KAAKnB,MAAL,CAAYuB,aAAZ,CAA0BrB,MAA1B,EAAkC;AACpDM,QAAAA;AADoD,OAAlC,CAApB;AAGD,KAvBD,SAuBU;AACRlB,MAAAA,GAAG,CAAC,2BAAD,CAAH;AACAa,MAAAA,OAAO;AACR;;AAED,SAAKJ,KAAL,CAAWL,UAAX,EAAuB;AAAEQ,MAAAA,MAAF;AAAUM,MAAAA,SAAS,EAAEW,WAAW,CAACX;AAAjC,KAAvB;AACD;AAED;AACF;AACA;;;AACc,QAANsB,MAAM,CAAE5B,MAAF,EAAU;AACpBZ,IAAAA,GAAG,CAAC,yBAAD,CAAH;AACA,UAAMa,OAAO,GAAG,MAAM,KAAKH,MAAL,CAAYI,IAAZ,CAAiBc,SAAjB,EAAtB;AACA5B,IAAAA,GAAG,CAAC,uBAAD,CAAH;AACA,QAAI0C,GAAJ;;AAEA,QAAI;AACFA,MAAAA,GAAG,GAAG,MAAM,KAAKhC,MAAL,CAAYgC,GAAZ,CAAgB9B,MAAhB,CAAZ;AAEA,YAAM,KAAKF,MAAL,CAAYuB,aAAZ,CAA0BrB,MAA1B,EAAkC;AACtCM,QAAAA,SAAS,EAAE;AAD2B,OAAlC,CAAN;AAGD,KAND,CAME;AAAO;AAAmBC,IAAAA,GAA1B,EAA+B;AAC/B,UAAIA,GAAG,CAACC,IAAJ,KAAatB,KAAK,CAACuB,aAAvB,EAAsC;AACpC,cAAMF,GAAN;AACD;AACF,KAVD,SAUU;AACRnB,MAAAA,GAAG,CAAC,2BAAD,CAAH;AACAa,MAAAA,OAAO;AACR;;AAED,QAAI6B,GAAJ,EAAS;AACP,WAAKjC,KAAL,CAAWL,UAAX,EAAuB;AAAEQ,QAAAA,MAAF;AAAUM,QAAAA,SAAS,EAAE;AAArB,OAAvB;AACD;AACF;;AApNuB;;AAuN1ByB,MAAM,CAACC,OAAP,GAAiBvC,mBAAjB","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst errcode = require('err-code')\nconst { codes } = require('../errors')\nconst PeerId = require('peer-id')\n\n/**\n * @typedef {import('./types').PeerStore} PeerStore\n * @typedef {import('./types').ProtoBook} ProtoBook\n */\n\nconst log = Object.assign(debug('libp2p:peer-store:proto-book'), {\n  error: debug('libp2p:peer-store:proto-book:err')\n})\n\nconst EVENT_NAME = 'change:protocols'\n\n/**\n * @implements {ProtoBook}\n */\nclass PersistentProtoBook {\n  /**\n   * @param {PeerStore[\"emit\"]} emit\n   * @param {import('./types').Store} store\n   */\n  constructor (emit, store) {\n    this._emit = emit\n    this._store = store\n  }\n\n  /**\n   * @param {PeerId} peerId\n   */\n  async get (peerId) {\n    log('get wait for read lock')\n    const release = await this._store.lock.readLock()\n    log('get got read lock')\n\n    try {\n      const peer = await this._store.load(peerId)\n\n      return peer.protocols\n    } catch (/** @type {any} */ err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err\n      }\n    } finally {\n      log('get release read lock')\n      release()\n    }\n\n    return []\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {string[]} protocols\n   */\n  async set (peerId, protocols) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    if (!Array.isArray(protocols)) {\n      log.error('protocols must be provided to store data')\n      throw errcode(new Error('protocols must be provided'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log('set await write lock')\n    const release = await this._store.lock.writeLock()\n    log('set got write lock')\n\n    let updatedPeer\n\n    try {\n      try {\n        const peer = await this._store.load(peerId)\n\n        if (new Set([\n          ...protocols\n        ]).size === peer.protocols.length) {\n          return\n        }\n      } catch (/** @type {any} */ err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err\n        }\n      }\n\n      updatedPeer = await this._store.patchOrCreate(peerId, {\n        protocols\n      })\n\n      log(`stored provided protocols for ${peerId.toB58String()}`)\n    } finally {\n      log('set release write lock')\n      release()\n    }\n\n    this._emit(EVENT_NAME, { peerId, protocols: updatedPeer.protocols })\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {string[]} protocols\n   */\n  async add (peerId, protocols) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    if (!Array.isArray(protocols)) {\n      log.error('protocols must be provided to store data')\n      throw errcode(new Error('protocols must be provided'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log('add await write lock')\n    const release = await this._store.lock.writeLock()\n    log('add got write lock')\n\n    let updatedPeer\n\n    try {\n      try {\n        const peer = await this._store.load(peerId)\n\n        if (new Set([\n          ...peer.protocols,\n          ...protocols\n        ]).size === peer.protocols.length) {\n          return\n        }\n      } catch (/** @type {any} */ err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err\n        }\n      }\n\n      updatedPeer = await this._store.mergeOrCreate(peerId, {\n        protocols\n      })\n\n      log(`added provided protocols for ${peerId.toB58String()}`)\n    } finally {\n      log('add release write lock')\n      release()\n    }\n\n    this._emit(EVENT_NAME, { peerId, protocols: updatedPeer.protocols })\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {string[]} protocols\n   */\n  async remove (peerId, protocols) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    if (!Array.isArray(protocols)) {\n      log.error('protocols must be provided to store data')\n      throw errcode(new Error('protocols must be provided'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log('remove await write lock')\n    const release = await this._store.lock.writeLock()\n    log('remove got write lock')\n\n    let updatedPeer\n\n    try {\n      try {\n        const peer = await this._store.load(peerId)\n        const protocolSet = new Set(peer.protocols)\n\n        for (const protocol of protocols) {\n          protocolSet.delete(protocol)\n        }\n\n        if (peer.protocols.length === protocolSet.size) {\n          return\n        }\n\n        protocols = Array.from(protocolSet)\n      } catch (/** @type {any} */ err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err\n        }\n      }\n\n      updatedPeer = await this._store.patchOrCreate(peerId, {\n        protocols\n      })\n    } finally {\n      log('remove release write lock')\n      release()\n    }\n\n    this._emit(EVENT_NAME, { peerId, protocols: updatedPeer.protocols })\n  }\n\n  /**\n   * @param {PeerId} peerId\n   */\n  async delete (peerId) {\n    log('delete await write lock')\n    const release = await this._store.lock.writeLock()\n    log('delete got write lock')\n    let has\n\n    try {\n      has = await this._store.has(peerId)\n\n      await this._store.patchOrCreate(peerId, {\n        protocols: []\n      })\n    } catch (/** @type {any} */ err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err\n      }\n    } finally {\n      log('delete release write lock')\n      release()\n    }\n\n    if (has) {\n      this._emit(EVENT_NAME, { peerId, protocols: [] })\n    }\n  }\n}\n\nmodule.exports = PersistentProtoBook\n"]},"metadata":{},"sourceType":"script"}