{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar timeoutAbortController = require('timeout-abort-controller');\n\nvar anySignal = require('any-signal');\n\nvar parseDuration = require('parse-duration');\n\nvar errors = require('./errors.js');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar parseDuration__default = /*#__PURE__*/_interopDefaultLegacy(parseDuration);\n\nfunction withTimeoutOption(fn, optionsArgIndex) {\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    const options = args[optionsArgIndex == null ? args.length - 1 : optionsArgIndex];\n    if (!options || !options.timeout) return fn(...args);\n    const timeout = typeof options.timeout === 'string' ? parseDuration__default[\"default\"](options.timeout) : options.timeout;\n    const controller = new timeoutAbortController.TimeoutController(timeout);\n    options.signal = anySignal.anySignal([options.signal, controller.signal]);\n    const fnRes = fn(...args);\n    const timeoutPromise = new Promise((_resolve, reject) => {\n      controller.signal.addEventListener('abort', () => {\n        reject(new errors.TimeoutError());\n      });\n    });\n    const start = Date.now();\n\n    const maybeThrowTimeoutError = () => {\n      if (controller.signal.aborted) {\n        throw new errors.TimeoutError();\n      }\n\n      const timeTaken = Date.now() - start;\n\n      if (timeTaken > timeout) {\n        controller.abort();\n        throw new errors.TimeoutError();\n      }\n    };\n\n    if (fnRes[Symbol.asyncIterator]) {\n      return async function* () {\n        const it = fnRes[Symbol.asyncIterator]();\n\n        try {\n          while (true) {\n            const {\n              value,\n              done\n            } = await Promise.race([it.next(), timeoutPromise]);\n\n            if (done) {\n              break;\n            }\n\n            maybeThrowTimeoutError();\n            yield value;\n          }\n        } catch (err) {\n          maybeThrowTimeoutError();\n          throw err;\n        } finally {\n          controller.clear();\n\n          if (it.return) {\n            it.return();\n          }\n        }\n      }();\n    }\n\n    return (async () => {\n      try {\n        const res = await Promise.race([fnRes, timeoutPromise]);\n        maybeThrowTimeoutError();\n        return res;\n      } catch (err) {\n        maybeThrowTimeoutError();\n        throw err;\n      } finally {\n        controller.clear();\n      }\n    })();\n  };\n}\n\nexports.withTimeoutOption = withTimeoutOption;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-core-utils/cjs/src/with-timeout-option.js"],"names":["Object","defineProperty","exports","value","timeoutAbortController","require","anySignal","parseDuration","errors","_interopDefaultLegacy","e","parseDuration__default","withTimeoutOption","fn","optionsArgIndex","args","options","length","timeout","controller","TimeoutController","signal","fnRes","timeoutPromise","Promise","_resolve","reject","addEventListener","TimeoutError","start","Date","now","maybeThrowTimeoutError","aborted","timeTaken","abort","Symbol","asyncIterator","it","done","race","next","err","clear","return","res"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar timeoutAbortController = require('timeout-abort-controller');\nvar anySignal = require('any-signal');\nvar parseDuration = require('parse-duration');\nvar errors = require('./errors.js');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar parseDuration__default = /*#__PURE__*/_interopDefaultLegacy(parseDuration);\n\nfunction withTimeoutOption(fn, optionsArgIndex) {\n  return (...args) => {\n    const options = args[optionsArgIndex == null ? args.length - 1 : optionsArgIndex];\n    if (!options || !options.timeout)\n      return fn(...args);\n    const timeout = typeof options.timeout === 'string' ? parseDuration__default[\"default\"](options.timeout) : options.timeout;\n    const controller = new timeoutAbortController.TimeoutController(timeout);\n    options.signal = anySignal.anySignal([\n      options.signal,\n      controller.signal\n    ]);\n    const fnRes = fn(...args);\n    const timeoutPromise = new Promise((_resolve, reject) => {\n      controller.signal.addEventListener('abort', () => {\n        reject(new errors.TimeoutError());\n      });\n    });\n    const start = Date.now();\n    const maybeThrowTimeoutError = () => {\n      if (controller.signal.aborted) {\n        throw new errors.TimeoutError();\n      }\n      const timeTaken = Date.now() - start;\n      if (timeTaken > timeout) {\n        controller.abort();\n        throw new errors.TimeoutError();\n      }\n    };\n    if (fnRes[Symbol.asyncIterator]) {\n      return async function* () {\n        const it = fnRes[Symbol.asyncIterator]();\n        try {\n          while (true) {\n            const {value, done} = await Promise.race([\n              it.next(),\n              timeoutPromise\n            ]);\n            if (done) {\n              break;\n            }\n            maybeThrowTimeoutError();\n            yield value;\n          }\n        } catch (err) {\n          maybeThrowTimeoutError();\n          throw err;\n        } finally {\n          controller.clear();\n          if (it.return) {\n            it.return();\n          }\n        }\n      }();\n    }\n    return (async () => {\n      try {\n        const res = await Promise.race([\n          fnRes,\n          timeoutPromise\n        ]);\n        maybeThrowTimeoutError();\n        return res;\n      } catch (err) {\n        maybeThrowTimeoutError();\n        throw err;\n      } finally {\n        controller.clear();\n      }\n    })();\n  };\n}\n\nexports.withTimeoutOption = withTimeoutOption;\n"]},"metadata":{},"sourceType":"script"}