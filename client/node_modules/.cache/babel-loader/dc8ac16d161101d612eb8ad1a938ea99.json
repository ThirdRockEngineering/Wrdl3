{"ast":null,"code":"'use strict';\n\nconst {\n  Message\n} = require('../message');\n\nconst parallel = require('it-parallel');\n\nconst map = require('it-map');\n\nconst {\n  convertBuffer,\n  logger\n} = require('../utils');\n\nconst {\n  ALPHA\n} = require('../constants');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst {\n  queryErrorEvent,\n  peerResponseEvent,\n  providerEvent\n} = require('../query/events');\n\nconst {\n  Message: {\n    MessageType\n  }\n} = require('../message/dht');\n/**\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n\nclass ContentRouting {\n  /**\n   * @param {object} params\n   * @param {import('peer-id')} params.peerId\n   * @param {import('../network').Network} params.network\n   * @param {import('../peer-routing').PeerRouting} params.peerRouting\n   * @param {import('../query/manager').QueryManager} params.queryManager\n   * @param {import('../routing-table').RoutingTable} params.routingTable\n   * @param {import('../providers').Providers} params.providers\n   * @param {import('libp2p/src/peer-store/types').PeerStore} params.peerStore\n   * @param {boolean} params.lan\n   */\n  constructor(_ref) {\n    let {\n      peerId,\n      network,\n      peerRouting,\n      queryManager,\n      routingTable,\n      providers,\n      peerStore,\n      lan\n    } = _ref;\n    this._log = logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}:content-routing`);\n    this._peerId = peerId;\n    this._network = network;\n    this._peerRouting = peerRouting;\n    this._queryManager = queryManager;\n    this._routingTable = routingTable;\n    this._providers = providers;\n    this._peerStore = peerStore;\n  }\n  /**\n   * Announce to the network that we can provide the value for a given key and\n   * are contactable on the given multiaddrs\n   *\n   * @param {CID} key\n   * @param {Multiaddr[]} multiaddrs\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  async *provide(key, multiaddrs) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    this._log('provide %s', key); // Add peer as provider\n\n\n    await this._providers.addProvider(key, this._peerId);\n    const msg = new Message(Message.TYPES.ADD_PROVIDER, key.bytes, 0);\n    msg.providerPeers = [{\n      id: this._peerId,\n      multiaddrs\n    }];\n    let sent = 0;\n    /**\n     * @param {import('../types').QueryEvent} event\n     */\n\n    const maybeNotifyPeer = event => {\n      return async () => {\n        if (event.name !== 'FINAL_PEER') {\n          return [event];\n        }\n\n        const events = [];\n\n        this._log('putProvider %s to %p', key, event.peer.id);\n\n        try {\n          this._log('sending provider record for %s to %p', key, event.peer.id);\n\n          for await (const sendEvent of this._network.sendMessage(event.peer.id, msg, options)) {\n            if (sendEvent.name === 'PEER_RESPONSE') {\n              this._log('sent provider record for %s to %p', key, event.peer.id);\n\n              sent++;\n            }\n\n            events.push(sendEvent);\n          }\n        } catch (\n        /** @type {any} */\n        err) {\n          this._log.error('error sending provide record to peer %p', event.peer.id, err);\n\n          events.push(queryErrorEvent({\n            from: event.peer.id,\n            error: err\n          }));\n        }\n\n        return events;\n      };\n    }; // Notify closest peers\n\n\n    yield* pipe(this._peerRouting.getClosestPeers(key.multihash.bytes, options), source => map(source, event => maybeNotifyPeer(event)), source => parallel(source, {\n      ordered: false,\n      concurrency: ALPHA\n    }), async function* (source) {\n      for await (const events of source) {\n        yield* events;\n      }\n    });\n\n    this._log('sent provider records to %d peers', sent);\n  }\n  /**\n   * Search the dht for up to `K` providers of the given CID.\n   *\n   * @param {CID} key\n   * @param {object} [options] - findProviders options\n   * @param {number} [options.maxNumProviders=5] - maximum number of providers to find\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.queryFuncTimeout]\n   */\n\n\n  async *findProviders(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      maxNumProviders: 5\n    };\n    const toFind = options.maxNumProviders || this._routingTable._kBucketSize;\n    const target = key.multihash.bytes;\n    const id = await convertBuffer(target);\n    const self = this;\n\n    this._log(`findProviders ${key}`);\n\n    const provs = await this._providers.getProviders(key); // yield values if we have some, also slice because maybe we got lucky and already have too many?\n\n    if (provs.length) {\n      /** @type {{ id: PeerId, multiaddrs: Multiaddr[] }[]} */\n      const providers = [];\n\n      for (const peerId of provs.slice(0, toFind)) {\n        providers.push({\n          id: peerId,\n          multiaddrs: ((await this._peerStore.addressBook.get(peerId)) || []).map(address => address.multiaddr)\n        });\n      }\n\n      yield peerResponseEvent({\n        from: this._peerId,\n        messageType: MessageType.GET_PROVIDERS,\n        providers\n      });\n      yield providerEvent({\n        from: this._peerId,\n        providers: providers\n      });\n    } // All done\n\n\n    if (provs.length >= toFind) {\n      return;\n    }\n    /**\n     * The query function to use on this particular disjoint path\n     *\n     * @type {import('../query/types').QueryFunc}\n     */\n\n\n    const findProvidersQuery = async function* (_ref2) {\n      let {\n        peer,\n        signal\n      } = _ref2;\n      const request = new Message(Message.TYPES.GET_PROVIDERS, target, 0);\n      yield* self._network.sendRequest(peer, request, {\n        signal\n      });\n    };\n\n    const providers = new Set(provs.map(p => p.toB58String()));\n\n    for await (const event of this._queryManager.run(target, this._routingTable.closestPeers(id), findProvidersQuery, options)) {\n      yield event;\n\n      if (event.name === 'PEER_RESPONSE') {\n        this._log(`Found ${event.providers.length} provider entries for ${key} and ${event.closer.length} closer peers`);\n\n        const newProviders = [];\n\n        for (const peer of event.providers) {\n          if (providers.has(peer.id.toB58String())) {\n            continue;\n          }\n\n          providers.add(peer.id.toB58String());\n          newProviders.push(peer);\n        }\n\n        if (newProviders.length) {\n          yield providerEvent({\n            from: event.from,\n            providers: newProviders\n          });\n        }\n\n        if (providers.size === toFind) {\n          return;\n        }\n      }\n    }\n  }\n\n}\n\nmodule.exports.ContentRouting = ContentRouting;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/libp2p-kad-dht/src/content-routing/index.js"],"names":["Message","require","parallel","map","convertBuffer","logger","ALPHA","pipe","queryErrorEvent","peerResponseEvent","providerEvent","MessageType","ContentRouting","constructor","peerId","network","peerRouting","queryManager","routingTable","providers","peerStore","lan","_log","_peerId","_network","_peerRouting","_queryManager","_routingTable","_providers","_peerStore","provide","key","multiaddrs","options","addProvider","msg","TYPES","ADD_PROVIDER","bytes","providerPeers","id","sent","maybeNotifyPeer","event","name","events","peer","sendEvent","sendMessage","push","err","error","from","getClosestPeers","multihash","source","ordered","concurrency","findProviders","maxNumProviders","toFind","_kBucketSize","target","self","provs","getProviders","length","slice","addressBook","get","address","multiaddr","messageType","GET_PROVIDERS","findProvidersQuery","signal","request","sendRequest","Set","p","toB58String","run","closestPeers","closer","newProviders","has","add","size","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Message } = require('../message')\nconst parallel = require('it-parallel')\nconst map = require('it-map')\nconst { convertBuffer, logger } = require('../utils')\nconst { ALPHA } = require('../constants')\nconst { pipe } = require('it-pipe')\nconst {\n  queryErrorEvent,\n  peerResponseEvent,\n  providerEvent\n} = require('../query/events')\nconst { Message: { MessageType } } = require('../message/dht')\n\n/**\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\nclass ContentRouting {\n  /**\n   * @param {object} params\n   * @param {import('peer-id')} params.peerId\n   * @param {import('../network').Network} params.network\n   * @param {import('../peer-routing').PeerRouting} params.peerRouting\n   * @param {import('../query/manager').QueryManager} params.queryManager\n   * @param {import('../routing-table').RoutingTable} params.routingTable\n   * @param {import('../providers').Providers} params.providers\n   * @param {import('libp2p/src/peer-store/types').PeerStore} params.peerStore\n   * @param {boolean} params.lan\n   */\n  constructor ({ peerId, network, peerRouting, queryManager, routingTable, providers, peerStore, lan }) {\n    this._log = logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}:content-routing`)\n    this._peerId = peerId\n    this._network = network\n    this._peerRouting = peerRouting\n    this._queryManager = queryManager\n    this._routingTable = routingTable\n    this._providers = providers\n    this._peerStore = peerStore\n  }\n\n  /**\n   * Announce to the network that we can provide the value for a given key and\n   * are contactable on the given multiaddrs\n   *\n   * @param {CID} key\n   * @param {Multiaddr[]} multiaddrs\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async * provide (key, multiaddrs, options = {}) {\n    this._log('provide %s', key)\n\n    // Add peer as provider\n    await this._providers.addProvider(key, this._peerId)\n\n    const msg = new Message(Message.TYPES.ADD_PROVIDER, key.bytes, 0)\n    msg.providerPeers = [{\n      id: this._peerId,\n      multiaddrs\n    }]\n\n    let sent = 0\n\n    /**\n     * @param {import('../types').QueryEvent} event\n     */\n    const maybeNotifyPeer = (event) => {\n      return async () => {\n        if (event.name !== 'FINAL_PEER') {\n          return [event]\n        }\n\n        const events = []\n\n        this._log('putProvider %s to %p', key, event.peer.id)\n\n        try {\n          this._log('sending provider record for %s to %p', key, event.peer.id)\n\n          for await (const sendEvent of this._network.sendMessage(event.peer.id, msg, options)) {\n            if (sendEvent.name === 'PEER_RESPONSE') {\n              this._log('sent provider record for %s to %p', key, event.peer.id)\n              sent++\n            }\n\n            events.push(sendEvent)\n          }\n        } catch (/** @type {any} */ err) {\n          this._log.error('error sending provide record to peer %p', event.peer.id, err)\n          events.push(queryErrorEvent({ from: event.peer.id, error: err }))\n        }\n\n        return events\n      }\n    }\n\n    // Notify closest peers\n    yield * pipe(\n      this._peerRouting.getClosestPeers(key.multihash.bytes, options),\n      (source) => map(source, (event) => maybeNotifyPeer(event)),\n      (source) => parallel(source, {\n        ordered: false,\n        concurrency: ALPHA\n      }),\n      async function * (source) {\n        for await (const events of source) {\n          yield * events\n        }\n      }\n    )\n\n    this._log('sent provider records to %d peers', sent)\n  }\n\n  /**\n   * Search the dht for up to `K` providers of the given CID.\n   *\n   * @param {CID} key\n   * @param {object} [options] - findProviders options\n   * @param {number} [options.maxNumProviders=5] - maximum number of providers to find\n   * @param {AbortSignal} [options.signal]\n   * @param {number} [options.queryFuncTimeout]\n   */\n  async * findProviders (key, options = { maxNumProviders: 5 }) {\n    const toFind = options.maxNumProviders || this._routingTable._kBucketSize\n    const target = key.multihash.bytes\n    const id = await convertBuffer(target)\n    const self = this\n\n    this._log(`findProviders ${key}`)\n\n    const provs = await this._providers.getProviders(key)\n\n    // yield values if we have some, also slice because maybe we got lucky and already have too many?\n    if (provs.length) {\n      /** @type {{ id: PeerId, multiaddrs: Multiaddr[] }[]} */\n      const providers = []\n\n      for (const peerId of provs.slice(0, toFind)) {\n        providers.push({\n          id: peerId,\n          multiaddrs: ((await this._peerStore.addressBook.get(peerId)) || []).map(address => address.multiaddr)\n        })\n      }\n\n      yield peerResponseEvent({ from: this._peerId, messageType: MessageType.GET_PROVIDERS, providers })\n      yield providerEvent({ from: this._peerId, providers: providers })\n    }\n\n    // All done\n    if (provs.length >= toFind) {\n      return\n    }\n\n    /**\n     * The query function to use on this particular disjoint path\n     *\n     * @type {import('../query/types').QueryFunc}\n     */\n    const findProvidersQuery = async function * ({ peer, signal }) {\n      const request = new Message(Message.TYPES.GET_PROVIDERS, target, 0)\n\n      yield * self._network.sendRequest(peer, request, { signal })\n    }\n\n    const providers = new Set(provs.map(p => p.toB58String()))\n\n    for await (const event of this._queryManager.run(target, this._routingTable.closestPeers(id), findProvidersQuery, options)) {\n      yield event\n\n      if (event.name === 'PEER_RESPONSE') {\n        this._log(`Found ${event.providers.length} provider entries for ${key} and ${event.closer.length} closer peers`)\n\n        const newProviders = []\n\n        for (const peer of event.providers) {\n          if (providers.has(peer.id.toB58String())) {\n            continue\n          }\n\n          providers.add(peer.id.toB58String())\n          newProviders.push(peer)\n        }\n\n        if (newProviders.length) {\n          yield providerEvent({ from: event.from, providers: newProviders })\n        }\n\n        if (providers.size === toFind) {\n          return\n        }\n      }\n    }\n  }\n}\n\nmodule.exports.ContentRouting = ContentRouting\n"]},"metadata":{},"sourceType":"script"}