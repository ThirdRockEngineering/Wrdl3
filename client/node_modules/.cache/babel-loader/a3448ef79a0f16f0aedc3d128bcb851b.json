{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar index$2 = require('../message/index.js');\n\nvar index = require('../wantlist/index.js');\n\nvar constants = require('../constants.js');\n\nvar msgQueue = require('./msg-queue.js');\n\nvar index$1 = require('../utils/index.js');\n\nvar base58 = require('multiformats/bases/base58');\n\nvar trackedMap = require('libp2p/src/metrics/tracked-map.js');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar trackedMap__default = /*#__PURE__*/_interopDefaultLegacy(trackedMap);\n\nclass WantManager {\n  constructor(peerId, network, stats, libp2p) {\n    this.peers = trackedMap__default[\"default\"]({\n      system: 'ipfs',\n      component: 'bitswap',\n      metric: 'want-manager-peers',\n      metrics: libp2p.metrics\n    });\n    this.wantlist = new index.Wantlist(stats, libp2p);\n    this.network = network;\n    this._stats = stats;\n    this._peerId = peerId;\n    this._log = index$1.logger(peerId, 'want');\n  }\n\n  _addEntries(cids, cancel, force) {\n    const entries = cids.map((cid, i) => {\n      return new index$2.BitswapMessage.Entry(cid, constants.kMaxPriority - i, index$2.BitswapMessage.WantType.Block, cancel);\n    });\n    entries.forEach(e => {\n      if (e.cancel) {\n        if (force) {\n          this.wantlist.removeForce(e.cid.toString(base58.base58btc));\n        } else {\n          this.wantlist.remove(e.cid);\n        }\n      } else {\n        this._log('adding to wl');\n\n        this.wantlist.add(e.cid, e.priority);\n      }\n    });\n\n    for (const p of this.peers.values()) {\n      p.addEntries(entries);\n    }\n  }\n\n  _startPeerHandler(peerId) {\n    let mq = this.peers.get(peerId.toB58String());\n\n    if (mq) {\n      mq.refcnt++;\n      return;\n    }\n\n    mq = new msgQueue.MsgQueue(this._peerId, peerId, this.network);\n    const fullwantlist = new index$2.BitswapMessage(true);\n\n    for (const entry of this.wantlist.entries()) {\n      fullwantlist.addEntry(entry[1].cid, entry[1].priority);\n    }\n\n    mq.addMessage(fullwantlist);\n    this.peers.set(peerId.toB58String(), mq);\n    return mq;\n  }\n\n  _stopPeerHandler(peerId) {\n    const mq = this.peers.get(peerId.toB58String());\n\n    if (!mq) {\n      return;\n    }\n\n    mq.refcnt--;\n\n    if (mq.refcnt > 0) {\n      return;\n    }\n\n    this.peers.delete(peerId.toB58String());\n  }\n\n  wantBlocks(cids) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    this._addEntries(cids, false);\n\n    if (options && options.signal) {\n      options.signal.addEventListener('abort', () => {\n        this.cancelWants(cids);\n      });\n    }\n  }\n\n  unwantBlocks(cids) {\n    this._log('unwant blocks: %s', cids.length);\n\n    this._addEntries(cids, true, true);\n  }\n\n  cancelWants(cids) {\n    this._log('cancel wants: %s', cids.length);\n\n    this._addEntries(cids, true);\n  }\n\n  connectedPeers() {\n    return Array.from(this.peers.keys());\n  }\n\n  connected(peerId) {\n    this._startPeerHandler(peerId);\n  }\n\n  disconnected(peerId) {\n    this._stopPeerHandler(peerId);\n  }\n\n  start() {}\n\n  stop() {\n    this.peers.forEach(mq => this.disconnected(mq.peerId));\n  }\n\n}\n\nexports.WantManager = WantManager;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-bitswap/cjs/src/want-manager/index.js"],"names":["Object","defineProperty","exports","value","index$2","require","index","constants","msgQueue","index$1","base58","trackedMap","_interopDefaultLegacy","e","trackedMap__default","WantManager","constructor","peerId","network","stats","libp2p","peers","system","component","metric","metrics","wantlist","Wantlist","_stats","_peerId","_log","logger","_addEntries","cids","cancel","force","entries","map","cid","i","BitswapMessage","Entry","kMaxPriority","WantType","Block","forEach","removeForce","toString","base58btc","remove","add","priority","p","values","addEntries","_startPeerHandler","mq","get","toB58String","refcnt","MsgQueue","fullwantlist","entry","addEntry","addMessage","set","_stopPeerHandler","delete","wantBlocks","options","signal","addEventListener","cancelWants","unwantBlocks","length","connectedPeers","Array","from","keys","connected","disconnected","start","stop"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar index$2 = require('../message/index.js');\nvar index = require('../wantlist/index.js');\nvar constants = require('../constants.js');\nvar msgQueue = require('./msg-queue.js');\nvar index$1 = require('../utils/index.js');\nvar base58 = require('multiformats/bases/base58');\nvar trackedMap = require('libp2p/src/metrics/tracked-map.js');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar trackedMap__default = /*#__PURE__*/_interopDefaultLegacy(trackedMap);\n\nclass WantManager {\n  constructor(peerId, network, stats, libp2p) {\n    this.peers = trackedMap__default[\"default\"]({\n      system: 'ipfs',\n      component: 'bitswap',\n      metric: 'want-manager-peers',\n      metrics: libp2p.metrics\n    });\n    this.wantlist = new index.Wantlist(stats, libp2p);\n    this.network = network;\n    this._stats = stats;\n    this._peerId = peerId;\n    this._log = index$1.logger(peerId, 'want');\n  }\n  _addEntries(cids, cancel, force) {\n    const entries = cids.map((cid, i) => {\n      return new index$2.BitswapMessage.Entry(cid, constants.kMaxPriority - i, index$2.BitswapMessage.WantType.Block, cancel);\n    });\n    entries.forEach(e => {\n      if (e.cancel) {\n        if (force) {\n          this.wantlist.removeForce(e.cid.toString(base58.base58btc));\n        } else {\n          this.wantlist.remove(e.cid);\n        }\n      } else {\n        this._log('adding to wl');\n        this.wantlist.add(e.cid, e.priority);\n      }\n    });\n    for (const p of this.peers.values()) {\n      p.addEntries(entries);\n    }\n  }\n  _startPeerHandler(peerId) {\n    let mq = this.peers.get(peerId.toB58String());\n    if (mq) {\n      mq.refcnt++;\n      return;\n    }\n    mq = new msgQueue.MsgQueue(this._peerId, peerId, this.network);\n    const fullwantlist = new index$2.BitswapMessage(true);\n    for (const entry of this.wantlist.entries()) {\n      fullwantlist.addEntry(entry[1].cid, entry[1].priority);\n    }\n    mq.addMessage(fullwantlist);\n    this.peers.set(peerId.toB58String(), mq);\n    return mq;\n  }\n  _stopPeerHandler(peerId) {\n    const mq = this.peers.get(peerId.toB58String());\n    if (!mq) {\n      return;\n    }\n    mq.refcnt--;\n    if (mq.refcnt > 0) {\n      return;\n    }\n    this.peers.delete(peerId.toB58String());\n  }\n  wantBlocks(cids, options = {}) {\n    this._addEntries(cids, false);\n    if (options && options.signal) {\n      options.signal.addEventListener('abort', () => {\n        this.cancelWants(cids);\n      });\n    }\n  }\n  unwantBlocks(cids) {\n    this._log('unwant blocks: %s', cids.length);\n    this._addEntries(cids, true, true);\n  }\n  cancelWants(cids) {\n    this._log('cancel wants: %s', cids.length);\n    this._addEntries(cids, true);\n  }\n  connectedPeers() {\n    return Array.from(this.peers.keys());\n  }\n  connected(peerId) {\n    this._startPeerHandler(peerId);\n  }\n  disconnected(peerId) {\n    this._stopPeerHandler(peerId);\n  }\n  start() {\n  }\n  stop() {\n    this.peers.forEach(mq => this.disconnected(mq.peerId));\n  }\n}\n\nexports.WantManager = WantManager;\n"]},"metadata":{},"sourceType":"script"}