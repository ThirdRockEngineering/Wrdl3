{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar mergeOpts = require('merge-options');\n\nvar toMfsPath = require('./utils/to-mfs-path.js');\n\nvar debug = require('debug');\n\nvar errCode = require('err-code');\n\nvar ipfsUnixfs = require('ipfs-unixfs');\n\nvar toTrail = require('./utils/to-trail.js');\n\nvar addLink = require('./utils/add-link.js');\n\nvar updateTree = require('./utils/update-tree.js');\n\nvar updateMfsRoot = require('./utils/update-mfs-root.js');\n\nvar dagPB = require('@ipld/dag-pb');\n\nvar cid = require('multiformats/cid');\n\nvar itPipe = require('it-pipe');\n\nvar ipfsUnixfsImporter = require('ipfs-unixfs-importer');\n\nvar ipfsUnixfsExporter = require('ipfs-unixfs-exporter');\n\nvar last = require('it-last');\n\nvar cp = require('./cp.js');\n\nvar rm = require('./rm.js');\n\nvar persist = require('./utils/persist.js');\n\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar mergeOpts__default = /*#__PURE__*/_interopDefaultLegacy(mergeOpts);\n\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\n\nvar dagPB__namespace = /*#__PURE__*/_interopNamespace(dagPB);\n\nvar last__default = /*#__PURE__*/_interopDefaultLegacy(last);\n\nconst mergeOptions = mergeOpts__default[\"default\"].bind({\n  ignoreUndefined: true\n});\nconst log = debug__default[\"default\"]('ipfs:mfs:touch');\nconst defaultOptions = {\n  flush: true,\n  shardSplitThreshold: 1000,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  recursive: false\n};\n\nfunction calculateModification(mode, originalMode, isDirectory) {\n  let modification = 0;\n\n  if (mode.includes('x') || mode.includes('X') && (isDirectory || originalMode & 1 || originalMode & 8 || originalMode & 64)) {\n    modification += 1;\n  }\n\n  if (mode.includes('w')) {\n    modification += 2;\n  }\n\n  if (mode.includes('r')) {\n    modification += 4;\n  }\n\n  return modification;\n}\n\nfunction calculateUGO(references, modification) {\n  let ugo = 0;\n\n  if (references.includes('u')) {\n    ugo += modification << 6;\n  }\n\n  if (references.includes('g')) {\n    ugo += modification << 3;\n  }\n\n  if (references.includes('o')) {\n    ugo += modification;\n  }\n\n  return ugo;\n}\n\nfunction calculateSpecial(references, mode, modification) {\n  if (mode.includes('t')) {\n    modification += parseInt('1000', 8);\n  }\n\n  if (mode.includes('s')) {\n    if (references.includes('u')) {\n      modification += parseInt('4000', 8);\n    }\n\n    if (references.includes('g')) {\n      modification += parseInt('2000', 8);\n    }\n  }\n\n  return modification;\n}\n\nfunction parseSymbolicMode(input, originalMode, isDirectory) {\n  if (!originalMode) {\n    originalMode = 0;\n  }\n\n  const match = input.match(/^(u?g?o?a?)(-?\\+?=?)?(r?w?x?X?s?t?)$/);\n\n  if (!match) {\n    throw new Error(`Invalid file mode: ${input}`);\n  }\n\n  let [, references, operator, mode] = match;\n\n  if (references === 'a' || !references) {\n    references = 'ugo';\n  }\n\n  let modification = calculateModification(mode, originalMode, isDirectory);\n  modification = calculateUGO(references, modification);\n  modification = calculateSpecial(references, mode, modification);\n\n  if (operator === '=') {\n    if (references.includes('u')) {\n      originalMode = originalMode & parseInt('7077', 8);\n      originalMode = originalMode | modification;\n    }\n\n    if (references.includes('g')) {\n      originalMode = originalMode & parseInt('7707', 8);\n      originalMode = originalMode | modification;\n    }\n\n    if (references.includes('o')) {\n      originalMode = originalMode & parseInt('7770', 8);\n      originalMode = originalMode | modification;\n    }\n\n    return originalMode;\n  }\n\n  if (operator === '+') {\n    return modification | originalMode;\n  }\n\n  if (operator === '-') {\n    return modification ^ originalMode;\n  }\n\n  return originalMode;\n}\n\nfunction calculateMode(mode, metadata) {\n  if (mode instanceof String || typeof mode === 'string') {\n    const strMode = `${mode}`;\n\n    if (strMode.match(/^\\d+$/g)) {\n      mode = parseInt(strMode, 8);\n    } else {\n      mode = 0 + strMode.split(',').reduce((curr, acc) => {\n        return parseSymbolicMode(acc, curr, metadata.isDirectory());\n      }, metadata.mode || 0);\n    }\n  }\n\n  return mode;\n}\n\nfunction createChmod(context) {\n  async function mfsChmod(path, mode) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const opts = mergeOptions(defaultOptions, options);\n    log(`Fetching stats for ${path}`);\n    const {\n      cid: cid$1,\n      mfsDirectory,\n      name\n    } = await toMfsPath.toMfsPath(context, path, opts);\n\n    if (cid$1.code !== dagPB__namespace.code) {\n      throw errCode__default[\"default\"](new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS');\n    }\n\n    if (opts.recursive) {\n      const root = await itPipe.pipe(async function* () {\n        for await (const entry of ipfsUnixfsExporter.recursive(cid$1, context.repo.blocks)) {\n          if (entry.type !== 'file' && entry.type !== 'directory') {\n            throw errCode__default[\"default\"](new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS');\n          }\n\n          entry.unixfs.mode = calculateMode(mode, entry.unixfs);\n          const node = dagPB__namespace.prepare({\n            Data: entry.unixfs.marshal(),\n            Links: entry.node.Links\n          });\n          yield {\n            path: entry.path,\n            content: node\n          };\n        }\n      }, source => ipfsUnixfsImporter.importer(source, context.repo.blocks, { ...opts,\n        pin: false,\n        dagBuilder: async function* (source, block, opts) {\n          for await (const entry of source) {\n            yield async function () {\n              const node = entry.content;\n              const buf = dagPB__namespace.encode(node);\n              const cid = await persist.persist(buf, block, opts);\n\n              if (!node.Data) {\n                throw errCode__default[\"default\"](new Error(`${cid} had no data`), 'ERR_INVALID_NODE');\n              }\n\n              const unixfs = ipfsUnixfs.UnixFS.unmarshal(node.Data);\n              return {\n                cid,\n                size: buf.length,\n                path: entry.path,\n                unixfs\n              };\n            };\n          }\n        }\n      }), nodes => last__default[\"default\"](nodes));\n\n      if (!root) {\n        throw errCode__default[\"default\"](new Error(`Could not chmod ${path}`), 'ERR_COULD_NOT_CHMOD');\n      }\n\n      await rm.createRm(context)(path, opts);\n      await cp.createCp(context)(`/ipfs/${root.cid}`, path, opts);\n      return;\n    }\n\n    const block = await context.repo.blocks.get(cid$1);\n    const node = dagPB__namespace.decode(block);\n\n    if (!node.Data) {\n      throw errCode__default[\"default\"](new Error(`${cid$1} had no data`), 'ERR_INVALID_NODE');\n    }\n\n    const metadata = ipfsUnixfs.UnixFS.unmarshal(node.Data);\n    metadata.mode = calculateMode(mode, metadata);\n    const updatedBlock = dagPB__namespace.encode({\n      Data: metadata.marshal(),\n      Links: node.Links\n    });\n    const hashAlg = opts.hashAlg || defaultOptions.hashAlg;\n    const hasher = await context.hashers.getHasher(hashAlg);\n    const hash = await hasher.digest(updatedBlock);\n    const updatedCid = cid.CID.create(opts.cidVersion, dagPB__namespace.code, hash);\n\n    if (opts.flush) {\n      await context.repo.blocks.put(updatedCid, updatedBlock);\n    }\n\n    const trail = await toTrail.toTrail(context, mfsDirectory);\n    const parent = trail[trail.length - 1];\n    const parentCid = cid.CID.decode(parent.cid.bytes);\n    const parentBlock = await context.repo.blocks.get(parentCid);\n    const parentNode = dagPB__namespace.decode(parentBlock);\n    const result = await addLink.addLink(context, {\n      parent: parentNode,\n      name: name,\n      cid: updatedCid,\n      size: updatedBlock.length,\n      flush: opts.flush,\n      hashAlg,\n      cidVersion: cid$1.version,\n      shardSplitThreshold: Infinity\n    });\n    parent.cid = result.cid;\n    const newRootCid = await updateTree.updateTree(context, trail, opts);\n    await updateMfsRoot.updateMfsRoot(context, newRootCid, opts);\n  }\n\n  return withTimeoutOption.withTimeoutOption(mfsChmod);\n}\n\nexports.createChmod = createChmod;","map":{"version":3,"sources":["/Users/emilsharafutdinov/Desktop/Work/SR3/Wrdl3/client/node_modules/ipfs-core/cjs/src/components/files/chmod.js"],"names":["Object","defineProperty","exports","value","mergeOpts","require","toMfsPath","debug","errCode","ipfsUnixfs","toTrail","addLink","updateTree","updateMfsRoot","dagPB","cid","itPipe","ipfsUnixfsImporter","ipfsUnixfsExporter","last","cp","rm","persist","withTimeoutOption","_interopDefaultLegacy","e","_interopNamespace","__esModule","n","create","keys","forEach","k","d","getOwnPropertyDescriptor","get","enumerable","freeze","mergeOpts__default","debug__default","errCode__default","dagPB__namespace","last__default","mergeOptions","bind","ignoreUndefined","log","defaultOptions","flush","shardSplitThreshold","hashAlg","cidVersion","recursive","calculateModification","mode","originalMode","isDirectory","modification","includes","calculateUGO","references","ugo","calculateSpecial","parseInt","parseSymbolicMode","input","match","Error","operator","calculateMode","metadata","String","strMode","split","reduce","curr","acc","createChmod","context","mfsChmod","path","options","opts","cid$1","mfsDirectory","name","code","root","pipe","entry","repo","blocks","type","unixfs","node","prepare","Data","marshal","Links","content","source","importer","pin","dagBuilder","block","buf","encode","UnixFS","unmarshal","size","length","nodes","createRm","createCp","decode","updatedBlock","hasher","hashers","getHasher","hash","digest","updatedCid","CID","put","trail","parent","parentCid","bytes","parentBlock","parentNode","result","version","Infinity","newRootCid"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar mergeOpts = require('merge-options');\nvar toMfsPath = require('./utils/to-mfs-path.js');\nvar debug = require('debug');\nvar errCode = require('err-code');\nvar ipfsUnixfs = require('ipfs-unixfs');\nvar toTrail = require('./utils/to-trail.js');\nvar addLink = require('./utils/add-link.js');\nvar updateTree = require('./utils/update-tree.js');\nvar updateMfsRoot = require('./utils/update-mfs-root.js');\nvar dagPB = require('@ipld/dag-pb');\nvar cid = require('multiformats/cid');\nvar itPipe = require('it-pipe');\nvar ipfsUnixfsImporter = require('ipfs-unixfs-importer');\nvar ipfsUnixfsExporter = require('ipfs-unixfs-exporter');\nvar last = require('it-last');\nvar cp = require('./cp.js');\nvar rm = require('./rm.js');\nvar persist = require('./utils/persist.js');\nvar withTimeoutOption = require('ipfs-core-utils/with-timeout-option');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar mergeOpts__default = /*#__PURE__*/_interopDefaultLegacy(mergeOpts);\nvar debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\nvar dagPB__namespace = /*#__PURE__*/_interopNamespace(dagPB);\nvar last__default = /*#__PURE__*/_interopDefaultLegacy(last);\n\nconst mergeOptions = mergeOpts__default[\"default\"].bind({ ignoreUndefined: true });\nconst log = debug__default[\"default\"]('ipfs:mfs:touch');\nconst defaultOptions = {\n  flush: true,\n  shardSplitThreshold: 1000,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  recursive: false\n};\nfunction calculateModification(mode, originalMode, isDirectory) {\n  let modification = 0;\n  if (mode.includes('x') || mode.includes('X') && (isDirectory || (originalMode & 1 || originalMode & 8 || originalMode & 64))) {\n    modification += 1;\n  }\n  if (mode.includes('w')) {\n    modification += 2;\n  }\n  if (mode.includes('r')) {\n    modification += 4;\n  }\n  return modification;\n}\nfunction calculateUGO(references, modification) {\n  let ugo = 0;\n  if (references.includes('u')) {\n    ugo += modification << 6;\n  }\n  if (references.includes('g')) {\n    ugo += modification << 3;\n  }\n  if (references.includes('o')) {\n    ugo += modification;\n  }\n  return ugo;\n}\nfunction calculateSpecial(references, mode, modification) {\n  if (mode.includes('t')) {\n    modification += parseInt('1000', 8);\n  }\n  if (mode.includes('s')) {\n    if (references.includes('u')) {\n      modification += parseInt('4000', 8);\n    }\n    if (references.includes('g')) {\n      modification += parseInt('2000', 8);\n    }\n  }\n  return modification;\n}\nfunction parseSymbolicMode(input, originalMode, isDirectory) {\n  if (!originalMode) {\n    originalMode = 0;\n  }\n  const match = input.match(/^(u?g?o?a?)(-?\\+?=?)?(r?w?x?X?s?t?)$/);\n  if (!match) {\n    throw new Error(`Invalid file mode: ${ input }`);\n  }\n  let [, references, operator, mode] = match;\n  if (references === 'a' || !references) {\n    references = 'ugo';\n  }\n  let modification = calculateModification(mode, originalMode, isDirectory);\n  modification = calculateUGO(references, modification);\n  modification = calculateSpecial(references, mode, modification);\n  if (operator === '=') {\n    if (references.includes('u')) {\n      originalMode = originalMode & parseInt('7077', 8);\n      originalMode = originalMode | modification;\n    }\n    if (references.includes('g')) {\n      originalMode = originalMode & parseInt('7707', 8);\n      originalMode = originalMode | modification;\n    }\n    if (references.includes('o')) {\n      originalMode = originalMode & parseInt('7770', 8);\n      originalMode = originalMode | modification;\n    }\n    return originalMode;\n  }\n  if (operator === '+') {\n    return modification | originalMode;\n  }\n  if (operator === '-') {\n    return modification ^ originalMode;\n  }\n  return originalMode;\n}\nfunction calculateMode(mode, metadata) {\n  if (mode instanceof String || typeof mode === 'string') {\n    const strMode = `${ mode }`;\n    if (strMode.match(/^\\d+$/g)) {\n      mode = parseInt(strMode, 8);\n    } else {\n      mode = 0 + strMode.split(',').reduce((curr, acc) => {\n        return parseSymbolicMode(acc, curr, metadata.isDirectory());\n      }, metadata.mode || 0);\n    }\n  }\n  return mode;\n}\nfunction createChmod(context) {\n  async function mfsChmod(path, mode, options = {}) {\n    const opts = mergeOptions(defaultOptions, options);\n    log(`Fetching stats for ${ path }`);\n    const {cid: cid$1, mfsDirectory, name} = await toMfsPath.toMfsPath(context, path, opts);\n    if (cid$1.code !== dagPB__namespace.code) {\n      throw errCode__default[\"default\"](new Error(`${ path } was not a UnixFS node`), 'ERR_NOT_UNIXFS');\n    }\n    if (opts.recursive) {\n      const root = await itPipe.pipe(async function* () {\n        for await (const entry of ipfsUnixfsExporter.recursive(cid$1, context.repo.blocks)) {\n          if (entry.type !== 'file' && entry.type !== 'directory') {\n            throw errCode__default[\"default\"](new Error(`${ path } was not a UnixFS node`), 'ERR_NOT_UNIXFS');\n          }\n          entry.unixfs.mode = calculateMode(mode, entry.unixfs);\n          const node = dagPB__namespace.prepare({\n            Data: entry.unixfs.marshal(),\n            Links: entry.node.Links\n          });\n          yield {\n            path: entry.path,\n            content: node\n          };\n        }\n      }, source => ipfsUnixfsImporter.importer(source, context.repo.blocks, {\n        ...opts,\n        pin: false,\n        dagBuilder: async function* (source, block, opts) {\n          for await (const entry of source) {\n            yield async function () {\n              const node = entry.content;\n              const buf = dagPB__namespace.encode(node);\n              const cid = await persist.persist(buf, block, opts);\n              if (!node.Data) {\n                throw errCode__default[\"default\"](new Error(`${ cid } had no data`), 'ERR_INVALID_NODE');\n              }\n              const unixfs = ipfsUnixfs.UnixFS.unmarshal(node.Data);\n              return {\n                cid,\n                size: buf.length,\n                path: entry.path,\n                unixfs\n              };\n            };\n          }\n        }\n      }), nodes => last__default[\"default\"](nodes));\n      if (!root) {\n        throw errCode__default[\"default\"](new Error(`Could not chmod ${ path }`), 'ERR_COULD_NOT_CHMOD');\n      }\n      await rm.createRm(context)(path, opts);\n      await cp.createCp(context)(`/ipfs/${ root.cid }`, path, opts);\n      return;\n    }\n    const block = await context.repo.blocks.get(cid$1);\n    const node = dagPB__namespace.decode(block);\n    if (!node.Data) {\n      throw errCode__default[\"default\"](new Error(`${ cid$1 } had no data`), 'ERR_INVALID_NODE');\n    }\n    const metadata = ipfsUnixfs.UnixFS.unmarshal(node.Data);\n    metadata.mode = calculateMode(mode, metadata);\n    const updatedBlock = dagPB__namespace.encode({\n      Data: metadata.marshal(),\n      Links: node.Links\n    });\n    const hashAlg = opts.hashAlg || defaultOptions.hashAlg;\n    const hasher = await context.hashers.getHasher(hashAlg);\n    const hash = await hasher.digest(updatedBlock);\n    const updatedCid = cid.CID.create(opts.cidVersion, dagPB__namespace.code, hash);\n    if (opts.flush) {\n      await context.repo.blocks.put(updatedCid, updatedBlock);\n    }\n    const trail = await toTrail.toTrail(context, mfsDirectory);\n    const parent = trail[trail.length - 1];\n    const parentCid = cid.CID.decode(parent.cid.bytes);\n    const parentBlock = await context.repo.blocks.get(parentCid);\n    const parentNode = dagPB__namespace.decode(parentBlock);\n    const result = await addLink.addLink(context, {\n      parent: parentNode,\n      name: name,\n      cid: updatedCid,\n      size: updatedBlock.length,\n      flush: opts.flush,\n      hashAlg,\n      cidVersion: cid$1.version,\n      shardSplitThreshold: Infinity\n    });\n    parent.cid = result.cid;\n    const newRootCid = await updateTree.updateTree(context, trail, opts);\n    await updateMfsRoot.updateMfsRoot(context, newRootCid, opts);\n  }\n  return withTimeoutOption.withTimeoutOption(mfsChmod);\n}\n\nexports.createChmod = createChmod;\n"]},"metadata":{},"sourceType":"script"}